#!/usr/bin/env python
# ---------------------------------------------------------------------------##
#
# PySol -- a Python Solitaire game
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.
# If not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# ---------------------------------------------------------------------------##

# import pychecker.checker
import sys

# Initialise basics and read command line and settings.
from pysollib.init import init
init()

# Setup and Load the main process modules.
# IMPORTANT: The set of modules to load depends on the settings
# and command line options. Therfore import of pysollib.main
# HAS TO BE after call to init().
# See docs/README.SOURCE.
# Flake8 test would complain here E402, so disabled
from pysollib.main import main  # noqa: E402,I202

# Execute it.
# import profile
# profile.run("main(sys.argv)")
sys.exit(main(sys.argv))
"""
Usage:
    python setup.py py2app
"""

import os
import shutil
import sys
from subprocess import call

from pysollib.settings import PACKAGE, VERSION

from setuptools import setup


# build the rule pages
if not os.path.exists('data/html'):
    os.chdir('html-src')
    call('./gen-html.py', shell=True)
    os.chdir(os.pardir)
    shutil.copytree('html-src/images', 'html-src/html/images')
    try:
        shutil.rmtree('data/html')
    except OSError:
        pass
    shutil.copytree('html-src/html', 'data/html')

# build the HTML list of games
call("./scripts/all_games.py > docs/all_games.html", shell=True)

# Use Freecell Solver, if it is installed.
# http://fc-solve.berlios.de/
SOLVER_LIB_PATH = "/usr/local/lib/libfreecell-solver.0.dylib"
SOLVER = ["/usr/local/bin/fc-solve"]
if not os.path.exists(SOLVER_LIB_PATH):
    SOLVER_LIB_PATH = None
    SOLVER = []

GETINFO_STRING = "PySol Fan Club Edition \
                %s %s, (C) 1998-2003 Markus F.X.J Oberhumer \
                (C) 2006-2007 Skomoroh" % (PACKAGE, VERSION)
PLIST = dict(
    CFBundleDevelopmentRegion='en_US',
    CFBundleExecutable=PACKAGE,
    CFBundleDisplayName=PACKAGE,
    CFBundleGetInfoString=GETINFO_STRING,
    CFBundleIdentifier='net.sourceforge.pysolfc',
    CFBundleName=PACKAGE,
    CFBundleVersion='%s' % VERSION,
    CFBundleShortVersionString='%s' % VERSION,
    NSHumanReadableCopyright="Copyright (C) 1998-2003 Markus F.X.J. Oberhumer",
    )
APP = ['pysol.py']
ICON_FILE = 'data/PySol.icns'
DATA_FILES = ['docs', 'data', 'locale', 'scripts', 'COPYING', 'README.md',
              ] + SOLVER
RESOURCES = []
FRAMEWORKS = [SOLVER_LIB_PATH] if SOLVER_LIB_PATH else []
OPTIONS = dict(argv_emulation=True,
               plist=PLIST,
               iconfile=ICON_FILE,
               resources=RESOURCES,
               frameworks=FRAMEWORKS,
               excludes=['pysollib.pysolgtk']
               )

setup(
    app=APP,
    data_files=DATA_FILES,
    options={'py2app': OPTIONS},
    setup_requires=['py2app'],
    )

#
top = os.getcwd()
# Modify the fc-solve binary with install_name_tool to use the dependent
# libfreecell-solver dynamic library in the app bundle.
if SOLVER and "py2app" in sys.argv:
    os.chdir('dist/%s.app/Contents/Resources' % PACKAGE)
    call("install_name_tool -change \
         /usr/local/lib/libfreecell-solver.0.dylib \
         @executable_path/../Frameworks/libfreecell-solver.0.dylib fc-solve",
         shell=True
         )
#!/usr/bin/env python
# -*- mode: python; -*-

import os

from pysollib.settings import PACKAGE_URL
from pysollib.settings import VERSION

from setuptools import setup

if os.name == 'nt':
    import py2exe  # noqa: F401


def get_data_files(source, destination):
    """Iterates over all files under the given tree, to install them to the
    destination using the data_files keyword of setuptools.setup."""
    for path, _, files in os.walk(source):
        files = [os.path.join(path, f) for f in files]
        path = path.replace(source, destination, 1)
        yield (path, files)


if os.name == 'posix':
    data_dir = 'share/PySolFC'
    locale_dir = 'share/locale'
else:
    data_dir = 'data'
    locale_dir = 'locale'

ddirs = [
    'html',
    'images',
    'sound',
    'tiles',
    'toolbar',
    'themes',
    'tcl',
    ]
for s in open('MANIFEST.in'):
    if s.startswith('graft data/cardset-'):
        ddirs.append(s[11:].strip())

data_files = []

for d in ddirs:
    data_files += get_data_files(os.path.join('data', d),
                                 os.path.join(data_dir, d))

data_files += get_data_files('locale', locale_dir)

if os.name == 'posix':
    for size in os.listdir('data/images/icons'):
        data_files.append(('share/icons/hicolor/%s/apps' % size,
                           ['data/images/icons/%s/pysol.png' % size]))
    data_files.append((data_dir, ['data/pysolfc.glade']))
    data_files.append(('share/applications', ['data/pysol.desktop']))

# from pprint import pprint; pprint(data_files)
# import sys; sys.exit()

long_description = '''\
PySolFC is a collection of more than 1000 solitaire card games.
Its features include modern look and feel (uses Tile widget set), multiple
cardsets and tableau backgrounds, sound, unlimited undo, player statistics,
a hint system, demo games, a solitaire wizard, support for user written
plug-ins, an integrated HTML help browser, and lots of documentation.
'''

kw = {
    'name': 'PySolFC',
    'version': VERSION,
    'url': PACKAGE_URL,
    'author': 'Skomoroh',
    'author_email': 'skomoroh@gmail.com',
    'description': 'a Python solitaire game collection',
    'install_requires': [
        'attrs',
        'configobj',
        'pycotap',
        'pysol_cards',
        'random2',
        'six',
    ],
    'long_description': long_description,
    'license': 'GPL',
    'scripts': ['pysol.py'],
    'packages': ['pysollib',
                 'pysollib.macosx',
                 'pysollib.winsystems',
                 'pysollib.tk',
                 'pysollib.tile',
                 'pysollib.pysolgtk',
                 'pysollib.ui',
                 'pysollib.ui.tktile',
                 'pysollib.kivy',
                 'pysollib.game',
                 'pysollib.games',
                 'pysollib.games.special',
                 'pysollib.games.ultra',
                 'pysollib.games.mahjongg'],
    'data_files': data_files,
    }

if os.name == 'nt':
    kw['windows'] = [{'script': 'pysol.py',
                      'icon_resources': [(1, 'data/pysol.ico')], }]
    kw['packages'].remove('pysollib.pysolgtk')

setup(**kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


# imports
import os
import traceback
from threading import Thread

try:
    import pysolsoundserver
except ImportError:
    pysolsoundserver = None


# ************************************************************************
# * basic audio client
# ************************************************************************

class AbstractAudioClient:

    EXTENSIONS = r"\.((wav)|(it)|(mod)|(mp3)|(pym)|(s3m)|(xm))$"

    CAN_PLAY_SOUND = False
    CAN_PLAY_MUSIC = False

    def __init__(self):
        self.server = None
        self.audiodev = None
        self.connected = 0
        self.app = None
        self.sample_priority = -1
        self.sample_loop = 0
        self.music_priority = -1
        self.music_loop = 0

    def __del__(self):
        self.destroy()

    # start server - set self.server on success (may also set self.audiodev)
    def startServer(self):
        pass

    # connect to server - set self.audiodev on success
    def connectServer(self, app):
        assert app
        self.app = app
        if self.server is not None:
            try:
                if self._connectServer():
                    self.connected = 1
            except Exception:
                if traceback:
                    traceback.print_exc()
                self.destroy()

    # disconnect and stop server
    def destroy(self):
        if self.audiodev:
            self._destroy()
        self.server = None
        self.audiodev = None
        self.connected = 0
        self.app = None

    #
    # high-level interface
    #

    def playSample(self, name, priority=0, loop=0, volume=-1):
        # print 'AbstractAudioClient.playSample', name
        if self.audiodev is None or not self.app or not self.app.opt.sound:
            return 0
        if priority <= self.sample_priority and self.sample_loop:
            return 0
        obj = self.app.sample_manager.getByName(name)
        if not obj or not obj.absname:
            return 0
        try:
            if self._playSample(obj.absname, priority, loop, volume):
                self.sample_priority = priority
                self.sample_loop = loop
                return 1
        except Exception:
            if traceback:
                traceback.print_exc()
        return 0

    def stopSamples(self):
        if self.audiodev is None:
            return
        try:
            self._stopSamples()
        except Exception:
            if traceback:
                traceback.print_exc()
        self.sample_priority = -1
        self.sample_loop = 0

    def stopSamplesLoop(self):
        if self.audiodev is None:
            return
        try:
            self._stopSamplesLoop()
        except Exception:
            if traceback:
                traceback.print_exc()
        self.sample_priority = -1
        self.sample_loop = 0

    #
    # subclass - core implementation
    #

    def _connectServer(self):
        return 0

    def _destroy(self):
        pass

    def _playSample(self, filename, priority, loop, volume):
        return 0

    def _stopSamples(self):
        pass

    def _stopSamplesLoop(self):
        self._stopSamples()

    #
    # subclass - extensions
    #

    def getMusicInfo(self):
        return -1

    def playContinuousMusic(self, music_list):
        pass

    def playNextMusic(self):
        pass

    def updateSettings(self):
        pass


# ************************************************************************
# * pysolsoundserver module
# ************************************************************************

class PysolSoundServerModuleClient(AbstractAudioClient):

    CAN_PLAY_SOUND = True
    CAN_PLAY_MUSIC = True

    def __init__(self):
        AbstractAudioClient.__init__(self)

    def startServer(self):
        # use the module
        try:
            import pysolsoundserver
            self.audiodev = pysolsoundserver
            self.audiodev.init()
            self.server = 1
        except Exception:
            if traceback:
                traceback.print_exc()
            self.server = None
            self.audiodev = None

    def cmd(self, cmd):
        return self.audiodev.cmd(cmd)

    # connect to server
    def _connectServer(self):
        r = self.cmd("protocol 6")
        if r != 0:
            return 0
        # self.cmd("debug 1")
        return 1

    # disconnect and stop server
    def _destroy(self):
        self.audiodev.exit()

    #
    #
    #

    def _playSample(self, filename, priority, loop, volume):
        self.cmd("playwav '%s' %d %d %d %d"
                 % (filename, -1, priority, loop, volume))
        return 1

    def _stopSamples(self):
        self.cmd("stopwav")

    def _stopSamplesLoop(self):
        self.cmd("stopwavloop")

    def getMusicInfo(self):
        if self.audiodev:
            return self.audiodev.getMusicInfo()
        return -1

    def playContinuousMusic(self, music_list):
        if self.audiodev is None or not self.app:
            return
        try:
            loop = 999999
            for music in music_list:
                if music.absname:
                    self.cmd("queuemus '%s' %d %d %d %d"
                             % (music.absname, music.index, 0, loop,
                                music.volume))
            self.cmd("startqueue")
        except Exception:
            if traceback:
                traceback.print_exc()

    def playNextMusic(self):
        self.cmd("nextmus")

    def updateSettings(self):
        if self.audiodev is None or not self.app:
            return
        s, m = 0, 0
        if self.app.opt.sound:
            s = self.app.opt.sound_sample_volume
            m = self.app.opt.sound_music_volume
        try:
            self.cmd("setwavvol %d" % s)
            self.cmd("setmusvol %d" % m)
        except Exception:
            if traceback:
                traceback.print_exc()


# ************************************************************************
# * Kivy audio
# ************************************************************************

class KivyAudioClient(AbstractAudioClient):

    CAN_PLAY_SOUND = True
    CAN_PLAY_MUSIC = False

    def __init__(self):
        AbstractAudioClient.__init__(self)
        from pysollib.kivy.LApp import LSoundLoader
        self.audiodev = LSoundLoader
        self.sound = None
        self.queue = []
        self.sounds = {}

    def startServer(self):
        pass

    def _condPlaySample(self):
        # print("_condPlaySample: queue = %s" % self.sounds)
        for k in self.sounds:
            # print("%s" % (k))
            pass

        if self.sound:
            sound = self.sound
            sound.stop()
            return

        if self.sound is None:
            if len(self.queue) > 0:
                # print("Sound play start")
                filename = self.queue[0]
                self.queue = self.queue[1:]
                self.sound = self.sounds[filename]
                if self.sound:
                    vol = float(self.app.opt.sound_sample_volume)/100.0
                    self.sound.volume = vol
                    self.sound.play()
                    print("Sound plays %s" % self.sound.source)
                    # print("Sound is %.3f seconds" % self.sound.length)
                    # print("Sound volume is %s" % self.sound.volume)
            else:
                # print("Sound queue is empty")
                pass
        else:
            # print("Sound play start deferred")
            pass

    def _playSample(self, filename, priority, loop, volume):
        self.queue.append(filename)
        if filename not in self.sounds:
            sound = self.audiodev.load(filename)
            sound.bind(on_stop=self._endSample)
            self.sounds[filename] = sound
            # print("Sound found at %s" % sound.source)
        self._condPlaySample()

    def _endSample(self, a):
        print('Sound: stopped, %s' % self.sound)
        self.sound = None
        self._condPlaySample()

    def _stopSamples(self):
        print("Sound play stop")
        self.queue = []
        if self.sound:
            self.sound.stop()
            self.sound = None


# ************************************************************************
# * Win32 winsound audio
# ************************************************************************

class Win32AudioClient(AbstractAudioClient):

    CAN_PLAY_SOUND = True
    CAN_PLAY_MUSIC = False

    def __init__(self):
        AbstractAudioClient.__init__(self)
        import winsound
        self.audiodev = winsound

    def startServer(self):
        pass

    def _playSample(self, filename, priority, loop, volume):
        a = self.audiodev
        flags = a.SND_FILENAME | a.SND_NODEFAULT | a.SND_NOWAIT | a.SND_ASYNC
        if loop:
            flags = flags | a.SND_LOOP
        if priority <= self.sample_priority:
            flags = flags | a.SND_NOSTOP
        # print filename, flags, priority
        try:
            a.PlaySound(filename, flags)
            return 1
        except Exception:
            pass
        return 0

    def _stopSamples(self):
        a = self.audiodev
        flags = a.SND_NODEFAULT | a.SND_PURGE
        a.PlaySound(None, flags)


# ************************************************************************
# * OSS audio
# ************************************************************************

class OSSAudioServer:

    def __init__(self, pipe):
        self.pipe = pipe
        # import ossaudiodev
        # self.audiodev = ossaudiodev.open('w')
        self.sound_priority = -1
        self._busy = False

    def mainLoop(self):
        while True:
            s = os.read(self.pipe, 256)
            ss = s.split(b'\0')
            if not ss[0]:
                os._exit(0)
            if ss[0] == b'break':
                self._play_loop = False
                continue
            filename, priority, loop = ss[0].decode(), int(ss[1]), int(ss[2])
            if loop:
                self._play_loop = True
                th = Thread(target=self.playLoop, args=(filename,))
                th.start()
            else:
                if not self._busy:
                    self.play(filename, priority)

    def _getParameters(self, filename):
        import ossaudiodev
        import wave
        w = wave.open(filename)
        fmt = ossaudiodev.AFMT_U8
        nch = w.getnchannels()
        rate = w.getframerate()
        frames = w.readframes(w.getnframes())
        return (frames, fmt, nch, rate)

    def playLoop(self, filename, priority=None):
        # print '_playLoop:', filename
        import ossaudiodev
        try:
            # audiodev = self.audiodev
            audiodev = ossaudiodev.open('w')
            # audiodev.nonblock()
            frames, fmt, nch, rate = self._getParameters(filename)
            audiodev.setparameters(fmt, nch, rate)
            while self._play_loop:
                audiodev.write(frames)
            audiodev.reset()
            # audiodev.close()
            # self.audiodev = ossaudiodev.open('w')
            return 1
        except Exception:
            if traceback:
                traceback.print_exc()
            return 0

    def play(self, filename, priority):
        # print '_play:', filename
        import ossaudiodev
        try:
            self._busy = True
            # audiodev = self.audiodev
            audiodev = ossaudiodev.open('w')
            # audiodev.nonblock()
            frames, fmt, nch, rate = self._getParameters(filename)
            audiodev.setparameters(fmt, nch, rate)
            audiodev.write(frames)
            # audiodev.close()
            # self.audiodev = ossaudiodev.open('w')
            self.sound_priority = priority
            self._busy = False
            return 1
        except Exception:
            if traceback:
                traceback.print_exc()
            self._busy = False
            return 0


class OSSAudioClient(AbstractAudioClient):

    CAN_PLAY_SOUND = True
    CAN_PLAY_MUSIC = False

    def __init__(self):
        AbstractAudioClient.__init__(self)
        import ossaudiodev
        if not os.path.exists('/dev/dsp'):
            raise RuntimeError('OSS interface not available')
        self.audiodev = ossaudiodev

    def startServer(self):
        pin, pout = os.pipe()
        self.pout = pout
        server = OSSAudioServer(pin)
        pid = os.fork()
        if pid == 0:
            server.mainLoop()

    def _playSample(self, filename, priority, loop, volume):
        # print '_playSample:', filename, loop
        os.write(self.pout, b'%s\0%s\0%s\0' %
                 (filename.encode(),
                  str(priority).encode(),
                  str(loop).encode()))
        return 1

    def _stopSamples(self):
        os.write(self.pout, b'break\0\0\0')

    def _destroy(self):
        os.write(self.pout, b'\0\0\0')


# ************************************************************************
# * PyGame
# ************************************************************************

class PyGameAudioClient(AbstractAudioClient):

    EXTENSIONS = r'\.((ogg)|(mp3)|(wav)|(it)|(mod)|(s3m)|(xm)|(mid)|(midi))$'

    CAN_PLAY_SOUND = True
    CAN_PLAY_MUSIC = True

    def __init__(self):
        AbstractAudioClient.__init__(self)
        import pygame.mixer
        import pygame.time
        if os.name == 'nt':
            # for py2exe
            import pygame.base
            import pygame.rwobject
            import pygame.mixer_music
        self.mixer = pygame.mixer
        self.time = pygame.time
        self.music = self.mixer.music
        self.audiodev = self.mixer
        self.sound = None
        self.sound_channel = None
        self.sound_priority = -1

    def startServer(self):
        pass

    def connectServer(self, app):
        AbstractAudioClient.connectServer(self, app)
        # http://www.pygame.org/docs/ref/mixer.html
        # NOTE: there is currently a bug on some windows machines which
        # makes sound play back 'scratchy'. There is not enough cpu in
        # the sound thread to feed the buffer to the sound api. To get
        # around this you can increase the buffer size. However this
        # means that there is more of a delay between the time you ask to
        # play the sound and when it gets played. Try calling this before
        # the pygame.init or pygame.mixer.init calls.
        # pygame.mixer.pre_init(44100,-16,2, 1024 * 3)
        # self.mixer.pre_init(44100, -16, 2, 1024 * 3)
        buff_size = self.app.opt.sound_sample_buffer_size
        self.mixer.pre_init(44100, -16, 2, 1024*buff_size)
        self.mixer.init()

    def _playSample(self, filename, priority, loop, volume):
        # print '_playSample:', filename, priority, loop, volume
        if self.sound_channel and self.sound_channel.get_busy():
            if self.sound_priority >= priority:
                return 0
            else:
                self.sound.stop()
        vol = self.app.opt.sound_sample_volume/128.0
        try:
            self.sound = self.mixer.Sound(filename)
            self.sound.set_volume(vol)
            self.sound_channel = self.sound.play(loop)
        except Exception:
            if traceback:
                traceback.print_exc()
            pass
        self.sound_priority = priority
        return 1

    def _stopSamples(self):
        if self.sound:
            self.sound.stop()
        self.sound = None
        self.sound_channel = None

    def _playMusicLoop(self):
        # print '_playMusicLoop'
        music_list = self.music_list
        if not music_list:
            return
        while True:
            if not self.music:
                break
            for m in music_list:
                if not self.music:
                    break
                vol = self.app.opt.sound_music_volume/128.0
                try:
                    self.music.load(m.absname)
                    self.music.set_volume(vol)
                    self.music.play()
                    while self.music and self.music.get_busy():
                        self._wait(200)
                    self._wait(300)
                except Exception:
                    # if traceback: traceback.print_exc()
                    self._wait(1000)

    def _destroy(self):
        self.mixer.stop()
        self.mixer.quit()
        self.music = None

    def _wait(self, s):
        # sometime time or time.wait is None (threading)
        if self.time and self.time.wait:
            self.time.wait(s)

    def playContinuousMusic(self, music_list):
        # print 'playContinuousMusic'
        self.music_list = music_list
        # if self.audiodev is None or not self.app:
        #    return
        if not music_list:
            return
        th = Thread(target=self._playMusicLoop)
        th.start()

    def updateSettings(self):
        if not self.app.opt.sound or self.app.opt.sound_music_volume == 0:
            if self.music:
                self.music.stop()
                self.music = None
        else:
            if not self.music:
                self.music = self.mixer.music
                th = Thread(target=self._playMusicLoop)
                th.start()
            else:
                vol = self.app.opt.sound_music_volume/128.0
                self.music.set_volume(vol)

    def playNextMusic(self):
        if self.music:
            self.music.stop()
import gettext
import sys

import six


class myLocalGettext(object):
    def __init__(self, lang):
        self.language = lang

    def translation(self):
        domain = gettext._current_domain
        localedir = gettext._localedirs.get(domain, None)
        if self.language == "":
            t = gettext.translation(domain, localedir)
        else:
            t = gettext.translation(
                domain, localedir, languages=[self.language])
        return t

    def maketext(self, msg):
        if not isinstance(msg, six.text_type):
            return six.text_type(msg, 'utf-8')
        return msg

    def ungettext(self, msgid1, msgid2, n):
        # unicoded ngettext
        msgid1 = self.maketext(msgid1)
        msgid2 = self.maketext(msgid2)
        try:
            t = self.translation()
        except IOError:
            if n == 1:
                return msgid1
            else:
                return msgid2
        if sys.version_info >= (3, 0):
            return t.ngettext(msgid1, msgid2, n)
        else:
            return t.ungettext(msgid1, msgid2, n)

    def ugettext(self, message):
        # unicoded gettext
        message = self.maketext(message)
        try:
            t = self.translation()
        except IOError:
            return message
        if sys.version_info >= (3, 0):
            return t.gettext(message)
        else:
            return t.ugettext(message)


myGettext = myLocalGettext('')


def n_(x):
    return x


def fix_gettext():
    gettext.ugettext = myGettext.ugettext
    gettext.ungettext = myGettext.ungettext


fix_gettext()

_ = gettext.ugettext
ungettext = gettext.ungettext
"""HTML 2.0 parser.

See the HTML 2.0 specification:
http://www.w3.org/hypertext/WWW/MarkUp/html-spec/html-spec_toc.html
"""

from formatter import AS_IS

from six.moves import html_parser


class HTMLParseError(RuntimeError):
    """Error raised when an HTML document can't be parsed."""


class HTMLParser(html_parser.HTMLParser):
    """This is the basic HTML parser class.

    It supports all entity names required by the XHTML 1.0 Recommendation.
    It also defines handlers for all HTML 2.0 and many HTML 3.0 and 3.2
    elements.

    """

    # from six.moves.html_entities import entitydefs

    def __init__(self, formatter):
        """Creates an instance of the HTMLParser class.

        The formatter parameter is the formatter instance associated with
        the parser.

        """
        html_parser.HTMLParser.__init__(self)
        self.formatter = formatter

    def error(self, message):
        raise HTMLParseError(message)

    def reset(self):
        html_parser.HTMLParser.reset(self)
        self.savedata = None
        self.isindex = 0
        self.title = None
        self.base = None
        self.anchor = None
        self.anchorlist = []
        self.nofill = 0
        self.list_stack = []

    # ------ Methods used internally; some may be overridden

    # --- Formatter interface, taking care of 'savedata' mode;
    # shouldn't need to be overridden

    def handle_data(self, data):
        if self.savedata is not None:
            self.savedata = self.savedata + data
        else:
            if self.nofill:
                self.formatter.add_literal_data(data)
            else:
                self.formatter.add_flowing_data(data)

    def handle_starttag(self, tag, attrs):
        try:
            method = getattr(self, 'start_' + tag)
        except AttributeError:
            try:
                method = getattr(self, 'do_' + tag)
            except AttributeError:
                self.unknown_starttag(tag, attrs)
                return
        method(attrs)

    def handle_endtag(self, tag):
        try:
            method = getattr(self, 'end_' + tag)
        except AttributeError:
            self.unknown_endtag(tag)
            return
        method()

    # --- Hooks to save data; shouldn't need to be overridden

    def save_bgn(self):
        """Begins saving character data in a buffer instead of sending it
        to the formatter object.

        Retrieve the stored data via the save_end() method.  Use of the
        save_bgn() / save_end() pair may not be nested.

        """
        self.savedata = ''

    def save_end(self):
        """Ends buffering character data and returns all data saved since
        the preceding call to the save_bgn() method.

        If the nofill flag is false, whitespace is collapsed to single
        spaces.  A call to this method without a preceding call to the
        save_bgn() method will raise a TypeError exception.

        """
        data = self.savedata
        self.savedata = None
        if not self.nofill:
            data = ' '.join(data.split())
        return data

    # --- Hooks for anchors; should probably be overridden

    def anchor_bgn(self, href, name, type):
        """This method is called at the start of an anchor region.

        The arguments correspond to the attributes of the <A> tag with
        the same names.  The default implementation maintains a list of
        hyperlinks (defined by the HREF attribute for <A> tags) within
        the document.  The list of hyperlinks is available as the data
        attribute anchorlist.

        """
        self.anchor = href
        if self.anchor:
            self.anchorlist.append(href)

    def anchor_end(self):
        """This method is called at the end of an anchor region.

        The default implementation adds a textual footnote marker using an
        index into the list of hyperlinks created by the anchor_bgn()method.

        """
        if self.anchor:
            self.handle_data("[%d]" % len(self.anchorlist))
            self.anchor = None

    # --- Hook for images; should probably be overridden

    def handle_image(self, src, alt, *args):
        """This method is called to handle images.

        The default implementation simply passes the alt value to the
        handle_data() method.

        """
        self.handle_data(alt)

    # --------- Top level elememts

    def start_html(self, attrs): pass

    def end_html(self): pass

    def start_head(self, attrs): pass

    def end_head(self): pass

    def start_body(self, attrs): pass

    def end_body(self): pass

    # ------ Head elements

    def start_title(self, attrs):
        self.save_bgn()

    def end_title(self):
        self.title = self.save_end()

    def do_base(self, attrs):
        for a, v in attrs:
            if a == 'href':
                self.base = v

    def do_isindex(self, attrs):
        self.isindex = 1

    def do_link(self, attrs):
        pass

    def do_meta(self, attrs):
        pass

    def do_nextid(self, attrs):  # Deprecated
        pass

    # ------ Body elements

    # --- Headings

    def start_h1(self, attrs):
        self.formatter.end_paragraph(1)
        self.formatter.push_font(('h1', 0, 1, 0))

    def end_h1(self):
        self.formatter.end_paragraph(1)
        self.formatter.pop_font()

    def start_h2(self, attrs):
        self.formatter.end_paragraph(1)
        self.formatter.push_font(('h2', 0, 1, 0))

    def end_h2(self):
        self.formatter.end_paragraph(1)
        self.formatter.pop_font()

    def start_h3(self, attrs):
        self.formatter.end_paragraph(1)
        self.formatter.push_font(('h3', 0, 1, 0))

    def end_h3(self):
        self.formatter.end_paragraph(1)
        self.formatter.pop_font()

    def start_h4(self, attrs):
        self.formatter.end_paragraph(1)
        self.formatter.push_font(('h4', 0, 1, 0))

    def end_h4(self):
        self.formatter.end_paragraph(1)
        self.formatter.pop_font()

    def start_h5(self, attrs):
        self.formatter.end_paragraph(1)
        self.formatter.push_font(('h5', 0, 1, 0))

    def end_h5(self):
        self.formatter.end_paragraph(1)
        self.formatter.pop_font()

    def start_h6(self, attrs):
        self.formatter.end_paragraph(1)
        self.formatter.push_font(('h6', 0, 1, 0))

    def end_h6(self):
        self.formatter.end_paragraph(1)
        self.formatter.pop_font()

    # --- Block Structuring Elements

    def do_p(self, attrs):
        self.formatter.end_paragraph(1)

    def start_pre(self, attrs):
        self.formatter.end_paragraph(1)
        self.formatter.push_font((AS_IS, AS_IS, AS_IS, 1))
        self.nofill = self.nofill + 1

    def end_pre(self):
        self.formatter.end_paragraph(1)
        self.formatter.pop_font()
        self.nofill = max(0, self.nofill - 1)

    def start_xmp(self, attrs):
        self.start_pre(attrs)
        self.setliteral('xmp')  # Tell SGML parser

    def end_xmp(self):
        self.end_pre()

    def start_listing(self, attrs):
        self.start_pre(attrs)
        self.setliteral('listing')  # Tell SGML parser

    def end_listing(self):
        self.end_pre()

    def start_address(self, attrs):
        self.formatter.end_paragraph(0)
        self.formatter.push_font((AS_IS, 1, AS_IS, AS_IS))

    def end_address(self):
        self.formatter.end_paragraph(0)
        self.formatter.pop_font()

    def start_blockquote(self, attrs):
        self.formatter.end_paragraph(1)
        self.formatter.push_margin('blockquote')

    def end_blockquote(self):
        self.formatter.end_paragraph(1)
        self.formatter.pop_margin()

    # --- List Elements

    def start_ul(self, attrs):
        self.formatter.end_paragraph(not self.list_stack)
        self.formatter.push_margin('ul')
        self.list_stack.append(['ul', '*', 0])

    def end_ul(self):
        if self.list_stack:
            del self.list_stack[-1]
        self.formatter.end_paragraph(not self.list_stack)
        self.formatter.pop_margin()

    def do_li(self, attrs):
        self.formatter.end_paragraph(0)
        if self.list_stack:
            [dummy, label, counter] = top = self.list_stack[-1]
            top[2] = counter = counter+1
        else:
            label, counter = '*', 0
        self.formatter.add_label_data(label, counter)

    def start_ol(self, attrs):
        self.formatter.end_paragraph(not self.list_stack)
        self.formatter.push_margin('ol')
        label = '1.'
        for a, v in attrs:
            if a == 'type':
                if len(v) == 1:
                    v += '.'
                label = v
        self.list_stack.append(['ol', label, 0])

    def end_ol(self):
        if self.list_stack:
            del self.list_stack[-1]
        self.formatter.end_paragraph(not self.list_stack)
        self.formatter.pop_margin()

    def start_menu(self, attrs):
        self.start_ul(attrs)

    def end_menu(self):
        self.end_ul()

    def start_dir(self, attrs):
        self.start_ul(attrs)

    def end_dir(self):
        self.end_ul()

    def start_dl(self, attrs):
        self.formatter.end_paragraph(1)
        self.list_stack.append(['dl', '', 0])

    def end_dl(self):
        self.ddpop(1)
        if self.list_stack:
            del self.list_stack[-1]

    def do_dt(self, attrs):
        self.ddpop()

    def do_dd(self, attrs):
        self.ddpop()
        self.formatter.push_margin('dd')
        self.list_stack.append(['dd', '', 0])

    def ddpop(self, bl=0):
        self.formatter.end_paragraph(bl)
        if self.list_stack:
            if self.list_stack[-1][0] == 'dd':
                del self.list_stack[-1]
                self.formatter.pop_margin()

    # --- Phrase Markup

    # Idiomatic Elements

    def start_cite(self, attrs): self.start_i(attrs)

    def end_cite(self): self.end_i()

    def start_code(self, attrs): self.start_tt(attrs)

    def end_code(self): self.end_tt()

    def start_em(self, attrs): self.start_i(attrs)

    def end_em(self): self.end_i()

    def start_kbd(self, attrs): self.start_tt(attrs)

    def end_kbd(self): self.end_tt()

    def start_samp(self, attrs): self.start_tt(attrs)

    def end_samp(self): self.end_tt()

    def start_strong(self, attrs): self.start_b(attrs)

    def end_strong(self): self.end_b()

    def start_var(self, attrs): self.start_i(attrs)

    def end_var(self): self.end_i()

    # Typographic Elements

    def start_i(self, attrs):
        self.formatter.push_font((AS_IS, 1, AS_IS, AS_IS))

    def end_i(self):
        self.formatter.pop_font()

    def start_b(self, attrs):
        self.formatter.push_font((AS_IS, AS_IS, 1, AS_IS))

    def end_b(self):
        self.formatter.pop_font()

    def start_tt(self, attrs):
        self.formatter.push_font((AS_IS, AS_IS, AS_IS, 1))

    def end_tt(self):
        self.formatter.pop_font()

    def start_a(self, attrs):
        href = ''
        name = ''
        type = ''
        for attrname, value in attrs:
            value = value.strip()
            if attrname == 'href':
                href = value
            if attrname == 'name':
                name = value
            if attrname == 'type':
                type = value.lower()
        self.anchor_bgn(href, name, type)

    def end_a(self):
        self.anchor_end()

    # --- Line Break

    def do_br(self, attrs):
        self.formatter.add_line_break()

    # --- Horizontal Rule

    def do_hr(self, attrs):
        self.formatter.add_hor_rule()

    # --- Image

    def do_img(self, attrs):
        align = ''
        alt = '(image)'
        ismap = ''
        src = ''
        width = 0
        height = 0
        for attrname, value in attrs:
            if attrname == 'align':
                align = value
            if attrname == 'alt':
                alt = value
            if attrname == 'ismap':
                ismap = value
            if attrname == 'src':
                src = value
            if attrname == 'width':
                try:
                    width = int(value)
                except ValueError:
                    pass
            if attrname == 'height':
                try:
                    height = int(value)
                except ValueError:
                    pass
        self.handle_image(src, alt, ismap, align, width, height)

    # --- Really Old Unofficial Deprecated Stuff

    def do_plaintext(self, attrs):
        self.start_pre(attrs)
        self.setnomoretags()  # Tell SGML parser

    # --- Unhandled tags

    def unknown_starttag(self, tag, attrs):
        pass

    def unknown_endtag(self, tag):
        pass


def test(args=None):
    import sys
    import formatter

    if not args:
        args = sys.argv[1:]

    silent = args and args[0] == '-s'
    if silent:
        del args[0]

    if args:
        fn = args[0]
    else:
        fn = 'test.html'

    if fn == '-':
        f = sys.stdin
    else:
        try:
            f = open(fn, 'r')
        except IOError as msg:
            print(fn, ":", msg)
            sys.exit(1)

    data = f.read()

    if f is not sys.stdin:
        f.close()

    if silent:
        f = formatter.NullFormatter()
    else:
        f = formatter.AbstractFormatter(formatter.DumbWriter())

    p = HTMLParser(f)
    p.feed(data)
    p.close()


if __name__ == '__main__':
    test()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os
import sys
import traceback

import configobj

import pysollib.settings
from pysollib.mfxutil import print_err
from pysollib.mygettext import _
from pysollib.mygettext import myGettext
from pysollib.pysoltk import TOOLBAR_BUTTONS, TOOLKIT
from pysollib.resource import CSI


import six

import validate

# ************************************************************************
# * Options
# ************************************************************************


configspec = '''
[general]
player = string
confirm = boolean
update_player_stats = boolean
autofaceup = boolean
autodrop = boolean
autodeal = boolean
quickplay = boolean
shuffle = boolean
undo = boolean
bookmarks = boolean
hint = boolean
highlight_piles = boolean
highlight_cards = boolean
highlight_samerank = boolean
highlight_not_matching = boolean
mahjongg_show_removed = boolean
mahjongg_create_solvable = integer(0, 2)
shisen_show_hint = boolean
shisen_show_matching = boolean
animations = integer(0, 5)
redeal_animation = boolean
win_animation = boolean
flip_animation = boolean
compact_stacks = boolean
shadow = boolean
shade = boolean
shrink_face_down = boolean
shade_filled_stacks = boolean
demo_logo = boolean
tile_theme = string
default_tile_theme = string
toolbar = integer(0, 4)
toolbar_style = string
toolbar_relief = string
toolbar_compound = string
toolbar_size = integer(0, 1)
statusbar = boolean
statusbar_game_number = boolean
statusbar_stuck = boolean
num_cards = boolean
helpbar = boolean
num_recent_games = integer(10, 100)
last_gameid = integer
game_holded = integer
wm_maximized = boolean
splashscreen = boolean
mouse_type = string
mouse_undo = boolean
negative_bottom = boolean
randomize_place = boolean
save_cardsets = boolean
dragcursor = boolean
save_games_geometry = boolean
game_geometry = int_list(min=2, max=2)
sound = boolean
sound_mode = integer(0, 1)
sound_sample_volume = integer(0, 128)
sound_sample_buffer_size = integer(1, 4)
tabletile_name = string
recent_gameid = int_list
favorite_gameid = int_list
visible_buttons = string_list
translate_game_names = boolean
solver_presets = string_list
solver_show_progress = boolean
solver_max_iterations = integer
solver_iterations_output_step = integer
solver_preset = string
display_win_message = boolean
language = string

[sound_samples]
move = boolean
autodrop = boolean
drop = boolean
nomove = boolean
gameperfect = boolean
deal = boolean
gamelost = boolean
autopilotwon = boolean
flip = boolean
undo = boolean
gamefinished = boolean
areyousure = boolean
startdrag = boolean
autoflip = boolean
autopilotlost = boolean
turnwaste = boolean
gamewon = boolean
droppair = boolean
redo = boolean
dealwaste = boolean

[fonts]
sans = list
small = list
fixed = list
canvas_default = list
canvas_small = list
canvas_fixed = list
canvas_large = list

[colors]
piles = string
text = string
table = string
hintarrow = string
cards_1 = string
cards_2 = string
samerank_1 = string
samerank_2 = string
not_matching = string

[timeouts]
highlight_samerank = float(0.2, 9.9)
raise_card = float(0.2, 9.9)
demo = float(0.2, 9.9)
highlight_cards = float(0.2, 9.9)
hint = float(0.2, 9.9)
highlight_piles = float(0.2, 9.9)

[cardsets]
0 = string_list(min=2, max=2)
1 = string_list(min=2, max=2)
2 = string_list(min=2, max=2)
3 = string_list(min=2, max=2)
4 = string_list(min=2, max=2)
5 = string_list(min=2, max=2)
6 = string_list(min=2, max=2)
7 = string_list(min=2, max=2)
8 = string_list(min=2, max=2)
9 = string_list(min=2, max=2)
scale_cards = boolean
scale_x = float
scale_y = float
auto_scale = boolean
preserve_aspect_ratio = boolean
'''.splitlines()


class Options:
    GENERAL_OPTIONS = [
        ('player', 'str'),
        ('confirm', 'bool'),
        ('update_player_stats', 'bool'),
        ('autofaceup', 'bool'),
        ('autodrop', 'bool'),
        ('autodeal', 'bool'),
        ('quickplay', 'bool'),
        ('shuffle', 'bool'),
        ('undo', 'bool'),
        ('bookmarks', 'bool'),
        ('hint', 'bool'),
        ('highlight_piles', 'bool'),
        ('highlight_cards', 'bool'),
        ('highlight_samerank', 'bool'),
        ('highlight_not_matching', 'bool'),
        ('mahjongg_show_removed', 'bool'),
        ('mahjongg_create_solvable', 'int'),
        ('shisen_show_hint', 'bool'),
        ('shisen_show_matching', 'bool'),
        ('animations', 'int'),
        ('redeal_animation', 'bool'),
        ('win_animation', 'bool'),
        ('flip_animation', 'bool'),
        ('compact_stacks', 'bool'),
        ('shadow', 'bool'),
        ('shade', 'bool'),
        ('shrink_face_down', 'bool'),
        ('shade_filled_stacks', 'bool'),
        ('demo_logo', 'bool'),
        ('tile_theme', 'str'),
        ('default_tile_theme', 'str'),
        ('toolbar', 'int'),
        ('toolbar_style', 'str'),
        ('toolbar_relief', 'str'),
        ('toolbar_compound', 'str'),
        ('toolbar_size', 'int'),
        ('statusbar', 'bool'),
        ('statusbar_game_number', 'bool'),
        ('statusbar_stuck', 'bool'),
        ('num_cards', 'bool'),
        ('helpbar', 'bool'),
        ('num_recent_games', 'int'),
        ('last_gameid', 'int'),
        ('game_holded', 'int'),
        ('wm_maximized', 'bool'),
        ('splashscreen', 'bool'),
        ('mouse_type', 'str'),
        ('mouse_undo', 'bool'),
        ('negative_bottom', 'bool'),
        ('randomize_place', 'bool'),
        ('save_cardsets', 'bool'),
        ('dragcursor', 'bool'),
        ('save_games_geometry', 'bool'),
        ('sound', 'bool'),
        ('sound_mode', 'int'),
        ('sound_sample_volume', 'int'),
        ('sound_music_volume', 'int'),
        ('sound_sample_buffer_size', 'int'),
        ('tabletile_name', 'str'),
        ('translate_game_names', 'bool'),
        ('solver_presets', 'list'),
        ('solver_show_progress', 'bool'),
        ('solver_max_iterations', 'int'),
        ('solver_iterations_output_step', 'int'),
        ('solver_preset', 'string'),
        # ('toolbar_vars', 'list'),
        # ('recent_gameid', 'list'),
        # ('favorite_gameid', 'list'),
        ('display_win_message', 'bool'),
        ('language', 'str'),
        ]

    def __init__(self):
        self._config = None             # configobj.ConfigObj instance
        self._config_encoding = 'utf-8'

        self.version_tuple = pysollib.settings.VERSION_TUPLE  # XXX
        self.saved = 0                  # XXX
        # options menu:
        self.player = _("Unknown")
        self.confirm = True
        self.update_player_stats = True
        self.autofaceup = True
        self.autodrop = False
        self.autodeal = True
        self.quickplay = True
        self.shuffle = True
        self.undo = True
        self.bookmarks = True
        self.hint = True
        self.highlight_piles = True
        self.highlight_cards = True
        self.highlight_samerank = True
        self.highlight_not_matching = True
        self.mahjongg_show_removed = False
        self.mahjongg_create_solvable = 2  # 0 - none, 1 - easy, 2 - hard
        if TOOLKIT == 'kivy':
            self.mahjongg_create_solvable = 1  # 0 - none, 1 - easy, 2 - hard
        self.shisen_show_hint = True
        self.shisen_show_matching = False
        self.animations = 3             # default to Medium
        self.redeal_animation = True
        self.win_animation = True
        if TOOLKIT == 'kivy':
            self.redeal_animation = False
            self.win_animation = False
        self.flip_animation = True
        self.compact_stacks = True
        self.shadow = True
        self.shade = True
        self.shrink_face_down = True
        self.shade_filled_stacks = True
        self.demo_logo = True
        self.tile_theme = 'default'
        self.default_tile_theme = 'default'
        self.toolbar = 1       # 0 == hide, 1,2,3,4 == top, bottom, lef, right
        # self.toolbar_style = 'default'
        if TOOLKIT == 'kivy':
            self.toolbar = 4  # 0 == hide, 1,2,3,4 == top, bottom, lef, right
        self.toolbar_style = 'bluecurve'
        self.toolbar_relief = 'flat'
        self.toolbar_compound = 'none'  # icons only
        self.toolbar_size = 0
        self.toolbar_vars = {}
        for w in TOOLBAR_BUTTONS:
            self.toolbar_vars[w] = True  # show all buttons
        self.statusbar = True
        self.statusbar_game_number = False  # show game number in statusbar
        self.statusbar_stuck = False        # show stuck indicator
        self.num_cards = False
        self.helpbar = False
        self.splashscreen = True
        self.mouse_type = 'drag-n-drop'  # or 'sticky-mouse' or 'point-n-click'
        self.mouse_undo = False         # use mouse for undo/redo
        self.negative_bottom = True
        self.translate_game_names = True
        self.display_win_message = True
        self.language = ''
        # sound
        self.sound = True
        self.sound_mode = 1
        self.sound_sample_volume = 75
        self.sound_music_volume = 100
        self.sound_sample_buffer_size = 1  # 1 - 4 (1024 - 4096 bytes)
        self.sound_samples = {
            'areyousure': True,
            'autodrop': True,
            'autoflip': True,
            'autopilotlost': True,
            'autopilotwon': True,
            'deal': True,
            'dealwaste': True,
            'droppair': True,
            'drop': True,
            # 'extra': True,
            'flip': True,
            'move': True,
            'nomove': True,
            'redo': True,
            'startdrag': True,
            'turnwaste': True,
            'undo': True,
            'gamefinished': False,
            'gamelost': False,
            'gameperfect': False,
            'gamewon': False,
            }
        # fonts
        self.fonts = {
            "default": None,
            # "default": ("helvetica", 12),
            "sans": ("times",     12),  # for html
            "fixed": ("courier",   12),  # for html & log
            "small": ("helvetica", 12),
            "canvas_default": ("helvetica", 12),
            # "canvas_card": ("helvetica", 12),
            "canvas_fixed": ("courier",   12),
            "canvas_large": ("helvetica", 16),
            "canvas_small": ("helvetica", 10),
            }
        # colors
        self.colors = {
            'table':        '#008200',
            'text':         '#ffffff',
            'piles':        '#ffc000',
            'cards_1':      '#ffc000',
            'cards_2':      '#0000ff',
            'samerank_1':   '#ffc000',
            'samerank_2':   '#0000ff',
            'hintarrow':    '#303030',
            'not_matching': '#ff0000',
            }
        # delays
        self.timeouts = {
            'hint':               1.0,
            'demo':               1.0,
            'raise_card':         1.0,
            'highlight_piles':    1.0,
            'highlight_cards':    1.0,
            'highlight_samerank': 1.0,
            }
        # additional startup information
        self.num_recent_games = 15
        self.recent_gameid = []
        self.favorite_gameid = []
        if TOOLKIT == 'kivy':
            self.favorite_gameid = [2, 7, 8, 19, 140, 116, 152, 176, 181,
                                    194, 207, 706, 721, 756, 903, 5034,
                                    11004, 14405, 14410, 15411, 22225]
        self.last_gameid = 0            # last game played
        self.game_holded = 0            # gameid or 0
        self.wm_maximized = 0
        self.save_games_geometry = False
        # saved games geometry (gameid: (width, height))
        self.games_geometry = {}
        self.game_geometry = (0, 0)  # game geometry before exit
        self.offsets = {}           # cards offsets
        #
        self.randomize_place = False
        self.save_cardsets = True
        self.dragcursor = True
        #
        self.scale_cards = False
        self.scale_x = 1.0
        self.scale_y = 1.0
        self.auto_scale = False
        self.preserve_aspect_ratio = True
        # solver
        self.solver_presets = [
            'none',
            'abra-kadabra',
            'blue-yonder',
            'conspiracy-theory',
            'cookie-monster',
            'cool-jives',
            'crooked-nose',
            'fools-gold',
            'good-intentions',
            'hello-world',
            'john-galt-line',
            'looking-glass',
            'one-big-family',
            'rin-tin-tin',
            'slick-rock',
            'the-last-mohican',
            'video-editing',
            'yellow-brick-road',
            ]
        self.solver_show_progress = True
        self.solver_max_iterations = 100000
        self.solver_iterations_output_step = 100
        self.solver_preset = 'video-editing'

    def setDefaults(self, top=None):
        WIN_SYSTEM = pysollib.settings.WIN_SYSTEM
        # toolbar
        # if WIN_SYSTEM == 'win32':
        #    self.toolbar_style = 'crystal'
        # fonts
        if WIN_SYSTEM == 'win32':
            self.fonts["sans"] = ("times new roman", 12)
            self.fonts["fixed"] = ("courier new", 10)
        elif WIN_SYSTEM == 'x11':
            self.fonts["sans"] = ("helvetica", -12)
        # tile theme
        if WIN_SYSTEM == 'win32':
            self.tile_theme = self.default_tile_theme = 'winnative'
            if sys.getwindowsversion() >= (5, 1):  # xp
                self.tile_theme = 'xpnative'
        elif WIN_SYSTEM == 'x11':
            self.tile_theme = 'clam'
            self.default_tile_theme = 'default'
        elif WIN_SYSTEM == 'aqua':
            self.tile_theme = self.default_tile_theme = 'aqua'
        #
        sw, sh, sd = 0, 0, 8
        if top:
            sw, sh, sd = (top.winfo_screenwidth(),
                          top.winfo_screenheight(),
                          top.winfo_screendepth())
        # bg
        if sd > 8:
            self.tabletile_name = "Nostalgy.gif"  # basename
        else:
            self.tabletile_name = None
        # cardsets
        c = "Standard"
        if sw < 800 or sh < 600:
            c = "2000"
        if TOOLKIT == 'kivy':
            c = "Standard"

        # if sw > 1024 and sh > 768:
        #    c = 'Dondorf'
        self.cardset = {
            # game_type:        (cardset_name, back_file)
            0:                  (c, ""),
            CSI.TYPE_FRENCH:    (c, ""),
            CSI.TYPE_HANAFUDA:  ("Kintengu", ""),
            CSI.TYPE_MAHJONGG:  ("Crystal Mahjongg", ""),
            CSI.TYPE_TAROCK:    ("Vienna 2K", ""),
            CSI.TYPE_HEXADECK:  ("Hex A Deck", ""),
            CSI.TYPE_MUGHAL_GANJIFA: ("Mughal Ganjifa", ""),
            # CSI.TYPE_NAVAGRAHA_GANJIFA: ("Navagraha Ganjifa", ""),
            CSI.TYPE_NAVAGRAHA_GANJIFA: ("Dashavatara Ganjifa", ""),
            CSI.TYPE_DASHAVATARA_GANJIFA: ("Dashavatara Ganjifa", ""),
            CSI.TYPE_TRUMP_ONLY: ("Matrix", ""),
        }

    # not changeable options
    def setConstants(self):
        if 'shuffle' not in self.toolbar_vars:
            # new in v.1.1
            self.toolbar_vars['shuffle'] = True
        if isinstance(self.mahjongg_create_solvable, bool):
            # changed in v.1.1
            self.mahjongg_create_solvable = 2
        pass

    def copy(self):
        opt = Options()
        opt.__dict__.update(self.__dict__)
        opt.setConstants()
        return opt

    def save(self, filename):
        config = self._config

        # general
        for key, t in self.GENERAL_OPTIONS:
            val = getattr(self, key)
            if isinstance(val, str):
                if sys.version_info < (3,):
                    val = six.text_type(val, 'utf-8')
            config['general'][key] = val

        config['general']['recent_gameid'] = self.recent_gameid
        config['general']['favorite_gameid'] = self.favorite_gameid
        visible_buttons = [b for b in self.toolbar_vars
                           if self.toolbar_vars[b]]
        config['general']['visible_buttons'] = visible_buttons
        if 'none' in config['general']['solver_presets']:
            config['general']['solver_presets'].remove('none')

        # sound_samples
        config['sound_samples'] = self.sound_samples

        # fonts
        for key, val in self.fonts.items():
            if key == 'default':
                continue
            if val is None:
                continue
            config['fonts'][key] = val

        # colors
        config['colors'] = self.colors

        # timeouts
        config['timeouts'] = self.timeouts

        # cardsets
        for key, val in self.cardset.items():
            config['cardsets'][str(key)] = val
        for key in ('scale_cards', 'scale_x', 'scale_y',
                    'auto_scale', 'preserve_aspect_ratio'):
            config['cardsets'][key] = getattr(self, key)

        # games_geometry
        config['games_geometry'].clear()
        for key, val in self.games_geometry.items():
            config['games_geometry'][str(key)] = val
        config['general']['game_geometry'] = self.game_geometry

        # offsets
        for key, val in self.offsets.items():
            config['offsets'][key] = val

        config.write()
        # config.write(sys.stdout); print

    def _getOption(self, section, key, t):
        config = self._config
        try:
            if config[section][key] is None:
                # invalid value
                return None
            if t == 'bool':
                val = config[section].as_bool(key)
            elif t == 'int':
                val = config[section].as_int(key)
            elif t == 'float':
                val = config[section].as_float(key)
            elif t == 'list':
                val = config[section][key]
                assert isinstance(val, (list, tuple))
            else:  # str
                val = config[section][key]
        except KeyError:
            val = None
        except Exception:
            print_err('load option error: %s: %s' % (section, key))
            traceback.print_exc()
            val = None
        return val

    def load(self, filename):

        # create ConfigObj instance
        try:
            config = configobj.ConfigObj(filename,
                                         configspec=configspec,
                                         encoding=self._config_encoding)
        except configobj.ParseError:
            traceback.print_exc()
            config = configobj.ConfigObj(configspec=configspec,
                                         encoding=self._config_encoding)
        self._config = config

        # create sections
        for section in (
            'general',
            'sound_samples',
            'fonts',
            'colors',
            'timeouts',
            'cardsets',
            'games_geometry',
            'offsets',
                ):
            if section not in config:
                config[section] = {}

        # add initial comment
        if not os.path.exists(filename):
            config.initial_comment = ['-*- coding: %s -*-' %
                                      self._config_encoding]
            return

        # validation
        vdt = validate.Validator()
        res = config.validate(vdt)
        # from pprint import pprint; pprint(res)
        if res is not True:
            for section, data in res.items():
                if data is True:
                    continue
                for key, value in data.items():
                    if value is False:
                        print_err('config file: validation error: '
                                  'section: "%s", key: "%s"' % (section, key))
                        config[section][key] = None

        # general
        for key, t in self.GENERAL_OPTIONS:
            val = self._getOption('general', key, t)
            if val == 'None':
                setattr(self, key, None)
            elif val is not None:
                setattr(self, key, val)

        pysollib.settings.TRANSLATE_GAME_NAMES = self.translate_game_names

        recent_gameid = self._getOption('general', 'recent_gameid', 'list')
        if recent_gameid is not None:
            try:
                self.recent_gameid = [int(i) for i in recent_gameid]
            except Exception:
                traceback.print_exc()

        favorite_gameid = self._getOption('general', 'favorite_gameid', 'list')
        if favorite_gameid is not None:
            try:
                self.favorite_gameid = [int(i) for i in favorite_gameid]
            except Exception:
                traceback.print_exc()

        visible_buttons = self._getOption('general', 'visible_buttons', 'list')
        if visible_buttons is not None:
            for key in TOOLBAR_BUTTONS:
                self.toolbar_vars[key] = (key in visible_buttons)

        myGettext.language = self.language

        # solver
        solver_presets = self._getOption('general', 'solver_presets', 'list')
        if solver_presets is not None:
            if 'none' not in solver_presets:
                solver_presets.insert(0, 'none')
            self.solver_presets = solver_presets

        # sound_samples
        for key in self.sound_samples:
            val = self._getOption('sound_samples', key, 'bool')
            if val is not None:
                self.sound_samples[key] = val

        # fonts
        for key in self.fonts:
            if key == 'default':
                continue
            val = self._getOption('fonts', key, 'str')
            if val is not None:
                try:
                    val[1] = int(val[1])
                except Exception:
                    traceback.print_exc()
                else:
                    val = tuple(val)
                    self.fonts[key] = val

        # colors
        for key in self.colors:
            val = self._getOption('colors', key, 'str')
            if val is not None:
                self.colors[key] = val

        # timeouts
        for key in self.timeouts:
            val = self._getOption('timeouts', key, 'float')
            if val is not None:
                self.timeouts[key] = val

        # cardsets
        for key in self.cardset:
            val = self._getOption('cardsets', str(key), 'list')
            if val is not None:
                try:
                    self.cardset[int(key)] = val
                except Exception:
                    traceback.print_exc()
        for key, t in (('scale_cards', 'bool'),
                       ('scale_x', 'float'),
                       ('scale_y', 'float'),
                       ('auto_scale', 'bool'),
                       ('preserve_aspect_ratio', 'bool')):
            val = self._getOption('cardsets', key, t)
            if val is not None:
                setattr(self, key, val)

        # games_geometry
        for key, val in config['games_geometry'].items():
            try:
                val = [int(i) for i in val]
                assert len(val) == 2
                self.games_geometry[int(key)] = val
            except Exception:
                traceback.print_exc()
        game_geometry = self._getOption('general', 'game_geometry', 'list')
        if game_geometry is not None:
            try:
                self.game_geometry = tuple(int(i) for i in game_geometry)
            except Exception:
                traceback.print_exc()

        # cards offsets
        for key, val in config['offsets'].items():
            try:
                val = [int(i) for i in val]
                assert len(val) == 2
                self.offsets[key] = val
            except Exception:
                traceback.print_exc()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


# imports
import os
import re
import subprocess
import time
from io import BytesIO

# PySol imports
from pysollib.mfxutil import destruct
from pysollib.pysolrandom import constructRandom
from pysollib.settings import DEBUG, FCS_COMMAND
from pysollib.util import KING

import six

FCS_VERSION = None

# ************************************************************************
# * HintInterface is an abstract class that defines the public
# * interface - it only consists of the constructor
# * and the getHints() method.
# *
# * The whole hint system is exclusively used by Game.getHints().
# ************************************************************************


class HintInterface:
    # level == 0: show hint (key `H')
    # level == 1: show hint and display score value (key `Ctrl-H')
    # level == 2: demo
    def __init__(self, game, level):
        pass

    # Compute all hints for the current position.
    # Subclass responsibility.
    #
    # Returns a list of "atomic hints" - an atomic hint is a 7-tuple
    # (score, pos, ncards, from_stack, to_stack, text_color, forced_move).
    #
    #    if ncards == 0: deal cards
    #    elif from_stack == to_stack: flip card
    #    else: move cards from from_stack to to_stack
    #
    #    score, pos and text_color are only for debugging.
    #    A forced_move is the next move that must be taken after this move
    #    in order to avoid endless loops during demo play.
    #
    # Deal and flip may only happen if self.level >= 2 (i.e. demo).
    #
    # See Game.showHint() for more information.
    def getHints(self, taken_hint=None):
        return []


# ************************************************************************
# * AbstractHint provides a useful framework for derived hint classes.
# *
# * Subclasses should override computeHints()
# ************************************************************************

class AbstractHint(HintInterface):
    def __init__(self, game, level):
        self.game = game
        self.level = level
        self.score_flatten_value = 0
        if self.level == 0:
            self.score_flatten_value = 10000
        # temporaries within getHints()
        self.bonus_color = None
        #
        self.__clones = []
        self.reset()

    def __del__(self):
        self.reset()

    def reset(self):
        self.hints = []
        self.max_score = 0
        self.__destructClones()
        self.solver_state = 'not_started'

    #
    # stack cloning
    #

    # Create a shallow copy of a stack.
    class AClonedStack:
        def __init__(self, stack, stackcards):
            # copy class identity
            self.__class__ = stack.__class__
            # copy model data (reference copy)
            stack.copyModel(self)
            # set new cards (shallow copy of the card list)
            self.cards = stackcards[:]

    def ClonedStack(self, stack, stackcards):
        s = self.AClonedStack(stack, stackcards)
        self.__clones.append(s)
        return s

    def __destructClones(self):
        for s in self.__clones:
            s.__class__ = self.AClonedStack     # restore orignal class
            destruct(s)
        self.__clones = []

    # When computing hints for level 0, the scores are flattened
    # (rounded down) to a multiple of score_flatten_value.
    #
    # The idea is that hints will appear equal within a certain score range
    # so that the player will not get confused by the demo-intelligence.
    #
    # Pressing `Ctrl-H' (level 1) will preserve the score.

    def addHint(self, score, ncards, from_stack,
                to_stack, text_color=None, forced_move=None):
        if score < 0:
            return
        self.max_score = max(self.max_score, score)
        # add an atomic hint
        if self.score_flatten_value > 0:
            score = (score // self.score_flatten_value) * \
                    self.score_flatten_value
        if text_color is None:
            text_color = self.BLACK
        assert forced_move is None or len(forced_move) == 7
        # pos is used for preserving the original sort order on equal scores
        pos = -len(self.hints)
        ah = (int(score), pos, ncards, from_stack, to_stack,
              text_color, forced_move)
        self.hints.append(ah)

    # clean up and return hints sorted by score
    def _returnHints(self):
        hints = self.hints
        self.reset()
        hints.sort()
        hints.reverse()
        return hints

    #
    # getHints() default implementation:
    #   - handle forced moves
    #   - try to flip face-down cards
    #   - call computeHints() to do something useful
    #   - try to deal cards
    #   - clean up and return hints sorted by score
    #

    # Default scores for flip and deal moves.
    SCORE_FLIP = 100000         # 0..100000
    SCORE_DEAL = 0              # 0..100000

    def getHints(self, taken_hint=None):
        # 0) setup
        self.reset()
        game = self.game
        # 1) forced moves of the prev. taken hint have absolute priority
        if taken_hint and taken_hint[6]:
            return [taken_hint[6]]
        # 2) try if we can flip a card
        if self.level >= 2:
            for r in game.allstacks:
                if r.canFlipCard():
                    self.addHint(self.SCORE_FLIP, 1, r, r)
                    if self.SCORE_FLIP >= 90000:
                        return self._returnHints()
        # 3) ask subclass to do something useful
        self.computeHints()
        # 4) try if we can deal cards
        if self.level >= 2:
            if game.canDealCards():
                self.addHint(self.SCORE_DEAL, 0, game.s.talon, None)
        return self._returnHints()

    # subclass
    def computeHints(self):
        pass

    #
    # utility shallMovePile()
    #

    # we move the pile if it is accepted by the target stack
    def _defaultShallMovePile(self, from_stack, to_stack, pile, rpile):
        if from_stack is to_stack or not \
                to_stack.acceptsCards(from_stack, pile):
            return 0
        return 1

    # same, but check for loops
    def _cautiousShallMovePile(self, from_stack, to_stack, pile, rpile):
        if from_stack is to_stack or not \
                to_stack.acceptsCards(from_stack, pile):
            return 0
        #
        if len(rpile) == 0:
            return 1
        # now check for loops
        rr = self.ClonedStack(from_stack, stackcards=rpile)
        if rr.acceptsCards(to_stack, pile):
            # the pile we are going to move could be moved back -
            # this is dangerous as we can create endless loops...
            return 0
        return 1

    # same, but only check for loops only when in demo mode
    def _cautiousDemoShallMovePile(self, from_stack, to_stack, pile, rpile):
        if from_stack is to_stack or not \
                to_stack.acceptsCards(from_stack, pile):
            return 0
        if self.level >= 2:
            #
            if len(rpile) == 0:
                return 1
            # now check for loops
            rr = self.ClonedStack(from_stack, stackcards=rpile)
            if rr.acceptsCards(to_stack, pile):
                # the pile we are going to move could be moved back -
                # this is dangerous as we can create endless loops...
                return 0
        return 1

    shallMovePile = _defaultShallMovePile

    #
    # other utility methods
    #

    def _canDropAllCards(self, from_stack, stacks, stackcards):
        assert from_stack not in stacks
        return 0
        # FIXME: this does not account for cards which are dropped herein
        #         cards = pile[:]
        #         cards.reverse()
        #         for card in cards:
        #             for s in stacks:
        #                 if s is not from_stack:
        #                     if s.acceptsCards(from_stack, [card]):
        #                         break
        #             else:
        #                 return 0
        #         return 1

    #
    # misc. constants
    #

    # score value so that the scores look nicer
    K = KING + 1
    # text_color that will display the score (for debug with level 1)
    BLACK = "black"
    RED = "red"
    BLUE = "blue"


# ************************************************************************
# *
# ************************************************************************

class DefaultHint(AbstractHint):

    # The DefaultHint is optimized for Klondike type games
    # and also deals quite ok with other simple variants.
    #
    # But it completely lacks any specific strategy about game
    # types like Forty Thieves, FreeCell, Golf, Spider, ...
    #
    # BTW, we do not cheat !

    #
    # bonus scoring used in _getXxxScore() below - subclass overrideable
    #

    def _preferHighRankMoves(self):
        return 0

    # Basic bonus for moving a card.
    # Bonus must be in range 0..999

    BONUS_DROP_CARD = 300        # 0..400
    BONUS_SAME_SUIT_MOVE = 200        # 0..400
    BONUS_NORMAL_MOVE = 100        # 0..400

    def _getMoveCardBonus(self, r, t, pile, rpile):
        assert pile
        bonus = 0
        if rpile:
            rr = self.ClonedStack(r, stackcards=rpile)
            if (rr.canDropCards(self.game.s.foundations))[0]:
                # the card below the pile can be dropped
                bonus = self.BONUS_DROP_CARD
        if t.cards and t.cards[-1].suit == pile[0].suit:
            # simple heuristics - prefer moving high-rank cards
            bonus += self.BONUS_SAME_SUIT_MOVE + (1 + pile[0].rank)
        elif self._preferHighRankMoves():
            # simple heuristics - prefer moving high-rank cards
            bonus += self.BONUS_NORMAL_MOVE + (1 + pile[0].rank)
        elif rpile:
            # simple heuristics - prefer low-rank cards in rpile
            bonus += self.BONUS_NORMAL_MOVE + (self.K - rpile[-1].rank)
        else:
            # simple heuristics - prefer moving high-rank cards
            bonus += self.BONUS_NORMAL_MOVE + (1 + pile[0].rank)
        return bonus

    # Special bonus for facing up a card after the current move.
    # Bonus must be in range 0..9000

    BONUS_FLIP_CARD = 1500        # 0..9000

    def _getFlipSpecialBonus(self, r, t, pile, rpile):
        assert pile and rpile
        # The card below the pile can be flipped
        # (do not cheat and look at it !)
        # default: prefer a short rpile
        bonus = max(self.BONUS_FLIP_CARD - len(rpile), 0)
        return bonus

    # Special bonus for moving a pile from stack r to stack t.
    # Bonus must be in range 0..9000

    BONUS_CREATE_EMPTY_ROW = 9000        # 0..9000
    BONUS_CAN_DROP_ALL_CARDS = 4000        # 0..4000
    BONUS_CAN_CREATE_EMPTY_ROW = 2000        # 0..4000

    def _getMoveSpecialBonus(self, r, t, pile, rpile):
        # check if we will create an empty row
        if not rpile:
            return self.BONUS_CREATE_EMPTY_ROW
        # check if the card below the pile can be flipped
        if not rpile[-1].face_up:
            return self._getFlipSpecialBonus(r, t, pile, rpile)
        # check if all the cards below our pile could be dropped
        if self._canDropAllCards(r, self.game.s.foundations, stackcards=rpile):
            # we can drop the whole remaining pile
            # (and will create an empty row in the next move)
            # print "BONUS_CAN_DROP_ALL_CARDS", r, pile, rpile
            self.bonus_color = self.RED
            return self.BONUS_CAN_DROP_ALL_CARDS + \
                self.BONUS_CAN_CREATE_EMPTY_ROW
        # check if the cards below our pile are a whole row
        if r.canMoveCards(rpile):
            # could we move the remaining pile ?
            for x in self.game.s.rows:
                # note: we allow x == r here, because the pile
                #       (currently at the top of r) will be
                #       available in the next move
                if x is t or not x.cards:
                    continue
                if x.acceptsCards(r, rpile):
                    # we can create an empty row in the next move
                    # print "BONUS_CAN_CREATE_EMPTY_ROW", r, x, pile, rpile
                    self.bonus_color = self.BLUE
                    return self.BONUS_CAN_CREATE_EMPTY_ROW
        return 0

    #
    # scoring used in getHints() - subclass overrideable
    #

    # Score for moving a pile from stack r to stack t.
    # Increased score should be in range 0..9999
    def _getMovePileScore(self, score, color, r, t, pile, rpile):
        assert pile
        self.bonus_color = color
        b1 = self._getMoveSpecialBonus(r, t, pile, rpile)
        assert 0 <= b1 <= 9000
        b2 = self._getMoveCardBonus(r, t, pile, rpile)
        assert 0 <= b2 <= 999
        return score + b1 + b2, self.bonus_color

    # Score for moving a pile (usually a single card) from the WasteStack.
    def _getMoveWasteScore(self, score, color, r, t, pile, rpile):
        assert pile
        self.bonus_color = color
        score = 30000
        if t.cards:
            score = 31000
        b2 = self._getMoveCardBonus(r, t, pile, rpile)
        assert 0 <= b2 <= 999
        return score + b2, self.bonus_color

    # Score for dropping ncards from stack r to stack t.
    def _getDropCardScore(self, score, color, r, t, ncards):
        assert t is not r
        if ncards > 1:
            # drop immediately (Spider)
            return 93000, color
        pile = r.cards
        c = pile[-1]
        # compute distance to t.cap.base_rank - compare Stack.getRankDir()
        if t.cap.base_rank < 0:
            d = len(t.cards)
        else:
            d = (c.rank - t.cap.base_rank) % t.cap.mod
            if d > t.cap.mod // 2:
                d -= t.cap.mod
        if abs(d) <= 1:
            # drop Ace and 2 immediately
            score = 92000
        elif r in self.game.sg.talonstacks:
            score = 25000              # less than _getMoveWasteScore()
        elif len(pile) == 1:
            # score = 50000
            score = 91000
        elif self._canDropAllCards(
                r, self.game.s.foundations, stackcards=pile[:-1]):
            score = 90000
            color = self.RED
        else:
            # don't drop this card too eagerly - we may need it
            # for pile moving
            score = 50000
        score += (self.K - c.rank)
        return score, color

    #
    # compute hints - main hint intelligence
    #

    def computeHints(self):
        game = self.game

        # 1) check Tableau piles
        self.step010(game.sg.dropstacks, game.s.rows)

        # 2) try if we can move part of a pile within the RowStacks
        #    so that we can drop a card afterwards
        if not self.hints and self.level >= 1:
            self.step020(game.s.rows, game.s.foundations)

        # 3) try if we should move a card from a Foundation to a RowStack
        if not self.hints and self.level >= 1:
            self.step030(game.s.foundations, game.s.rows, game.sg.dropstacks)

        # 4) try if we can move a card from a RowStack to a ReserveStack
        if not self.hints or self.level == 0:
            self.step040(game.s.rows, game.sg.reservestacks)

        # 5) try if we should move a card from a ReserveStack to a RowStack
        if not self.hints or self.level == 0:
            self.step050(game.sg.reservestacks, game.s.rows)

        # Don't be too clever and give up ;-)

    #
    # implementation of the hint steps
    #

    # 1) check Tableau piles

    def step010(self, dropstacks, rows):
        # for each stack
        for r in dropstacks:
            # 1a) try if we can drop cards
            t, ncards = r.canDropCards(self.game.s.foundations)
            if t:
                score, color = 0, None
                score, color = self._getDropCardScore(
                    score, color, r, t, ncards)
                self.addHint(score, ncards, r, t, color)
                if score >= 90000 and self.level >= 1:
                    break
            # 1b) try if we can move cards to one of the RowStacks
            for pile in self.step010b_getPiles(r):
                if pile:
                    self.step010_movePile(r, pile, rows)

    def step010b_getPiles(self, stack):
        # return all moveable piles for this stack, longest one first
        return (stack.getPile(), )

    def step010_movePile(self, r, pile, rows):
        lp = len(pile)
        lr = len(r.cards)
        assert 1 <= lp <= lr
        rpile = r.cards[: (lr-lp)]   # remaining pile

        empty_row_seen = 0
        r_is_waste = r in self.game.sg.talonstacks

        for t in rows:
            score, color = 0, None
            if not self.shallMovePile(r, t, pile, rpile):
                continue
            if r_is_waste:
                # moving a card from the WasteStack
                score, color = self._getMoveWasteScore(
                    score, color, r, t, pile, rpile)
            else:
                if not t.cards:
                    # the target stack is empty
                    if lp == lr:
                        # do not move a whole stack from row to row
                        continue
                    if empty_row_seen:
                        # only make one hint for moving to an empty stack
                        # (in case we have multiple empty stacks)
                        continue
                    score = 60000
                    empty_row_seen = 1
                else:
                    # the target stack is not empty
                    score = 80000
                score, color = self._getMovePileScore(
                    score, color, r, t, pile, rpile)
            self.addHint(score, lp, r, t, color)

    # 2) try if we can move part of a pile within the RowStacks
    #    so that we can drop a card afterwards
    #    score: 40000 .. 59999

    step020_getPiles = step010b_getPiles

    def step020(self, rows, foundations):
        for r in rows:
            for pile in self.step020_getPiles(r):
                if not pile or len(pile) < 2:
                    continue
                # is there a card in our pile that could be dropped ?
                drop_info = []
                i = 0
                for c in pile:
                    rr = self.ClonedStack(r, stackcards=[c])
                    stack, ncards = rr.canDropCards(foundations)
                    if stack and stack is not r:
                        assert ncards == 1
                        drop_info.append((c, stack, ncards, i))
                    i += 1
                # now try to make a move so that the drop-card will get free
                for di in drop_info:
                    c = di[0]
                    sub_pile = pile[di[3]+1:]
                    # print "trying drop move", c, pile, sub_pile
                    # assert r.canMoveCards(sub_pile)
                    if not r.canMoveCards(sub_pile):
                        continue
                    for t in rows:
                        if t is r or not t.acceptsCards(r, sub_pile):
                            continue
                        # print "drop move", r, t, sub_pile
                        score = 40000
                        score += 1000 + (self.K - r.getCard().rank)
                        # force the drop (to avoid loops)
                        force = (999999, 0, di[2], r, di[1], self.BLUE, None)
                        self.addHint(
                                score, len(sub_pile), r, t,
                                self.RED, forced_move=force)

    # 3) try if we should move a card from a Foundation to a RowStack
    #    score: 20000 .. 29999

    def step030(self, foundations, rows, dropstacks):
        for s in foundations:
            card = s.getCard()
            if not card or not s.canMoveCards([card]):
                continue
            # search a RowStack that would accept the card
            for t in rows:
                if t is s or not t.acceptsCards(s, [card]):
                    continue
                tt = self.ClonedStack(t, stackcards=t.cards+[card])
                # search a Stack that would benefit from this card
                for r in dropstacks:
                    if r is t:
                        continue
                    pile = r.getPile()
                    if not pile:
                        continue
                    if not tt.acceptsCards(r, pile):
                        continue
                    # compute remaining pile in r
                    rpile = r.cards[:(len(r.cards)-len(pile))]
                    rr = self.ClonedStack(r, stackcards=rpile)
                    if rr.acceptsCards(t, pile):
                        # the pile we are going to move from r to t
                        # could be moved back from t ro r - this is
                        # dangerous as we can create loops...
                        continue
                    score = 20000 + card.rank
                    # print score, s, t, r, pile, rpile
                    # force the move from r to t (to avoid loops)
                    force = (999999, 0, len(pile), r, t, self.BLUE, None)
                    self.addHint(score, 1, s, t, self.BLUE, forced_move=force)

    # 4) try if we can move a card from a RowStack to a ReserveStack
    #    score: 10000 .. 19999

    def step040(self, rows, reservestacks):
        if not reservestacks:
            return
        for r in rows:
            card = r.getCard()
            if not card or not r.canMoveCards([card]):
                continue
            pile = [card]
            # compute remaining pile in r
            rpile = r.cards[:(len(r.cards)-len(pile))]
            rr = self.ClonedStack(r, stackcards=rpile)
            for t in reservestacks:
                if t is r or not t.acceptsCards(r, pile):
                    continue
                if rr.acceptsCards(t, pile):
                    # the pile we are going to move from r to t
                    # could be moved back from t ro r - this is
                    # dangerous as we can create loops...
                    continue
                score = 10000
                score, color = self._getMovePileScore(
                    score, None, r, t, pile, rpile)
                self.addHint(score, len(pile), r, t, color)
                break

    # 5) try if we should move a card from a ReserveStack to a RowStack

    def step050(self, reservestacks, rows):
        if not reservestacks:
            return
        # FIXME


# ************************************************************************
# *
# ************************************************************************

class CautiousDefaultHint(DefaultHint):
    shallMovePile = DefaultHint._cautiousShallMovePile
    # shallMovePile = DefaultHint._cautiousDemoShallMovePile

    def _preferHighRankMoves(self):
        return 1


# ************************************************************************
# * now some default hints for the various game types
# ************************************************************************

# DefaultHint is optimized for Klondike type games anyway
class KlondikeType_Hint(DefaultHint):
    pass


# this works for Yukon, but not too well for Russian Solitaire
class YukonType_Hint(CautiousDefaultHint):
    def step010b_getPiles(self, stack):
        # return all moveable piles for this stack, longest one first
        p = stack.getPile()
        piles = []
        while p:
            piles.append(p)
            p = p[1:]       # note: we need a fresh shallow copy
        return piles


class Yukon_Hint(YukonType_Hint):
    BONUS_FLIP_CARD = 9000
    BONUS_CREATE_EMPTY_ROW = 100

    # FIXME: this is only a rough approximation and doesn't seem to help
    #        for Russian Solitaire
    def _getMovePileScore(self, score, color, r, t, pile, rpile):
        s, color = YukonType_Hint._getMovePileScore(
            self, score, color, r, t, pile, rpile)
        bonus = s - score
        assert 0 <= bonus <= 9999
        # We must take care when moving piles that we won't block cards,
        # i.e. if there is a card in pile which would be needed
        # for a card in stack t.
        tpile = t.getPile()
        if tpile:
            for cr in pile:
                rr = self.ClonedStack(r, stackcards=[cr])
                for ct in tpile:
                    if rr.acceptsCards(t, [ct]):
                        d = bonus // 1000
                        bonus = (d * 1000) + bonus % 100
                        break
        return score + bonus, color


# FIXME
class FreeCellType_Hint(CautiousDefaultHint):
    pass


class GolfType_Hint(DefaultHint):
    pass


class SpiderType_Hint(DefaultHint):
    pass


class PySolHintLayoutImportError(Exception):

    def __init__(self, msg, cards, line_num):
        """docstring for __init__"""
        self.msg = msg
        self.cards = cards
        self.line_num = line_num

    def format(self):
        return self.msg + ":\n\n" + ', '.join(self.cards)


# ************************************************************************
# * FreeCell-Solver
# ************************************************************************

class Base_Solver_Hint:
    def __init__(self, game, dialog, **game_type):
        self.game = game
        self.dialog = dialog
        self.game_type = game_type
        self.options = {
            'iters_step': 100,
            'max_iters': 10000,
            'progress': False,
            'preset': None,
            }
        self.hints = []
        self.hints_index = 0

        # correct cards rank if foundations.base_rank != 0 (Penguin, Opus)
        if 'base_rank' in game_type:    # (Simple Simon)
            self.base_rank = game_type['base_rank']
        else:
            self.base_rank = game.s.foundations[0].cap.base_rank
        # print 'game_type:', game_type
        # print 'base_rank:', self.base_rank

    def config(self, **kw):
        self.options.update(kw)

    def _card2str_format(self, fmt, rank, suit):
        # row and reserves
        rank = (rank-self.base_rank) % 13
        return fmt % {'R': "A23456789TJQK"[rank], 'S': "CSHD"[suit]}

    def card2str1_(self, rank, suit):
        # row and reserves
        return self._card2str_format('%(R)s%(S)s', rank, suit)

    def card2str1(self, card):
        return self.card2str1_(card.rank, card.suit)

    def card2str2(self, card):
        # foundations
        return self._card2str_format('%(S)s-%(R)s', card.rank, card.suit)

# hard solvable: Freecell #47038300998351211829 (65539 iters)

    def getHints(self, taken_hint=None):
        if taken_hint and taken_hint[6]:
            return [taken_hint[6]]
        h = self.hints[self.hints_index]
        # print 'getHints', taken_hint, h
        if h is None:
            return None
        ncards, src, dest = h
        thint = None
        if len(src.cards) > ncards and not src.cards[-ncards-1].face_up:
            # flip card
            thint = (999999, 0, 1, src, src, None, None)
        skip = False
        if dest is None:                 # foundation
            if src is self.game.s.talon:
                if not src.cards[-1].face_up:
                    self.game.flipMove(src)
                # src.prepareStack()
                # src.dealCards()
                dest = self.game.s.foundations[0]
                # skip = True
            else:
                cards = src.cards[-ncards:]
                for f in self.game.s.foundations:
                    if f.acceptsCards(src, cards):
                        dest = f
                        break
        assert dest
        self.hints_index += 1
        if skip:
            return []
        hint = (999999, 0, ncards, src, dest, None, thint)
        # print hint
        return [hint]

    def colonPrefixMatch(self, prefix, s):
        m = re.match(prefix + ': ([0-9]+)', s)
        if m:
            self._v = int(m.group(1))
            return True
        else:
            self._v = None
            return False

    def run_solver(self, command, board):
        if DEBUG:
            print(command)
        kw = {'shell': True,
              'stdin': subprocess.PIPE,
              'stdout': subprocess.PIPE,
              'stderr': subprocess.PIPE}
        if os.name != 'nt':
            kw['close_fds'] = True
        p = subprocess.Popen(command, **kw)
        bytes_board = six.binary_type(board, 'utf-8')
        pout, perr = p.communicate(bytes_board)
        if p.returncode in (127, 1):
            # Linux and Windows return codes for "command not found" error
            raise RuntimeError('Solver exited with {}'.format(p.returncode))
        return BytesIO(pout), BytesIO(perr)


class FreeCellSolver_Hint(Base_Solver_Hint):
    def _determineIfSolverState(self, line):
        if re.search('^(?:Iterations count exceeded)', line):
            self.solver_state = 'intractable'
            return True
        elif re.search('^(?:I could not solve this game)', line):
            self.solver_state = 'unsolved'
            return True
        else:
            return False

    def _isSimpleSimon(self):
        game_type = self.game_type
        return ('preset' in game_type and
                game_type['preset'] == 'simple_simon')

    def _addBoardLine(self, l):
        self.board += l + '\n'
        return

    def _addPrefixLine(self, prefix, b):
        if b:
            self._addBoardLine(prefix + b)
        return

    def importFile(solver, fh, s_game, self):
        s_game.endGame()
        s_game.random = constructRandom('Custom')
        s_game.newGame(
            shuffle=True,
            random=constructRandom('Custom'),
            dealer=lambda: solver.importFileHelper(fh, s_game))
        s_game.random = constructRandom('Custom')

    def importFileHelper(solver, fh, s_game):
        game = s_game.s
        stack_idx = 0

        RANKS_S = "A23456789TJQK"
        RANKS0_S = '0' + RANKS_S
        RANKS_RE = '(?:' + '[' + RANKS_S + ']' + '|10)'
        SUITS_S = "CSHD"
        SUITS_RE = '[' + SUITS_S + ']'
        CARD_RE = r'(?:' + RANKS_RE + SUITS_RE + ')'
        line_num = 0

        def cards():
            return game.talon.cards

        def put(target, suit, rank):
            ret = [i for i, c in enumerate(cards())
                   if c.suit == suit and c.rank == rank]
            if len(ret) < 1:
                raise PySolHintLayoutImportError(
                    "Duplicate cards in input",
                    [solver.card2str1_(rank, suit)],
                    line_num
                )

            ret = ret[0]
            game.talon.cards = \
                cards()[0:ret] + cards()[(ret+1):] + [cards()[ret]]
            s_game.flipMove(game.talon)
            s_game.moveMove(1, game.talon, target, frames=0)

        def put_str(target, str_):
            put(target, SUITS_S.index(str_[-1]),
                (RANKS_S.index(str_[0]) if len(str_) == 2 else 9))

        def my_find_re(RE, m, msg):
            s = m.group(1)
            if not re.match(r'^\s*(?:' + RE + r')?(?:\s+' + RE + r')*\s*$', s):
                raise PySolHintLayoutImportError(
                    msg,
                    [],
                    line_num
                )
            return re.findall(r'\b' + RE + r'\b', s)

        # Based on https://stackoverflow.com/questions/8898294 - thanks!
        def mydecode(s):
            for encoding in "utf-8-sig", "utf-8":
                try:
                    return s.decode(encoding)
                except UnicodeDecodeError:
                    continue
            return s.decode("latin-1")  # will always work

        mytext = mydecode(fh.read())
        for line_p in mytext.splitlines():
            line_num += 1
            line = line_p.rstrip('\r\n')
            m = re.match(r'^(?:Foundations:|Founds?:)\s*(.*)', line)
            if m:
                for gm in my_find_re(
                        r'(' + SUITS_RE + r')-([' + RANKS0_S + r'])', m,
                        "Invalid Foundations line"):
                    for foundat in game.foundations:
                        suit = foundat.cap.suit
                        if SUITS_S[suit] == gm[0]:
                            rank = gm[1]
                            if len(rank) == 1:
                                lim = RANKS0_S.index(rank)
                            else:
                                lim = 10
                            for r in range(lim):
                                put(foundat, suit, r)
                            break
                continue
            m = re.match(r'^(?:FC:|Freecells:)\s*(.*)', line)
            if m:
                g = my_find_re(r'(' + CARD_RE + r'|\-)', m,
                               "Invalid Freecells line")
                while len(g) < len(game.reserves):
                    g.append('-')
                for i, gm in enumerate(g):
                    str_ = gm
                    if str_ != '-':
                        put_str(game.reserves[i], str_)
                continue
            m = re.match(r'^:?\s*(.*)', line)
            for str_ in my_find_re(r'(' + CARD_RE + r')', m,
                                   "Invalid column text"):
                put_str(game.rows[stack_idx], str_)

            stack_idx += 1
        if len(cards()) > 0:
            raise PySolHintLayoutImportError(
                "Missing cards in input",
                [solver.card2str1(c) for c in cards()],
                -1
            )

    def calcBoardString(self):
        game = self.game
        self.board = ''
        is_simple_simon = self._isSimpleSimon()
        #
        #
        b = ''
        for s in game.s.foundations:
            if s.cards:
                b += ' ' + self.card2str2(
                    s.cards[0 if is_simple_simon else -1])
        self._addPrefixLine('Founds:', b)

        b = ''
        for s in game.s.reserves:
            b += ' ' + (self.card2str1(s.cards[-1]) if s.cards else '-')
        self._addPrefixLine('FC:', b)

        for s in game.s.rows:
            b = ''
            for c in s.cards:
                cs = self.card2str1(c)
                if not c.face_up:
                    cs = '<%s>' % cs
                b += cs + ' '
            self._addBoardLine(b.strip())

        return self.board

    def computeHints(self):
        game = self.game
        game_type = self.game_type
        global FCS_VERSION
        if FCS_VERSION is None:
            pout, _ = self.run_solver(FCS_COMMAND + ' --version', '')
            s = six.text_type(pout.read(), encoding='utf-8')
            m = re.search(r'version ([0-9]+)\.([0-9]+)\.([0-9]+)', s)
            if m:
                FCS_VERSION = (int(m.group(1)), int(m.group(2)),
                               int(m.group(3)))
            else:
                FCS_VERSION = (0, 0, 0)

        progress = self.options['progress']

        board = self.calcBoardString()
        #
        if DEBUG:
            print('--------------------\n', board, '--------------------')
        #
        args = []
        # args += ['-sam', '-p', '-opt', '--display-10-as-t']
        args += ['-m', '-p', '-opt', '-sel']
        if FCS_VERSION >= (4, 20, 0):
            args += ['-hoi']
        if progress:
            args += ['--iter-output']
            fcs_iter_output_step = None
            if FCS_VERSION >= (4, 20, 0):
                # fcs_iter_output_step = 10000
                fcs_iter_output_step = self.options['iters_step']
                args += ['--iter-output-step', str(fcs_iter_output_step)]
            if DEBUG:
                args += ['-s']
        if self.options['preset'] and self.options['preset'] != 'none':
            args += ['--load-config', self.options['preset']]
        args += ['--max-iters', self.options['max_iters'],
                 '--decks-num', game.gameinfo.decks,
                 '--stacks-num', len(game.s.rows),
                 '--freecells-num', len(game.s.reserves),
                 ]
        #
        if 'preset' in game_type:
            args += ['--preset', game_type['preset']]
        if 'sbb' in game_type:
            args += ['--sequences-are-built-by', game_type['sbb']]
        if 'sm' in game_type:
            args += ['--sequence-move', game_type['sm']]
        if 'esf' in game_type:
            args += ['--empty-stacks-filled-by', game_type['esf']]

        command = FCS_COMMAND+' '+' '.join([str(i) for i in args])
        pout, perr = self.run_solver(command, board)
        self.solver_state = 'unknown'
        #
        stack_types = {
            'the': game.s.foundations,
            'stack': game.s.rows,
            'freecell': game.s.reserves,
            }
        if DEBUG:
            start_time = time.time()
        if progress:
            # iteration output
            iter_ = 0
            depth = 0
            states = 0

            for sbytes in pout:
                s = six.text_type(sbytes, encoding='utf-8')
                if DEBUG >= 5:
                    print(s)

                if self.colonPrefixMatch('Iteration', s):
                    iter_ = self._v
                elif self.colonPrefixMatch('Depth', s):
                    depth = self._v
                elif self.colonPrefixMatch('Stored-States', s):
                    states = self._v
                    if iter_ % 100 == 0 or fcs_iter_output_step:
                        self.dialog.setText(iter=iter_, depth=depth,
                                            states=states)
                elif re.search('^(?:-=-=)', s):
                    break
                elif self._determineIfSolverState(s):
                    break
            self.dialog.setText(iter=iter_, depth=depth, states=states)

        hints = []
        for sbytes in pout:
            s = six.text_type(sbytes, encoding='utf-8')
            if DEBUG:
                print(s)
            if self._determineIfSolverState(s):
                next
            m = re.match('Total number of states checked is ([0-9]+)\\.', s)
            if m:
                iter_ = int(m.group(1))
                self.dialog.setText(iter=iter_)

            m = re.match('This scan generated ([0-9]+) states\\.', s)

            if m:
                states = int(m.group(1))
                self.dialog.setText(states=states)

            m = re.match('Move (.*)', s)
            if not m:
                continue

            move_s = m.group(1)

            m = re.match(
                'the sequence on top of Stack ([0-9]+) to the foundations',
                move_s)

            if m:
                ncards = 13
                st = stack_types['stack']
                sn = int(m.group(1))
                src = st[sn]
                dest = None
            else:
                m = re.match(
                    '(?P<ncards>a card|(?P<count>[0-9]+) cards) '
                    'from (?P<source_type>stack|freecell) '
                    '(?P<source_idx>[0-9]+) to '
                    '(?P<dest>the foundations|(?P<dest_type>freecell|stack) '
                    '(?P<dest_idx>[0-9]+))\\s*', move_s)

                if not m:
                    continue

                ncards = m.group('ncards')
                if ncards == 'a card':
                    ncards = 1
                else:
                    ncards = int(m.group('count'))

                st = stack_types[m.group('source_type')]
                sn = int(m.group('source_idx'))
                src = st[sn]            # source stack

                dest_s = m.group('dest')
                if dest_s == 'the foundations':
                    # to foundation
                    dest = None
                else:
                    # to rows or reserves
                    dt = stack_types[m.group('dest_type')]
                    dn = int(m.group('dest_idx'))
                    dest = dt[dn]

            hints.append([ncards, src, dest])
            # print src, dest, ncards

        #
        if DEBUG:
            print('time:', time.time()-start_time)
        # print perr.read(),

        self.hints = hints
        if len(hints) > 0:
            if self.solver_state != 'intractable':
                self.solver_state = 'solved'
        self.hints.append(None)         # XXX

        # print self.hints

        pout.close()
        perr.close()


class BlackHoleSolver_Hint(Base_Solver_Hint):
    BLACK_HOLE_SOLVER_COMMAND = 'black-hole-solve'

    def calcBoardString(self):
        board = ''
        cards = self.game.s.talon.cards
        if (len(cards) > 0):
            board += ' '.join(['Talon:'] +
                              [self.card2str1(x) for x in reversed(cards)])
            board += '\n'
        cards = self.game.s.foundations[0].cards
        s = '-'
        if (len(cards) > 0):
            s = self.card2str1(cards[-1])
        board += 'Foundations: ' + s + '\n'

        for s in self.game.s.rows:
            b = ''
            for c in s.cards:
                cs = self.card2str1(c)
                if not c.face_up:
                    cs = '<%s>' % cs
                b += cs + ' '
            board += b.strip() + '\n'

        return board

    def computeHints(self):
        game = self.game
        game_type = self.game_type

        board = self.calcBoardString()
        #
        if DEBUG:
            print('--------------------\n', board, '--------------------')
        #
        args = []
        # args += ['-sam', '-p', '-opt', '--display-10-as-t']
        args += ['--game', game_type['preset'], '--rank-reach-prune']
        args += ['--max-iters', self.options['max_iters']]
        if 'queens_on_kings' in game_type:
            args += ['--queens-on-kings']
        if 'wrap_ranks' in game_type:
            args += ['--wrap-ranks']
        #

        command = self.BLACK_HOLE_SOLVER_COMMAND + ' ' + \
            ' '.join([str(i) for i in args])
        pout, perr = self.run_solver(command, board)
        #
        if DEBUG:
            start_time = time.time()

        result = ''
        # iteration output
        iter_ = 0
        depth = 0
        states = 0

        for sbytes in pout:
            s = six.text_type(sbytes, encoding='utf-8')
            if DEBUG >= 5:
                print(s)

            m = re.search('^(Intractable|Unsolved|Solved)!', s.rstrip())
            if m:
                result = m.group(1)
                break

        self.dialog.setText(iter=iter_, depth=depth, states=states)
        self.solver_state = result.lower()

        hints = []
        for sbytes in pout:
            s = six.text_type(sbytes, encoding='utf-8')
            if DEBUG:
                print(s)

            if s.strip() == 'Deal talon':
                hints.append([1, game.s.talon, None])
                continue

            m = re.match('Total number of states checked is ([0-9]+)\\.', s)
            if m:
                iter_ = int(m.group(1))
                self.dialog.setText(iter=iter_)
                continue

            m = re.match('This scan generated ([0-9]+) states\\.', s)

            if m:
                states = int(m.group(1))
                self.dialog.setText(states=states)
                continue

            m = re.match(
                'Move a card from stack ([0-9]+) to the foundations', s)
            if not m:
                continue

            found_stack_idx = int(m.group(1))
            ncards = 1
            st = game.s.rows
            sn = found_stack_idx
            src = st[sn]            # source stack
            dest = None

            hints.append([ncards, src, dest])
            # print src, dest, ncards

        #
        if DEBUG:
            print('time:', time.time()-start_time)
        # print perr.read(),

        self.hints = hints
        self.hints.append(None)         # XXX

        # print self.hints

        pout.close()
        perr.close()


class FreeCellSolverWrapper:

    def __init__(self, **game_type):
        self.game_type = game_type

    def __call__(self, game, dialog):
        hint = FreeCellSolver_Hint(game, dialog, **self.game_type)
        return hint


class BlackHoleSolverWrapper:

    def __init__(self, **game_type):
        self.game_type = game_type

    def __call__(self, game, dialog):
        hint = BlackHoleSolver_Hint(game, dialog, **self.game_type)
        return hint
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


import os

from pysollib.mfxutil import Image, ImageTk, USE_PIL
from pysollib.pysoltk import copyImage, createBottom, createImage, loadImage
from pysollib.pysoltk import shadowImage
from pysollib.resource import CSI
from pysollib.settings import TOOLKIT

# ************************************************************************
# * Images
# ************************************************************************


class ImagesCardback:
    def __init__(self, index, name, image, menu_image=None):
        if menu_image is None:
            menu_image = image
        self.index = index
        self.name = name
        self.image = image
        self.menu_image = menu_image


class Images:
    def __init__(self, dataloader, cs, r=1):
        self.d = dataloader
        self.cs = cs
        self.reduced = r
        self._xfactor = 1.0
        self._yfactor = 1.0
        if cs is None:
            return
        self._setSize()
        self._card = []
        self._back = []
        # bottom of stack (link to _bottom_negative/_bottom_positive)
        self._bottom = []
        self._bottom_negative = []      # negative bottom of stack (white)
        self._bottom_positive = []      # positive bottom of stack (black)
        self._blank_bottom = None       # blank (transparent) bottom of stack
        self._letter = []               # images of letter
        self._letter_negative = []
        self._letter_positive = []
        # vertical shadow of card (used when we drag a card)
        self._shadow = []
        self._xshadow = []              # horizontal shadow of card
        self._pil_shadow = {}           # key: (width, height)
        self._highlight = []            # highlight of card (tip)
        self._highlight_index = 0       #
        self._highlighted_images = {}   # key: (suit, rank)

    def destruct(self):
        pass

    def __loadCard(self, filename, check_w=1, check_h=1):
        # print '__loadCard:', filename
        f = os.path.join(self.cs.dir, filename)
        if not os.path.exists(f):
            print('card image path %s does not exist' % (f))
            return None
        try:
            img = loadImage(file=f)
        except Exception:
            return None

        if TOOLKIT == 'kivy':
            w = img.texture.size[0]
            h = img.texture.size[1]
        else:
            w, h = img.width(), img.height()

        if self.CARDW < 0:
            self.CARDW, self.CARDH = w, h
        else:
            if ((check_w and w != self.CARDW) or
                    (check_h and h != self.CARDH)):
                raise ValueError("Invalid size %dx%d of image %s" % (w, h, f))
        return img

    def __loadBottom(self, filename, check_w=1, check_h=1, color='white'):
        cs_type = CSI.TYPE_ID[self.cs.type]
        imagedir = None
        d = os.path.join('images', 'cards', 'bottoms')
        try:
            imagedir = self.d.findDir(cs_type, d)
        except Exception:
            pass
        if (not USE_PIL and TOOLKIT != 'kivy') or imagedir is None:
            # load image
            img = self.__loadCard(filename+self.cs.ext, check_w, check_h)
            if USE_PIL and img is not None:
                # we have no bottom images
                # (data/images/cards/bottoms/<cs_type>)
                img = img.resize(self._xfactor, self._yfactor)
            return img
        # create image
        d = os.path.join('images', 'cards', 'bottoms', cs_type)
        try:
            fn = self.d.findImage(filename, d)
        except Exception:
            fn = None
        img = createBottom(self._card[0], color, fn)
        return img

    def __addBack(self, im1, name):
        r = max(self.CARDW / 40.0, self.CARDH / 60.0)
        r = max(2, int(round(r)))
        im2 = im1.subsample(r)
        self._back.append(ImagesCardback(len(self._back), name, im1, im2))

    def _createMissingImages(self):
        cw, ch = self.getSize()
        # back
        if not self._back:
            im = createImage(cw, ch, fill="#a0a0a0", outline="#000000")
            name = ""
            self.__addBack(im, name)
            self.cs.backnames = tuple(self.cs.backnames) + (name,)
        # bottoms / letters
        bottom = None
        neg_bottom = None
        while len(self._bottom_positive) < max(7, self.cs.nbottoms):
            if bottom is None:
                bottom = createImage(cw, ch, fill=None, outline="#000000")
            self._bottom_positive.append(bottom)
        while len(self._bottom_negative) < max(7, self.cs.nbottoms):
            if neg_bottom is None:
                neg_bottom = createImage(cw, ch, fill=None, outline="#ffffff")
            self._bottom_negative.append(neg_bottom)
        while len(self._letter_positive) < 4:
            if bottom is None:
                bottom = createImage(cw, ch, fill=None, outline="#000000")
            self._letter_positive.append(bottom)
        while len(self._letter_negative) < 4:
            if neg_bottom is None:
                neg_bottom = createImage(cw, ch, fill=None, outline="#ffffff")
            self._letter_negative.append(neg_bottom)
        self._blank_bottom = createImage(cw, ch, fill=None, outline=None)

    def load(self, app, progress=None):
        ext = self.cs.ext[1:]
        pstep = 0
        if progress:
            pstep = self.cs.ncards + len(self.cs.backnames) + \
                    self.cs.nbottoms + self.cs.nletters
            pstep += self.cs.nshadows + 1  # shadows & shade
            pstep = max(0, (80.0 - progress.percent) / pstep)
        # load face cards
        for n in self.cs.getFaceCardNames():
            self._card.append(self.__loadCard(n + self.cs.ext))
            self._card[-1].filename = n
            if progress:
                progress.update(step=pstep)
        assert len(self._card) == self.cs.ncards
        # load backgrounds
        for name in self.cs.backnames:
            if name:
                im = self.__loadCard(name)
                self.__addBack(im, name)
        if progress:
            progress.update(step=1)
        # load bottoms
        for i in range(self.cs.nbottoms):
            name = "bottom%02d" % (i + 1)
            bottom = self.__loadBottom(name, color='black')
            if bottom is not None:
                self._bottom_positive.append(bottom)
            if progress:
                progress.update(step=pstep)
            # load negative bottoms
            name = "bottom%02d-n" % (i + 1)
            bottom = self.__loadBottom(name, color='white')
            if bottom is not None:
                self._bottom_negative.append(bottom)
            if progress:
                progress.update(step=pstep)
        # load letters
        for rank in range(self.cs.nletters):
            name = "l%02d" % (rank + 1)
            self._letter_positive.append(
                self.__loadBottom(name, color='black'))
            if progress:
                progress.update(step=pstep)
            # load negative letters
            name = "l%02d-n" % (rank + 1)
            self._letter_negative.append(
                self.__loadBottom(name, color='white'))
            if progress:
                progress.update(step=pstep)
        # shadow
        if not USE_PIL:
            for i in range(self.cs.nshadows):
                name = "shadow%02d.%s" % (i, ext)
                im = self.__loadCard(name, check_w=0, check_h=0)
                self._shadow.append(im)
                if i > 0:  # skip 0
                    name = "xshadow%02d.%s" % (i, ext)
                    im = self.__loadCard(name, check_w=0, check_h=0)
                    self._xshadow.append(im)
                if progress:
                    progress.update(step=pstep)
        # shade
        if USE_PIL:
            self._highlight.append(
                self._getHighlight(self._card[0], None, '#3896f8'))
        else:
            self._highlight.append(self.__loadCard("shade." + ext))
        if progress:
            progress.update(step=pstep)
        # create missing
        self._createMissingImages()
        #
        self._bottom = self._bottom_positive
        self._letter = self._letter_positive
        #
        return 1

    def getFace(self, deck, suit, rank):
        index = suit * len(self.cs.ranks) + rank
        # print "getFace:", suit, rank, index
        return self._card[index % self.cs.ncards]

    def getBack(self, update=False):
        if update:
            self._shadow_back = None
        index = self.cs.backindex % len(self._back)
        return self._back[index].image

    def getTalonBottom(self):
        return self._bottom[0]

    def getReserveBottom(self):
        return self._bottom[0]

    def getBlankBottom(self):
        if TOOLKIT == 'kivy':
            return self._bottom[0]
        return self._blank_bottom

    def getSuitBottom(self, suit=-1):
        assert isinstance(suit, int)
        if suit == -1:
            return self._bottom[1]   # any suit
        i = 3 + suit
        if i >= len(self._bottom):
            # Trump (for Tarock type games)
            return self._bottom[1]
        return self._bottom[i]

    def getBraidBottom(self):
        return self._bottom[2]

    def getLetter(self, rank):
        assert 0 <= rank <= 3
        if rank >= len(self._letter):
            return self._bottom[0]
        return self._letter[rank]

    def getShadow(self, ncards):
        if ncards >= 0:
            if ncards >= len(self._shadow):
                # ncards = len(self._shadow) - 1
                return None
            return self._shadow[ncards]
        else:
            ncards = abs(ncards)-2
            if ncards >= len(self._xshadow):
                return None
            return self._xshadow[ncards]

    def getShadowPIL(self, stack, cards):
        x0, y0 = stack.getPositionFor(cards[0])
        x1, y1 = stack.getPositionFor(cards[-1])
        x0, x1 = min(x1, x0), max(x1, x0)
        y0, y1 = min(y1, y0), max(y1, y0)
        cw, ch = self.getSize()
        x1 += cw
        y1 += ch
        w, h = x1-x0, y1-y0
        if (w, h) in self._pil_shadow:
            return self._pil_shadow[(w, h)]
        # create mask
        mask = Image.new('RGBA', (w, h))
        for c in cards:
            x, y = stack.getPositionFor(c)
            x, y = x-x0, y-y0
            im = c._active_image._pil_image
            mask.paste(im, (x, y), im)
        # create shadow
        sh_color = (0x00, 0x00, 0x00, 0x50)
        shadow = Image.new('RGBA', (w, h))
        shadow.paste(sh_color, (0, 0, w, h), mask)
        sx, sy = self.SHADOW_XOFFSET, self.SHADOW_YOFFSET
        mask = mask.crop((sx, sy, w, h))
        tmp = Image.new('RGBA', (w-sx, h-sy))
        shadow.paste(tmp, (0, 0), mask)
        shadow = ImageTk.PhotoImage(shadow)
        self._pil_shadow[(w, h)] = shadow
        return shadow

    def getShade(self):
        # highlight
        return self._highlight[self._highlight_index]

    def _getHighlight(self, image, card, color='#3896f8', factor=0.3):
        if USE_PIL:
            # use semitransparent image; one for each color (PIL >= 1.1.7)
            if color in self._highlighted_images:
                shade = self._highlighted_images[color]
            else:
                shade = shadowImage(image, color, factor)
                self._highlighted_images[color] = shade
        else:
            # use alpha blending (PIL <= 1.1.6)
            if card in self._highlighted_images:
                shade = self._highlighted_images[card]
            else:
                shade = shadowImage(image, color, factor)
                self._highlighted_images[card] = shade
        if not shade:
            # we have not PIL
            return self.getShade()
        return shade

    def getHighlightedCard(self, deck, suit, rank, color=None):
        image = self.getFace(deck, suit, rank)
        if color:
            return self._getHighlight(image, (suit, rank, color), color)
        return self._getHighlight(image, (suit, rank))

    def getHighlightedBack(self):
        image = self.getBack()
        return self._getHighlight(image, 'back')

    def getCardbacks(self):
        return self._back

    def setNegative(self, flag=0):
        if flag:
            self._bottom = self._bottom_negative
            self._letter = self._letter_negative
        else:
            self._bottom = self._bottom_positive
            self._letter = self._letter_positive

    def setOffsets(self):
        cs = self.cs
        if cs is None:
            return
        r = self.reduced
        if r > 1:
            self.CARD_XOFFSET = max(10//r, cs.CARD_XOFFSET)
            self.CARD_YOFFSET = max(10//r, cs.CARD_YOFFSET)
        else:
            self.CARD_XOFFSET = cs.CARD_XOFFSET
            self.CARD_YOFFSET = cs.CARD_YOFFSET
        self.SHADOW_XOFFSET = cs.SHADOW_XOFFSET
        self.SHADOW_YOFFSET = cs.SHADOW_YOFFSET
        self.CARD_DX, self.CARD_DY = cs.CARD_DX, cs.CARD_DY

    def _setSize(self, xf=1, yf=1):
        # print 'image._setSize', xf, yf
        self._xfactor = xf
        self._yfactor = yf
        cs = self.cs
        if cs is None:
            return
        r = self.reduced
        xf = float(xf)/r
        yf = float(yf)/r
        # from cardset
        self.CARDW, self.CARDH = int(cs.CARDW*xf), int(cs.CARDH*yf)
        self.setOffsets()

    def getSize(self):
        return (int(self.CARDW * self._xfactor),
                int(self.CARDH * self._yfactor))

    def getOffsets(self):
        return (int(self.CARD_XOFFSET * self._xfactor),
                int(self.CARD_YOFFSET * self._yfactor))

    def getDelta(self):
        return (int(self.CARD_DX * self._xfactor),
                int(self.CARD_DY * self._yfactor))

    def resize(self, xf, yf):
        # print 'Images.resize:', xf, yf, self._card[0].width(), self.CARDW
        if self._xfactor == xf and self._yfactor == yf:
            # print 'no resize'
            return
        self._xfactor = xf
        self._yfactor = yf
        # ???self._setSize(xf, yf)
        self.setOffsets()
        # cards
        cards = []
        for c in self._card:
            c = c.resize(xf, yf)
            cards.append(c)
        self._card = cards
        # back
        for b in self._back:
            b.image = b.image.resize(xf, yf)
        # stack bottom image
        neg = self._bottom is self._bottom_negative
        self._bottom_negative = []
        self._bottom_positive = []
        for i in range(self.cs.nbottoms):
            name = "bottom%02d" % (i + 1)
            bottom = self.__loadBottom(name, color='black')
            if bottom is not None:
                self._bottom_positive.append(bottom)
            name = "bottom%02d-n" % (i + 1)
            bottom = self.__loadBottom(name, color='white')
            if bottom is not None:
                self._bottom_negative.append(bottom)
        # letters
        self._letter_positive = []
        self._letter_negative = []
        for rank in range(self.cs.nletters):
            name = "l%02d" % (rank + 1)
            self._letter_positive.append(
                self.__loadBottom(name, color='black'))
            name = "l%02d-n" % (rank + 1)
            self._letter_negative.append(
                self.__loadBottom(name, color='white'))
        self._createMissingImages()
        self.setNegative(neg)
        #
        self._highlighted_images = {}
        self._highlight = []
        self._highlight.append(
            self._getHighlight(self._card[0], None, '#3896f8'))
        self._pil_shadow = {}

    def reset(self):
        print('Image.reset')
        self.resize(1, 1)


# ************************************************************************
# *
# ************************************************************************

class SubsampledImages(Images):
    def __init__(self, images, r=2):
        Images.__init__(self, None, images.cs, r=r)
        self._card = self._subsample(images._card, r)
        self._bottom_positive = self._subsample(images._bottom_positive, r)
        self._letter_positive = self._subsample(images._letter_positive, r)
        self._bottom_negative = self._subsample(images._bottom_negative, r)
        self._letter_negative = self._subsample(images._letter_negative, r)
        self._bottom = self._bottom_positive
        self._letter = self._letter_positive
        #
        for _back in images._back:
            if _back is None:
                self._back.append(None)
            else:
                im = _back.image.subsample(r)
                self._back.append(
                    ImagesCardback(len(self._back), _back.name, im, im))
        #
        CW, CH = self.CARDW, self.CARDH
        for im in images._highlight:
            # self._highlight.append(None)
            self._highlight.append(copyImage(im, 0, 0, CW, CH))

    def getShadow(self, ncards):
        return None

    def _subsample(self, l, r):
        s = []
        for im in l:
            if im is None or r == 1:
                s.append(im)
            else:
                s.append(im.subsample(r))
        return s
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


# imports

# PySol imports
from pysollib.mfxutil import Struct
from pysollib.pysoltk import MfxCanvasText
from pysollib.resource import CSI


# ************************************************************************
# * a helper class to create common layouts
# ************************************************************************

# a layout stack
class _LayoutStack:
    def __init__(self, x, y, suit=None):
        self.x = int(round(x))
        self.y = int(round(y))
        self.suit = suit
        self.text_args = {}
        self.text_format = "%d"

    def setText(self, x, y, anchor="center", format=None, **kw):
        self.text_args["x"] = x
        self.text_args["y"] = y
        self.text_args["anchor"] = anchor
        self.text_args.update(kw)
        if format is not None:
            self.text_format = format


class Layout:
    def __init__(self, game, card_x_space=None, card_y_space=None, **kw):
        self.game = game
        self.canvas = self.game.canvas
        self.size = None
        self.s = Struct(
            talon=None,
            waste=None,
            foundations=[],
            rows=[],
            reserves=[],
        )
        self.stackmap = {}
        self.regions = []
        # set visual constants
        images = self.game.app.images
        cardset_size = images.cs.si.size
        if cardset_size in (CSI.SIZE_TINY, CSI.SIZE_SMALL):
            layout_x_margin = 6
            layout_y_margin = 6
            layout_card_x_space = 6
            layout_card_y_space = 10
        elif cardset_size in (CSI.SIZE_MEDIUM,):
            layout_x_margin = 8
            layout_y_margin = 8
            layout_card_x_space = 8
            layout_card_y_space = 12
        else:  # CSI.SIZE_LARGE, CSI.SIZE_XLARGE
            layout_x_margin = 10
            layout_y_margin = 10
            layout_card_x_space = 10
            layout_card_y_space = 14

        self.CW = images.CARDW
        self.CH = images.CARDH
        self.XOFFSET = images.CARD_XOFFSET
        self.YOFFSET = images.CARD_YOFFSET
        self.XM = layout_x_margin       # XMARGIN
        self.YM = layout_y_margin       # YMARGIN

        if card_x_space is None:
            self.XS = self.CW + layout_card_x_space          # XSPACE
        else:
            self.XS = self.CW + card_x_space
        if card_y_space is None:
            self.YS = self.CH + layout_card_y_space          # YSPACE
        else:
            self.YS = self.CH + card_y_space

        # self.CARD_X_SPACE = layout_card_x_space
        # self.CARD_Y_SPACE = layout_card_y_space
        # self.RIGHT_MARGIN = layout_x_margin-layout_card_x_space
        # self.BOTTOM_MARGIN = layout_y_margin-layout_card_y_space

        font = game.app.getFont("canvas_default")
        # self.TEXT_MARGIN = 10
        self.TEXT_MARGIN = font[1]
        # self.TEXT_HEIGHT = 30
        self.TEXT_HEIGHT = 18+font[1]

        self.__dict__.update(kw)
        if self.game.preview > 1:
            if "XOFFSET" in kw:
                self.XOFFSET //= self.game.preview
            if "YOFFSET" in kw:
                self.YOFFSET //= self.game.preview
            self.TEXT_HEIGHT = 10

    def __createStack(self, x, y, suit=None):
        stack = _LayoutStack(x, y, suit)
        mapkey = (stack.x, stack.y)
        # from pprint import pprint
        # print mapkey
        # pprint(self.stackmap)
        assert mapkey not in self.stackmap
        self.stackmap[mapkey] = stack
        return stack

    def _setText(self, stack, anchor="center"):
        tx, ty, ta, tf = self.getTextAttr(stack, anchor)
        stack.setText(tx, ty, ta, tf)

    #
    #
    #

    def createGame(self, layout_method,
                   talon_class=None,
                   waste_class=None,
                   foundation_class=None,
                   row_class=None,
                   reserve_class=None,
                   **kw
                   ):
        # create layout
        game = self.game
        s = game.s
        layout_method(self, **kw)
        game.setSize(self.size[0], self.size[1])
        # create stacks
        if talon_class:
            s.talon = talon_class(self.s.talon.x, self.s.talon.y, game)
        if waste_class:
            s.waste = waste_class(self.s.waste.x, self.s.waste.y, game)
        if foundation_class:
            if isinstance(foundation_class, (list, tuple)):
                n = len(self.s.foundations)//len(foundation_class)
                i = 0
                for j in range(n):
                    for cls in foundation_class:
                        r = self.s.foundations[i]
                        s.foundations.append(cls(r.x, r.y, game, suit=r.suit))
                        i += 1

            else:
                for r in self.s.foundations:
                    s.foundations.append(foundation_class(r.x, r.y, game,
                                                          suit=r.suit))
        if row_class:
            for r in self.s.rows:
                s.rows.append(row_class(r.x, r.y, game))
        if reserve_class:
            for r in self.s.reserves:
                s.reserves.append(reserve_class(r.x, r.y, game))
        # default
        self.defaultAll()
        # reserves texts
        if self.s.reserves and ('reserve_texts' in kw) and kw['reserve_texts']:
            game = self.game
            for i in range(len(game.s.reserves)):
                s1 = game.s.reserves[i]
                s2 = self.s.reserves[i]
                s1.texts.ncards = self.defaultText(s2)

    #
    # public util for use by class Game
    #

    def getTextAttr(self, stack, anchor):
        x, y = 0, 0
        if stack is not None:
            x, y = stack.x, stack.y
        delta_x, delta_y = 4, 4
        delta_yy = 10
        d = {
            "n": (x+self.CW//2,       y-delta_y,          "s",  "%d"),
            "nn": (x+self.CW//2,       y-delta_yy,         "s",  "%d"),
            "s": (x+self.CW//2,       y+self.CH+delta_y,  "n",  "%d"),
            "ss": (x+self.CW//2,       y+self.CH+delta_yy, "n",  "%d"),
            "nw": (x-delta_x,         y,                  "ne", "%d"),
            "sw": (x-delta_x,         y+self.CH,          "se", "%d"),
            "ne": (x+self.CW+delta_x, y,                  "nw", "%d"),
            "se": (x+self.CW+delta_x, y+self.CH,          "sw", "%d"),
            "w": (x-delta_x,         y+self.CH//2,        "e",  "%d"),
            "e": (x+self.CW+delta_x, y+self.CH//2,        "w",  "%d"),
            }
        return d[anchor]

    def createText(self, stack, anchor, dx=0, dy=0, text_format=""):
        if self.canvas.preview > 1:
            return
        assert stack.texts.ncards is None
        tx, ty, ta, tf = self.getTextAttr(stack, anchor)
        font = self.game.app.getFont("canvas_default")
        stack.texts.ncards = MfxCanvasText(self.canvas, tx+dx, ty+dy,
                                           anchor=ta, font=font)
        stack.texts.ncards.text_format = text_format or tf

    def createRoundText(self, stack, anchor, dx=0, dy=0):
        if self.canvas.preview > 1:
            return
        assert stack.texts.rounds is None
        delta_x, delta_y = 0, 0
        if anchor == 'nnn':
            anchor = 'nn'
            delta_y = -self.TEXT_MARGIN
        elif anchor == 'sss':
            anchor = 'ss'
            delta_y = self.TEXT_MARGIN
        tx, ty, ta, tf = self.getTextAttr(stack, anchor)
        tx += delta_x + dx
        ty += delta_y + dy
        font = self.game.app.getFont("canvas_default")
        stack.texts.rounds = MfxCanvasText(self.canvas, tx, ty,
                                           anchor=ta, font=font)

    def setRegion(self, stacks, rects):
        self.regions.append((stacks, rects))

    #
    # util for use by a Game
    #

    def defaultAll(self):
        game = self.game
        # create texts
        if game.s.talon:
            game.s.talon.texts.ncards = self.defaultText(self.s.talon)
        if game.s.waste:
            game.s.waste.texts.ncards = self.defaultText(self.s.waste)
        # define stack-groups
        self.defaultStackGroups()
        # set regions
        self.defaultRegions()

    def defaultText(self, layout_stack):
        if self.canvas.preview > 1:
            return None
        # print layout_stack, layout_stack.text_args
        if layout_stack is None or not layout_stack.text_args:
            return None
        layout_stack.text_args["font"] = \
            self.game.app.getFont("canvas_default")
        t = MfxCanvasText(self.game.canvas, **layout_stack.text_args)
        t.text_format = layout_stack.text_format
        return t

    # define stack-groups
    def defaultStackGroups(self):
        game = self.game
        waste = []
        if game.s.waste is not None:
            waste = [game.s.waste]
        game.sg.talonstacks = [game.s.talon] + waste
        game.sg.dropstacks = game.s.rows + game.s.reserves + waste
        game.sg.openstacks = game.s.foundations + game.s.rows + game.s.reserves
        game.sg.reservestacks = game.s.reserves

    def defaultRegions(self):
        for region in self.regions:
            # convert layout-stacks to corresponding game-stacks
            stacks = []
            for s in region[0]:
                mapkey = (s.x, s.y)
                id = self.game.stackmap[mapkey]
                stacks.append(self.game.allstacks[id])
            # print stacks, region[1]
            self.game.setRegion(stacks, region[1])

    #
    # Baker's Dozen layout
    #  - left: 2 rows
    #  - right: foundations, talon
    #

    def bakersDozenLayout(self, rows, texts=0, playcards=9):
        S = self.__createStack
        CW, CH = self.CW, self.CH
        XM, YM = self.XM, self.YM
        XS, YS = self.XS, self.YS

        decks = self.game.gameinfo.decks
        suits = len(self.game.gameinfo.suits) + bool(self.game.gameinfo.trumps)
        halfrows = (rows + 1) // 2

        # set size so that at least 9 cards are fully playable
        h = YS + min(2*YS, (playcards-1)*self.YOFFSET)
        h = max(h, 5*YS//2, 3*YS//2+CH)
        h = min(h, 3*YS)

        # create rows
        x, y = XM, YM
        for i in range(halfrows):
            self.s.rows.append(S(x+i*XS, y))
        for i in range(rows-halfrows):
            self.s.rows.append(S(x+i*XS, y+h))

        # create foundations
        x, y = XM + halfrows * XS, YM
        self.setRegion(self.s.rows, (-999, -999, x - CW // 2, 999999))
        for suit in range(suits):
            for i in range(decks):
                self.s.foundations.append(S(x+i*XS, y, suit=suit))
            y += YS

        # create talon
        h = YM + 2*h
        self.s.talon = S(x, h - YS)
        if texts:
            assert 0

        # set window
        self.size = (XM + (halfrows+decks)*XS, h)

    #
    # FreeCell layout
    #  - top: free cells, foundations
    #  - below: rows
    #  - left bottom: talon, waste
    #

    def freeCellLayout(self, rows=0, reserves=0, waste=0,
                       texts=0, reserve_texts=False, playcards=18):
        S = self.__createStack
        CH = self.CH
        XM, YM = self.XM, self.YM
        XS, YS = self.XS, self.YS

        decks = self.game.gameinfo.decks
        suits = len(self.game.gameinfo.suits) + bool(self.game.gameinfo.trumps)
        toprows = suits*decks
        if reserves:
            toprows += reserves+1
        maxrows = max(rows, toprows)

        w = XM + maxrows*XS

        # set size so that at least 2//3 of a card is visible with 18 cards
        h = CH*2//3 + (playcards-1)*self.YOFFSET
        h = YM + YS + max(h, 3*YS)
        if reserves and reserve_texts:
            h += self.TEXT_HEIGHT

        # create reserves & foundations
        x, y = (w - (toprows*XS - XM))//2, YM
        if reserves:
            for i in range(reserves):
                s = S(x, y)
                self.s.reserves.append(s)
                if reserve_texts:
                    self._setText(s, anchor="s")
                x += XS
            x += XS
        for suit in range(suits):
            for i in range(decks):
                self.s.foundations.append(S(x, y, suit=suit))
                x += XS

        # create rows
        x, y = (w - (rows*XS - XM))//2, YM + YS
        if reserves and reserve_texts:
            y += self.TEXT_HEIGHT
        for i in range(rows):
            self.s.rows.append(S(x, y))
            x += XS
        self.setRegion(self.s.rows, (-999, y - CH // 2, 999999, 999999))

        # create talon
        x, y = XM, h - YS
        self.s.talon = s = S(x, y)
        if texts:
            if waste:
                # place text top of stack
                self._setText(s, anchor="n")
            else:
                # place text right of stack
                self._setText(s, anchor="se")
        if waste:
            x += XS
            self.s.waste = s = S(x, y)
            if texts:
                # place text top of stack
                self._setText(s, anchor="n")

        # set window
        self.size = (w, h)

    #
    # Gypsy layout
    #  - left: rows
    #  - right: foundations, talon
    #  - bottom: reserves
    #

    def gypsyLayout(self, rows, waste=0, reserves=0,
                    texts=1, reserve_texts=False, round_text=False,
                    playcards=25):
        S = self.__createStack
        CW, CH = self.CW, self.CH
        XM, YM = self.XM, self.YM
        XS, YS = self.XS, self.YS

        decks = self.game.gameinfo.decks
        suits = len(self.game.gameinfo.suits) + bool(self.game.gameinfo.trumps)

        w = XM + max(rows+decks, reserves+2+waste)*XS
        if reserves:
            h = YS+(playcards-1)*self.YOFFSET+YS
        else:
            # set size so that at least 2//3 of a card is visible with 25 cards
            h = CH*2//3 + (playcards-1)*self.YOFFSET
        h = YM + max(h, (suits+1)*YS)
        if reserves and reserve_texts:
            h += self.TEXT_HEIGHT

        # create rows
        x, y = XM, YM
        for i in range(rows):
            self.s.rows.append(S(x, y))
            x += XS
        if reserves:
            yy = h - YS - CH//2
        else:
            yy = 999999
        self.setRegion(self.s.rows, (-999, -999, x - CW // 2, yy))

        # create foundations
        x = w - decks*XS
        for suit in range(suits):
            for i in range(decks):
                self.s.foundations.append(S(x+i*XS, y, suit=suit))
            y += YS

        # create talon and waste
        x, y = x + (decks-1)*XS, h - YS
        if texts:
            x -= XS//2
        self.s.talon = s = S(x, y)
        anchor = 's'
        if round_text:
            anchor = 'n'
        if texts:
            # place text right of stack
            self._setText(s, anchor=anchor+"e")
        if waste:
            x -= XS
            self.s.waste = s = S(x, y)
            if texts:
                # place text left of stack
                self._setText(s, anchor=anchor+"w")
        # create reserves
        x, y = XM, h-YS
        for i in range(reserves):
            s = S(x, y)
            self.s.reserves.append(s)
            if reserve_texts:
                self._setText(s, anchor="n")
            x += XS

        # set window
        self.size = (w, h)

    #
    # Harp layout
    #  - top: reserves, rows
    #  - bottom: foundations, waste, talon
    #

    def harpLayout(self, rows, waste, reserves=0,
                   texts=1, reserve_texts=False, playcards=19):
        S = self.__createStack
        CH = self.CH
        XM, YM = self.XM, self.YM
        XS, YS = self.XS, self.YS

        decks = self.game.gameinfo.decks
        suits = len(self.game.gameinfo.suits) + bool(self.game.gameinfo.trumps)

        w = max(reserves*XS, rows*XS, (suits*decks+waste+1)*XS,
                (suits*decks+1)*XS+2*XM)
        w += XM

        # set size so that at least 19 cards are fully playable
        h = YS + (playcards-1)*self.YOFFSET
        h = max(h, 3*YS)
        if texts:
            h += self.TEXT_HEIGHT
        if reserves:
            h += YS
        if reserves and reserve_texts:
            h += self.TEXT_HEIGHT

        # top
        y = YM
        if reserves:
            if reserve_texts:
                y += self.TEXT_HEIGHT
            x = (w - (reserves*XS - XM))//2
            for i in range(reserves):
                s = S(x, y)
                self.s.reserves.append(s)
                x += XS
                if reserve_texts:
                    self._setText(s, anchor="n")
            y += YS
        x = (w - (rows*XS - XM))//2
        for i in range(rows):
            self.s.rows.append(S(x, y))
            x += XS

        # bottom
        x, y = XM, YM + h
        for suit in range(suits):
            for i in range(decks):
                self.s.foundations.append(S(x, y, suit=suit))
                x += XS
        if reserves:
            yy = YM + YS - CH//2
            if reserve_texts:
                yy += self.TEXT_HEIGHT
        else:
            yy = -999
        self.setRegion(self.s.rows, (-999, yy, 999999, y - YS // 2))
        if waste:
            x = w - 2*XS
            self.s.waste = s = S(x, y)
            if texts:
                # place text above stack
                self._setText(s, 'n')
        x = w - XS
        self.s.talon = s = S(x, y)
        if texts:
            # place text above stack
            self._setText(s, 'n')

        # set window
        self.size = (w, YM + h + YS)

    #
    # Klondike layout
    #  - top: talon, waste, foundations
    #  - below: rows
    #  - bottom: reserves
    #

    def klondikeLayout(self, rows=0, waste=0, reserves=0,
                       texts=1, reserve_texts=False, round_text=False,
                       playcards=16, center=1, text_height=0):
        S = self.__createStack
        CH = self.CH
        XM, YM = self.XM, self.YM
        XS, YS = self.XS, self.YS

        decks = self.game.gameinfo.decks
        suits = len(self.game.gameinfo.suits) + bool(self.game.gameinfo.trumps)
        foundrows = 1 + (suits > 5)
        frows = decks * suits // foundrows
        toprows = 1 + waste + frows
        if round_text:
            toprows += 1
        maxrows = max(rows, toprows, reserves)

        w = XM + maxrows * XS
        # set size so that at least 2//3 of a card is visible with 16 cards
        h = CH * 2 // 3 + (playcards - 1) * self.YOFFSET
        h = max(h, 2 * YS)
        h += YM + YS * foundrows
        if reserves and reserve_texts:
            h += self.TEXT_HEIGHT

        # top
        # text_height = 0
        x, y = XM, YM
        self.s.talon = s = S(x, y)
        if texts:
            if waste or not center or maxrows - frows <= 1:
                # place text below stack
                self._setText(s, 's')
                text_height = self.TEXT_HEIGHT
            else:
                # place text right of stack
                self._setText(s, 'ne')
        if waste:
            x += XS
            self.s.waste = s = S(x, y)
            if texts:
                # place text below stack
                self._setText(s, 's')
                text_height = self.TEXT_HEIGHT

        for row in range(foundrows):
            x = w - frows * XS
            if center and frows + 2 * (1 + waste + 1) <= maxrows:
                # center the foundations
                x = XM + (maxrows - frows) * XS // 2
            for suit in range(suits // foundrows):
                for i in range(decks):
                    self.s.foundations.append(
                        S(x, y, suit=suit + (row * (suits // 2))))
                    x += XS
            y += YS

        # below
        x = XM
        if rows < maxrows:
            x += (maxrows-rows) * XS//2
        # y += YM * (3 - foundrows)
        y += text_height
        for i in range(rows):
            self.s.rows.append(S(x, y))
            x += XS
        if reserves:
            yy = h - CH//2
        else:
            yy = 999999
        self.setRegion(self.s.rows, (-999, y-CH//2, 999999, yy))

        # bottom
        if reserves:
            x = (maxrows-reserves)*XS//2
            y = h
            h += YS
            for i in range(reserves):
                s = S(x, y)
                self.s.reserves.append(s)
                x += XS
                if reserve_texts:
                    self._setText(s, anchor="n")

        # set window
        self.size = (w, h)

    #
    # Yukon layout
    #  - left: rows
    #  - right: foundations
    #  - left bottom: talon
    #

    def yukonLayout(self, rows, texts=0, playcards=20):
        S = self.__createStack
        CW, CH = self.CW, self.CH
        XM, YM = self.XM, self.YM
        XS, YS = self.XS, self.YS

        decks = self.game.gameinfo.decks
        suits = len(self.game.gameinfo.suits) + bool(self.game.gameinfo.trumps)

        # set size so that at least 2//3 of a card is visible with 20 cards
        h = CH*2//3 + (playcards-1)*self.YOFFSET
        h = YM + max(h, suits*YS)

        # create rows
        x, y = XM, YM
        for i in range(rows):
            self.s.rows.append(S(x, y))
            x += XS
        self.setRegion(self.s.rows, (-999, -999, x - CW // 2, 999999))

        # create foundations
        for suit in range(suits):
            for i in range(decks):
                self.s.foundations.append(S(x+i*XS, y, suit=suit))
            y += YS

        # create talon
        x, y = XM, h - YS
        self.s.talon = s = S(x, y)
        if texts:
            # place text right of stack
            self._setText(s, 'se')

        # set window
        self.size = (XM + (rows+decks)*XS,  h)

    #
    # Easy layout
    #  - top: talon, waste, foundations
    #  - bottom: rows
    #

    def easyLayout(self, rows, waste, texts=1, playcards=10, center=1):
        S = self.__createStack
        CH = self.CH
        XM, YM = self.XM, self.YM
        XS, YS = self.XS, self.YS

        decks = self.game.gameinfo.decks
        ranks = len(self.game.gameinfo.ranks)
        frows = 4 * decks // (1 + (decks >= 3))
        toprows = 1 + waste + frows
        maxrows = max(rows, toprows)
        yextra = 0

        # set size so that at least 2//3 of a card is visible with 10 cards
        h = CH * 2 // 3 + (playcards - 1) * self.YOFFSET
        h = max(h, 2 * YS)

        # top
        x, y = XM, YM
        self.s.talon = s = S(x, y)
        if texts:
            if waste or not center or maxrows - frows <= 1:
                # place text below stack
                self._setText(s, 's')
                yextra = 20
            else:
                # place text right of stack
                self._setText(s, 'ne')
        if waste:
            x += XS
            self.s.waste = s = S(x, y)
            if texts:
                # place text below stack
                self._setText(s, 's')
        x = XM + (maxrows - frows) * XS
        if center and frows + 2 * (1 + waste + 1) <= maxrows:
            # center the foundations
            x = XM + (maxrows - frows) * XS // 2

        x0, y0 = x, y
        for i in range(decks):
            for rank in range(ranks):
                self.s.foundations.append(S(x0, y0, suit=rank))
                x0 += XS
            if i == 1 and decks > 2:
                x0, y0 = x, y + YS
                y = y0

        # bottom
        x, y = XM, y + YS + yextra * (decks <= 2)
        self.setRegion(self.s.rows, (-999, y - YM // 2, 999999, 999999))
        for i in range(rows):
            self.s.rows.append(S(x, y))
            x += XS

        # set window
        self.size = (XM + maxrows * XS, YM + YS + yextra + h)

    #
    # Samuri layout
    #  - top center: rows
    #  - left & right: foundations
    #  - bottom center: talon
    #

    def samuriLayout(self, rows, waste, texts=1, playcards=20, center=1):
        S = self.__createStack
        CH = self.CH
        XM, YM = self.XM, self.YM
        XS, YS = self.XS, self.YS

        decks = self.game.gameinfo.decks
        toprows = 2 * decks + rows
        yextra = 0

        # set size so that at least 2//3 of a card is visible with 20 cards
        h = CH * 2 // 3 + (playcards - 1) * self.YOFFSET
        h = max(h, 2 * YS)

        # bottom center
        x = (XM + (toprows * XS) // 2) - XS
        y = h
        self.s.talon = s = S(x, y)
        if texts:
            if waste or not center or toprows - rows <= 1:
                # place text below stack
                self._setText(s, 's')
                yextra = 20
            else:
                # place text right of stack
                self._setText(s, 'ne')
        if waste:
            x += XS
            self.s.waste = s = S(x, y)
            if texts:
                # place text below stack
                self._setText(s, 's')

        # left & right
        x, y = XM, YM
        d, x0, y0 = 0, x, y
        for suit in range(12):
            for i in range(decks):
                x0, y0 = x + XS * i, y + YS * d
                self.s.foundations.append(S(x0, y0, suit=suit))
                if i == decks - 1 and suit == 5:
                    x0, y0 = x + XS * (toprows - decks), YM
                    d, x, y = -1, x0, y0
            d += 1

        # top center
        x, y = XM + XS * decks, YM
        self.setRegion(self.s.rows, (x - XM // 2, 0, x + XS * rows, 999999))
        for i in range(rows):
            self.s.rows.append(S(x, y))
            x += XS

        # set window
        self.size = (XM + toprows * XS, YM + YS + yextra + h)

    #
    # Sumo layout
    #  - top center: rows
    #  - left & right: foundations
    #  - bottom center: talon
    #

    def sumoLayout(self, rows, reserves, texts=0, playcards=12, center=1):
        S = self.__createStack
        CH = self.CH
        XM, YM = self.XM, self.YM
        XS, YS = self.XS, self.YS

        decks = self.game.gameinfo.decks
        assert reserves % 2 == 0
        toprows = 12
        maxrows = max(rows, toprows)
        w = XM + maxrows * XS

        # set size so that at least 2//3 of a card is visible with 12 cards
        h = CH * 2 // 3 + (playcards - 1) * self.YOFFSET
        h = max(h, 2 * YS)

        # create foundations
        x, y = XM, YM
        for i in range(decks):
            for suit in range(12):
                self.s.foundations.append(S(x, y, suit=suit))
                x += XS
            x, y = XM, y + YS

        # create rows
        x, y = XM + XS * ((toprows - rows) // 2), YM + YS * decks
        for i in range(rows):
            self.s.rows.append(S(x, y))
            x += XS
        self.setRegion(
            self.s.rows,
            (XS + XM // 2, YS * decks + YM // 2, XS * 11 - XM // 2, 999999))

        # create reserves
        x, y = XM, YM + YS * decks
        for i in range(reserves // 2):
            self.s.reserves.append(S(x, y))
            y += YS
        x, y = w - XS, YM + YS * decks
        for i in range(reserves // 2):
            self.s.reserves.append(S(x, y))
            y += YS

        # create talon
        x, y = XM, h + YM
        self.s.talon = s = S(x, y)
        if texts:
            # place text right of stack
            self._setText(s, 'se')

        # set window
        self.size = (XM + toprows * XS, YM + YS + h)

    #
    # Fun layout
    #  - top: rows
    #  - right: foundations
    #  - bottom right: reserves
    #

    def funLayout(self, rows, reserves, texts=0, playcards=12, center=1):
        S = self.__createStack
        CH = self.CH
        XM, YM = self.XM, self.YM
        XS, YS = self.XS, self.YS

        decks = self.game.gameinfo.decks
        ranks = len(self.game.gameinfo.ranks)
        assert rows % 2 == 0
        assert reserves % decks == 0
        toprows = decks + rows // 2
        w = XM * 2 + toprows * XS

        # set size so that at least 2//3 of a card is visible with 12 cards
        h1 = CH * 2 // 3 + (playcards - 1) * self.YOFFSET
        h2 = (3 + reserves // decks) * YS
        h = max(h1, h2)

        # create foundations
        x, y = w - XS * decks, YM
        for i in range(decks):
            for rank in range(ranks):
                self.s.foundations.append(S(x, y, suit=rank))
                y += YS
            x, y = x + XS, YM

        # create rows
        x, y = XM, YM
        for i in range(rows // 2):
            self.s.rows.append(S(x, y))
            x += XS
        x, y = XM, (YS + h) // 2
        for i in range(rows // 2):
            self.s.rows.append(S(x, y))
            x += XS
        self.setRegion(self.s.rows, (0, 0, XS * rows // 2 + XM // 2, 999999))

        # create reserves
        x, y = w - XS * decks, YM + YS * 4
        for i in range(decks):
            for i in range(reserves // decks):
                self.s.reserves.append(S(x, y))
                y += YS
            x, y = x + XS, YM + YS * 4

        # create talon
        x, y = XM, h
        self.s.talon = s = S(x, y)
        if texts:
            # place text right of stack
            self._setText(s, 'se')

        # set window
        self.size = (w, YM + YS + h)

    #
    # Oonsoo layout
    #  - top: talon & rows
    #  - left: reserves
    #  - center right: rows
    #

    def oonsooLayout(self, rows, reserves, texts=0, playcards=12, center=1):
        S = self.__createStack
        CH = self.CH
        XM, YM = self.XM, self.YM
        XS, YS = self.XS, self.YS

        decks = self.game.gameinfo.decks
        assert rows % 2 == 0
        toprows = decks + rows // 2
        w = XM * 2 + toprows * (XS + XM)

        # set size so that at least 2//3 of a card is visible with 12 cards
        h = CH * 2 // 3 + (playcards - 1) * self.YOFFSET
        h = max(h, 2 * YS)

        # create talon
        x, y = XM, YM
        self.s.talon = s = S(x, y)
        if texts:
            # place text below stack
            self._setText(s, 's')

        # create rows
        x, y = XS + XM * 3, YM
        for i in range(rows // 2):
            self.s.rows.append(S(x, y))
            x += XS + XM
        x, y = XS + XM * 3, (YS + h) // 2
        for i in range(rows // 2):
            self.s.rows.append(S(x, y))
            x += XS + XM
        self.setRegion(self.s.rows, (XS + XM, -999, 999999, 999999))

        # create reserves
        x, y = XM, YM + YS + self.TEXT_HEIGHT
        for i in range(decks):
            for i in range(reserves // decks):
                self.s.reserves.append(S(x, y))
                y += YS
            x, y = x + XS, YM + YS * 4

        # set window
        self.size = (w, YM + YS + h)

    #
    # Ghulam layout
    #  - left & right: foundations & reserves
    #  - center: two groups of rows
    #  - lower right: talon
    #

    def ghulamLayout(self, rows, reserves=0, texts=0):
        S = self.__createStack
        XM, YM = self.XM, self.YM
        XS, YS = self.XS, self.YS

        suits = len(self.game.gameinfo.suits)
        assert rows % 2 == 0
        assert reserves % 2 == 0

        # set size
        w, h = XM * 3 + XS * ((rows // 2) + 2), YM + YS * ((suits // 2) + 2)

        # create foundations
        x, y = XM, YM
        for i in range(suits):
            self.s.foundations.append(S(x, y, suit=i))
            y += YS
            if i == suits // 2 - 1:
                x, y = w - XS, YM

        # create rows
        x = XM * 2 + XS
        for i in range(rows // 2):
            self.s.rows.append(S(x + i * XS, YM))
        for i in range(rows // 2):
            self.s.rows.append(S(x + i * XS, h // 2))
        self.setRegion(self.s.rows, (XM + XS, -999, w - XM - XS, 999999))

        # create reserves
        for i in range(reserves // 2):
            self.s.reserves.append(S(XM, h - YS * (i + 1)))
        for i in range(reserves // 2):
            self.s.reserves.append(S(w - XS, h - YS * (i + 1)))

        # create talon
        self.s.talon = S(w - XS * 2, h - YS)
        if texts:
            assert 0

        # set window
        self.size = (w, h)

    #
    # Generiklon layout
    #  - top: talon & foundations
    #  - bottom: rows
    #

    def generiklonLayout(self, rows, waste=1, height=6):
        S = self.__createStack
        XM, YM = self.XM, self.YM
        XS, YS = self.XS, self.YS

        decks = self.game.gameinfo.decks
        suits = len(self.game.gameinfo.suits) + bool(self.game.gameinfo.trumps)
        frows = suits * decks // 2
        fspace = XS * (rows - 1) // 2

        # Set window size
        w, h = XM + XS * rows, YM * 2 + YS * height
        self.size = (w, h)

        # Talon
        x, y = XM, YM
        self.s.talon = s = S(x, y)
        self._setText(s, 'se')
        self.s.waste = s = S(x, y + YS)
        self._setText(s, 'se')

        # Create foundations
        x = w - fspace - XS * frows // 2
        for suit in range(suits // 2):
            for i in range(decks):
                self.s.foundations.append(S(x, y, suit=suit))
                x += XS
        x = w - fspace - XS * frows // 2
        y += YS
        for suit in range(suits // 2):
            for i in range(decks):
                self.s.foundations.append(S(x, y, suit=(suit + suits // 20)))
                x += XS

        # bottom
        x, y = XM, YM * 2 + YS * 2
        for i in range(rows):
            self.s.rows.append(S(x, y))
            x += XS
        self.setRegion(self.s.rows, (-999, y - YM, 999999, 999999))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import sys

if sys.version_info > (3,):
    def cmp(a, b):
        return ((b > a)-(a > b))

# imports


# ************************************************************************
# * moves (undo / redo)
# ************************************************************************

# Currently we have the following atomic moves:
# - move the top cards from one stack on the top of another
# - flip the top card of a stack
# - turn a whole stack onto another stack
# - update the model or complete view a stack
# - increase the round (the number of redeals)
# - save the seed of game.random
# - shuffle a stack

class AtomicMove:

    def do(self, game):
        self.redo(game)

    def __repr__(self):
        return str(self.__dict__)

    def __str__(self):
        return str(self.__dict__)

    # Custom comparison for detecting redo moves. See Game.finishMove().
    def cmpForRedo(self, other):
        return -1


# ************************************************************************
# * Move the top N cards from a stack to another stack.
# ************************************************************************

class AMoveMove(AtomicMove):
    def __init__(self, ncards, from_stack, to_stack, frames, shadow=-1):
        assert from_stack is not to_stack
        self.ncards = ncards
        self.from_stack_id = from_stack.id
        self.to_stack_id = to_stack.id
        self.frames = frames
        self.shadow = shadow

    # do the actual move
    def _doMove(self, game, ncards, from_stack, to_stack):
        if game.moves.state == game.S_PLAY:
            assert to_stack.acceptsCards(
                from_stack, from_stack.cards[-ncards:])
        frames = self.frames
        if frames == -2 and game.moves.state not in (game.S_UNDO, game.S_REDO):
            # don't use animation for drag-move
            frames = 0
        cards = from_stack.cards[-ncards:]
        if frames != 0:
            from_stack.unshadeStack()
            x, y = to_stack.getPositionForNextCard()
            game.animatedMoveTo(from_stack, to_stack, cards, x, y,
                                frames=frames, shadow=self.shadow)
        for i in range(ncards):
            from_stack.removeCard()
        for c in cards:
            to_stack.addCard(c)
        from_stack.updatePositions()
        to_stack.updatePositions()

    def redo(self, game):
        self._doMove(game, self.ncards, game.allstacks[self.from_stack_id],
                     game.allstacks[self.to_stack_id])

    def undo(self, game):
        self._doMove(game, self.ncards, game.allstacks[self.to_stack_id],
                     game.allstacks[self.from_stack_id])

    def cmpForRedo(self, other):
        return (cmp(self.ncards, other.ncards) or
                cmp(self.from_stack_id, other.from_stack_id) or
                cmp(self.to_stack_id, other.to_stack_id))


# ************************************************************************
# * Flip the top card of a stack.
# ************************************************************************

class AFlipMove(AtomicMove):
    def __init__(self, stack):
        self.stack_id = stack.id

    # do the actual move
    def _doMove(self, game, stack):
        card = stack.cards[-1]
        # game.animatedFlip(stack)
        if card.face_up:
            card.showBack()
        else:
            card.showFace()

    def redo(self, game):
        self._doMove(game, game.allstacks[self.stack_id])

    def undo(self, game):
        self._doMove(game, game.allstacks[self.stack_id])

    def cmpForRedo(self, other):
        return cmp(self.stack_id, other.stack_id)


# flip with animation
class ASingleFlipMove(AFlipMove):
    def _doMove(self, game, stack):
        card = stack.cards[-1]
        game.animatedFlip(stack)
        if card.face_up:
            card.showBack()
        else:
            card.showFace()


# flip and move one card
class AFlipAndMoveMove(AtomicMove):

    def __init__(self, from_stack, to_stack, frames):
        assert from_stack is not to_stack
        self.from_stack_id = from_stack.id
        self.to_stack_id = to_stack.id
        self.frames = frames

    def _doMove(self, game, from_stack, to_stack):
        if game.moves.state == game.S_PLAY:
            assert to_stack.acceptsCards(from_stack, from_stack.cards[-1])
        if self.frames == 0:
            moved = True
        else:
            moved = game.animatedFlipAndMove(from_stack, to_stack, self.frames)
        c = from_stack.cards[-1]
        if c.face_up:
            c.showBack()
        else:
            c.showFace()
        if not moved:
            cards = from_stack.cards[-1:]
            x, y = to_stack.getPositionForNextCard()
            game.animatedMoveTo(from_stack, to_stack, cards, x, y,
                                frames=self.frames, shadow=0)
        c = from_stack.removeCard(update=False)
        to_stack.addCard(c, update=False)
        from_stack.updateText()
        to_stack.updateText()

    def redo(self, game):
        self._doMove(game, game.allstacks[self.from_stack_id],
                     game.allstacks[self.to_stack_id])

    def undo(self, game):
        self._doMove(game, game.allstacks[self.to_stack_id],
                     game.allstacks[self.from_stack_id])

    def cmpForRedo(self, other):
        return (cmp(self.from_stack_id, other.from_stack_id) or
                cmp(self.to_stack_id, other.to_stack_id))


# ************************************************************************
# * Flip all cards
# ************************************************************************

class AFlipAllMove(AtomicMove):
    def __init__(self, stack):
        self.stack_id = stack.id

    def redo(self, game):
        stack = game.allstacks[self.stack_id]
        for card in stack.cards:
            if card.face_up:
                card.showBack()
            else:
                card.showFace()
        stack.refreshView()

    def undo(self, game):
        stack = game.allstacks[self.stack_id]
        for card in stack.cards:
            if card.face_up:
                card.showBack()
            else:
                card.showFace()
        stack.refreshView()

    def cmpForRedo(self, other):
        return cmp(self.stack_id, other.stack_id)


# ************************************************************************
# * Turn the Waste stack onto the empty Talon.
# ************************************************************************

class ATurnStackMove(AtomicMove):
    def __init__(self, from_stack, to_stack):
        assert from_stack is not to_stack
        self.from_stack_id = from_stack.id
        self.to_stack_id = to_stack.id

    def redo(self, game):
        from_stack = game.allstacks[self.from_stack_id]
        to_stack = game.allstacks[self.to_stack_id]
        assert len(from_stack.cards) > 0
        assert len(to_stack.cards) == 0
        mylen = len(from_stack.cards)
        for i in range(mylen):
            # unhide = (i >= mylen - 2)
            unhide = 1
            # print 1, unhide, from_stack.getCard().__dict__
            card = from_stack.removeCard(unhide=unhide, update=0)
            # print 2, unhide, card.__dict__
            assert card.face_up
            to_stack.addCard(card, unhide=unhide, update=0)
            card.showBack(unhide=unhide)
            # print 3, unhide, to_stack.getCard().__dict__
        from_stack.updateText()
        to_stack.updateText()

    def undo(self, game):
        from_stack = game.allstacks[self.to_stack_id]
        to_stack = game.allstacks[self.from_stack_id]
        assert len(from_stack.cards) > 0
        assert len(to_stack.cards) == 0
        mylen = len(from_stack.cards)
        for i in range(mylen):
            # unhide = (i >= mylen - 2)
            unhide = 1
            card = from_stack.removeCard(unhide=unhide, update=0)
            assert not card.face_up
            card.showFace(unhide=unhide)
            to_stack.addCard(card, unhide=unhide, update=0)
        from_stack.updateText()
        to_stack.updateText()

    def cmpForRedo(self, other):
        return (cmp(self.from_stack_id, other.from_stack_id) or
                cmp(self.to_stack_id, other.to_stack_id))


# ************************************************************************
# * ATurnStackMove is somewhat optimized to avoid unnecessary
# * unhide and hide operations.
# * FIXME: doesn't work yet
# ************************************************************************

class NEW_ATurnStackMove(AtomicMove):
    def __init__(self, from_stack, to_stack, update_flags=1):
        assert from_stack is not to_stack
        self.from_stack_id = from_stack.id
        self.to_stack_id = to_stack.id
        self.update_flags = update_flags

    # do the actual turning move
    def _doMove(self, from_stack, to_stack, show_face):
        assert len(from_stack.cards) > 0
        assert len(to_stack.cards) == 0
        for card in from_stack.cards:
            card.item.dtag(from_stack.group)
            card.item.addtag(to_stack.group)
            if show_face:
                assert not card.face_up
                card.showFace(unhide=0)
            else:
                assert card.face_up
                card.showBack(unhide=0)
        to_stack.cards = from_stack.cards
        from_stack.cards = []
        from_stack.refreshView()
        from_stack.updateText()
        to_stack.refreshView()
        to_stack.updateText()

    def redo(self, game):
        from_stack = game.allstacks[self.from_stack_id]
        to_stack = game.allstacks[self.to_stack_id]
        if self.update_flags & 1:
            assert to_stack is game.s.talon
            assert to_stack.round < to_stack.max_rounds or \
                to_stack.max_rounds < 0
            to_stack.round = to_stack.round + 1
        self._doMove(from_stack, to_stack, 0)

    def undo(self, game):
        from_stack = game.allstacks[self.from_stack_id]
        to_stack = game.allstacks[self.to_stack_id]
        if self.update_flags & 1:
            assert to_stack is game.s.talon
            assert to_stack.round > 1
            to_stack.round = to_stack.round - 1
        self._doMove(to_stack, from_stack, 1)

    def cmpForRedo(self, other):
        return (cmp(self.from_stack_id, other.from_stack_id) or
                cmp(self.to_stack_id, other.to_stack_id) or
                cmp(self.update_flags, other.update_flags))


# ************************************************************************
# * Update the view or model of a stack. Only needed for complex
# * games in combination with undo.
# ************************************************************************

class AUpdateStackMove(AtomicMove):
    def __init__(self, stack, flags):
        self.stack_id = stack.id
        self.flags = flags

    # do the actual move
    def _doMove(self, game, stack, undo):
        if self.flags & 64:
            # model
            stack.updateModel(undo, self.flags)
        else:
            # view
            if self.flags & 16:
                stack.updateText()
            if self.flags & 32:
                stack.refreshView()

    def redo(self, game):
        if (self.flags & 3) in (1, 3):
            self._doMove(game, game.allstacks[self.stack_id], 0)

    def undo(self, game):
        if (self.flags & 3) in (2, 3):
            self._doMove(game, game.allstacks[self.stack_id], 1)

    def cmpForRedo(self, other):
        return cmp(self.stack_id, other.stack_id) or \
            cmp(self.flags, other.flags)


AUpdateStackModelMove = AUpdateStackMove
AUpdateStackViewMove = AUpdateStackMove


# ************************************************************************
# * Increase the `round' member variable of a Talon stack.
# ************************************************************************

class ANextRoundMove(AtomicMove):
    def __init__(self, stack):
        self.stack_id = stack.id

    def redo(self, game):
        stack = game.allstacks[self.stack_id]
        assert stack is game.s.talon
        assert stack.round < stack.max_rounds or stack.max_rounds < 0
        stack.round = stack.round + 1
        stack.updateText()

    def undo(self, game):
        stack = game.allstacks[self.stack_id]
        assert stack is game.s.talon
        assert stack.round > 1
        stack.round = stack.round - 1
        stack.updateText()

    def cmpForRedo(self, other):
        return cmp(self.stack_id, other.stack_id)


# ************************************************************************
# * Save the current state (needed for undo in some games).
# ************************************************************************

class ASaveSeedMove(AtomicMove):
    def __init__(self, game):
        self.state = game.random.getstate()

    def redo(self, game):
        game.random.setstate(self.state)

    def undo(self, game):
        game.random.setstate(self.state)

    def cmpForRedo(self, other):
        return cmp(self.state, other.state)


# ************************************************************************
# * Save game variables
# ************************************************************************

class ASaveStateMove(AtomicMove):
    def __init__(self, game, flags):
        self.state = game.getState()
        self.flags = flags

    def redo(self, game):
        if (self.flags & 3) in (1, 3):
            game.setState(self.state)

    def undo(self, game):
        if (self.flags & 3) in (2, 3):
            game.setState(self.state)

    def cmpForRedo(self, other):
        return cmp(self.state, other.state)


# ************************************************************************
# * Shuffle all cards of a stack. Saves the seed. Does not flip any cards.
# ************************************************************************

class AShuffleStackMove(AtomicMove):
    def __init__(self, stack, game):
        self.stack_id = stack.id
        # save cards and state
        self.card_ids = tuple([c.id for c in stack.cards])
        self.state = game.random.getstate()

    def redo(self, game):
        stack = game.allstacks[self.stack_id]
        # paranoia
        assert stack is game.s.talon
        # shuffle (see random)
        game.random.setstate(self.state)
        seq = stack.cards
        n = len(seq) - 1
        while n > 0:
            j = game.random.randint(0, n)
            seq[n], seq[j] = seq[j], seq[n]
            n = n - 1
        stack.refreshView()

    def undo(self, game):
        stack = game.allstacks[self.stack_id]
        # restore cards
        cards = []
        for id in self.card_ids:
            c = game.cards[id]
            assert c.id == id
            cards.append(c)
        stack.cards = cards
        # restore the state
        game.random.setstate(self.state)
        stack.refreshView()

    def cmpForRedo(self, other):
        return (cmp(self.stack_id, other.stack_id) or
                cmp(self.card_ids, other.card_ids) or
                cmp(self.state, other.state))


# ************************************************************************
# * ASingleCardMove - move single card from *anyone* position
# * (for ArbitraryStack)
# ************************************************************************

class ASingleCardMove(AtomicMove):

    def __init__(self, from_stack, to_stack, from_pos, frames, shadow=-1):
        self.from_stack_id = from_stack.id
        self.to_stack_id = to_stack.id
        self.from_pos = from_pos
        self.frames = frames
        self.shadow = shadow

    def redo(self, game):
        from_stack = game.allstacks[self.from_stack_id]
        to_stack = game.allstacks[self.to_stack_id]
        from_pos = self.from_pos
        if game.moves.state == game.S_PLAY:
            assert to_stack.acceptsCards(
                from_stack, [from_stack.cards[from_pos]])
        card = from_stack.cards[from_pos]
        card = from_stack.removeCard(card, update_positions=1)
        if self.frames != 0:
            x, y = to_stack.getPositionFor(card)
            game.animatedMoveTo(from_stack, to_stack, [card], x, y,
                                frames=self.frames, shadow=self.shadow)
        to_stack.addCard(card)
        # to_stack.refreshView()

    def undo(self, game):
        from_stack = game.allstacks[self.from_stack_id]
        to_stack = game.allstacks[self.to_stack_id]
        from_pos = self.from_pos
        card = to_stack.removeCard()
        # if self.frames != 0:
        #  x, y = to_stack.getPositionFor(card)
        #  game.animatedMoveTo(from_stack, to_stack, [card], x, y,
        #                      frames=self.frames, shadow=self.shadow)
        from_stack.insertCard(card, from_pos)
        # to_stack.refreshView()

    def cmpForRedo(self, other):
        return cmp((self.from_stack_id, self.to_stack_id, self.from_pos),
                   (other.from_stack_id, other.to_stack_id, other.from_pos))


# ************************************************************************
# * AInnerMove - change position of single card in stack (TODO)
# ************************************************************************

class AInnerMove(AtomicMove):

    def __init__(self, stack, from_pos, to_pos):
        self.stack_id = stack.id
        self.from_pos, self.to_pos = from_pos, to_pos

    def redo(self, game):
        # stack = game.allstacks[self.stack_id]
        pass

    def undo(self, game):
        # stack = game.allstacks[self.stack_id]
        pass

    def cmpForRedo(self, other):
        return cmp((self.stack_id, self.from_pos, self.to_pos),
                   (other.stack_id, other.from_pos, other.to_pos))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.gamedb import GI, loadGame
from pysollib.layout import Layout
from pysollib.mygettext import _, n_
from pysollib.stack import AC_FoundationStack, \
        AC_RowStack, \
        BO_RowStack, \
        DealReserveRedealTalonStack, \
        DealRowRedealTalonStack, \
        GroundsForADivorceTalonStack, \
        InitialDealTalonStack, \
        RK_FoundationStack, \
        RK_RowStack, \
        SC_FoundationStack, \
        SC_RowStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        SpiderTalonStack, \
        Spider_AC_Foundation, \
        Spider_AC_RowStack, \
        Spider_RK_Foundation, \
        Spider_SS_Foundation, \
        Spider_SS_RowStack, \
        UD_AC_RowStack, \
        UD_RK_RowStack, \
        UD_SC_RowStack, \
        UD_SS_RowStack, \
        WasteTalonStack, \
        Yukon_AC_RowStack, \
        Yukon_RK_RowStack, \
        Yukon_SS_RowStack
from pysollib.util import ACE, ANY_RANK, KING, NO_RANK, UNLIMITED_MOVES
from pysollib.wizardpresets import presets

import six

# ************************************************************************
# *
# ************************************************************************


class WizSetting:
    def __init__(self, values_map, default, var_name,
                 label, widget='menu'):
        self.values_map = values_map
        self.default = default
        # self.values_dict = dict(self.values_map)
        self.translation_map = {}       # for backward translation
        if widget == 'menu':
            self.values = []
            for k, v in self.values_map:
                self.values.append(k)
                self.translation_map[_(k)] = k
            assert self.default in self.values
        elif widget == 'preset':
            self.values = []
            for v in self.values_map:
                self.values.append(v)
                self.translation_map[_(v)] = v
            assert self.default in self.values
        else:
            self.values = self.values_map
        self.var_name = var_name
        self.label = label
        self.widget = widget
        self.variable = None            # Tk variable
        self.current_value = None


WizardPresets = WizSetting(
    values_map=list(presets.keys()),
    default='None',
    widget='preset',
    label=_('Initial setting:'),
    var_name='preset',
    )
GameName = WizSetting(
    values_map=(),
    default=_('My Game'),
    widget='entry',
    label=_('Name:'),
    var_name='name',
    )
SkillLevel = WizSetting(
    values_map=((n_('Luck only'),    GI.SL_LUCK),
                (n_('Mostly luck'),  GI.SL_MOSTLY_LUCK),
                (n_('Balanced'),     GI.SL_BALANCED),
                (n_('Mostly skill'), GI.SL_MOSTLY_SKILL),
                (n_('Skill only'),   GI.SL_SKILL),
                ),
    default=n_('Balanced'),
    label=_('Skill level:'),
    var_name='skill_level',
    )
NumDecks = WizSetting(
    values_map=((n_('One'),   1),
                (n_('Two'),   2),
                (n_('Three'), 3),
                (n_('Four'),  4)),
    default=n_('One'),
    label=_('Number of decks:'),
    var_name='decks',
    )
LayoutType = WizSetting(
    values_map=((n_('FreeCell'), Layout.freeCellLayout),
                (n_('Klondike'), Layout.klondikeLayout),
                (n_('Gypsy'),    Layout.gypsyLayout),
                (n_('Harp'),     Layout.harpLayout),
                ),
    default=n_('FreeCell'),
    label=_('Layout:'),
    var_name='layout',
    )
TalonType = WizSetting(
    values_map=((n_('Deal all cards at the beginning'), InitialDealTalonStack),
                (n_('Deal to waste'),         WasteTalonStack),
                (n_('Deal to tableau'),       DealRowRedealTalonStack),
                (n_('Deal to reserves'),      DealReserveRedealTalonStack),
                (n_('Spider'),                SpiderTalonStack),
                (n_('Grounds for a Divorce'), GroundsForADivorceTalonStack),
                ),
    default=n_('Deal all cards at the beginning'),
    label=_('Type:'),
    var_name='talon',
    )
Redeals = WizSetting(
    values_map=((n_('No redeals'), 0),
                (n_('One redeal'), 1),
                (n_('Two redeals'), 2),
                (n_('Three redeals'), 3),
                (n_('Unlimited redeals'), -1),
                ),
    default=n_('No redeals'),
    label=_('Number of redeals:'),
    var_name='redeals',
    )
DealToWaste = WizSetting(
    values_map=(1, 5),
    default=1,
    widget='spin',
    label=_('# of cards dealt to the waste:'),
    var_name='deal_to_waste',
    )
TalonShuffle = WizSetting(
    values_map=(0, 1),
    default=0,
    label=_('Shuffle during redeal:'),
    var_name='talon_shuffle',
    widget='check',
    )
FoundType = WizSetting(
    values_map=((n_('Same suit'),              SS_FoundationStack),
                (n_('Alternate color'),        AC_FoundationStack),
                (n_('Same color'),             SC_FoundationStack),
                (n_('Rank'),                   RK_FoundationStack),
                (n_('Spider same suit'),       Spider_SS_Foundation),
                (n_('Spider alternate color'), Spider_AC_Foundation),
                (n_('Spider rank'),            Spider_RK_Foundation),
                ),
    default=n_('Same suit'),
    label=_('Type:'),
    var_name='found_type',
    )
FoundBaseCard = WizSetting(
    values_map=((n_('Ace'),  ACE),
                (n_('King'), KING),
                (n_('Any'),  ANY_RANK),
                ),
    default=n_('Ace'),
    label=_('Base card:'),
    var_name='found_base_card',
    )
FoundDir = WizSetting(
    values_map=((n_('Up'), 1), (n_('Down'), -1)),
    default=n_('Up'),
    label=_('Direction:'),
    var_name='found_dir',
    )
FoundMaxMove = WizSetting(
    values_map=((n_('None'), 0,), (n_('Top card'), 1)),
    default=n_('Top card'),
    label=_('Move:'),
    var_name='found_max_move',
    )
FoundEqual = WizSetting(
    values_map=(0, 1),
    default=1,
    label=_('First card sets base cards:'),
    var_name='found_equal',
    widget='check',
    )
RowsNum = WizSetting(
    values_map=(1, 20),
    default=8,
    widget='spin',
    label=_('Number of tableau piles:'),
    var_name='rows_num',
    )
RowsType = WizSetting(
    values_map=((n_('Same suit'),                     SS_RowStack),
                (n_('Alternate color'),               AC_RowStack),
                (n_('Same color'),                    SC_RowStack),
                (n_('Rank'),                          RK_RowStack),
                (n_('Any suit but the same'),         BO_RowStack),

                (n_('Up or down by same suit'),       UD_SS_RowStack),
                (n_('Up or down by alternate color'), UD_AC_RowStack),
                (n_('Up or down by rank'),            UD_RK_RowStack),
                (n_('Up or down by same color'),      UD_SC_RowStack),

                (n_('Spider same suit'),              Spider_SS_RowStack),
                (n_('Spider alternate color'),        Spider_AC_RowStack),

                (n_('Yukon same suit'),               Yukon_SS_RowStack),
                (n_('Yukon alternate color'),         Yukon_AC_RowStack),
                (n_('Yukon rank'),                    Yukon_RK_RowStack),
                ),
    default=n_('Alternate color'),
    label=_('Type:'),
    var_name='rows_type',
    )
RowsBaseCard = WizSetting(
    values_map=((n_('Ace'),  ACE),
                (n_('King'), KING),
                (n_('Any'),  ANY_RANK),
                (n_('None'), NO_RANK),
                ),
    default=n_('Any'),
    label=_('Base card:'),
    var_name='rows_base_card',
    )
RowsDir = WizSetting(
    values_map=((n_('Up'), 1), (n_('Down'), -1)),
    default=n_('Down'),
    label=_('Direction:'),
    var_name='rows_dir',
    )
RowsMaxMove = WizSetting(
    values_map=((n_('Top card'), 1), (n_('Sequence'), UNLIMITED_MOVES)),
    default=n_('Sequence'),
    label=_('Move:'),
    var_name='rows_max_move',
    )
RowsWrap = WizSetting(
    values_map=(0, 1),
    default=0,
    label=_('Wrapping:'),
    var_name='rows_wrap',
    widget='check',
    )
RowsSuperMove = WizSetting(
    values_map=(0, 1),
    default=0,
    label=_('Use "Super Move" feature:'),
    var_name='rows_super_move',
    widget='check',
    )
ReservesNum = WizSetting(
    values_map=(0, 20),
    default=4,
    widget='spin',
    label=_('Number of reserves:'),
    var_name='reserves_num',
    )
ReservesMaxAccept = WizSetting(
    values_map=(0, 20),
    default=1,
    widget='spin',
    label=_('Max # of accepted cards:'),
    var_name='reserves_max_accept',
    )
DealType = WizSetting(
    values_map=((n_('Triangle'),  'triangle'),
                (n_('Rectangle'), 'rectangle'),
                ),
    default=n_('Rectangle'),
    label=_('Type:'),
    var_name='deal_type',
    )
DealFaceDown = WizSetting(
    values_map=(0, 20),
    default=0,
    widget='spin',
    label=_('# of face-down cards dealt to the tableau pile:'),
    var_name='deal_face_down',
    )
DealFaceUp = WizSetting(
    values_map=(0, 20),
    default=8,
    widget='spin',
    label=_('# of face-up cards dealt to the tableau pile:'),
    var_name='deal_face_up',
    )
DealToReseves = WizSetting(
    values_map=(0, 208),
    default=0,
    widget='spin',
    label=_('# of cards dealt to the reserve:'),
    var_name='deal_to_reserves',
    )
DealMaxCards = WizSetting(
    values_map=(0, 208),
    default=52,
    widget='spin',
    label=_('Max # of dealt cards:'),
    var_name='deal_max_cards',
    )
DealToFound = WizSetting(
    values_map=(0, 1),
    default=0,
    label=_('Deal first cards to the foundations:'),
    var_name='deal_found',
    widget='check',
    )

WizardWidgets = (
    _('General'),
    WizardPresets,
    GameName,
    SkillLevel,
    NumDecks,
    LayoutType,
    _('Talon'),
    TalonType,
    Redeals,
    DealToWaste,
    TalonShuffle,
    _('Foundations'),
    FoundType,
    FoundBaseCard,
    FoundDir,
    FoundMaxMove,
    FoundEqual,
    _('Tableau'),
    RowsNum,
    RowsType,
    RowsBaseCard,
    RowsDir,
    RowsMaxMove,
    RowsWrap,
    RowsSuperMove,
    _('Reserves'),
    ReservesNum,
    ReservesMaxAccept,
    _('Opening deal'),
    DealType,
    DealFaceDown,
    DealFaceUp,
    DealToReseves,
    DealMaxCards,
    DealToFound,
    )


def write_game(app, game=None):
    import pysollib.customgame                   # for py2exe
    pysollib.customgame.no_use()
    if game is None:
        # new game
        d = app.dn.plugins
        n = 1
        while True:
            fn = os.path.join(d, 'customgame%d.py' % n)  # file name
            mn = 'customgame%d' % n         # module name
            gameid = 200000+n
            if not os.path.exists(fn):
                break
            n += 1
        check_game = True
    else:
        # edit current game
        fn = game.MODULE_FILENAME
        mn = game.__module__
        gameid = game.SETTINGS['gameid']
        check_game = False

    # print '===>', fn
    with open(fn, 'w') as fd:

        fd.write('''\
## -*- coding: utf-8 -*-
## THIS FILE WAS GENERATED AUTOMATICALLY BY THE SOLITAIRE WIZARD
## DO NOT EDIT

from pysollib.customgame import CustomGame, registerCustomGame

class MyCustomGame(CustomGame):
    WIZARD_VERSION = 1
    SETTINGS = {
''')

        for w in WizardWidgets:
            if isinstance(w, six.string_types):
                continue
            v = w.variable.get()
            if w.widget in ('menu', 'preset'):
                v = w.translation_map[v]
            if v == w.default:
                # save only unique values
                continue
            if isinstance(v, int):
                fd.write("        '%s': %i,\n" % (w.var_name, v))
            else:
                if w.var_name == 'name':
                    # escape
                    v = v.replace('\\', '\\\\')
                    v = v.replace("'", "\\'")
                    if isinstance(v, six.text_type):
                        v = v.encode('utf-8')
                    if not v:
                        v = 'Invalid Game Name'
                fd.write("        '%s': '%s',\n" % (w.var_name, v))
        fd.write("        'gameid': %i,\n" % gameid)

        fd.write('''\
            }

registerCustomGame(MyCustomGame)
''')

    loadGame(mn, fn, check_game=check_game)

    return gameid


def reset_wizard(game):
    for w in WizardWidgets:
        if isinstance(w, six.string_types):
            continue
        if game is None:
            # set to default
            v = w.default
        else:
            # set from current game
            if w.var_name in game.SETTINGS:
                v = game.SETTINGS[w.var_name]
            else:
                v = w.default
        w.current_value = v
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


# imports

# PySol imports
from pysollib.mygettext import _
from pysollib.pysoltk import HTMLViewer
from pysollib.pysoltk import MfxMessageDialog
from pysollib.pysoltk import PysolAboutDialog
from pysollib.pysoltk import make_help_toplevel
from pysollib.settings import PACKAGE_URL, TITLE, TOOLKIT, VERSION


# ************************************************************************
# *
# ************************************************************************

def help_about(app, timeout=0, sound=True):
    if sound:
        app.audio.playSample("about")
    t = _("A Python Solitaire Game Collection")
    if app.miscrandom.random() < 0.8:
        t = _("A World Domination Project")
    strings = (_("&Nice"), _("&Credits..."))
    if timeout:
        strings = (_("&Enjoy"),)
    version = _("Version %s") % VERSION
    d = PysolAboutDialog(app, app.top, title=_("About %s") % TITLE,
                         timeout=timeout,
                         text=_('''PySol Fan Club edition
%(description)s
%(versioninfo)s

Copyright (C) 1998 - 2003 Markus F.X.J. Oberhumer.
Copyright (C) 2003 Mt. Hood Playing Card Co.
Copyright (C) 2005 - 2009 Skomoroh.
All Rights Reserved.

PySol is free software distributed under the terms
of the GNU General Public License.

For more information about this application visit''') %
                         {'description': t, 'versioninfo': version},
                         url=PACKAGE_URL,
                         image=app.gimages.logos[2],
                         strings=strings, default=0,
                         separator=True)
    if d.status == 0 and d.button == 1:
        help_credits(app, sound=sound)
    return d.status


def help_credits(app, timeout=0, sound=True):
    if sound:
        app.audio.playSample("credits")
    t = ""
    if TOOLKIT == "tk":
        t = "Tcl/Tk"
    elif TOOLKIT == "gtk":
        t = "PyGTK"
    elif TOOLKIT == "kde":
        t = "pyKDE"
    elif TOOLKIT == "wx":
        t = "wxPython"
    elif TOOLKIT == "kivy":
        t = "kivy"
    d = MfxMessageDialog(
        app.top, title=_("Credits"), timeout=timeout,
        text=_('''%(app)s credits go to:

Volker Weidner for getting me into Solitaire
Guido van Rossum for the initial example program
T. Kirk for lots of contributed games and cardsets
Carl Larsson for the background music
The Gnome AisleRiot team for parts of the documentation
Natascha

The Python, %(gui_library)s, SDL & Linux crews
for making this program possible''') % {'app': TITLE, 'gui_library': t},
        image=app.gimages.logos[3], image_side="right",
        separator=True)
    return d.status


# ************************************************************************
# *
# ************************************************************************

help_html_viewer = None
help_html_index = None


def help_html(app, document, dir_, top=None):
    global help_html_viewer, help_html_index
    if not document:
        return None
    if top is None:
        top = app.top
    try:
        doc = app.dataloader.findFile(document, dir_)
        if help_html_index is None:
            document, dir_ = "index.html", "html"
            help_html_index = app.dataloader.findFile(document, dir_)
    except EnvironmentError:
        MfxMessageDialog(app.top, title=_("%s HTML Problem") % TITLE,
                         text=_("Cannot find help document\n%s") % document,
                         bitmap="warning")
        return None
    # print doc, help_html_index
    try:
        viewer = help_html_viewer
        # if viewer.parent.winfo_parent() != top._w:
        #    viewer.destroy()
        #    viewer = None
        viewer.updateHistoryXYView()
        viewer.display(doc, relpath=0)
    except Exception:
        # traceback.print_exc()
        top = make_help_toplevel(app, title=_("%s Help") % TITLE)
        if top.winfo_screenwidth() < 800 or top.winfo_screenheight() < 600:
            # maximized = 1
            top.wm_minsize(300, 150)
        else:
            # maximized = 0
            top.wm_minsize(400, 200)
        viewer = HTMLViewer(top, app, help_html_index)
        viewer.display(doc)
    # wm_map(top, maximized=maximized)
    viewer.parent.wm_deiconify()
    viewer.parent.tkraise()
    help_html_viewer = viewer
    return viewer


def destroy_help_html():
    try:
        help_html_viewer.destroy()
    except Exception:
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import Yukon_Hint
from pysollib.layout import Layout
from pysollib.stack import \
        AC_RowStack, \
        BO_RowStack, \
        DealReserveRedealTalonStack, \
        DealRowRedealTalonStack, \
        GroundsForADivorceTalonStack, \
        InitialDealTalonStack, \
        OpenStack, \
        RK_RowStack, \
        ReserveStack, \
        SC_RowStack, \
        SS_RowStack, \
        SpiderTalonStack, \
        Spider_AC_Foundation, \
        Spider_AC_RowStack, \
        Spider_RK_Foundation, \
        Spider_SS_Foundation, \
        Spider_SS_RowStack, \
        StackWrapper, \
        SuperMoveAC_RowStack, \
        SuperMoveBO_RowStack, \
        SuperMoveRK_RowStack, \
        SuperMoveSC_RowStack, \
        SuperMoveSS_RowStack, \
        UD_AC_RowStack, \
        UD_RK_RowStack, \
        UD_SC_RowStack, \
        UD_SS_RowStack, \
        WasteStack, \
        WasteTalonStack, \
        Yukon_AC_RowStack, \
        Yukon_RK_RowStack, \
        Yukon_SS_RowStack
from pysollib.util import ACE, ANY_RANK, ANY_SUIT, \
    KING, \
    UNLIMITED_MOVES
from pysollib.wizardutil import WizardWidgets

import six

# ************************************************************************
# *
# ************************************************************************


def get_settings(ss):
    s = {}
    for w in WizardWidgets:
        if isinstance(w, six.string_types):
            continue
        if w.var_name in ss:
            v = ss[w.var_name]
        else:
            v = w.default
        if w.widget == 'menu':
            v = dict(w.values_map)[v]
        s[w.var_name] = v
    return s


class CustomGame(Game):

    def createGame(self):

        s = get_settings(self.SETTINGS)
        # from pprint import pprint; pprint(s)

        # foundations
        kw = {
            'dir': s['found_dir'],
            'base_rank': s['found_base_card'],
            'mod': 13,
            }
        # max_move
        if s['found_type'] not in (Spider_SS_Foundation,
                                   Spider_AC_Foundation,
                                   Spider_RK_Foundation,):
            kw['max_move'] = s['found_max_move']
        # suit
        if s['found_type'] in (Spider_SS_Foundation,
                               Spider_AC_Foundation,
                               Spider_RK_Foundation,):
            kw['suit'] = ANY_SUIT
        # fix dir and base_rank for Spider foundations
        if s['found_type'] in (Spider_SS_Foundation,
                               Spider_AC_Foundation,
                               Spider_RK_Foundation,):
            kw['dir'] = -kw['dir']
            if s['found_base_card'] == KING:
                kw['base_rank'] = ACE
            elif s['found_base_card'] == ACE:
                kw['base_rank'] = KING
        foundation = StackWrapper(s['found_type'], **kw)

        # talon
        kw = {
            'max_rounds': s['redeals'],
            }
        if s['redeals'] >= 0:
            kw['max_rounds'] += 1
        if s['talon'] is WasteTalonStack:
            kw['num_deal'] = s['deal_to_waste']
        talon = StackWrapper(s['talon'], **kw)

        # rows
        kw = {
            'base_rank': s['rows_base_card'],
            'dir':       s['rows_dir'],
            'max_move':  s['rows_max_move'],
            }
        if s['rows_wrap']:
            kw['mod'] = 13
        if s['rows_type'] in (UD_SS_RowStack, UD_AC_RowStack,
                              UD_RK_RowStack, UD_SC_RowStack):
            kw['max_move'] = 1
        # Super Move
        if s['rows_super_move'] and kw['max_move'] == 1:
            for s1, s2 in ((SS_RowStack, SuperMoveSS_RowStack),
                           (AC_RowStack, SuperMoveAC_RowStack),
                           (RK_RowStack, SuperMoveRK_RowStack),
                           (SC_RowStack, SuperMoveSC_RowStack),
                           (BO_RowStack, SuperMoveBO_RowStack)):
                if s['rows_type'] is s1:
                    s['rows_type'] = s2
                    kw['max_move'] = UNLIMITED_MOVES
                    break
        row = StackWrapper(s['rows_type'], **kw)

        # layout
        layout_kw = {
            'rows': s['rows_num'],
            'reserves': s['reserves_num'],
            'waste': False,
            'texts': True,
            }
        playcards = 0
        if s['talon'] is InitialDealTalonStack:
            layout_kw['texts'] = False
            playcards = 12 + 52 * s['decks'] / s['rows_num']
        else:
            playcards = 12 + s['deal_face_down'] + s['deal_face_up']
        layout_kw['playcards'] = max(16, playcards)
        if s['talon'] in (DealRowRedealTalonStack,
                          SpiderTalonStack,
                          GroundsForADivorceTalonStack):
            layout_kw['playcards'] += 2 * s['decks']

        # reserves
        if s['reserves_num']:
            kw = {
                'max_cards': s['reserves_max_accept'],
                }
            if s['reserves_max_accept']:
                layout_kw['reserve_class'] = StackWrapper(ReserveStack, **kw)
            else:
                layout_kw['reserve_class'] = StackWrapper(OpenStack, **kw)
            if s['talon'] is DealReserveRedealTalonStack or \
               s['reserves_max_accept'] > 1 or s['deal_to_reserves'] > 1:
                layout_kw['reserve_texts'] = True

        # waste
        if s['talon'] is WasteTalonStack:
            layout_kw['waste'] = True
            layout_kw['waste_class'] = WasteStack

        Layout(self).createGame(
            layout_method=s['layout'],
            talon_class=talon,
            foundation_class=foundation,
            row_class=row,
            **layout_kw
        )

        # shuffle
        if s['talon_shuffle'] and s['talon'] in (WasteTalonStack,
                                                 DealRowRedealTalonStack):
            self.s.talon.dealCards = self.s.talon.shuffleAndDealCards

        # shallHighlightMatch
        for c, f in (
                ((Spider_AC_RowStack, Spider_SS_RowStack),
                 (self._shallHighlightMatch_RK,
                  self._shallHighlightMatch_RKW)),
                ((AC_RowStack, UD_AC_RowStack,
                  Yukon_AC_RowStack, SuperMoveAC_RowStack),
                 (self._shallHighlightMatch_AC,
                  self._shallHighlightMatch_ACW)),
                ((SS_RowStack, UD_SS_RowStack,
                  Yukon_SS_RowStack, SuperMoveSS_RowStack),
                 (self._shallHighlightMatch_SS,
                  self._shallHighlightMatch_SSW)),
                ((RK_RowStack, UD_RK_RowStack,
                  Yukon_RK_RowStack, SuperMoveRK_RowStack),
                 (self._shallHighlightMatch_RK,
                  self._shallHighlightMatch_RKW)),
                ((SC_RowStack, UD_SC_RowStack, SuperMoveSC_RowStack),
                 (self._shallHighlightMatch_SC,
                  self._shallHighlightMatch_SCW)),
                ((BO_RowStack, SuperMoveBO_RowStack),
                 (self._shallHighlightMatch_BO,
                  self._shallHighlightMatch_BOW)),
                ):
            if s['rows_type'] in c:
                if s['rows_wrap']:
                    self.shallHighlightMatch = f[1]
                else:
                    self.shallHighlightMatch = f[0]
                break

        # getQuickPlayScore
        if s['rows_type'] in (Spider_AC_RowStack,
                              Spider_SS_RowStack,):
            self.getQuickPlayScore = self._getSpiderQuickPlayScore

        # canDropCards
        if s['found_type'] in (Spider_SS_Foundation,
                               Spider_AC_Foundation,
                               Spider_RK_Foundation,):
            for stack in self.s.rows:
                stack.canDropCards = stack.spiderCanDropCards

        # acceptsCards
        if s['found_base_card'] == ANY_RANK and s['found_equal']:
            for stack in self.s.foundations:
                stack.acceptsCards = stack.varyAcceptsCards
                stack.getBaseCard = stack.varyGetBaseCard

        # getBottomImage
        if s['deal_face_down'] + s['deal_face_up'] == 0:
            for stack in self.s.rows:
                stack.getBottomImage = stack.getReserveBottomImage

        # Hint_Class
        # TODO
        if s['rows_type'] in (Yukon_SS_RowStack,
                              Yukon_AC_RowStack,
                              Yukon_RK_RowStack):
            self.Hint_Class = Yukon_Hint

    def _shuffleHook(self, cards):
        s = get_settings(self.SETTINGS)
        if not s['deal_found']:
            return cards
        if s['found_type'] in (Spider_SS_Foundation,
                               Spider_AC_Foundation,
                               Spider_RK_Foundation,):
            return cards
        base_card = s['found_base_card']
        if base_card == ANY_RANK:
            base_card = cards[0].rank
        # move base_card to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards,
            lambda c, rank=base_card: (c.rank == rank, c.suit))

    def startGame(self):

        s = get_settings(self.SETTINGS)
        anim_frames = -1

        def deal(rows, flip, frames, max_cards):
            if frames == 0:
                if len(self.s.talon.cards) <= min_cards or \
                       max_cards <= min_cards:
                    frames = anim_frames
                    self.startDealSample()
            if max_cards <= 0:
                return frames, 0
            max_cards -= self.s.talon.dealRowAvail(rows=rows, flip=flip,
                                                   frames=frames)
            return frames, max_cards

        frames = 0
        if isinstance(self.s.talon, InitialDealTalonStack):
            max_cards = 52 * s['decks']
        else:
            max_cards = s['deal_max_cards']

        min_cards = max(len(self.s.rows), 8)
        max_rows = s['deal_face_down'] + s['deal_face_up'] \
            + s['deal_to_reserves']
        if max_rows <= 1:
            min_cards = max_cards

        # deal to foundations
        if s['deal_found']:
            frames, max_cards = deal(self.s.foundations,
                                     True, frames, max_cards)

        # deal to reserves
        n = s['deal_to_reserves']
        for i in range(n):
            frames, max_cards = deal(self.s.reserves[:max_cards],
                                     True, frames, max_cards)

        # deal to rows
        face_down = s['deal_face_down']
        max_rows = s['deal_face_down'] + s['deal_face_up']
        if s['deal_type'] == 'triangle':
            # triangle
            for i in range(1, len(self.s.rows)):
                if max_rows <= 1:
                    break
                flip = (face_down <= 0)
                mc = max_cards - len(self.s.rows)
                frames, max_cards = deal(self.s.rows[i:i+mc],
                                         flip, frames, max_cards)
                face_down -= 1
                max_rows -= 1

        else:
            # rectangle
            for i in range(max_rows-1):
                flip = (face_down <= 0)
                mc = max_cards - len(self.s.rows)
                frames, max_cards = deal(self.s.rows[:mc],
                                         flip, frames, max_cards)
                face_down -= 1

        if isinstance(self.s.talon, InitialDealTalonStack):
            while self.s.talon.cards:
                frames, max_cards = deal(self.s.rows, True, frames, max_cards)
        else:
            if max_rows > 0:
                deal(self.s.rows, True, frames, len(self.s.rows))

        # deal to waste
        if self.s.waste:
            if frames == 0:
                self.startDealSample()
            self.s.talon.dealCards()


def registerCustomGame(gameclass):

    s = get_settings(gameclass.SETTINGS)
    gameid = gameclass.SETTINGS['gameid']

    registerGame(GameInfo(gameid, gameclass, s['name'],
                          GI.GT_CUSTOM | GI.GT_ORIGINAL,
                          s['decks'], s['redeals'], s['skill_level']))


def no_use():
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


# imports
from random import randint

# PySol imports
from pysollib.mfxutil import SubclassResponsibility

# ************************************************************************
# *
# ************************************************************************


class AbstractCard:
    # A playing card.
    #
    # A card doesn't record to which stack it belongs; only the stack
    # records this (it turns out that we always know this from the
    # context, and this saves a ``double update'' with potential for
    # inconsistencies).
    #
    # Public methods:
    #
    # moveTo(x, y) -- move the card to an absolute position
    # moveBy(dx, dy) -- move the card by a relative offset
    # tkraise() -- raise the card to the top of its stack
    # showFace(), showBack() -- turn the card face up or down & raise it
    #
    # Public read-only instance variables:
    #
    # suit, rank, color -- the card's suit, rank and color
    # face_up -- true when the card is shown face up, else false
    #
    # Semi-public read-only instance variables:
    #
    # item -- the CanvasItem representing the card
    # x, y -- the position of the card's top left corner
    #

    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        # The card is created at position (x, y), with its face down.
        # Adding it to a stack will position it according to that
        # stack's rules.
        self.id = id
        self.deck = deck
        self.suit = suit
        self.color = suit // 2
        self.rank = rank
        self.game = game
        self.x = x
        self.y = y
        self.item = None
        self.face_up = 0
        # To improve display speed, we hide cards (except 2 top cards).
        self.hide_stack = None

    def __str__(self):
        # Return a string for debug print statements.
        return "Card(%d, %d, %d, %d)" % \
               (self.id, self.deck, self.suit, self.rank)

    def isHidden(self):
        return self.hide_stack is not None

    def moveTo(self, x, y):
        # print 'moveTo', x, y
        # Move the card to absolute position (x, y).
        dx, dy = 0, 0
        if self.game.app.opt.randomize_place:
            d = 1
            dx, dy = randint(-d, d), randint(-d, d)
        self.moveBy(x - self.x + dx, y - self.y + dy)

    def moveBy(self, dx, dy):
        # Move the card by (dx, dy).
        dx, dy = int(dx), int(dy)
        if dx or dy:
            self.x = self.x + dx
            self.y = self.y + dy
            # print "moveBy:", self.id, dx, dy, self.item.coords()
            self.item.move(dx, dy)

    def tkraise(self, unhide=1):
        # Raise the card above all other objects in its group (i.e. stack).
        if unhide:
            self.unhide()
        self.item.tkraise()

    #
    # abstract methods
    #

    def hide(self, stack):
        pass

    def unhide(self):
        pass

    def setSelected(self, s, group=None):
        pass

    def showFace(self, unhide=1):
        # Turn the card's face up.
        raise SubclassResponsibility

    def showBack(self, unhide=1):
        # Turn the card's face down.
        raise SubclassResponsibility

    def updateCardBackground(self, image):
        raise SubclassResponsibility

    def close(self):
        pass

    def unclose(self):
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import locale
import os

from pysollib.gamedb import GI
from pysollib.help import help_about, help_html
from pysollib.mfxutil import Struct, openURL
from pysollib.mfxutil import print_err
from pysollib.mygettext import _
from pysollib.pysolrandom import constructRandom
from pysollib.pysoltk import AllGames_StatsDialog, SingleGame_StatsDialog
from pysollib.pysoltk import ColorsDialog
from pysollib.pysoltk import EditTextDialog
from pysollib.pysoltk import FontsDialog
from pysollib.pysoltk import FullLog_StatsDialog, SessionLog_StatsDialog
from pysollib.pysoltk import GameInfoDialog
from pysollib.pysoltk import MfxExceptionDialog
from pysollib.pysoltk import MfxMessageDialog, MfxSimpleEntry
from pysollib.pysoltk import PlayerOptionsDialog
from pysollib.pysoltk import ProgressionDialog
from pysollib.pysoltk import PysolMenubarTk, PysolToolbarTk
from pysollib.pysoltk import Status_StatsDialog, Top_StatsDialog
from pysollib.pysoltk import TimeoutsDialog
from pysollib.pysoltk import create_find_card_dialog
from pysollib.pysoltk import create_solver_dialog
from pysollib.settings import DEBUG
from pysollib.settings import PACKAGE_URL, TITLE
from pysollib.settings import TOP_SIZE
from pysollib.stats import FileStatsFormatter


# ************************************************************************
# * menubar
# ************************************************************************

class PysolMenubar(PysolMenubarTk):
    def __init__(self, app, top, progress=None):
        self.app = app
        self.top = top
        self.game = None
        # enabled/disabled - this is set by updateMenuState()
        self.menustate = Struct(
            save=0,
            save_as=0,
            hold_and_quit=0,
            undo=0,
            redo=0,
            restart=0,
            deal=0,
            hint=0,
            autofaceup=0,
            autodrop=0,
            shuffle=0,
            autodeal=0,
            quickplay=0,
            demo=0,
            highlight_piles=0,
            find_card=0,
            rules=0,
            pause=0,
            custom_game=0,
        )
        PysolMenubarTk.__init__(self, app, top, progress)

    #
    # delegation to Game
    #

    def _finishDrag(self):
        return self.game is None or self.game._finishDrag()

    def _cancelDrag(self, break_pause=True):
        if self.game is None:
            return True
        ret = self.game._cancelDrag(break_pause=break_pause)
        self._setPauseMenu(self.game.pause)
        return ret

    def changed(self, *args, **kw):
        assert self.game is not None
        return self.game.changed(*args, **kw)

    #
    # menu updates
    #

    def _clearMenuState(self):
        ms = self.menustate
        for k, v in ms.__dict__.items():
            if isinstance(v, list):
                ms.__dict__[k] = [0] * len(v)
            else:
                ms.__dict__[k] = 0

    # update self.menustate for menu items and toolbar
    def _updateMenuState(self):
        self._clearMenuState()
        game = self.game
        assert game is not None
        opt = self.app.opt
        ms = self.menustate
        # 0 = DISABLED, 1 = ENABLED
        ms.save_as = game.canSaveGame()
        ms.hold_and_quit = ms.save_as
        if game.filename and ms.save_as:
            ms.save = 1
        if opt.undo:
            if game.canUndo() and game.moves.index > 0:
                ms.undo = 1
            if game.canRedo() and game.moves.index < len(game.moves.history):
                ms.redo = 1
        if game.moves.index > 0:
            ms.restart = 1
        if game.canDealCards():
            ms.deal = 1
        if game.getHintClass() is not None:
            if opt.hint:
                ms.hint = 1
            # if not game.demo:       # if not already running
            ms.demo = 1
        autostacks = game.getAutoStacks()
        if autostacks[0]:
            ms.autofaceup = 1
        if autostacks[1] and game.s.foundations:
            ms.autodrop = 1
        if game.s.waste:
            ms.autodeal = 1
        if autostacks[2]:
            ms.quickplay = 1
        if opt.highlight_piles and game.getHighlightPilesStacks():
            ms.highlight_piles = 1
        if game.canFindCard():
            ms.find_card = 1
        if game.app.getGameRulesFilename(game.id):  # note: this may return ""
            ms.rules = 1
        if not game.finished:
            ms.pause = 1
        if game.gameinfo.si.game_type == GI.GT_CUSTOM:
            ms.custom_game = 1
        if game.canShuffle():
            if opt.shuffle:
                ms.shuffle = 1

    # update menu items and toolbar
    def _updateMenus(self):
        if self.game is None:
            return
        ms = self.menustate
        # File menu
        self.setMenuState(ms.save, "file.save")
        self.setMenuState(ms.save_as, "file.saveas")
        self.setMenuState(ms.hold_and_quit, "file.holdandquit")
        # Edit menu
        self.setMenuState(ms.undo, "edit.undo")
        self.setMenuState(ms.redo, "edit.redo")
        self.setMenuState(ms.redo, "edit.redoall")
        self.updateBookmarkMenuState()
        self.setMenuState(ms.restart, "edit.restart")
        self.setMenuState(ms.custom_game, "edit.editcurrentgame")
        # Game menu
        self.setMenuState(ms.deal, "game.dealcards")
        self.setMenuState(ms.autodrop, "game.autodrop")
        self.setMenuState(ms.shuffle, "game.shuffletiles")
        self.setMenuState(ms.pause, "game.pause")
        # Assist menu
        self.setMenuState(ms.hint, "assist.hint")
        self.setMenuState(ms.highlight_piles, "assist.highlightpiles")
        self.setMenuState(ms.find_card, "assist.findcard")
        self.setMenuState(ms.demo, "assist.demo")
        self.setMenuState(ms.demo, "assist.demoallgames")
        # Options menu
        self.setMenuState(ms.autofaceup, "options.automaticplay.autofaceup")
        self.setMenuState(ms.autodrop, "options.automaticplay.autodrop")
        self.setMenuState(ms.autodeal, "options.automaticplay.autodeal")
        self.setMenuState(ms.quickplay, "options.automaticplay.quickplay")
        # Help menu
        self.setMenuState(ms.rules, "help.rulesforthisgame")
        # Toolbar
        self.setToolbarState(ms.restart, "restart")
        self.setToolbarState(ms.save_as, "save")
        self.setToolbarState(ms.undo, "undo")
        self.setToolbarState(ms.redo, "redo")
        self.setToolbarState(ms.autodrop, "autodrop")
        self.setToolbarState(ms.shuffle, "shuffle")
        self.setToolbarState(ms.pause, "pause")
        self.setToolbarState(ms.rules, "rules")

    # update menu items and toolbar
    def updateMenus(self):
        if self.game is None:
            return
        self._updateMenuState()
        self._updateMenus()

    # disable menu items and toolbar
    def disableMenus(self):
        if self.game is None:
            return
        self._clearMenuState()
        self._updateMenus()

    #
    # File menu
    #

    def mNewGame(self, *args):
        if self._cancelDrag():
            return
        if self.changed():
            if not self.game.areYouSure(_("New game")):
                return
        if self.game.nextGameFlags(self.game.id) == 0:
            self.game.endGame()
            self.game.newGame()
        else:
            self.game.endGame()
            self.game.quitGame(self.game.id)

    def _mSelectGame(self, id, random=None, force=False):
        if self._cancelDrag():
            return
        if not force and self.game.id == id:
            return
        if self.changed():
            if not self.game.areYouSure(_("Select game")):
                return
        self.game.endGame()
        self.game.quitGame(id, random=random)

    def _mNewGameBySeed(self, seed, origin):
        try:
            random = constructRandom(seed)
            if random is None:
                return
            id = self.game.id
            if not self.app.getGameInfo(id):
                raise ValueError
        except (ValueError, TypeError):
            MfxMessageDialog(self.top, title=_("Invalid game number"),
                             text=_("Invalid game number\n") + str(seed),
                             bitmap="error")
            return
        f = self.game.nextGameFlags(id, random)
        if f & 17 == 0:
            return
        random.origin = origin
        if f & 15 == 0:
            self.game.endGame()
            self.game.newGame(random=random)
        else:
            self.game.endGame()
            self.game.quitGame(id, random=random)

    def mNewGameWithNextId(self, *args):
        if self._cancelDrag():
            return
        if self.changed():
            if not self.game.areYouSure(_("Select next game number")):
                return
        r = self.game.random
        seed = r.increaseSeed(r.initial_seed)
        seed = r.str(seed)
        self._mNewGameBySeed(seed, self.game.random.ORIGIN_NEXT_GAME)

    def mSelectGameById(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        f = self.game.getGameNumber(format=0)
        d = MfxSimpleEntry(self.top, _("Select new game number"),
                           _("\n\nEnter new game number"), f,
                           strings=(_("&OK"), _("&Next number"), _("&Cancel")),
                           default=0, e_width=25)
        if d.status != 0:
            return
        if d.button == 2:
            return
        if d.button == 1:
            self.mNewGameWithNextId()
            return
        if self.changed():
            if not self.game.areYouSure(_("Select new game number")):
                return
        self._mNewGameBySeed(d.value, self.game.random.ORIGIN_SELECTED)

    def mSelectRandomGame(self, type='all'):
        if self._cancelDrag():
            return
        if self.changed():
            if not self.game.areYouSure(_("Select random game")):
                return
        game_id = None
        games = []
        for g in self.app.gdb.getGamesIdSortedById():
            gi = self.app.getGameInfo(g)
            if 1 and gi.id == self.game.id:
                # force change of game
                continue
            if 1 and gi.category != self.game.gameinfo.category:
                # don't change game category
                continue
            won, lost = self.app.stats.getStats(self.app.opt.player, gi.id)
            if type == 'all':
                games.append(gi.id)
            elif type == 'won' and won > 0:
                games.append(gi.id)
            elif type == 'not won' and won == 0 and lost > 0:
                games.append(gi.id)
            elif type == 'not played' and won+lost == 0:
                games.append(gi.id)
        if games:
            game_id = self.app.chooseRandomOutOfGames(games)
        if game_id and game_id != self.game.id:
            self.game.endGame()
            self.game.quitGame(game_id)

    def _mSelectNextGameFromList(self, gl, step):
        if self._cancelDrag():
            return
        id = self.game.id
        gl = list(gl)
        if len(gl) < 2 or (id not in gl):
            return
        if self.changed():
            if not self.game.areYouSure(_("Select next game")):
                return
        index = (gl.index(id) + step) % len(gl)
        self.game.endGame()
        self.game.quitGame(gl[index])

    def mSelectNextGameById(self, *args):
        self._mSelectNextGameFromList(self.app.gdb.getGamesIdSortedById(), 1)

    def mSelectPrevGameById(self, *args):
        self._mSelectNextGameFromList(self.app.gdb.getGamesIdSortedById(), -1)

    def mSelectNextGameByName(self, *args):
        self._mSelectNextGameFromList(self.app.gdb.getGamesIdSortedByName(), 1)

    def mSelectPrevGameByName(self, *args):
        self._mSelectNextGameFromList(
            self.app.gdb.getGamesIdSortedByName(), -1)

    def mSave(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        if self.menustate.save_as:
            if self.game.filename:
                self.game.saveGame(self.game.filename)
            else:
                self.mSaveAs()

    def mHoldAndQuit(self, *args):
        if self._cancelDrag():
            return
        self.game.endGame(holdgame=1)
        self.game.quitGame(holdgame=1)

    def mQuit(self, *args):
        if self._cancelDrag():
            return
        if self.changed():
            if not self.game.areYouSure(_("Quit %s") % TITLE):
                return
        self.game.endGame()
        self.game.quitGame()

    #
    # Edit menu
    #

    def mUndo(self, *args):
        if self._cancelDrag():
            return
        if self.menustate.undo:
            self.game.playSample("undo")
            self.game.undo()

    def mRedo(self, *args):
        if self._cancelDrag():
            return
        if self.menustate.redo:
            self.game.playSample("redo")
            self.game.redo()
            self.game.checkForWin()

    def mRedoAll(self, *args):
        if self._cancelDrag():
            return
        if self.menustate.redo:
            self.app.top.busyUpdate()
            self.game.playSample("redo", loop=1)
            while self.game.moves.index < len(self.game.moves.history):
                self.game.redo()
                if self.game.checkForWin():
                    break
            self.game.stopSamples()

    def mSetBookmark(self, n, confirm=1):
        if self._cancelDrag():
            return
        if not self.app.opt.bookmarks:
            return
        if not (0 <= n <= 8):
            return
        self.game.setBookmark(n, confirm=confirm)
        self.game.updateMenus()

    def mGotoBookmark(self, n, confirm=-1):
        if self._cancelDrag():
            return
        if not self.app.opt.bookmarks:
            return
        if not (0 <= n <= 8):
            return
        self.game.gotoBookmark(n, confirm=confirm)
        self.game.updateMenus()

    def mClearBookmarks(self, *args):
        if self._cancelDrag():
            return
        if not self.app.opt.bookmarks:
            return
        if not self.game.gsaveinfo.bookmarks:
            return
        if not self.game.areYouSure(_("Clear bookmarks"),
                                    _("Clear all bookmarks?")):
            return
        self.game.gsaveinfo.bookmarks = {}
        self.game.updateMenus()

    def mRestart(self, *args):
        if self._cancelDrag():
            return
        if self.game.moves.index == 0:
            return
        if self.changed(restart=1):
            if not self.game.areYouSure(_("Restart game"),
                                        _("Restart this game?")):
                return
        self.game.restartGame()

    #
    # Game menu
    #

    def mDeal(self, *args):
        if self._cancelDrag():
            return
        self.game.dealCards()

    def mDrop(self, *args):
        if self._cancelDrag():
            return
        # self.game.autoPlay(autofaceup=-1, autodrop=1)
        self.game.autoDrop(autofaceup=-1)

    def mDrop1(self, *args):
        if self._cancelDrag():
            return
        # self.game.autoPlay(autofaceup=1, autodrop=1)
        self.game.autoDrop(autofaceup=1)

    def mShuffle(self, *args):
        if self._cancelDrag():
            return
        if self.menustate.shuffle:
            if self.game.canShuffle():
                self.game._mahjonggShuffle()

    def mFindCard(self, *args):
        if self.game.canFindCard():
            create_find_card_dialog(self.game.top, self.game,
                                    self.app.getFindCardImagesDir())

    def mSolver(self, *args):
        create_solver_dialog(self.game.top, self.app)

    def mEditGameComment(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        game, gi = self.game, self.game.gameinfo
        kw = {'game': gi.name,
              'id': game.getGameNumber(format=1)}
        cc = _("Comments for %(game)s %(id)s:\n\n") % kw
        c = game.gsaveinfo.comment or cc
        d = EditTextDialog(game.top, _("Comments for %(id)s") % kw, text=c)
        if d.status == 0 and d.button == 0:
            text = d.text
            if text.strip() == cc.strip():
                game.gsaveinfo.comment = ""
            else:
                game.gsaveinfo.comment = d.text
                # save to file
                fn = os.path.join(self.app.dn.config, "comments.txt")
                fn = os.path.normpath(fn)
                if not text.endswith(os.linesep):
                    text += os.linesep
                enc = locale.getpreferredencoding()
                try:
                    open(fn, 'a').write(text.encode(enc, 'replace'))
                except Exception as err:
                    d = MfxExceptionDialog(
                        self.top, err,
                        text=_("Error while writing to file"))
                else:
                    d = MfxMessageDialog(
                        self.top, title=_("%s Info") % TITLE, bitmap="info",
                        text=_("Comments were appended to\n\n%(filename)s")
                        % {'filename': fn})
        self._setCommentMenu(bool(game.gsaveinfo.comment))

    #
    # Game menu - statistics
    #

    def _mStatsSave(self, player, filename, write_method):
        if player is None:
            text = _("Demo statistics were appended to\n\n%(filename)s")
            filename = filename + "_demo"
        else:
            text = _("Your statistics were appended to\n\n%(filename)s")
        filename = os.path.join(self.app.dn.config, filename + ".txt")
        filename = os.path.normpath(filename)
        try:
            a = FileStatsFormatter(self.app, open(filename, "a"))
            write_method(a, player)
        except EnvironmentError as ex:
            MfxExceptionDialog(self.top, ex,
                               text=_("Error while writing to file"))
        else:
            MfxMessageDialog(
                self.top, title=_("%s Info") % TITLE, bitmap="info",
                text=text % {'filename': filename})

    def mPlayerStats(self, *args, **kw):
        wasPaused = False
        if not self.game.pause:
            self.game.doPause()
            wasPaused = True
        mode = kw.get("mode", 101)
        demo = 0
        gameid = None
        while mode > 0:
            if mode > 1000:
                demo = not demo
                mode = mode % 1000
            #
            d = Struct(status=-1, button=-1)
            if demo:
                player = None
            else:
                player = self.app.opt.player
            n = self.game.gameinfo.name
            # translation keywords
            transkw = {'app': TITLE,
                       'player': player,
                       'game': n,
                       'tops': TOP_SIZE}
            #
            if mode == 100:
                d = Status_StatsDialog(self.top, game=self.game)
            elif mode == 101:
                header = (_("%(app)s Demo Statistics for %(game)s") if demo
                          else _("Statistics for %(game)s")) % transkw
                d = SingleGame_StatsDialog(
                   self.top, header, self.app, player, gameid=self.game.id)
                gameid = d.selected_game
            elif mode == 102:
                header = (_("%(app)s Demo Statistics") if demo
                          else _("Statistics for %(player)s")) % transkw
                d = AllGames_StatsDialog(self.top, header, self.app, player)
                gameid = d.selected_game
            elif mode == 103:
                header = (_("%(app)s Demo Full log") if demo
                          else _("Full log for %(player)s")) % transkw
                d = FullLog_StatsDialog(self.top, header, self.app, player)
            elif mode == 104:
                header = (_("%(app)s Demo Session log") if demo
                          else _("Session log for %(player)s")) % transkw
                d = SessionLog_StatsDialog(self.top, header, self.app, player)
            elif mode == 105:
                # TRANSLATORS: eg. top 10 or top 5 results for a certain game
                header = (_("%(app)s Demo Top %(tops)d for %(game)s") if demo
                          else _("Top %(tops)d for %(game)s")) % transkw
                d = Top_StatsDialog(
                    self.top, header, self.app, player, gameid=self.game.id)
            elif mode == 106:
                header = _("Game Info")
                d = GameInfoDialog(self.top, header, self.app)
            elif mode == 107:
                header = _("Statistics progression")
                d = ProgressionDialog(
                    self.top, header, self.app, player, gameid=self.game.id)
            elif mode == 202:
                # print stats to file
                write_method = FileStatsFormatter.writeStats
                self._mStatsSave(player, "stats", write_method)
            elif mode == 203:
                # print full log to file
                write_method = FileStatsFormatter.writeFullLog
                self._mStatsSave(player, "log", write_method)
            elif mode == 204:
                # print session log to file
                write_method = FileStatsFormatter.writeSessionLog
                self._mStatsSave(player, "log", write_method)
            elif mode == 301:
                # reset all player stats
                if self.game.areYouSure(
                    _("Reset all statistics"),
                    _("Reset ALL statistics and logs for player\n" +
                      "%(player)s?") % transkw,
                    confirm=1, default=1
                ):
                    self.app.stats.resetStats(player, 0)
                    self.game.updateStatus(stats=self.app.stats.getStats(
                        self.app.opt.player, self.game.id))
            elif mode == 302:
                # reset player stats for current game
                if self.game.areYouSure(
                    _("Reset game statistics"),
                    _('Reset statistics and logs for player\n%(player)s\n'
                      'and game\n%(game)s?') % transkw,
                    confirm=1, default=1
                ):
                    self.app.stats.resetStats(player, self.game.id)
                    self.game.updateStatus(stats=self.app.stats.getStats(
                        self.app.opt.player, self.game.id))
            elif mode == 401:
                # start a new game with a gameid
                if gameid and gameid != self.game.id:
                    self.game.endGame()
                    self.game.quitGame(gameid)
            elif mode == 402:
                # start a new game with a gameid / gamenumber
                # TODO
                pass
            else:
                print_err("stats problem: %s %s %s" % (mode, demo, player))
                pass
            if d.status != 0:
                break
            mode = d.button
        if self.game.pause:
            if wasPaused:
                self.game.doPause()

    #
    # Assist menu
    #

    def mHint(self, *args):
        if self._cancelDrag():
            return
        if self.app.opt.hint:
            if self.game.showHint(0, self.app.opt.timeouts['hint']):
                self.game.stats.hints += 1

    def mHint1(self, *args):
        if self._cancelDrag():
            return
        if self.app.opt.hint:
            if self.game.showHint(1, self.app.opt.timeouts['hint']):
                self.game.stats.hints += 1

    def mHighlightPiles(self, *args):
        if self._cancelDrag():
            return
        if self.app.opt.highlight_piles:
            if self.game.highlightPiles(
                self.app.opt.timeouts['highlight_piles']
            ):
                self.game.stats.highlight_piles += 1

    def mDemo(self, *args):
        if self._cancelDrag():
            return
        if self.game.getHintClass() is not None:
            self._mDemo(mixed=0)

    def mMixedDemo(self, *args):
        if self._cancelDrag():
            return
        self._mDemo(mixed=1)

    def _mDemo(self, mixed):
        if self.changed():
            # only ask if there have been no demo moves or hints yet
            if self.game.stats.demo_moves == 0 and self.game.stats.hints == 0:
                if not self.game.areYouSure(_("Play demo")):
                    return
        # self.app.demo_counter = 0
        self.game.startDemo(mixed=mixed)

    #
    # Options menu
    #

    def mOptPlayerOptions(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        d = PlayerOptionsDialog(self.top, _("Set player options"), self.app)
        if d.status == 0 and d.button == 0:
            self.app.opt.confirm = bool(d.confirm)
            self.app.opt.update_player_stats = bool(d.update_stats)
            self.app.opt.win_animation = bool(d.win_animation)
            # n = string.strip(d.player)
            n = d.player[:30].strip()
            if 0 < len(n) <= 30:
                self.app.opt.player = n
                self.game.updateStatus(player=self.app.opt.player)
                self.game.updateStatus(stats=self.app.stats.getStats(
                    self.app.opt.player, self.game.id))

    def mOptColors(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        d = ColorsDialog(self.top, _("Set colors"), self.app)
        text_color = self.app.opt.colors['text']
        if d.status == 0 and d.button == 0:
            self.app.opt.colors['text'] = d.text_color
            self.app.opt.colors['piles'] = d.piles_color
            self.app.opt.colors['cards_1'] = d.cards_1_color
            self.app.opt.colors['cards_2'] = d.cards_2_color
            self.app.opt.colors['samerank_1'] = d.samerank_1_color
            self.app.opt.colors['samerank_2'] = d.samerank_2_color
            self.app.opt.colors['hintarrow'] = d.hintarrow_color
            self.app.opt.colors['not_matching'] = d.not_matching_color
            #
            if text_color != self.app.opt.colors['text']:
                self.app.setTile(self.app.tabletile_index, force=True)

    def mOptFonts(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        d = FontsDialog(self.top, _("Set fonts"), self.app)
        if d.status == 0 and d.button == 0:
            self.app.opt.fonts.update(d.fonts)
            self._cancelDrag()
            self.game.endGame(bookmark=1)
            self.game.quitGame(bookmark=1)

    def mOptTimeouts(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        d = TimeoutsDialog(self.top, _("Set timeouts"), self.app)
        if d.status == 0 and d.button == 0:
            self.app.opt.timeouts['demo'] = d.demo_timeout
            self.app.opt.timeouts['hint'] = d.hint_timeout
            self.app.opt.timeouts['raise_card'] = d.raise_card_timeout
            self.app.opt.timeouts['highlight_piles'] = \
                d.highlight_piles_timeout
            self.app.opt.timeouts['highlight_cards'] = \
                d.highlight_cards_timeout
            self.app.opt.timeouts['highlight_samerank'] = \
                d.highlight_samerank_timeout

    #
    # Help menu
    #

    def mHelpHtml(self, *args):
        print('mHelpHtml: %s' % str(args))
        if self._cancelDrag(break_pause=False):
            return
        help_html(self.app, args[0], "html")

    def mHelp(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        help_html(self.app, "index.html", "html")

    def mHelpHowToPlay(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        help_html(self.app, "howtoplay.html", "html")

    def mHelpRules(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        if not self.menustate.rules:
            return
        dir = os.path.join("html", "rules")
        # FIXME: plugins
        help_html(self.app, self.app.getGameRulesFilename(self.game.id), dir)

    def mHelpLicense(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        help_html(self.app, "license.html", "html")

    def mHelpNews(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        help_html(self.app, "news.html", "html")

    def mHelpWebSite(self, *args):
        openURL(PACKAGE_URL)

    def mHelpAbout(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        help_about(self.app)

    #
    # misc
    #

    def mScreenshot(self, *args):
        if self._cancelDrag():
            return
        f = os.path.join(self.app.dn.config, "screenshots")
        if not os.path.isdir(f):
            return
        f = os.path.join(f, self.app.getGameSaveName(self.game.id))
        i = 1
        while 1:
            fn = "%s-%d.ppm" % (f, i)
            if not os.path.exists(fn):
                break
            i = i + 1
            if i >= 10000:      # give up
                return
        self.top.screenshot(fn)

    def mPlayNextMusic(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        if self.app.audio and self.app.opt.sound_music_volume > 0:
            self.app.audio.playNextMusic()
            if 1 and DEBUG:
                index = self.app.audio.getMusicInfo()
                music = self.app.music_manager.get(index)
                if music:
                    print("playing music:", music.filename)

    def mIconify(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.top.wm_iconify()


# ************************************************************************
# * toolbar
# ************************************************************************

class PysolToolbar(PysolToolbarTk):
    def __init__(self, *args, **kwargs):
        self.game = None
        PysolToolbarTk.__init__(self, *args, **kwargs)

    #
    # public methods
    #

    def connectGame(self, game):
        self.game = game

    #
    # button event handlers - delegate to menubar
    #

    def mNewGame(self, *args):
        if not self._busy():
            self.menubar.mNewGame()
        return 1

    def mOpen(self, *args):
        if not self._busy():
            self.menubar.mOpen()
        return 1

    def mRestart(self, *args):
        if not self._busy():
            self.menubar.mRestart()
        return 1

    def mSave(self, *args):
        if not self._busy():
            self.menubar.mSaveAs()
        return 1

    def mUndo(self, *args):
        if not self._busy():
            self.menubar.mUndo()
        return 1

    def mRedo(self, *args):
        if not self._busy():
            self.menubar.mRedo()
        return 1

    def mDrop(self, *args):
        if not self._busy():
            self.menubar.mDrop()
        return 1

    def mShuffle(self, *args):
        if not self._busy():
            self.menubar.mShuffle()
        return 1

    def mPause(self, *args):
        if not self._busy():
            self.menubar.mPause()
        return 1

    def mPlayerStats(self, *args):
        if not self._busy():
            self.menubar.mPlayerStats()
        return 1

    def mHelpRules(self, *args):
        if not self._busy():
            self.menubar.mHelpRules()
        return 1

    def mQuit(self, *args):
        if not self._busy():
            self.menubar.mQuit()
        return 1

    def mOptPlayerOptions(self, *args):
        if not self._busy():
            self.menubar.mOptPlayerOptions()
        return 1
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os


def n_(x):                        # for gettext
    return x


PACKAGE = 'PySolFC'
TITLE = 'PySol'
PACKAGE_URL = 'http://pysolfc.sourceforge.net/'

VERSION_TUPLE = (2, 8, 0)
VERSION = '.'.join(map(str, VERSION_TUPLE))

# Tk windowing system (auto set up in init.py)
WIN_SYSTEM = 'x11'                      # win32, x11, aqua, classic

# toolkit
TOOLKIT = 'tk'                          # or 'gtk'
USE_TILE = 'auto'                       # or True or False

# sound
# available values:
#   'pss' - PySol-Sound-Server (all)
#   'pygame' - PyGame (all)
#   'oss' (*nix)
#   'win' (windows)
#   'none' - disable
SOUND_MOD = 'auto'

# freecell-solver
USE_FREECELL_SOLVER = True
FCS_COMMAND = 'fc-solve'
# FCS_HOME = None                         # path to fcs presets files

# data dirs
DATA_DIRS = []
# you can add your extra directories here
if os.name == 'posix':
    DATA_DIRS = [
        '/usr/share/PySolFC',
        '/usr/local/share/PySolFC',
        '/usr/share/games/PySolFC',
        '/usr/local/share/games/PySolFC',
        ]
if os.name == 'nt':
    pass

TOP_SIZE = 10
TOP_TITLE = n_('Top 10')

# use menu for select game
SELECT_GAME_MENU = True

# i18n, see also options.py
TRANSLATE_GAME_NAMES = True

# debug
DEBUG = 0                               # must be integer
CHECK_GAMES = False                     # check duplicated names and classes
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# imports
import getopt
import os
import sys
import traceback

from pysollib.app import Application
from pysollib.gamedb import GAME_DB
from pysollib.mfxutil import print_err
from pysollib.mygettext import _
from pysollib.pysolaudio import AbstractAudioClient
from pysollib.pysolaudio import KivyAudioClient, OSSAudioClient
from pysollib.pysolaudio import PyGameAudioClient, Win32AudioClient
from pysollib.pysolaudio import PysolSoundServerModuleClient
from pysollib.pysolaudio import pysolsoundserver
from pysollib.pysoltk import MfxMessageDialog
from pysollib.pysoltk import MfxRoot
from pysollib.pysoltk import PysolProgressBar
from pysollib.pysoltk import loadImage
from pysollib.resource import Tile
from pysollib.settings import SOUND_MOD, TITLE, TOOLKIT
from pysollib.util import DataLoader
from pysollib.winsystems import init_root_window

# ************************************************************************
# *
# ************************************************************************

if TOOLKIT == 'kivy':
    from pysollib.mfxutil import getprefdir
    from pysollib.settings import PACKAGE

    def fatal_no_cardsets(app):
        app.wm_withdraw()
        MfxMessageDialog(app.top, title=_("%s installation error") % TITLE,
                         text=_('''No cardsets were found!!!

Cardsets should be installed into:
%(dir)s

Please check your %(app)s installation.
''') % {'dir': getprefdir(PACKAGE) + '/cardsets/', 'app': TITLE},
            bitmap="error", strings=(_("&Quit"),))
else:
    def fatal_no_cardsets(app):
        app.wm_withdraw()
        MfxMessageDialog(app.top, title=_("%s installation error") % TITLE,
                         text=_('''No cardsets were found!!!

Main data directory is:
%(dir)s

Please check your %(app)s installation.
''') % {'dir': app.dataloader.dir, 'app': TITLE},
                     bitmap="error", strings=(_("&Quit"),))


# ************************************************************************
# *
# ************************************************************************

def parse_option(argv):
    prog_name = argv[0]
    try:
        optlist, args = getopt.getopt(argv[1:], "g:i:hD:",
                                      ["deal=", "game=", "gameid=",
                                       "french-only",
                                       "noplugins",
                                       "nosound",
                                       "sound-mod=",
                                       "help"])
    except getopt.GetoptError as err:
        print_err(str(err) + "\n" + _("try %s --help for more information") %
                  prog_name, 0)
        return None
    opts = {"help": False,
            "deal": None,
            "game": None,
            "gameid": None,
            "french-only": False,
            "noplugins": False,
            "nosound": False,
            "sound-mod": None,
            }
    for i in optlist:
        if i[0] in ("-h", "--help"):
            opts["help"] = True
        elif i[0] in ("--deal"):
            opts["deal"] = i[1]
        elif i[0] in ("-g", "--game"):
            opts["game"] = i[1]
        elif i[0] in ("-i", "--gameid"):
            opts["gameid"] = i[1]
        elif i[0] == "--french-only":
            opts["french-only"] = True
        elif i[0] == "--noplugins":
            opts["noplugins"] = True
        elif i[0] == "--nosound":
            opts["nosound"] = True
        elif i[0] == "--sound-mod":
            assert i[1] in ('pss', 'pygame', 'oss', 'win')
            opts["sound-mod"] = i[1]

    if opts["help"]:
        print(_("""Usage: %s [OPTIONS] [FILE]
  -g    --game=GAMENAME        start game GAMENAME
  -i    --gameid=GAMEID
        --french-only
        --sound-mod=MOD
        --nosound              disable sound support
        --noplugins            disable load plugins
  -h    --help                 display this help and exit

  FILE - file name of a saved game
  MOD - one of following: pss(default), pygame, oss, win
""") % prog_name)
        return None

    if len(args) > 1:
        print_err(
            _("too many files\ntry %s --help for more information") %
            prog_name, 0)
        return None
    filename = args and args[0] or None
    if filename and not os.path.isfile(filename):
        print_err(
            _("invalid file name\ntry %s --help for more information") %
            prog_name, 0)
        return None
    return opts, filename

# ************************************************************************
# *
# ************************************************************************


def pysol_init(app, args):

    # init commandline options (undocumented)
    opts = parse_option(args)
    if not opts:
        return 1
        sys.exit(1)
    opts, filename = opts
    if filename:
        app.commandline.loadgame = filename
    app.commandline.deal = opts['deal']
    app.commandline.game = opts['game']
    if opts['gameid'] is not None:
        try:
            app.commandline.gameid = int(opts['gameid'])
        except ValueError:
            print_err(_('invalid game id: ') + opts['gameid'])

    # try to create the config directory
    for d in (
        app.dn.config,
        app.dn.savegames,
        os.path.join(app.dn.config, "music"),
        # os.path.join(app.dn.config, "screenshots"),
        os.path.join(app.dn.config, "tiles"),
        os.path.join(app.dn.config, "tiles", "stretch"),
        os.path.join(app.dn.config, "tiles", "save-aspect"),
        os.path.join(app.dn.config, "cardsets"),
        os.path.join(app.dn.config, "plugins"),
            ):
        if not os.path.exists(d):
            try:
                os.makedirs(d)
            except Exception:
                traceback.print_exc()
                pass

    # init DataLoader
    f = os.path.join("html", "license.html")
    app.dataloader = DataLoader(args[0], f)

    # init toolkit 1)
    top = MfxRoot(className=TITLE)
    app.top = top
    app.top_bg = top.cget("bg")
    app.top_cursor = top.cget("cursor")

    # load options
    try:
        app.loadOptions()
    except Exception:
        traceback.print_exc()
        pass

    # init toolkit 2)
    init_root_window(top, app)

    # prepare the progress bar
    app.loadImages1()
    if not app.progress_images:
        app.progress_images = (loadImage(app.gimages.logos[0]),
                               loadImage(app.gimages.logos[1]))
    app.wm_withdraw()

    # create the progress bar
    title = _("Welcome to %s") % TITLE
    color = app.opt.colors['table']
    if app.tabletile_index > 0:
        color = "#008200"
    app.intro.progress = PysolProgressBar(app, top, title=title, color=color,
                                          images=app.progress_images, norm=2.0)
    app.intro.progress.update(step=1)

    # init games database
    def progressCallback(*args):
        app.intro.progress.update(step=1)
    GAME_DB.setCallback(progressCallback)
    import pysollib.games
    if not opts['french-only']:
        import pysollib.games.ultra
        import pysollib.games.mahjongg
        import pysollib.games.special
        pysollib.games.special.no_use()

    # try to load plugins
    if not opts["noplugins"]:
        for dir in (os.path.join(app.dataloader.dir, "games"),
                    os.path.join(app.dataloader.dir, "plugins"),
                    app.dn.plugins):
            try:
                app.loadPlugins(dir)
            except Exception:
                pass
    GAME_DB.setCallback(None)

    # init audio 1)
    app.audio = None
    sounds = {'pss':     PysolSoundServerModuleClient,
              'pygame':  PyGameAudioClient,
              'oss':     OSSAudioClient,
              'win':     Win32AudioClient}
    if TOOLKIT == 'kivy':
        sounds['kivy'] = KivyAudioClient
    if opts["nosound"] or SOUND_MOD == 'none':
        app.audio = AbstractAudioClient()
    elif opts['sound-mod']:
        c = sounds[opts['sound-mod']]
        app.audio = c()
    elif SOUND_MOD == 'auto':
        snd = []
        snd.append(PyGameAudioClient)
        if TOOLKIT == 'kivy':
            snd.append(KivyAudioClient)
        if pysolsoundserver:
            snd.append(PysolSoundServerModuleClient)
        snd.append(OSSAudioClient)
        snd.append(Win32AudioClient)
        snd.append(AbstractAudioClient)
        for c in snd:
            try:
                app.audio = c()
                app.audio.startServer()
                app.audio.connectServer(app)
            except Exception:
                pass
            else:
                # success
                break
    else:
        c = sounds[SOUND_MOD]
        app.audio = c()
        app.audio.startServer()
        app.audio.connectServer(app)

    # update sound_mode
    if isinstance(app.audio, PysolSoundServerModuleClient):
        app.opt.sound_mode = 1
    else:
        app.opt.sound_mode = 0

    # check games
    if len(app.gdb.getGamesIdSortedByName()) == 0:
        app.wm_withdraw()
        app.intro.progress.destroy()
        d = MfxMessageDialog(top, title=_("%s installation error") % TITLE,
                             text=_('''
No games were found!!!

Main data directory is:
%(dir)s

Please check your %(app)s installation.
''') % {'dir': app.dataloader.dir, 'app': TITLE},
                             bitmap="error", strings=(_("&Quit"),))
        return 1

    # init cardsets
    app.initCardsets()
    cardset = None
    c = app.opt.cardset.get(0)
    if c:
        cardset = app.cardset_manager.getByName(c[0])
        if cardset and c[1]:
            cardset.updateCardback(backname=c[1])
    if not cardset:
        cardset = app.cardset_manager.get(0)
    if app.cardset_manager.len() == 0 or not cardset:
        fatal_no_cardsets(app)
        return 3

    # init tiles
    manager = app.tabletile_manager
    tile = Tile()
    tile.color = app.opt.colors['table']
    tile.name = "None"
    tile.filename = None
    manager.register(tile)
    app.initTiles()
    if app.opt.tabletile_name:  # and top.winfo_screendepth() > 8:
        for tile in manager.getAll():
            if app.opt.tabletile_name == tile.basename:
                app.tabletile_index = tile.index
                break

    # init samples and music resources
    app.initSamples()
    app.initMusic()

    # init audio 2)
    if not app.audio.CAN_PLAY_SOUND:
        app.opt.sound = 0
    app.audio.updateSettings()
    # start up the background music
    if app.audio.CAN_PLAY_MUSIC:
        music = app.music_manager.getAll()
        if music:
            app.music_playlist = list(music)[:]
            app.miscrandom.shuffle(app.music_playlist)
            # Cancelling because otherwise people complain
            # that the music order is not random.
            SHOULD_PUT_bye_for_now_FIRST = False
            if SHOULD_PUT_bye_for_now_FIRST:
                for m in app.music_playlist:
                    if m.name.lower() == "bye_for_now":
                        app.music_playlist.remove(m)
                        app.music_playlist.insert(0, m)
                        break
            app.audio.playContinuousMusic(app.music_playlist)

    # prepare other images
    app.loadImages2()
    app.loadImages3()
    app.loadImages4()

    # load cardset
    progress = app.intro.progress
    if not app.loadCardset(cardset, progress=progress, update=1):
        for cardset in app.cardset_manager.getAll():
            progress.reset()
            if app.loadCardset(cardset, progress=progress, update=1):
                break
        else:
            fatal_no_cardsets(app)
            return 3

    # ok
    return 0


# ************************************************************************
# * main
# ************************************************************************


if TOOLKIT == 'kivy':
    from pysollib.kivy.LApp import LApp
    import logging

    class KivyApp(LApp):
        def __init__(self, args):
            super(KivyApp, self).__init__()
            self.args = args

        def build(self):
            logging.info("KivyApp: build")

            self.app = app = Application()
            app.top = self.mainWindow
            self.startCode = pysol_init(app, self.args)

            logging.info('Main: App Initialised - starting main loop')
            return self.mainWindow

    def main(args=None):
        logging.basicConfig(level=logging.INFO)
        KivyApp(args).run()

else:

    def main(args=None):
        # create the application
        app = Application()
        r = pysol_init(app, args)
        if r != 0:
            return r
        # let's go - enter the mainloop
        app.mainloop()
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.


from pysollib.app_stat_result import GameStatResult


class GameStat:
    def __init__(self, id):
        self.gameid = id
        #
        self.num_total = 0
        # self.num_not_won = 0
        self.num_lost = 0
        self.num_won = 0
        self.num_perfect = 0
        #
        self.time_result = GameStatResult()
        self.moves_result = GameStatResult()
        self.total_moves_result = GameStatResult()
        self.score_result = GameStatResult()
        self.score_casino_result = GameStatResult()

    def update(self, game, status):
        #
        game_number = game.getGameNumber(format=0)
        game_start_time = game.gstats.start_time
        # update number of games
        # status:
        # -1 - NOT WON (not played)
        # 0 - LOST
        # 1 - WON
        # 2 - PERFECT
        self.num_total += 1
        assert status in (0, 1, 2)
        if status == 0:
            self.num_lost += 1
            return
        elif status == 1:
            self.num_won += 1
        else:  # status == 2
            self.num_perfect += 1

        score = game.getGameScore()
        # print 'GameScore:', score
        score_p = None
        if score is not None:
            score_p = self.score_result.update(
                game.id, score, game_number, game_start_time)
        score = game.getGameScoreCasino()
        # print 'GameScoreCasino:', score
        score_casino_p = None
        if score is not None:
            score_casino_p = self.score_casino_result.update(
                game.id, score, game_number, game_start_time)

        if status == 0:
            return

        game.updateTime()
        time_p = self.time_result.update(
            game.id, game.stats.elapsed_time, game_number, game_start_time)
        moves_p = self.moves_result.update(
            game.id, game.moves.index, game_number, game_start_time)
        total_moves_p = self.total_moves_result.update(
            game.id, game.stats.total_moves, game_number, game_start_time)

        return time_p, moves_p, total_moves_p, score_p, score_casino_p
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import locale
import os
import re
import sys
import time
import webbrowser
from pickle import Pickler, Unpickler

from pysollib.settings import PACKAGE, TOOLKIT

import six
from six import print_

Image = ImageTk = ImageOps = None
if TOOLKIT == 'tk':
    try:  # PIL
        from PIL import Image
        from PIL import ImageTk  # noqa: F401
        from PIL import ImageOps  # noqa: F401
    except ImportError:
        Image = None
    else:
        # for py2exe
        from PIL import GifImagePlugin  # noqa: F401
        from PIL import PngImagePlugin  # noqa: F401
        from PIL import JpegImagePlugin  # noqa: F401
        from PIL import BmpImagePlugin  # noqa: F401
        from PIL import PpmImagePlugin  # noqa: F401
        Image._initialized = 2
USE_PIL = False
if TOOLKIT == 'tk' and Image:
    USE_PIL = True

# debug
# Image = None
# USE_PIL = False

# ************************************************************************
# * exceptions
# ************************************************************************


class SubclassResponsibility(Exception):
    pass


# ************************************************************************
# * misc. util
# ************************************************************************


def latin1_to_ascii(n):
    if sys.version_info > (3,):
        return n
    # return n
    n = n.encode('iso8859-1', 'replace')
    # FIXME: rewrite this for better speed
    return (n.replace("\xc4", "Ae")
             .replace("\xd6", "Oe")
             .replace("\xdc", "Ue")
             .replace("\xe4", "ae")
             .replace("\xf6", "oe")
             .replace("\xfc", "ue"))


def latin1_normalize(n):
    return re.sub(r"[^\w]", "", latin1_to_ascii(n).lower())


def format_time(t):
    # print 'format_time:', t
    if t <= 0:
        return "0:00"
    if t < 3600:
        return "%d:%02d" % (t // 60, t % 60)
    return "%d:%02d:%02d" % (t // 3600, (t % 3600) // 60, t % 60)


def print_err(s, level=1):
    if level == 0:
        ss = PACKAGE+': ERROR:'
    elif level == 1:
        ss = PACKAGE+': WARNING:'
    elif level == 2:
        ss = PACKAGE+': DEBUG WARNING:'
    try:
        print_(ss, s, file=sys.stderr)
    except Exception:
        print_(ss, s.encode(locale.getpreferredencoding()), file=sys.stderr)
    sys.stderr.flush()


# ************************************************************************
# * misc. portab stuff
# ************************************************************************

def getusername():
    if os.name == "nt":
        return win32_getusername()
    user = os.environ.get("USER", "").strip()
    if not user:
        user = os.environ.get("LOGNAME", "").strip()
    return user


def getprefdir(package):

    if (TOOLKIT == 'kivy'):
        from pysollib.kivy.LApp import get_platform
        plat = get_platform()
        if plat == 'android':
            os.environ['HOME'] = '/sdcard'

    if os.name == "nt":
        return win32_getprefdir(package)
    home = os.environ.get("HOME", "").strip()
    if not home or not os.path.isdir(home):
        home = os.curdir
    return os.path.join(home, ".PySolFC")


# high resolution clock() and sleep()
try:
    uclock = time.perf_counter
except Exception:
    uclock = time.clock

usleep = time.sleep
if os.name == "posix":
    uclock = time.time

# ************************************************************************
# * MSWin util
# ************************************************************************


def win32_getusername():
    user = os.environ.get('USERNAME', '').strip()
    try:
        user = six.text_type(user, locale.getpreferredencoding())
    except Exception:
        user = ''
    return user


def win32_getprefdir(package):
    portprefdir = 'config'      # portable varsion
    if os.path.isdir(portprefdir):
        return portprefdir
    # %USERPROFILE%, %APPDATA%
    hd = os.environ.get('APPDATA')
    if not hd:
        hd = os.path.expanduser('~')
        if hd == '~':  # win9x
            hd = os.path.abspath('/windows/Application Data')
            if not os.path.exists(hd):
                hd = os.path.abspath('/')
    return os.path.join(hd, 'PySolFC')


# ************************************************************************
# * memory util
# ************************************************************************

def destruct(obj):
    if TOOLKIT == 'kivy':
        return

    # assist in breaking circular references
    if obj is not None:
        for k in obj.__dict__.keys():
            obj.__dict__[k] = None
            # del obj.__dict__[k]


# ************************************************************************
# *
# ************************************************************************

class Struct:
    def __init__(self, **kw):
        self.__dict__.update(kw)

    def __str__(self):
        return str(self.__dict__)

    def __setattr__(self, key, value):
        if key not in self.__dict__:
            raise AttributeError(key)
        self.__dict__[key] = value

    def addattr(self, **kw):
        for key in kw.keys():
            if hasattr(self, key):
                raise AttributeError(key)
        self.__dict__.update(kw)

    def update(self, dict):
        for key in dict.keys():
            if key not in self.__dict__:
                raise AttributeError(key)
        self.__dict__.update(dict)

    def clear(self):
        for key in self.__dict__.keys():
            if isinstance(key, list):
                self.__dict__[key] = []
            elif isinstance(key, tuple):
                self.__dict__[key] = ()
            elif isinstance(key, dict):
                self.__dict__[key] = {}
            else:
                self.__dict__[key] = None

    def copy(self):
        c = self.__class__()
        c.__dict__.update(self.__dict__)
        return c


# ************************************************************************
# * keyword argument util
# ************************************************************************

# update keyword arguments with default arguments
def kwdefault(kw, **defaults):
    for k, v in defaults.items():
        if k not in kw:
            kw[k] = v


class KwStruct:
    def __init__(self, kw={}, **defaults):
        if isinstance(kw, KwStruct):
            kw = kw.__dict__
        if isinstance(defaults, KwStruct):
            defaults = defaults.__dict__
        if defaults:
            kw = kw.copy()
            for k, v in defaults.items():
                if k not in kw:
                    kw[k] = v
        self.__dict__.update(kw)

    def __setattr__(self, key, value):
        if key not in self.__dict__:
            raise AttributeError(key)
        self.__dict__[key] = value

    def __getitem__(self, key):
        return getattr(self, key)

    def get(self, key, default=None):
        return self.__dict__.get(key, default)

    def getKw(self):
        return self.__dict__


# ************************************************************************
# * pickling support
# ************************************************************************

def pickle(obj, filename, protocol=0):
    f = None
    try:
        f = open(filename, "wb")
        Pickler(f, protocol).dump(obj)
        f.close()
        f = None
        # print "Pickled", filename
    finally:
        if f:
            f.close()


def unpickle(filename):
    f, obj = None, None
    try:
        f = open(filename, "rb")
        x = Unpickler(f).load()
        f.close()
        f = None
        obj = x
        # print "Unpickled", filename
    finally:
        if f:
            f.close()
    return obj


# ************************************************************************
# *
# ************************************************************************

def openURL(url):
    try:
        webbrowser.open(url)
    except OSError:                  # raised on windows if link is unreadable
        pass
    except Exception:
        return False
    return True
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import glob
import os
import traceback

from pysollib.mfxutil import KwStruct, Struct
from pysollib.mygettext import _
from pysollib.settings import DEBUG

import six

# ************************************************************************
# * Abstract
# ************************************************************************


class Resource(Struct):
    def __init__(self, **kw):
        kw = KwStruct(
            kw,
            name="",
            filename="",
            basename="",      # basename of filename
            absname="",       # absolute filename
            # implicit
            index=-1,
            error=0,          # error while loading this resource
        )
        Struct.__init__(self, **kw.getKw())

    def getSortKey(self):
        return self.name.lower()


class ResourceManager:
    def __init__(self):
        self._selected_key = -1
        self._objects = []
        self._objects_by_name = None
        self._objects_cache_name = {}
        self._objects_cache_filename = {}
        self._objects_cache_basename = {}
        self._objects_cache_absname = {}

    def getSelected(self):
        return self._selected_key

    def setSelected(self, index):
        assert -1 <= index < len(self._objects)
        self._selected_key = index

    def len(self):
        return len(self._objects)

    def register(self, obj):
        assert obj.index == -1
        assert obj.name and obj.name not in self._objects_cache_name
        self._objects_cache_name[obj.name] = obj
        if obj.filename:
            obj.absname = os.path.abspath(obj.filename)
            obj.basename = os.path.basename(obj.filename)
            self._objects_cache_filename[obj.filename] = obj
            self._objects_cache_basename[obj.basename] = obj
            self._objects_cache_absname[obj.absname] = obj
        obj.index = len(self._objects)
        self._objects.append(obj)
        self._objects_by_name = None    # invalidate

    def get(self, index):
        if 0 <= index < len(self._objects):
            return self._objects[index]
        return None

    def getByName(self, key):
        return self._objects_cache_name.get(key)

    def getByBasename(self, key):
        return self._objects_cache_basename.get(key)

    def getAll(self):
        return tuple(self._objects)

    def getAllSortedByName(self):
        if self._objects_by_name is None:
            lst = [(obj.getSortKey(), obj) for obj in self._objects]
            lst.sort()
            self._objects_by_name = tuple([item[1] for item in lst])
        return self._objects_by_name

    #
    # static methods
    #

    def _addDir(self, result, dir):
        try:
            if dir:
                dir = os.path.normpath(dir)
                if dir and os.path.isdir(dir) and dir not in result:
                    result.append(dir)
        except EnvironmentError:
            pass

    def getSearchDirs(self, app, search, env=None):
        if isinstance(search, str):
            search = (search,)
        result = []
        if env:
            for d in os.environ.get(env, "").split(os.pathsep):
                self._addDir(result, d.strip())
        for dir in (app.dataloader.dir, app.dn.maint, app.dn.config):
            if not dir:
                continue
            dir = os.path.normpath(dir)
            if not dir or not os.path.isdir(dir):
                continue
            for s in search:
                try:
                    if s[-2:] == "-*":
                        d = os.path.normpath(os.path.join(dir, s[:-2]))
                        self._addDir(result, d)
                        globdirs = glob.glob(d + "-*")
                        globdirs.sort()
                        for d in globdirs:
                            self._addDir(result, d)
                    else:
                        self._addDir(result, os.path.join(dir, s))
                except EnvironmentError:
                    traceback.print_exc()
                    pass
        if DEBUG >= 6:
            print("getSearchDirs", env, search, "->", result)
        return result


# ************************************************************************
# * Cardset
# ************************************************************************

# CardsetInfo constants
class CSI:
    # cardset size
    SIZE_TINY = 1
    SIZE_SMALL = 2
    SIZE_MEDIUM = 3
    SIZE_LARGE = 4
    SIZE_XLARGE = 5

    # cardset types
    TYPE_FRENCH = 1
    TYPE_HANAFUDA = 2
    TYPE_TAROCK = 3
    TYPE_MAHJONGG = 4
    TYPE_HEXADECK = 5
    TYPE_MUGHAL_GANJIFA = 6
    TYPE_NAVAGRAHA_GANJIFA = 7
    TYPE_DASHAVATARA_GANJIFA = 8
    TYPE_TRUMP_ONLY = 9

    TYPE = {
        1:  _("French type (52 cards)"),
        2:  _("Hanafuda type (48 cards)"),
        3:  _("Tarock type (78 cards)"),
        4:  _("Mahjongg type (42 tiles)"),
        5:  _("Hex A Deck type (68 cards)"),
        6:  _("Mughal Ganjifa type (96 cards)"),
        7:  _("Navagraha Ganjifa type (108 cards)"),
        8:  _("Dashavatara Ganjifa type (120 cards)"),
        9:  _("Trumps only type (variable cards)"),
    }

    TYPE_NAME = {
        1:  _("French"),
        2:  _("Hanafuda"),
        3:  _("Tarock"),
        4:  _("Mahjongg"),
        5:  _("Hex A Deck"),
        6:  _("Mughal Ganjifa"),
        7:  _("Navagraha Ganjifa"),
        8:  _("Dashavatara Ganjifa"),
        9:  _("Trumps only"),
    }

    TYPE_ID = {
        1: "french",
        2: "hanafuda",
        3: "tarock",
        4: "mahjongg",
        5: "hex-a-deck",
        6: "mughal-ganjifa",
        7: "navagraha-ganjifa",
        8: "dashavatara-ganjifa",
        9: "trumps-only",
    }

    # cardset styles
    STYLE = {
        1:  _("Adult"),                #
        2:  _("Animals"),              #
        3:  _("Anime"),                #
        4:  _("Art"),                  #
        5:  _("Cartoons"),             #
        6:  _("Children"),             #
        7:  _("Classic look"),         #
        8:  _("Collectors"),           # scanned collectors cardsets
        9:  _("Computers"),            #
        10:  _("Engines"),              #
        11:  _("Fantasy"),              #
        30:  _("Ganjifa"),              #
        12:  _("Hanafuda"),             #
        29:  _("Hex A Deck"),           #
        13:  _("Holiday"),              #
        28:  _("Mahjongg"),             #
        14:  _("Movies"),               #
        31:  _("Matrix"),               #
        15:  _("Music"),                #
        16:  _("Nature"),               #
        17:  _("Operating Systems"),    # e.g. cards with Linux logos
        19:  _("People"),               # famous people
        20:  _("Places"),               #
        21:  _("Plain"),                #
        22:  _("Products"),             #
        18:  _("Round cardsets"),       #
        23:  _("Science Fiction"),      #
        24:  _("Sports"),               #
        27:  _("Tarock"),               #
        25:  _("Vehicels"),             #
        26:  _("Video Games"),          #
    }

    # cardset nationality (suit and rank symbols)
    NATIONALITY = {
        1021:  _("Australia"),         #
        1001:  _("Austria"),           #
        1019:  _("Belgium"),           #
        1010:  _("Canada"),            #
        1011:  _("China"),             #
        1012:  _("Czech Republic"),    #
        1013:  _("Denmark"),           #
        1003:  _("England"),           #
        1004:  _("France"),            #
        1006:  _("Germany"),           #
        1014:  _("Great Britain"),     #
        1015:  _("Hungary"),           #
        1020:  _("India"),             #
        1005:  _("Italy"),             #
        1016:  _("Japan"),             #
        1002:  _("Netherlands"),       #
        1007:  _("Russia"),            #
        1008:  _("Spain"),             #
        1017:  _("Sweden"),            #
        1009:  _("Switzerland"),       #
        1018:  _("USA"),               #
    }

    # cardset creation date
    DATE = {
        10:  "1000 - 1099",
        11:  "1100 - 1199",
        12:  "1200 - 1299",
        13:  "1300 - 1399",
        14:  "1400 - 1499",
        15:  "1500 - 1599",
        16:  "1600 - 1699",
        17:  "1700 - 1799",
        18:  "1800 - 1899",
        19:  "1900 - 1999",
        20:  "2000 - 2099",
        21:  "2100 - 2199",
        22:  "2200 - 2299",
    }


class CardsetConfig(Struct):
    # see config.txt and _readCardsetConfig()
    def __init__(self):
        Struct.__init__(
            self,
            # line[0]
            version=1,
            ext=".gif",
            type=CSI.TYPE_FRENCH,
            ncards=-1,
            styles=[],
            year=0,
            # line[1]
            ident="",
            name="",
            # line[2]
            CARDW=0,
            CARDH=0,
            CARDD=0,
            # line[3]
            CARD_XOFFSET=0,
            CARD_YOFFSET=0,
            SHADOW_XOFFSET=0,
            SHADOW_YOFFSET=0,
            # line[4]
            backindex=0,
            # line[5]
            backnames=(),
            # other
            CARD_DX=0,        # relative pos of real card image within Card
            CARD_DY=0,
        )


class Cardset(Resource):
    def __init__(self, **kw):
        # start with all fields from CardsetConfig
        config = CardsetConfig()
        kw = KwStruct(config.__dict__, **kw)
        # si is the SelectionInfo struct that will be queried by
        # the "select cardset" dialogs. It can be freely modified.
        si = Struct(type=0, size=0, styles=[], nationalities=[], dates=[])
        kw = KwStruct(
            kw,
            # essentials
            ranks=(),
            suits=(),
            trumps=(),
            nbottoms=7,
            nletters=4,
            nshadows=1 + 13,
            # selection criteria
            si=si,
            # implicit
            backname=None,
            dir="",
        )
        Resource.__init__(self, **kw.getKw())

    def getFaceCardNames(self):
        names = []
        for suit in self.suits:
            for rank in self.ranks:
                names.append("%02d%s" % (rank + 1, suit))
        for trump in self.trumps:
            names.append("%02d%s" % (trump + 1, "z"))
        assert len(names) == self.ncards
        return names

    def getPreviewCardNames(self):
        names = self.getFaceCardNames()
        pnames = []
        ranks, suits = self.ranks, self.suits
        lr, ls = len(ranks), len(suits)
        if lr == 0 or ls == 0:     # TYPE_TRUMP_ONLY
            return names[:16], 4
        if lr >= 4:
            ls = min(ls, 4)
        low_ranks, high_ranks = 1, 3
        # if self.type == 3: high_ranks = 4
        for rank in list(range(0, low_ranks)) + list(range(lr-high_ranks, lr)):
            for suit in range(ls):
                index = suit * len(self.ranks) + rank
                pnames.append(names[index % len(names)])
        return pnames, ls

    def updateCardback(self, backname=None, backindex=None):
        # update default back
        if isinstance(backname, six.string_types):
            if backname in self.backnames:
                backindex = self.backnames.index(backname)
        if isinstance(backindex, int):
            self.backindex = backindex % len(self.backnames)
        self.backname = self.backnames[self.backindex]

    def saveSettings(self):
        print('saveSettings')


class CardsetManager(ResourceManager):
    def __init__(self):
        ResourceManager.__init__(self)
        self.registered_types = {}
        self.registered_sizes = {}
        self.registered_styles = {}
        self.registered_nationalities = {}
        self.registered_dates = {}

    def _check(self, cs):
        s = cs.type
        if s not in CSI.TYPE:
            return 0
        cs.si.type = s
        if s == CSI.TYPE_FRENCH:
            cs.ranks = list(range(13))
            cs.suits = "cshd"
        elif s == CSI.TYPE_HANAFUDA:
            cs.nbottoms = 15
            cs.ranks = list(range(4))
            cs.suits = "abcdefghijkl"
        elif s == CSI.TYPE_TAROCK:
            cs.nbottoms = 8
            cs.ranks = list(range(14))
            cs.suits = "cshd"
            cs.trumps = list(range(22))
        elif s == CSI.TYPE_MAHJONGG:
            cs.ranks = list(range(10))
            cs.suits = "abc"
            cs.trumps = list(range(12))
            #
            cs.nbottoms = 0
            cs.nletters = 0
            cs.nshadows = 0
        elif s == CSI.TYPE_HEXADECK:
            cs.nbottoms = 8
            cs.ranks = list(range(16))
            cs.suits = "cshd"
            cs.trumps = list(range(4))
        elif s == CSI.TYPE_MUGHAL_GANJIFA:
            cs.nbottoms = 11
            cs.ranks = list(range(12))
            cs.suits = "abcdefgh"
        elif s == CSI.TYPE_NAVAGRAHA_GANJIFA:
            # ???return 0                            ## FIXME
            cs.nbottoms = 12
            cs.ranks = list(range(12))
            cs.suits = "abcdefghi"
        elif s == CSI.TYPE_DASHAVATARA_GANJIFA:
            cs.nbottoms = 13
            cs.ranks = list(range(12))
            cs.suits = "abcdefghij"
        elif s == CSI.TYPE_TRUMP_ONLY:
            # ???return 0                            ## FIXME
            # cs.nbottoms = 7
            # cs.ranks = ()
            # cs.suits = ""
            # cs.trumps = range(cs.ncards)
            cs.nbottoms = 1
            cs.nletters = 0
            cs.nshadows = 0
            cs.ranks = ()
            cs.suits = ""
            cs.trumps = list(range(cs.ncards))

        else:
            return 0
        return 1

    def register(self, cs):
        if not self._check(cs):
            return
        cs.ncards = len(cs.ranks) * len(cs.suits) + len(cs.trumps)
        cs.name = cs.name[:25]
        if not (1 <= cs.si.size <= 5):
            CW, CH = cs.CARDW, cs.CARDH
            if CW <= 55 and CH <= 72:
                cs.si.size = CSI.SIZE_TINY
            elif CW <= 60 and CH <= 85:
                cs.si.size = CSI.SIZE_SMALL
            elif CW <= 75 and CH <= 105:
                cs.si.size = CSI.SIZE_MEDIUM
            elif CW <= 90 and CH <= 125:
                cs.si.size = CSI.SIZE_LARGE
            else:
                cs.si.size = CSI.SIZE_XLARGE
        #
        keys = cs.styles[:]
        cs.si.styles = tuple([s for s in keys if s in CSI.STYLE])
        for s in cs.si.styles:
            self.registered_styles[s] = self.registered_styles.get(s, 0) + 1
        cs.si.nationalities = tuple([s for s in keys if s in CSI.NATIONALITY])
        for s in cs.si.nationalities:
            self.registered_nationalities[s] = \
                self.registered_nationalities.get(s, 0) + 1
        keys = (cs.year // 100,)
        cs.si.dates = tuple([s for s in keys if s in CSI.DATE])
        for s in cs.si.dates:
            self.registered_dates[s] = self.registered_dates.get(s, 0) + 1
        #
        s = cs.si.type
        self.registered_types[s] = self.registered_types.get(s, 0) + 1
        s = cs.si.size
        self.registered_sizes[s] = self.registered_sizes.get(s, 0) + 1
        cs.updateCardback()
        ResourceManager.register(self, cs)


# ************************************************************************
# * Tile
# ************************************************************************

class Tile(Resource):
    def __init__(self, **kw):
        kw['color'] = None
        kw['stretch'] = 0
        kw['save_aspect'] = 0
        Resource.__init__(self, **kw)


class TileManager(ResourceManager):
    pass


# ************************************************************************
# * Sample
# ************************************************************************

class Sample(Resource):
    def __init__(self, **kw):
        kw['volume'] = -1
        Resource.__init__(self, **kw)


class SampleManager(ResourceManager):
    pass


# ************************************************************************
# * Music
# ************************************************************************

class Music(Sample):
    pass


class MusicManager(SampleManager):
    pass
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

from pysollib.mfxutil import Struct
from pysollib.settings import TOP_SIZE


class GameStatResult:
    def __init__(self):
        self.min = 0
        self.max = 0
        self.top = []
        self.num = 0
        self.total = 0  # sum of all values
        self.average = 0

    def update(self, gameid, value, game_number, game_start_time):
        # update min & max
        if not self.min or value < self.min:
            self.min = value
        if not self.max or value > self.max:
            self.max = value
        # calculate position & update top
        position = None
        n = 0
        for i in self.top:
            if value < i.value:
                position = n+1
                v = Struct(gameid=gameid,
                           value=value,
                           game_number=game_number,
                           game_start_time=game_start_time)
                self.top.insert(n, v)
                del self.top[TOP_SIZE:]
                break
            n += 1
        if not position and len(self.top) < TOP_SIZE:
            v = Struct(gameid=gameid,
                       value=value,
                       game_number=game_number,
                       game_start_time=game_start_time)
            self.top.append(v)
            position = len(self.top)
        # update average
        self.total += value
        self.num += 1
        self.average = float(self.total)/self.num
        return position
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.mfxutil import Image, ImageTk, USE_PIL
from pysollib.mfxutil import Struct, SubclassResponsibility, kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import ANCHOR_NW, ANCHOR_SE
from pysollib.pysoltk import CURSOR_DOWN_ARROW, CURSOR_DRAG
from pysollib.pysoltk import EVENT_HANDLED, EVENT_PROPAGATE
from pysollib.pysoltk import MfxCanvasGroup, MfxCanvasImage
from pysollib.pysoltk import MfxCanvasRectangle, MfxCanvasText
from pysollib.pysoltk import after_cancel, after_idle
from pysollib.pysoltk import bind, unbind_destroy
from pysollib.pysoltk import get_text_width
from pysollib.pysoltk import markImage
from pysollib.settings import DEBUG
from pysollib.settings import TOOLKIT
from pysollib.util import ACE, KING
from pysollib.util import ANY_RANK, ANY_SUIT, NO_RANK

# ************************************************************************
# * Let's start with some test methods for cards.
# * Empty card-lists return false.
# ************************************************************************


# check that all cards are face-up
def cardsFaceUp(cards):
    if not cards:
        return False
    for c in cards:
        if not c.face_up:
            return False
    return True


# check that all cards are face-down
def cardsFaceDown(cards):
    if not cards:
        return False
    for c in cards:
        if c.face_up:
            return False
    return True


# check that cards are face-up and build down by rank
def isRankSequence(cards, mod=8192, dir=-1):
    if not cardsFaceUp(cards):
        return False
    c1 = cards[0]
    for c2 in cards[1:]:
        if (c1.rank + dir) % mod != c2.rank:
            return False
        c1 = c2
    return True


# check that cards are face-up and build down by alternate color
def isAlternateColorSequence(cards, mod=8192, dir=-1):
    if not cardsFaceUp(cards):
        return False
    c1 = cards[0]
    for c2 in cards[1:]:
        if (c1.rank + dir) % mod != c2.rank or c1.color == c2.color:
            return False
        c1 = c2
    return True


# check that cards are face-up and build down by same color
def isSameColorSequence(cards, mod=8192, dir=-1):
    if not cardsFaceUp(cards):
        return False
    c1 = cards[0]
    for c2 in cards[1:]:
        if (c1.rank + dir) % mod != c2.rank or c1.color != c2.color:
            return False
        c1 = c2
    return True


# check that cards are face-up and build down by same suit
def isSameSuitSequence(cards, mod=8192, dir=-1):
    if not cardsFaceUp(cards):
        return False
    c1 = cards[0]
    for c2 in cards[1:]:
        if (c1.rank + dir) % mod != c2.rank or c1.suit != c2.suit:
            return False
        c1 = c2
    return True


# check that cards are face-up and build down by any suit but own
def isAnySuitButOwnSequence(cards, mod=8192, dir=-1):
    if not cardsFaceUp(cards):
        return False
    c1 = cards[0]
    for c2 in cards[1:]:
        if (c1.rank + dir) % mod != c2.rank or c1.suit == c2.suit:
            return False
        c1 = c2
    return True


def getNumberOfFreeStacks(stacks):
    return len([s for s in stacks if not s.cards])


# collect the top cards of several stacks into a pile
def getPileFromStacks(stacks, reverse=False):
    cards = []
    for s in stacks:
        if not s.cards or not s.cards[-1].face_up:
            return None
        cards.append(s.cards[-1])
    return (reversed(cards) if reverse else cards)


class Stack:
    # A generic stack of cards.
    #
    # This is used as a base class for all other stacks (e.g. the talon,
    # the foundations and the row stacks).
    #
    # The default event handlers turn the top card of the stack with
    # its face up on a (single or double) click, and also support
    # moving a subpile around.

    # constants
    MIN_VISIBLE_XOFFSET = 3
    MIN_VISIBLE_YOFFSET = 3
    SHRINK_FACTOR = 2.

    def __init__(self, x, y, game, cap={}):
        # Arguments are the stack's nominal x and y position (the top
        # left corner of the first card placed in the stack), and the
        # game object (which is used to get the canvas; subclasses use
        # the game object to find other stacks).

        #
        # link back to game
        #
        id = len(game.allstacks)
        game.allstacks.append(self)
        x = int(round(x))
        y = int(round(y))
        mapkey = (x, y)
        # assert not game.stackmap.has_key(mapkey) ## can happen in PyJonngg
        game.stackmap[mapkey] = id

        #
        # setup our pseudo MVC scheme
        #
        model, view = self, self

        #
        # model
        #
        model.id = id
        model.game = game
        model.cards = []
        #
        model.is_filled = False

        # capabilites - the game logic
        model.cap = Struct(
            suit=-1,          # required suit for this stack (-1 is ANY_SUIT)
            color=-1,         # required color for this stack (-1 is ANY_COLOR)
            rank=-1,          # required rank for this stack (-1 is ANY_RANK)
            base_suit=-1,     # base suit for this stack (-1 is ANY_SUIT)
            base_color=-1,    # base color for this stack (-1 is ANY_COLOR)
            base_rank=-1,     # base rank for this stack (-1 is ANY_RANK)
            dir=0,            # direction - stack builds up/down
            mod=8192,         # modulo for wrap around (typically 13 or 8192)
            max_move=0,       # can move at most # cards at a time
            max_accept=0,     # can accept at most # cards at a time
            max_cards=999999,  # total number of cards may not exceed this
            # not commonly used:
            min_move=1,       # must move at least # cards at a time
            min_accept=1,     # must accept at least # cards at a time
            # total number of cards this stack at least requires
            min_cards=0,
        )
        model.cap.update(cap)
        assert isinstance(model.cap.suit, int)
        assert isinstance(model.cap.color, int)
        assert isinstance(model.cap.rank, int)
        assert isinstance(model.cap.base_suit, int)
        assert isinstance(model.cap.base_color, int)
        assert isinstance(model.cap.base_rank, int)
        #
        # view
        #
        self.init_coord = (x, y)
        view.x = x
        view.y = y
        view.canvas = game.canvas
        view.CARD_XOFFSET = 0
        view.CARD_YOFFSET = 0
        view.INIT_CARD_OFFSETS = (0, 0)
        view.INIT_CARD_YOFFSET = 0      # for reallocateCards
        view.group = MfxCanvasGroup(view.canvas)

        if (TOOLKIT == 'kivy'):
            if hasattr(view.group, 'stack'):
                view.group.stack = self

        view.shrink_face_down = 1
        # image items
        view.images = Struct(
            bottom=None,              # canvas item
            redeal=None,              # canvas item
            redeal_img=None,          # the corresponding PhotoImage
            shade_img=None,
        )
        # other canvas items
        view.items = Struct(
            bottom=None,              # dummy canvas item
            shade_item=None,
        )
        # text items
        view.texts = Struct(
            ncards=None,              # canvas item
            # by default only used by Talon:
            rounds=None,              # canvas item
            redeal=None,              # canvas item
            redeal_str=None,          # the corresponding string
            # for use by derived stacks:
            misc=None,                # canvas item
        )
        view.top_bottom = None          # the highest of all bottom items
        cardw, cardh = game.app.images.CARDW, game.app.images.CARDH
        dx, dy = cardw+view.canvas.xmargin, cardh+view.canvas.ymargin
        view.is_visible = view.x >= -dx and view.y >= -dy
        view.is_open = -1
        view.can_hide_cards = -1
        view.max_shadow_cards = -1
        view.current_cursor = ''
        view.cursor_changed = False

    def destruct(self):
        # help breaking circular references
        unbind_destroy(self.group)

    def prepareStack(self):
        self.prepareView()
        if self.is_visible:
            self.initBindings()

    # bindings {view widgets bind to controller}
    def initBindings(self):
        group = self.group
        bind(group, "<1>", self.__clickEventHandler)
        # bind(group, "<B1-Motion>", self.__motionEventHandler)
        bind(group, "<Motion>", self.__motionEventHandler)
        bind(group, "<ButtonRelease-1>", self.__releaseEventHandler)
        bind(group, "<Control-1>", self.__controlclickEventHandler)
        bind(group, "<Shift-1>", self.__shiftclickEventHandler)
        bind(group, "<Double-1>", self.__doubleclickEventHandler)
        bind(group, "<3>", self.__rightclickEventHandler)
        bind(group, "<2>", self.__middleclickEventHandler)
        bind(group, "<Control-3>", self.__middleclickEventHandler)
        # bind(group, "<Control-2>", self.__controlmiddleclickEventHandler)
        # bind(group, "<Shift-3>", self.__shiftrightclickEventHandler)
        # bind(group, "<Double-2>", "")
        bind(group, "<Enter>", self.__enterEventHandler)
        bind(group, "<Leave>", self.__leaveEventHandler)

    def prepareView(self):
        # assertView(self)
        if (self.CARD_XOFFSET == 0 and self.CARD_YOFFSET == 0):
            assert self.cap.max_move <= 1
        # prepare some variables
        ox, oy = self.CARD_XOFFSET, self.CARD_YOFFSET
        if isinstance(ox, (int, float)):
            self.CARD_XOFFSET = (ox,)
        else:
            self.CARD_XOFFSET = tuple([int(round(x)) for x in ox])
        if isinstance(oy, (int, float)):
            self.CARD_YOFFSET = (oy,)
        else:
            self.CARD_YOFFSET = tuple([int(round(y)) for y in oy])

        # preserve offsets
        # for resize()
        self.INIT_CARD_OFFSETS = (self.CARD_XOFFSET, self.CARD_YOFFSET)
        self.INIT_CARD_YOFFSET = self.CARD_YOFFSET  # for reallocateCards

        if self.can_hide_cards < 0:
            self.can_hide_cards = self.is_visible
            if self.cap.max_cards < 3:
                self.can_hide_cards = 0
            elif [_f for _f in self.CARD_XOFFSET if _f]:
                self.can_hide_cards = 0
            elif [_f for _f in self.CARD_YOFFSET if _f]:
                self.can_hide_cards = 0
            elif self.canvas.preview:
                self.can_hide_cards = 0
        if self.is_open < 0:
            self.is_open = False
            if (self.is_visible and
                (abs(self.CARD_XOFFSET[0]) >= self.MIN_VISIBLE_XOFFSET or
                 abs(self.CARD_YOFFSET[0]) >= self.MIN_VISIBLE_YOFFSET)):
                self.is_open = True
        if self.max_shadow_cards < 0:
            self.max_shadow_cards = 999999
            # if abs(self.CARD_YOFFSET[0])
            #     != self.game.app.images.CARD_YOFFSET:
            #           # don't display a shadow if the YOFFSET of the stack
            #           # and the images don't match
            #      self.max_shadow_cards = 1
        if (self.game.app.opt.shrink_face_down and
                isinstance(ox, (int, float)) and
                isinstance(oy, (int, float))):
            # no shrink if xoffset/yoffset too small
            f = self.SHRINK_FACTOR
            if ((ox == 0 and oy >= self.game.app.images.CARD_YOFFSET//f) or
                    (oy == 0 and
                     ox >= self.game.app.images.CARD_XOFFSET//f)):
                self.shrink_face_down = f
        # bottom image
        if self.is_visible:
            self.prepareBottom()

    # stack bottom image
    def prepareBottom(self):
        assert self.is_visible and self.images.bottom is None
        img = self.getBottomImage()
        if img is not None:
            self.images.bottom = MfxCanvasImage(self.canvas, self.x, self.y,
                                                image=img, anchor=ANCHOR_NW,
                                                group=self.group)
            self.top_bottom = self.images.bottom

    # invisible stack bottom
    # We need this if we want to get any events for an empty stack (which
    # is needed by the quickPlayHandler in some games like Montana)
    def prepareInvisibleBottom(self):
        assert self.is_visible and self.items.bottom is None
        images = self.game.app.images
        self.items.bottom = MfxCanvasRectangle(self.canvas, self.x, self.y,
                                               self.x + images.CARDW,
                                               self.y + images.CARDH,
                                               fill="", outline="", width=0,
                                               group=self.group)
        self.top_bottom = self.items.bottom

    # sanity checks
    def assertStack(self):
        assert self.cap.min_move > 0
        assert self.cap.min_accept > 0
        assert not hasattr(self, "suit")

    #
    # Core access methods {model -> view}
    #

    # Add a card add the top of a stack. Also update display. {model -> view}
    def addCard(self, card, unhide=1, update=1):
        model, view = self, self
        model.cards.append(card)
        card.tkraise(unhide=unhide)
        if view.can_hide_cards and len(model.cards) >= 3:
            # we only need to display the 2 top cards
            model.cards[-3].hide(self)
        card.item.addtag(view.group)
        view._position(card)
        if update:
            view.updateText()
        self.closeStack()
        return card

    def insertCard(self, card, position, unhide=1, update=1):
        model, view = self, self
        model.cards.insert(position, card)
        for c in model.cards[position:]:
            c.tkraise(unhide=unhide)
        if (view.can_hide_cards and len(model.cards) >= 3 and
                len(model.cards)-position <= 2):
            # we only need to display the 2 top cards
            model.cards[-3].hide(self)
        card.item.addtag(view.group)
        for c in model.cards[position:]:
            view._position(c)
        if update:
            view.updateText()
        self.closeStack()
        return card

    # Remove a card from the stack. Also update display. {model -> view}
    def removeCard(self, card=None, unhide=1, update=1, update_positions=0):
        model, view = self, self
        assert len(model.cards) > 0
        if card is None:
            card = model.cards[-1]
            # optimized a little bit (compare with the else below)
            card.item.dtag(view.group)
            if unhide and self.can_hide_cards:
                card.unhide()
                if len(self.cards) >= 3:
                    model.cards[-3].unhide()
            del model.cards[-1]
        else:
            card.item.dtag(view.group)
            if unhide and view.can_hide_cards:
                # Note: the 2 top cards ([-1] and [-2]) are already unhidden.
                card.unhide()
                if len(model.cards) >= 3:
                    if card is model.cards[-1] or model is self.cards[-2]:
                        # Make sure that 2 top cards will be un-hidden.
                        model.cards[-3].unhide()
            card_index = model.cards.index(card)
            model.cards.remove(card)
            if update_positions:
                for c in model.cards[card_index:]:
                    view._position(c)

        if update:
            view.updateText()
        self.unshadeStack()
        self.is_filled = False
        return card

    # Get the top card {model}
    def getCard(self):
        if self.cards:
            return self.cards[-1]
        return None

    # get the largest moveable pile {model} - uses canMoveCards()
    def getPile(self):
        if self.cap.max_move > 0:
            cards = self.cards[-self.cap.max_move:]
            while len(cards) >= self.cap.min_move:
                if self.canMoveCards(cards):
                    return cards
                del cards[0]
        return None

    # Position the card on the canvas {view}
    def _position(self, card):
        x, y = self.getPositionFor(card)
        card.moveTo(x, y)

    # find card
    def _findCard(self, event):
        model, view = self, self
        if event is not None and model.cards:
            # ask the canvas
            return view.canvas.findCard(self, event)
        return -1

    # find card
    def _findCardXY(self, x, y, cards=None):
        model = self
        if cards is None:
            cards = model.cards
        images = self.game.app.images
        cw, ch = images.getSize()
        index = -1
        for i in range(len(cards)):
            c = cards[i]
            r = (c.x, c.y, c.x + cw, c.y + ch)
            if r[0] <= x < r[2] and r[1] <= y < r[3]:
                index = i
        return index

    # generic model update (can be used for undo/redo - see move.py)
    def updateModel(self, undo, flags):
        pass

    # copy model data - see Hint.AClonedStack
    def copyModel(self, clone):
        clone.id = self.id
        clone.game = self.game
        clone.cap = self.cap

    def getRankDir(self, cards=None):
        if cards is None:
            cards = self.cards[-2:]
        if len(cards) < 2:
            return 0
        dir = (cards[-1].rank - cards[-2].rank) % self.cap.mod
        if dir > self.cap.mod // 2:
            return dir - self.cap.mod
        return dir

    #
    # Basic capabilities {model}
    # Used by various subclasses.
    #

    def basicIsBlocked(self):
        # Check if the stack is blocked (e.g. Pyramid or Mahjongg)
        return False

    def basicAcceptsCards(self, from_stack, cards):
        # Check that the limits are ok and that the cards are face up
        if from_stack is self or self.basicIsBlocked():
            return False
        cap = self.cap
        mylen = len(cards)
        if mylen < cap.min_accept or mylen > cap.max_accept:
            return False
        mylen += len(self.cards)
        # note: we don't check cap.min_cards here
        if mylen > cap.max_cards:
            return False

        def _check(c, suit, color, rank):
            return ((suit >= 0 and c.suit != suit) or
                    (color >= 0 and c.color != color) or
                    (rank >= 0 and c.rank != rank))
        for c in cards:
            if not c.face_up or _check(c, cap.suit, cap.color, cap.rank):
                return False
        if self.cards:
            # top card of our stack must be face up
            return self.cards[-1].face_up
        # check required base
        return not _check(cards[0], cap.base_suit, cap.base_color,
                          cap.base_rank)

    def basicCanMoveCards(self, cards):
        # Check that the limits are ok and the cards are face up
        if self.basicIsBlocked():
            return False
        cap = self.cap
        mylen = len(cards)
        if mylen < cap.min_move or mylen > cap.max_move:
            return False
        mylen = len(self.cards) - mylen
        # note: we don't check cap.max_cards here
        if mylen < cap.min_cards:
            return False
        return cardsFaceUp(cards)

    #
    # Capabilities - important for game logic {model}
    #

    def acceptsCards(self, from_stack, cards):
        # Do we accept receiving `cards' from `from_stack' ?
        return False

    def canMoveCards(self, cards):
        # Can we move these cards when assuming they are our top-cards ?
        return False

    def canFlipCard(self):
        # Can we flip our top card ?
        return False

    def canDropCards(self, stacks):
        # Can we drop the top cards onto one of the foundation stacks ?
        return (None, 0)    # return the stack and the number of cards

    #
    # State {model}
    #

    def resetGame(self):
        # Called when starting a new game.
        self.CARD_YOFFSET = self.INIT_CARD_YOFFSET
        self.items.shade_item = None
        self.images.shade_img = None
        # self.items.bottom = None
        # self.images.bottom = None

    def __repr__(self):
        # Return a string for debug print statements.
        return "%s(%d)" % (self.__class__.__name__, self.id)

    #
    # Atomic move actions {model -> view}
    #

    def flipMove(self, animation=False):
        # Flip the top card.
        if animation:
            self.game.singleFlipMove(self)
        else:
            self.game.flipMove(self)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        # Move the top n cards.
        self.game.moveMove(
            ncards, self, to_stack, frames=frames, shadow=shadow)
        self.fillStack()

    def fillStack(self):
        self.game.fillStack(self)

    def closeStack(self):
        pass

    #
    # Playing move actions. Better not override.
    #

    def playFlipMove(self, sound=True, animation=False):
        if sound:
            self.game.playSample("flip", 5)
        self.flipMove(animation=animation)
        if not self.game.checkForWin():
            self.game.autoPlay()
        self.game.finishMove()

    def playMoveMove(self, ncards, to_stack, frames=-1, shadow=-1, sound=True):
        if sound:
            if to_stack in self.game.s.foundations:
                self.game.playSample("drop", priority=30)
            else:
                self.game.playSample("move", priority=10)
        self.moveMove(ncards, to_stack, frames=frames, shadow=shadow)
        if not self.game.checkForWin():
            # let the player put cards back from the foundations
            if self not in self.game.s.foundations:
                self.game.autoPlay()
        self.game.finishMove()

    #
    # Appearance {view}
    #

    def _getBlankBottomImage(self):
        return self.game.app.images.getBlankBottom()

    def _getReserveBottomImage(self):
        return self.game.app.images.getReserveBottom()

    def _getSuitBottomImage(self):
        return self.game.app.images.getSuitBottom(self.cap.base_suit)

    def _getNoneBottomImage(self):
        return None

    def _getTalonBottomImage(self):
        return self.game.app.images.getTalonBottom()

    def _getBraidBottomImage(self):
        return self.game.app.images.getBraidBottom()

    def _getLetterImage(self):
        return self.game.app.images.getLetter(self.cap.base_rank)

    getBottomImage = _getBlankBottomImage

    def getPositionFor(self, card):
        model, view = self, self
        x, y = view.x, view.y
        if view.can_hide_cards:
            return x, y
        ix, iy, lx, ly = 0, 0, len(view.CARD_XOFFSET), len(view.CARD_YOFFSET)
        d = self.shrink_face_down
        for c in model.cards:
            if c is card:
                break
            if c.face_up:
                x += self.CARD_XOFFSET[ix]
                y += self.CARD_YOFFSET[iy]
            else:
                x += self.CARD_XOFFSET[ix]//d
                y += self.CARD_YOFFSET[iy]//d
            ix = (ix + 1) % lx
            iy = (iy + 1) % ly
        return int(x), int(y)

    def getPositionForNextCard(self):
        model, view = self, self
        x, y = view.x, view.y
        if view.can_hide_cards:
            return x, y
        if not self.cards:
            return x, y
        ix, iy, lx, ly = 0, 0, len(view.CARD_XOFFSET), len(view.CARD_YOFFSET)
        d = self.shrink_face_down
        for c in model.cards:
            if c.face_up:
                x += self.CARD_XOFFSET[ix]
                y += self.CARD_YOFFSET[iy]
            else:
                x += self.CARD_XOFFSET[ix]//d
                y += self.CARD_YOFFSET[iy]//d
            ix = (ix + 1) % lx
            iy = (iy + 1) % ly
        return int(x), int(y)

    def getOffsetFor(self, card):
        model, view = self, self
        if view.can_hide_cards:
            return 0, 0
        lx, ly = len(view.CARD_XOFFSET), len(view.CARD_YOFFSET)
        i = list(model.cards).index(card)
        return view.CARD_XOFFSET[i % lx], view.CARD_YOFFSET[i % ly]

    # Fully update the view of a stack - updates
    # hiding, card positions and stacking order.
    # Avoid calling this as it is rather slow.
    def refreshView(self):
        model, view = self, self
        cards = model.cards
        if not view.is_visible or len(cards) < 2:
            return
        if view.can_hide_cards:
            # hide all lower cards
            for c in cards[:-2]:
                # print "refresh hide", c, c.hide_stack
                c.hide(self)
            # unhide the 2 top cards
            for c in cards[-2:]:
                # print "refresh unhide 1", c, c.hide_stack
                c.unhide()
                # print "refresh unhide 1", c, c.hide_stack
        # update the card postions and stacking order
        item = cards[0].item
        x, y = view.x, view.y
        ix, iy, lx, ly = 0, 0, len(view.CARD_XOFFSET), len(view.CARD_YOFFSET)
        for c in cards[1:]:
            c.item.tkraise(item)
            item = c.item
            if not view.can_hide_cards:
                d = self.shrink_face_down
                if c.face_up:
                    x += self.CARD_XOFFSET[ix]
                    y += self.CARD_YOFFSET[iy]
                else:
                    x += int(self.CARD_XOFFSET[ix]/d)
                    y += int(self.CARD_YOFFSET[iy]/d)
                ix = (ix + 1) % lx
                iy = (iy + 1) % ly
                c.moveTo(x, y)

    def updateText(self):
        if self.game.preview > 1 or self.texts.ncards is None:
            return
        t = ""
        format = "%d"
        if self.texts.ncards.text_format is not None:
            format = self.texts.ncards.text_format
            if format == "%D":
                format = ""
                if self.cards:
                    format = "%d"
        if format:
            t = format % len(self.cards)
            # if 0:
            #     visible = 0
            #     for c in self.cards:
            #         if c.isHidden():
            #             assert c.hide_stack is not None
            #         else:
            #             visible = visible + 1
            #             assert c.hide_stack is None
            #     t  = t + " (%d)" % visible
        self.texts.ncards.config(text=t)

    def updatePositions(self):
        # compact the stack when a cards goes off screen
        if self.reallocateCards():
            for c in self.cards:
                self._position(c)

    def reallocateCards(self):
        # change CARD_YOFFSET if a cards is off-screen
        # returned False if CARD_YOFFSET is not changed, otherwise True
        if not self.game.app.opt.compact_stacks:
            return False
        if TOOLKIT != 'tk':
            return False
        if self.CARD_XOFFSET != (0,):
            return False
        if len(self.CARD_YOFFSET) != 1:
            return False
        if self.CARD_YOFFSET[0] <= 0:
            return False
        if len(self.cards) <= 1:
            return False
        if not self.canvas.winfo_ismapped():
            return False
        yoffset = self.CARD_YOFFSET[0]
        # 1/2 of a card is visible
        cardh = self.game.app.images.getSize()[0] // 2
        num_face_up = len([c for c in self.cards if c.face_up])
        num_face_down = len(self.cards) - num_face_up
        stack_height = int(self.y +
                           num_face_down * yoffset // self.shrink_face_down +
                           num_face_up * yoffset +
                           cardh)
        visible_height = self.canvas.winfo_height()
        if USE_PIL and self.game.app.opt.auto_scale:
            # use visible_height only
            game_height = 0
        else:
            game_height = self.game.height + 2*self.canvas.ymargin
        height = max(visible_height, game_height)
        # print 'reallocateCards:', stack_height, height, \
        # visible_height, game_height
        if stack_height > height:
            # compact stack
            n = num_face_down // self.shrink_face_down + num_face_up
            dy = float(height - self.y - cardh) / n
            if dy < yoffset:
                # print 'compact:', dy
                self.CARD_YOFFSET = (dy,)
            return True
        elif stack_height < height:
            # expande stack
            if self.CARD_YOFFSET == self.INIT_CARD_YOFFSET:
                return False
            n = num_face_down // self.shrink_face_down + num_face_up
            dy = float(height - self.y - cardh) / n
            dy = min(dy, self.INIT_CARD_YOFFSET[0])
            # print 'expande:', dy
            self.CARD_YOFFSET = (dy,)
            return True
        return False

    def resize(self, xf, yf):
        # resize and move stack
        # xf, yf - a multiplicative factor (from the original values)
        # print 'Stack.resize:', self, self.is_visible, xf, yf
        x0, y0 = self.init_coord
        x, y = int(round(x0*xf)), int(round(y0*yf))
        self.x, self.y = x, y
        # offsets
        xoffset = tuple(int(round(i*xf)) for i in self.INIT_CARD_OFFSETS[0])
        yoffset = tuple(int(round(i*yf)) for i in self.INIT_CARD_OFFSETS[1])
        self.CARD_XOFFSET = xoffset
        self.CARD_YOFFSET = yoffset
        self.INIT_CARD_YOFFSET = yoffset
        # print '* resize offset:', self.INIT_CARD_XOFFSET,
        # move cards
        for c in self.cards:
            cx, cy = self.getPositionFor(c)
            c.moveTo(cx, cy)
        # ---
        if not self.is_visible:
            return
        # bottom and shade
        if self.images.bottom:
            img = self.getBottomImage()
            self.images.bottom['image'] = img
            self.images.bottom.moveTo(x, y)
        if self.items.bottom:
            c = self.items.bottom.coords()
            c = ((int(round(c[0]*xf)), int(round(c[1]*yf))),
                 (int(round(c[2]*xf)), int(round(c[3]*yf))))
            self.items.bottom.coords(c)
        if self.items.shade_item:
            c = self.cards[-1]
            img = self.game.app.images.getHighlightedCard(
                c.deck, c.suit, c.rank)
            if img:
                self.items.shade_item['image'] = img
            self.items.shade_item.moveTo(x, y)

        # move the items
        def move(item):
            ix, iy = item.init_coord
            x = int(round(ix*xf))
            y = int(round(iy*yf))
            item.moveTo(x, y)
        # images
        if self.images.redeal:
            move(self.images.redeal)
        # texts
        if self.texts.ncards:
            move(self.texts.ncards)
        if self.texts.rounds:
            move(self.texts.rounds)
        if self.texts.redeal:
            move(self.texts.redeal)
        if self.texts.misc:
            move(self.texts.misc)

    def basicShallHighlightSameRank(self, card):
        # by default all open stacks are available for highlighting
        assert card in self.cards
        if not self.is_visible or not card.face_up:
            return False
        if card is self.cards[-1]:
            return True
        if not self.is_open:
            return False
        # dx, dy = self.getOffsetFor(card)
        # if ((dx == 0 and dy <= self.MIN_VISIBLE_XOFFSET) or
        #     (dx <= self.MIN_VISIBLE_YOFFSET and dy == 0)):
        #     return False
        return True

    def basicShallHighlightMatch(self, card):
        # by default all open stacks are available for highlighting
        return self.basicShallHighlightSameRank(card)

    def highlightSameRank(self, event):
        i = self._findCard(event)
        if i < 0:
            return 0
        card = self.cards[i]
        if not self.basicShallHighlightSameRank(card):
            return 0
        col_1 = self.game.app.opt.colors['samerank_1']
        col_2 = self.game.app.opt.colors['samerank_2']
        info = [(self, card, card, col_1)]
        for s in self.game.allstacks:
            for c in s.cards:
                if c is card:
                    continue
                # check the rank
                if c.rank != card.rank:
                    continue
                # ask the target stack
                if s.basicShallHighlightSameRank(c):
                    info.append((s, c, c, col_2))
        self.game.stats.highlight_samerank += 1
        return self.game._highlightCards(
            info, self.game.app.opt.timeouts['highlight_samerank'])

    def highlightMatchingCards(self, event):
        i = self._findCard(event)
        if i < 0:
            return 0
        card = self.cards[i]
        if not self.basicShallHighlightMatch(card):
            return 0
        col_1 = self.game.app.opt.colors['cards_1']
        col_2 = self.game.app.opt.colors['cards_2']
        c1 = c2 = card
        info = []
        found = 0
        for s in self.game.allstacks:
            # continue if both stacks are foundations
            if (self in self.game.s.foundations and
                    s in self.game.s.foundations):
                continue
            # for all cards
            for c in s.cards:
                if c is card:
                    continue
                # ask the target stack
                if not s.basicShallHighlightMatch(c):
                    continue
                # ask the game
                if self.game.shallHighlightMatch(self, card, s, c):
                    found = 1
                    if s is self:
                        # enlarge rectangle for neighbours
                        j = self.cards.index(c)
                        if i - 1 == j:
                            c1 = c
                            continue
                        if i + 1 == j:
                            c2 = c
                            continue
                    info.append((s, c, c, col_1))
        if found:
            if info:
                self.game.stats.highlight_cards += 1
            info.append((self, c1, c2, col_2))
            return self.game._highlightCards(
                info, self.game.app.opt.timeouts['highlight_cards'])
        if not self.basicIsBlocked():
            self.game.highlightNotMatching()
        return 0

    #
    # Subclass overridable handlers {contoller -> model -> view}
    #

    def clickHandler(self, event):
        return 0

    def middleclickHandler(self, event):
        # default action: show the card if it is overlapped by other cards
        if not self.is_open:
            return 0
        i = self._findCard(event)
        positions = len(self.cards) - i - 1
        if i < 0 or positions <= 0 or not self.cards[i].face_up:
            return 0
        # print self.cards[i]
        self.cards[i].item.tkraise()
        self.canvas.update_idletasks()
        self.game.sleep(self.game.app.opt.timeouts['raise_card'])
        if TOOLKIT == 'tk':
            self.cards[i].item.lower(self.cards[i+1].item)
        elif TOOLKIT == 'gtk':
            for c in self.cards[i+1:]:
                c.tkraise()
        self.canvas.update_idletasks()
        return 1

    def controlmiddleclickHandler(self, event):
        # cheating: show face-down card
        if not self.is_open:
            return 0
        i = self._findCard(event)
        positions = len(self.cards) - i - 1
        if i < 0 or positions < 0:
            return 0
        # print self.cards[i]
        face_up = self.cards[i].face_up
        if not face_up:
            self.cards[i].showFace()
        self.cards[i].item.tkraise()
        self.canvas.update_idletasks()
        self.game.sleep(self.game.app.opt.timeouts['raise_card'])
        if not face_up:
            self.cards[i].showBack()
        if TOOLKIT == 'tk':
            if positions > 0:
                self.cards[i].item.lower(self.cards[i+1].item)
        elif TOOLKIT == 'gtk':
            for c in self.cards[i+1:]:
                c.tkraise()
        self.canvas.update_idletasks()
        return 1

    def rightclickHandler(self, event):
        return 0

    def doubleclickHandler(self, event):
        return self.clickHandler(event)

    def controlclickHandler(self, event):
        return 0

    def shiftclickHandler(self, event):
        # default action: highlight all cards of the same rank
        if self.game.app.opt.highlight_samerank:
            return self.highlightSameRank(event)
        return 0

    def shiftrightclickHandler(self, event):
        return 0

    def releaseHandler(self, event, drag, sound=True):
        # default action: move cards back to their origin position
        if drag.cards:
            if sound:
                self.game.playSample("nomove")
            if self.game.app.opt.mouse_type == 'point-n-click':
                drag.stack.moveCardsBackHandler(event, drag)
            else:
                self.moveCardsBackHandler(event, drag)

    def moveCardsBackHandler(self, event, drag):
        if self.game.app.opt.animations:
            if drag.cards:
                c = drag.cards[0]
                x0, y0 = drag.stack.getPositionFor(c)
                x1, y1 = c.x, c.y
                dx, dy = abs(x0-x1), abs(y0-y1)
                w, h = self.game.app.images.getSize()
                if dx > 2*w or dy > 2*h:
                    self.game.animatedMoveTo(drag.stack, drag.stack,
                                             drag.cards, x0, y0, frames=-1)
                elif dx > w or dy > h:
                    self.game.animatedMoveTo(drag.stack, drag.stack,
                                             drag.cards, x0, y0, frames=4)
        for card in drag.cards:
            self._position(card)
        if self.is_filled and self.items.shade_item:
            self.items.shade_item.show()
            self.items.shade_item.tkraise()

    #
    # Event handlers {controller}
    #

    def __defaultClickEventHandler(self, event, handler,
                                   start_drag=0, cancel_drag=1):
        self.game.event_handled = True  # for Game.undoHandler
        if self.game.demo:
            self.game.stopDemo(event)
            return EVENT_HANDLED
        self.game.interruptSleep()
        if self.game.busy:
            return EVENT_HANDLED
        if self.game.drag.stack and cancel_drag:
            # in case we lost an event
            self.game.drag.stack.cancelDrag(event)
        if start_drag:
            # this handler may start a drag operation
            r = handler(event)
            if r <= 0:
                sound = r == 0
                self.startDrag(event, sound=sound)
        else:
            handler(event)
        return EVENT_HANDLED

    if (TOOLKIT == 'kivy'):
        def _motionEventHandler(self, event):
            return self.__motionEventHandler(event)

    def __clickEventHandler(self, event):
        if self.game.app.opt.mouse_type == 'drag-n-drop':
            cancel_drag = 1
            start_drag = 1
            handler = self.clickHandler
        else:  # sticky-mouse or point-n-click
            cancel_drag = 0
            start_drag = not self.game.drag.stack
            if start_drag:
                handler = self.clickHandler
            else:
                handler = self.finishDrag
        return self.__defaultClickEventHandler(
            event, handler, start_drag, cancel_drag)

    def __doubleclickEventHandler(self, event):
        return self.__defaultClickEventHandler(event, self.doubleclickHandler)

    def __middleclickEventHandler(self, event):
        return self.__defaultClickEventHandler(event, self.middleclickHandler)

    def __controlmiddleclickEventHandler(self, event):
        return self.__defaultClickEventHandler(
            event, self.controlmiddleclickHandler)

    def __rightclickEventHandler(self, event):
        return self.__defaultClickEventHandler(event, self.rightclickHandler)

    def __controlclickEventHandler(self, event):
        return self.__defaultClickEventHandler(event, self.controlclickHandler)

    def __shiftclickEventHandler(self, event):
        return self.__defaultClickEventHandler(event, self.shiftclickHandler)

    def __shiftrightclickEventHandler(self, event):
        return self.__defaultClickEventHandler(
            event, self.shiftrightclickHandler)

    def __motionEventHandler(self, event):
        if not self.game.drag.stack or self is not self.game.drag.stack:
            return EVENT_PROPAGATE
        if self.game.demo:
            self.game.stopDemo(event)
        if self.game.busy:
            return EVENT_HANDLED
        if self.game.app.opt.mouse_type == 'point-n-click':
            return EVENT_HANDLED
        self.keepDrag(event)
        #  if self.game.app.opt.mouse_type == 'drag-n-drop' \
        #           and TOOLKIT == 'tk':
        #      # use a timer to update the drag
        #      # this allows us to skip redraws on slow machines
        #      drag = self.game.drag
        #      if drag.timer is None:
        #          drag.timer = after_idle(self.canvas, self.keepDragTimer)
        #      drag.event = event
        #  else:
        #      # update now
        #      self.keepDrag(event)
        return EVENT_HANDLED

    def __releaseEventHandler(self, event):
        if self.game.demo:
            self.game.stopDemo(event)
        self.game.interruptSleep()
        if self.game.busy:
            return EVENT_HANDLED
        if self.game.app.opt.mouse_type == 'drag-n-drop':

            if TOOLKIT == 'kivy':
                drag = self.game.drag
                if drag and drag.stack:
                    drag.stack.keepDrag(event)
                    drag.stack.finishDrag(event)
                return EVENT_HANDLED

            self.keepDrag(event)
            self.finishDrag(event)
        return EVENT_HANDLED

    def __enterEventHandler(self, event):
        if self.game.drag.stack:
            if self.game.app.opt.mouse_type == 'point-n-click':
                if self.acceptsCards(self.game.drag.stack,
                                     self.game.drag.cards):
                    self.canvas.config(cursor=CURSOR_DOWN_ARROW)
                    self.current_cursor = CURSOR_DOWN_ARROW
                    self.cursor_changed = True
        else:
            help = self.getHelp()  # +' '+self.getBaseCard(),
            if DEBUG:
                help = repr(self)
            after_idle(self.canvas, self.game.showHelp,
                       'help', help,
                       'info', self.getNumCards())
        return EVENT_HANDLED

    def __leaveEventHandler(self, event):
        if not self.game.drag.stack:
            after_idle(self.canvas, self.game.showHelp)
        if self.game.app.opt.mouse_type == 'drag-n-drop':
            return EVENT_HANDLED
        if self.cursor_changed:
            self.canvas.config(cursor='')
            self.current_cursor = ''
            self.cursor_changed = False
        drag_stack = self.game.drag.stack
        if self is drag_stack:
            x, y = event.x, event.y
            w, h = self.canvas.winfo_width(), self.canvas.winfo_height()
            if x < 0 or y < 0 or x >= w or y >= h:
                # cancel drag if mouse leave canvas
                drag_stack.cancelDrag(event)
                after_idle(self.canvas, self.game.showHelp)
                return EVENT_HANDLED
            else:
                # continue drag
                return self.__motionEventHandler(event)
        else:
            return EVENT_PROPAGATE

    #
    # Drag internals {controller -> model -> view}
    #

    def getDragCards(self, index):
        return self.cards[index:]

    # begin a drag operation
    def startDrag(self, event, sound=True):
        # print event.x, event.y
        assert self.game.drag.stack is None
        i = self._findCard(event)
        if i < 0 or not self.canMoveCards(self.cards[i:]):
            return
        if self.is_filled and self.items.shade_item:
            self.items.shade_item.hide()
        x_offset, y_offset = self.cards[i].x, self.cards[i].y
        if sound:
            self.game.playSample("startdrag")
        self.lastx = event.x
        self.lasty = event.y
        game = self.game
        drag = game.drag
        drag.start_x = event.x
        drag.start_y = event.y
        drag.stack = self
        drag.noshade_stacks = [self]
        drag.cards = self.getDragCards(i)
        drag.index = i
        if self.game.app.opt.mouse_type == 'point-n-click':
            self._markCards(drag)
            return
        # if TOOLKIT == 'gtk':
        #     drag.stack.group.tkraise()
        images = game.app.images
        drag.shadows = self.createShadows(drag.cards)
        # sx, sy = 0, 0
        sx, sy = -images.SHADOW_XOFFSET, -images.SHADOW_YOFFSET
        dx, dy = 0, 0
        cw, ch = images.getSize()
        if game.app.opt.mouse_type == 'sticky-mouse':
            # return cards under mouse
            dx = event.x - (x_offset+cw+sx) - game.canvas.xmargin
            dy = event.y - (y_offset+ch+sy) - game.canvas.ymargin
            if dx < 0:
                dx = 0
            if dy < 0:
                dy = 0
        for s in drag.shadows:
            if dx > 0 or dy > 0:
                s.move(dx, dy)
            if TOOLKIT == 'gtk':
                s.addtag(drag.stack.group)
            s.tkraise()
        for card in drag.cards:
            card.tkraise()
            card.moveBy(sx+dx, sy+dy)
        if game.app.opt.dragcursor:
            game.canvas.config(cursor=CURSOR_DRAG)

    # continue a drag operation
    def keepDrag(self, event):
        drag = self.game.drag
        if not drag.cards:
            return
        assert self is drag.stack
        dx = event.x - self.lastx
        dy = event.y - self.lasty
        if dx or dy:
            self.lastx = event.x
            self.lasty = event.y
            if self.game.app.opt.shade:
                self._updateShade()
            for s in drag.shadows:
                s.move(dx, dy)
            for card in drag.cards:
                card.moveBy(dx, dy)
        drag.event = None

    def keepDragTimer(self):
        drag = self.game.drag
        after_cancel(drag.timer)
        drag.timer = None
        if drag.event:
            self.keepDrag(drag.event)
            self.canvas.update_idletasks()

    # create shadows, return a tuple of MfxCanvasImages
    def createShadows(self, cards, dx=0, dy=0):
        if not self.game.app.opt.shadow or self.canvas.preview > 1:
            return ()
        mylen = len(cards)
        if mylen == 0 or mylen > self.max_shadow_cards:
            return ()
        images = self.game.app.images
        cx, cy = cards[0].x, cards[0].y
        ddx, ddy = cx-cards[-1].x, cy-cards[-1].y
        cw, ch = images.getSize()
        if USE_PIL:
            c0 = cards[-1]
            if self.CARD_XOFFSET[0] < 0:
                c0 = cards[0]
            if self.CARD_YOFFSET[0] < 0:
                c0 = cards[0]
            img = images.getShadowPIL(self, cards)
            cx, cy = c0.x + cw + dx, c0.y + ch + dy
            s = MfxCanvasImage(self.canvas, cx, cy,
                               image=img, anchor=ANCHOR_SE)
            s.lower(c0.item)
            return (s,)

        if ddx == 0:  # vertical
            for c in cards[1:]:
                if c.x != cx or abs(c.y - cy) != images.CARD_YOFFSET:
                    return ()
                cy = c.y
            img0, img1 = images.getShadow(0), images.getShadow(mylen)
            c0 = cards[-1]
            if self.CARD_YOFFSET[0] < 0:
                c0 = cards[0]
        elif ddy == 0:  # horizontal
            for c in cards[1:]:
                if c.y != cy or abs(c.x - cx) != images.CARD_XOFFSET:
                    return ()
                cx = c.x
            img0, img1 = images.getShadow(-mylen), images.getShadow(1)
            c0 = cards[-1]
            if self.CARD_XOFFSET[0] < 0:
                c0 = cards[0]
        else:
            return ()
        if img0 and img1:
            cx, cy = c0.x + cw + dx, c0.y + ch + dy

            if TOOLKIT == 'kivy':
                height0 = img0.getHeight()
            else:
                height0 = img0.height()

            s1 = MfxCanvasImage(self.game.canvas, cx, cy - height0,
                                image=img1, anchor=ANCHOR_SE)
            s2 = MfxCanvasImage(self.canvas, cx, cy,
                                image=img0, anchor=ANCHOR_SE)
            if TOOLKIT == 'tk':
                s1.lower(c0.item)
                s2.lower(c0.item)
            #  elif TOOLKIT == 'gtk':
            #      positions = 2           ## FIXME
            #      s1.lower(positions)
            #      s2.lower(positions)
            return (s1, s2)
        return ()

    # handle shade within a drag operation
    def _deleteShade(self):
        if self.game.drag.shade_img:
            self.game.drag.shade_img.delete()
        self.game.drag.shade_img = None
        self.game.drag.shade_stack = None

    def _updateShade(self):
        # optimized for speed - we use lots of local variables
        game = self.game
        images = game.app.images
        CW, CH = images.CARDW, images.CARDH
        drag = game.drag
        # stacks = game.allstacks
        c = drag.cards[0]
        stacks = (game.getClosestStack(c, drag.stack), )
        r1_0, r1_1, r1_2, r1_3 = c.x, c.y, c.x + CW, c.y + CH
        sstack, sdiff, sx, sy = None, 999999999, 0, 0
        for s in stacks:
            if s is None or s in drag.noshade_stacks:
                continue
            if s.cards:
                c = s.cards[-1]
                r2 = (c.x, c.y, c.x + CW, c.y + CH)
            else:
                r2 = (s.x, s.y, s.x + CW, s.y + CH)
            if (r1_2 <= r2[0] or r1_3 <= r2[1] or
                    r2[2] <= r1_0 or r2[3] <= r1_1):
                # rectangles do not intersect
                continue
            if s in drag.canshade_stacks:
                pass
            elif s.acceptsCards(drag.stack, drag.cards):
                drag.canshade_stacks.append(s)
            else:
                drag.noshade_stacks.append(s)
                continue
            diff = (r1_0 - r2[0])**2 + (r1_1 - r2[1])**2
            if diff < sdiff:
                sstack, sdiff, sx, sy = s, diff, r2[0], r2[1]
        if sstack is drag.shade_stack:
            return
        if sstack is None:
            self._deleteShade()
            return
        if drag.shade_img:
            self._deleteShade()
        # create the shade image
        drag.shade_stack = sstack
        if sstack.cards:
            card = sstack.cards[-1]
            if card.face_up:
                img = images.getHighlightedCard(
                    card.deck, card.suit, card.rank)
            else:
                img = images.getHighlightedBack()
        else:
            img = images.getShade()
        if not img:
            return
        img = MfxCanvasImage(game.canvas, sx, sy, image=img, anchor=ANCHOR_NW)
        drag.shade_img = img
        # raise/lower the shade image to the correct stacking order
        if TOOLKIT == 'tk':
            if drag.shadows:
                img.lower(drag.shadows[0])
            else:
                img.lower(drag.cards[0].item)
        elif TOOLKIT == 'gtk':
            img.tkraise()
            drag.stack.group.tkraise()

    # for closeStack
    def _shadeStack(self):
        if not self.game.app.opt.shade_filled_stacks:
            return
        #  if (self.CARD_XOFFSET != (0,) or
        #      self.CARD_YOFFSET != (0,)):
        #      return
        card = self.cards[-1]
        img = self.game.app.images.getHighlightedCard(
            card.deck, card.suit, card.rank)
        if img is None:
            return
        # self.canvas.update_idletasks()
        if TOOLKIT == 'kivy':
            self.game.top.waitAnimation()
        item = MfxCanvasImage(self.canvas, card.x, card.y,
                              image=img, anchor=ANCHOR_NW, group=self.group)
        # item.tkraise()
        self.items.shade_item = item

    def unshadeStack(self):
        if self.items.shade_item:
            self.items.shade_item.delete()
            self.items.shade_item = None

    def _markCards(self, drag):
        cards = drag.cards
        drag.stack.group.tkraise()
        #
        x0, y0 = self.getPositionFor(cards[0])
        x1, y1 = self.getPositionFor(cards[-1])
        x0, x1 = min(x1, x0), max(x1, x0)
        y0, y1 = min(y1, y0), max(y1, y0)
        cw, ch = self.game.app.images.getSize()
        x1 += cw
        y1 += ch
        xx0, yy0 = x0, y0
        w, h = x1-x0, y1-y0
        #
        if TOOLKIT == 'gtk' or not Image:
            color = self.game.app.opt.colors['cards_1']
            r = MfxCanvasRectangle(self.canvas, xx0, yy0, xx0+w, yy0+h,
                                   fill="", outline=color, width=4,
                                   group=self.group)
            drag.shadows.append(r)
            #  mylen = MfxCanvasLine(self.canvas, xx0, yy0, xx0+w, yy0+h,
            #                    fill=color, width=4)
            #  drag.shadows.append(mylen)
            #  mylen = MfxCanvasLine(self.canvas, xx0, yy0+h, xx0+w, yy0,
            #                    fill=color, width=4)
            #  drag.shadows.append(mylen)
            return
        #
        shade = Image.new('RGBA', (w, h))
        for c in cards:
            x, y = self.getPositionFor(c)
            x, y = x-xx0, y-yy0
            im = c._active_image._pil_image
            shade.paste(im, (x, y), im)
        #
        shade = markImage(shade)
        tkshade = ImageTk.PhotoImage(shade)
        im = MfxCanvasImage(self.canvas, xx0, yy0,
                            image=tkshade, anchor=ANCHOR_NW,
                            group=self.group)
        drag.shadows.append(im)

    def _stopDrag(self):
        drag = self.game.drag
        after_cancel(drag.timer)
        drag.timer = None
        self._deleteShade()
        drag.canshade_stacks = []
        drag.noshade_stacks = []
        for s in drag.shadows:
            s.delete()
        drag.shadows = []
        drag.stack = None
        drag.cards = []

    # finish a drag operation
    def finishDrag(self, event=None):
        if self.game.app.opt.dragcursor:
            self.canvas.config(cursor='')
        drag = self.game.drag.copy()
        if self.game.app.opt.mouse_type == 'point-n-click':
            drag.stack._stopDrag()
        else:
            self._stopDrag()
        if drag.cards:
            if self.game.app.opt.mouse_type == 'point-n-click':
                self.releaseHandler(event, drag)
            else:
                assert drag.stack is self
                self.releaseHandler(event, drag)

    # cancel a drag operation
    def cancelDrag(self, event=None):
        if self.game.app.opt.dragcursor:
            self.canvas.config(cursor='')
        drag = self.game.drag.copy()
        if self.game.app.opt.mouse_type == 'point-n-click':
            drag.stack._stopDrag()
        else:
            self._stopDrag()
        if drag.cards:
            assert drag.stack is self
            self.moveCardsBackHandler(event, drag)

    def getHelp(self):
        return str(self)  # debug

    def getBaseCard(self):
        return ''

    def _getBaseCard(self, rank=None):
        # FIXME: no-french games
        if self.cap.max_accept == 0:
            return ''
        if rank is None:
            br = self.cap.base_rank
        else:
            br = rank
        s = _('Base card - %s.')
        if br == NO_RANK:
            s = _('Empty row cannot be filled.')
        elif br == -1:
            s = s % _('any card')
        elif br == 10:
            s = s % _('Jack')
        elif br == 11:
            s = s % _('Queen')
        elif br == 12:
            s = s % _('King')
        elif br == 0:
            s = s % _('Ace')
        else:
            s = s % str(br+1)
        return s

    def getNumCards(self):
        from pysollib.mygettext import ungettext
        n = len(self.cards)
        if n == 0:
            return _('No cards')
        else:
            return ungettext('%d card', '%d cards', n) % n


# ************************************************************************
# * Abstract interface that supports a concept of dealing.
# ************************************************************************

class DealRow_StackMethods:
    # Deal a card to each of the RowStacks. Return number of cards dealt.
    def dealRow(self, rows=None, flip=1, reverse=0, frames=-1, sound=False):
        if rows is None:
            rows = self.game.s.rows
        if sound and frames and self.game.app.opt.animations:
            self.game.startDealSample()
        n = self.dealToStacks(rows, flip, reverse, frames)
        if sound:
            self.game.stopSamples()
        return n

    # Same, but no error if not enough cards are available.
    def dealRowAvail(self, rows=None, flip=1,
                     reverse=0, frames=-1, sound=False):
        if rows is None:
            rows = self.game.s.rows
        if sound and frames and self.game.app.opt.animations:
            self.game.startDealSample()
        if len(self.cards) < len(rows):
            rows = rows[:len(self.cards)]
        n = self.dealToStacks(rows, flip, reverse, frames)
        if sound:
            self.game.stopSamples()
        return n

    def dealToStacks(self, stacks, flip=1, reverse=0, frames=-1):
        if not self.cards or not stacks:
            return 0
        assert len(self.cards) >= len(stacks)
        old_state = self.game.enterState(self.game.S_DEAL)
        if reverse:
            stacks = list(stacks)
            stacks.reverse()
        for r in stacks:
            assert not self.getCard().face_up
            assert r is not self
            if flip:
                self.game.flipMove(self)
            self.game.moveMove(1, self, r, frames=frames)
        self.game.leaveState(old_state)
        if TOOLKIT == 'kivy':
            self.game.top.waitAnimation()
        return len(stacks)

    # all Aces go to the Foundations
    def dealToStacksOrFoundations(self, stacks, flip=1,
                                  reverse=0, frames=-1, rank=-1):
        if rank < 0:
            rank = self.game.s.foundations[0].cap.base_rank
        if not self.cards or not stacks:
            return 0
        old_state = self.game.enterState(self.game.S_DEAL)
        if reverse:
            stacks = list(stacks)
            stacks.reverse()
        n = 0
        for r in stacks:
            assert r is not self
            while self.cards:
                n += 1
                if flip:
                    self.game.flipMove(self)
                if flip and self.cards[-1].rank == rank:
                    for s in self.game.s.foundations:
                        assert s is not self
                        if s.acceptsCards(self, self.cards[-1:]):
                            self.game.moveMove(1, self, s, frames=frames)
                            break
                else:
                    self.game.moveMove(1, self, r, frames=frames)
                    break
        self.game.leaveState(old_state)
        if TOOLKIT == 'kivy':
            self.game.top.waitAnimation()
        return n


class DealBaseCard_StackMethods:
    def dealSingleBaseCard(self, frames=-1, update_saveinfo=1):
        c = self.cards[-1]
        self.dealBaseCards(ncards=1, frames=frames, update_saveinfo=0)
        for s in self.game.s.foundations:
            s.cap.base_rank = c.rank
            if update_saveinfo:
                cap = Struct(base_rank=c.rank)
                self.game.saveinfo.stack_caps.append((s.id, cap))
        return c

    def dealBaseCards(self, ncards=1, frames=-1, update_saveinfo=1):
        assert self.game.moves.state == self.game.S_INIT
        assert not self.base_cards
        while ncards > 0:
            assert self.cards
            c = self.cards[-1]
            for s in self.game.s.foundations:
                if (not s.cards and
                        (s.cap.base_suit < 0 or s.cap.base_suit == c.suit)):
                    break
            else:
                assert 0
                s = None
            s.cap.base_rank = c.rank
            if update_saveinfo:
                cap = Struct(base_rank=c.rank)
                self.game.saveinfo.stack_caps.append((s.id, cap))
            if not c.face_up:
                self.game.flipMove(self)
            self.game.moveMove(1, self, s, frames=frames)
            ncards -= 1


class RedealCards_StackMethods:

    def _redeal(self, rows=None, reverse=False, frames=0):
        # move all cards to the Talon
        num_cards = 0
        assert len(self.cards) == 0
        if rows is None:
            rows = self.game.s.rows
        rows = list(rows)
        if reverse:
            rows.reverse()
        for r in rows:
            for i in range(len(r.cards)):
                num_cards += 1
                self.game.moveMove(1, r, self, frames=frames, shadow=0)
                if self.cards[-1].face_up:
                    self.game.flipMove(self)
        assert len(self.cards) == num_cards
        return num_cards

    def redealCards(self, rows=None, sound=False,
                    shuffle=False, reverse=False, frames=0):
        if sound and self.game.app.opt.animations:
            self.game.startDealSample()
        num_cards = self._redeal(rows=rows, reverse=reverse, frames=frames)
        if num_cards == 0:          # game already finished
            return 0
        if shuffle:
            # shuffle
            self.game.shuffleStackMove(self)
        # redeal
        self.game.nextRoundMove(self)
        self.game.redealCards()
        if sound:
            self.game.stopSamples()
        return num_cards


# ************************************************************************
# * The Talon is a stack with support for dealing.
# ************************************************************************

class TalonStack(Stack,
                 DealRow_StackMethods,
                 DealBaseCard_StackMethods,
                 ):
    def __init__(self, x, y, game, max_rounds=1, num_deal=1, **cap):
        Stack.__init__(self, x, y, game, cap=cap)
        self.max_rounds = max_rounds
        self.num_deal = num_deal
        self.init_redeal = Struct(
            top_bottom=None,
            img_coord=None,
            txt_coord=None,
            )
        self.resetGame()

    def resetGame(self):
        Stack.resetGame(self)
        self.round = 1
        self.base_cards = []        # for DealBaseCard_StackMethods

    def assertStack(self):
        Stack.assertStack(self)
        n = self.game.gameinfo.redeals
        if n < 0:
            assert self.max_rounds == n
        else:
            assert self.max_rounds == n + 1

    # Control of dealing is transferred to the game which usually
    # transfers it back to the Talon - see dealCards() below.
    def clickHandler(self, event):
        return self.game.dealCards(sound=True)

    def rightclickHandler(self, event):
        return self.clickHandler(event)

    # Usually called by Game.canDealCards()
    def canDealCards(self):
        return len(self.cards) > 0

    # Actual dealing, usually called by Game.dealCards().
    # Either deal all cards in Game.startGame(), or subclass responsibility.
    def dealCards(self, sound=False):
        pass

    # remove all cards from all stacks
    def removeAllCards(self):
        for stack in self.game.allstacks:
            while stack.cards:
                stack.removeCard(update=0)
                # stack.removeCard(unhide=0, update=0)
        for stack in self.game.allstacks:
            stack.updateText()

    def updateText(self, update_rounds=1, update_redeal=1):
        # assertView(self)
        Stack.updateText(self)
        if update_rounds and self.game.preview <= 1:
            if self.texts.rounds is not None:
                t = _("Round %d") % self.round
                self.texts.rounds.config(text=t)
        if update_redeal:
            deal = self.canDealCards() != 0
            if self.images.redeal is not None:
                img = (self.getRedealImages())[deal]
                if img is not None and img is not self.images.redeal_img:
                    self.images.redeal.config(image=img)
                    self.images.redeal_img = img
                t = ("", _("Redeal"))[deal]
            else:
                t = (_("Stop"), _("Redeal"))[deal]
            if self.texts.redeal is not None and self.game.preview <= 1:
                if t != self.texts.redeal_str:
                    self.texts.redeal.config(text=t)
                    self.texts.redeal_str = t

    def _addRedealImage(self):
        # add or remove the redeal image/text
        if not self.is_visible or self.images.bottom is None:
            return
        if self.game.preview > 1:
            return
        images = self.game.app.images
        cw, ch = images.getSize()
        cx, cy = self.init_redeal.img_coord
        ca = 'center'
        tx, ty = self.init_redeal.txt_coord

        if self.images.redeal:
            self.canvas.delete(self.images.redeal)
            self.images.redeal = None
            self.images.redeal_img = None
        if self.texts.redeal:
            self.canvas.delete(self.texts.redeal)
            self.texts.redeal = None
            self.texts.redeal_str = ''
        self.top_bottom = self.init_redeal.top_bottom

        if cw >= 60 and ch >= 60:
            # add a redeal image above the bottom image
            img = (self.getRedealImages())[self.max_rounds != 1]
            if img is not None:
                self.images.redeal_img = img
                self.images.redeal = MfxCanvasImage(self.canvas,
                                                    cx, cy, image=img,
                                                    anchor="center",
                                                    group=self.group)
                if TOOLKIT == 'tk':
                    self.images.redeal.tkraise(self.top_bottom)
                elif TOOLKIT == 'kivy':
                    self.images.redeal.tkraise(self.top_bottom)
                elif TOOLKIT == 'gtk':
                    # FIXME
                    pass
                self.top_bottom = self.images.redeal
                if ch >= 90:
                    cy, ca = ty, "s"
                else:
                    ca = None
        font = self.game.app.getFont("canvas_default")
        text_width = get_text_width(_('Redeal'), font=font,
                                    root=self.canvas)
        if cw >= text_width+4 and ca:
            # add a redeal text below the bottom image
            if self.max_rounds != 1:
                # FIXME: sometimes canvas do not show the text
                # print 'add txt', cx, cy
                self.texts.redeal_str = ""
                images = self.game.app.images
                self.texts.redeal = MfxCanvasText(self.canvas, cx, cy,
                                                  anchor=ca, font=font,
                                                  group=self.group)
                if TOOLKIT == 'tk':
                    self.texts.redeal.tkraise(self.top_bottom)
                elif TOOLKIT == 'kivy':
                    self.texts.redeal.tkraise(self.top_bottom)
                elif TOOLKIT == 'gtk':
                    # FIXME
                    pass
                self.top_bottom = self.texts.redeal

    def prepareView(self):
        Stack.prepareView(self)
        if 0:
            if not self.is_visible or self.images.bottom is None:
                return
            if self.images.redeal is not None or self.texts.redeal is not None:
                return
            if self.game.preview > 1:
                return
        images = self.game.app.images
        self.init_redeal.top_bottom = self.top_bottom
        cx, cy = self.x + images.CARDW//2, self.y + images.CARDH//2
        ty = self.y + images.CARDH - 4
        self.init_redeal.img_coord = cx, cy
        self.init_redeal.txt_coord = cx, ty

        # At least display a redealImage at start, if USE_PIL is not set.
        if USE_PIL is False:
            self._addRedealImage()

    getBottomImage = Stack._getTalonBottomImage

    def getRedealImages(self):
        # returns a tuple of two PhotoImages
        return self.game.app.gimages.redeal

    def getHelp(self):
        from pysollib.mygettext import ungettext
        if self.max_rounds == -2:
            nredeals = _('Variable redeals.')
        elif self.max_rounds == -1:
            nredeals = _('Unlimited redeals.')
        else:
            n = self.max_rounds-1
            nredeals = ungettext('%d redeal', '%d redeals', n) % n
        # round = _('Round #%d.') % self.round
        return _('Talon.')+' '+nredeals  # +' '+round

    # def getBaseCard(self):
    #    return self._getBaseCard()

    def resize(self, xf, yf):
        self._addRedealImage()
        Stack.resize(self, xf, yf)


# A single click deals one card to each of the RowStacks.
class DealRowTalonStack(TalonStack):
    def dealCards(self, sound=False):
        return self.dealRowAvail(sound=sound)


# For games where the Talon is only used for the initial dealing.
class InitialDealTalonStack(TalonStack):
    # no bindings
    def initBindings(self):
        pass
    # no bottom
    getBottomImage = Stack._getNoneBottomImage


class RedealTalonStack(TalonStack, RedealCards_StackMethods):
    def canDealCards(self):
        if self.round == self.max_rounds:
            return False
        return not self.game.isGameWon()

    def dealCards(self, sound=False):
        RedealCards_StackMethods.redealCards(self, sound=sound)


class DealRowRedealTalonStack(TalonStack, RedealCards_StackMethods):

    def canDealCards(self, rows=None):
        if rows is None:
            rows = self.game.s.rows
        r_cards = sum([len(r.cards) for r in rows])
        if self.cards:
            return True
        elif r_cards and self.round != self.max_rounds:
            return True
        return False

    def dealCards(self, sound=False, rows=None, shuffle=False):
        num_cards = 0
        if rows is None:
            rows = self.game.s.rows
        if sound and self.game.app.opt.animations:
            self.game.startDealSample()
        if not self.cards:
            # move all cards to talon
            num_cards = self._redeal(rows=rows, frames=4)
            if shuffle:
                # shuffle
                self.game.shuffleStackMove(self)
            self.game.nextRoundMove(self)
        num_cards += self.dealRowAvail(rows=rows, sound=False)
        if sound:
            self.game.stopSamples()
        return num_cards

    def shuffleAndDealCards(self, sound=False, rows=None):
        DealRowRedealTalonStack.dealCards(self, sound=sound,
                                          rows=rows, shuffle=True)


class DealReserveRedealTalonStack(DealRowRedealTalonStack):

    def canDealCards(self, rows=None):
        return DealRowRedealTalonStack.canDealCards(
            self, rows=self.game.s.reserves)

    def dealCards(self, sound=False, rows=None):
        return DealRowRedealTalonStack.dealCards(
            self, sound=sound, rows=self.game.s.reserves)


# Spider Talons
class SpiderTalonStack(DealRowRedealTalonStack):
    def canDealCards(self):
        if not DealRowRedealTalonStack.canDealCards(self):
            return False
        # no row may be empty
        for r in self.game.s.rows:
            if not r.cards:
                return False
        return True


class GroundsForADivorceTalonStack(DealRowRedealTalonStack):
    # A single click deals a new cards to each non-empty row.
    def dealCards(self, sound=True):
        if self.cards:
            rows = [r for r in self.game.s.rows if r.cards]
            # if not rows:
            #     # deal one card to first row if all rows are empty
            #     rows = self.game.s.rows[:1]
            return DealRowRedealTalonStack.dealRowAvail(self, rows=rows,
                                                        sound=sound)
        return 0


# ************************************************************************
# * An OpenStack is a stack where cards can be placed and dragged
# * (i.e. FoundationStack, RowStack, ReserveStack, ...)
# *
# * Note that it defaults to max_move=1 and max_accept=0.
# ************************************************************************

class OpenStack(Stack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=1, max_accept=0, max_cards=999999)
        Stack.__init__(self, x, y, game, cap=cap)

    #
    # Capabilities {model}
    #

    def acceptsCards(self, from_stack, cards):
        # default for OpenStack: we cannot accept
        # cards (max_accept defaults to 0)
        return self.basicAcceptsCards(from_stack, cards)

    def canMoveCards(self, cards):
        # default for OpenStack: we can move the top card
        # (max_move defaults to 1)
        return self.basicCanMoveCards(cards)

    def canFlipCard(self):
        # default for OpenStack: we can flip the top card
        if self.basicIsBlocked() or not self.cards:
            return False
        return not self.cards[-1].face_up

    def canDropCards(self, stacks):
        if self.basicIsBlocked() or not self.cards:
            return (None, 0)
        cards = self.cards[-1:]
        if self.canMoveCards(cards):
            for s in stacks:
                if s is not self and s.acceptsCards(self, cards):
                    return (s, 1)
        return (None, 0)

    #
    # Mouse handlers {controller}
    #

    def clickHandler(self, event):
        flipstacks, dropstacks, quickstacks = self.game.getAutoStacks(event)
        if self in flipstacks and self.canFlipCard():
            self.playFlipMove(animation=True)
            # return -1                   # continue this event (start a drag)
            return 1                    # break
        return 0

    def rightclickHandler(self, event):
        if self.doubleclickHandler(event):
            return 1
        if self.game.app.opt.quickplay:
            flipstacks, dropstacks, quickstacks = \
                self.game.getAutoStacks(event)
            if self in quickstacks:
                n = self.quickPlayHandler(event)
                self.game.stats.quickplay_moves += n
                return n
        return 0

    def doubleclickHandler(self, event):
        # flip or drop a card
        flipstacks, dropstacks, quickstacks = self.game.getAutoStacks(event)
        if self in flipstacks and self.canFlipCard():
            self.playFlipMove(animation=True)
            return -1               # continue this event (start a drag)
        if self in dropstacks:
            to_stack, ncards = self.canDropCards(self.game.s.foundations)
            if to_stack:
                self.game.playSample("autodrop", priority=30)
                self.playMoveMove(ncards, to_stack, sound=False)
                return 1
        return 0

    def controlclickHandler(self, event):
        # highlight matching cards
        if self.game.app.opt.highlight_cards:
            return self.highlightMatchingCards(event)
        return 0

    def dragMove(self, drag, stack, sound=True):
        if self.game.app.opt.mouse_type == 'point-n-click':
            self.playMoveMove(len(drag.cards), stack, sound=sound)
        else:
            # self.playMoveMove(len(drag.cards), stack, frames=0, sound=sound)
            self.playMoveMove(len(drag.cards), stack, frames=-2, sound=sound)

    def releaseHandler(self, event, drag, sound=True):
        cards = drag.cards
        # check if we moved the card by at least 10 pixels
        if event is not None:
            dx, dy = event.x - drag.start_x, event.y - drag.start_y
            if abs(dx) < 10 and abs(dy) < 10:
                # move cards back to their origin stack
                Stack.releaseHandler(self, event, drag, sound=sound)
                return
            # print dx, dy
        # get destination stack
        if self.game.app.opt.mouse_type == 'point-n-click':
            from_stack = drag.stack
            to_stack = self
        else:
            from_stack = self
            to_stack = self.game.getClosestStack(cards[0], self)
        # move cards
        if (not to_stack or from_stack is to_stack or
                not to_stack.acceptsCards(from_stack, cards)):
            # move cards back to their origin stack
            Stack.releaseHandler(self, event, drag, sound=sound)
        else:
            # this code actually moves the cards to the new stack
            # self.playMoveMove(len(cards), stack, frames=0, sound=sound)
            from_stack.dragMove(drag, to_stack, sound=sound)

    def quickPlayHandler(self, event, from_stacks=None, to_stacks=None):
        # from_stacks and to_stacks are meant for possible
        # use in a subclasses
        if from_stacks is None:
            from_stacks = self.game.sg.dropstacks
        if to_stacks is None:
            # to_stacks = self.game.s.rows + self.game.s.reserves
            # to_stacks = self.game.sg.dropstacks
            to_stacks = self.game.s.foundations + self.game.sg.dropstacks
            # from pprint import pprint; pprint(to_stacks)
        moves = []
        #
        if not self.cards:
            for s in from_stacks:
                if s is not self and s.cards:
                    pile = s.getPile()
                    if pile and self.acceptsCards(s, pile):
                        score = self.game.getQuickPlayScore(len(pile), s, self)
                        moves.append((score, -len(moves), len(pile), s, self))
        else:
            pile1, pile2 = None, self.getPile()
            if pile2:
                i = self._findCard(event)
                if i >= 0:
                    pile = self.cards[i:]
                    if len(pile) != len(pile2) and self.canMoveCards(pile):
                        pile1 = pile
            for pile in (pile1, pile2):
                if not pile:
                    continue
                for s in to_stacks:
                    if s is not self and s.acceptsCards(self, pile):
                        score = self.game.getQuickPlayScore(len(pile), self, s)
                        moves.append((score, -len(moves), len(pile), self, s))
        #
        if moves:
            moves.sort()
            # from pprint import pprint; pprint(moves)
            score, len_moves, ncards, from_stack, to_stack = moves[-1]
            if score >= 0:
                # self.game.playSample("startdrag")
                from_stack.playMoveMove(ncards, to_stack)
                return 1
        return 0

    def getHelp(self):
        if self.cap.max_accept == 0:
            return _('Reserve. No building.')
        return ''


# ************************************************************************
# * Foundations stacks
# ************************************************************************

class AbstractFoundationStack(OpenStack):
    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, suit=suit, base_suit=suit, base_rank=ACE,
                  dir=1, max_accept=1, max_cards=13)
        OpenStack.__init__(self, x, y, game, **cap)

    def canDropCards(self, stacks):
        return (None, 0)

    def clickHandler(self, event):
        return 0

    def rightclickHandler(self, event):
        # return 0
        if self.game.app.opt.quickplay:
            n = self.quickPlayHandler(event)
            self.game.stats.quickplay_moves += n
            return n
        return 0

    def quickPlayHandler(self, event):
        # return 0
        from_stacks = self.game.sg.dropstacks + self.game.s.foundations
        # to_stacks = self.game.sg.dropstacks
        to_stacks = from_stacks
        return OpenStack.quickPlayHandler(self, event, from_stacks, to_stacks)

    getBottomImage = Stack._getSuitBottomImage

    def getBaseCard(self):
        return self._getBaseCard()

    def closeStack(self):
        if len(self.cards) == self.cap.max_cards:
            self.is_filled = True
            self._shadeStack()

    def getHelp(self):
        return _('Foundation.')

    def varyAcceptsCards(self, from_stack, cards):
        # if base rank of foundations is vary
        subclass = self.__class__    # derived class (SS_FoundationStack, etc)
        assert subclass is not AbstractFoundationStack
        if self.cards:
            return subclass.acceptsCards(self, from_stack, cards)
        if not subclass.acceptsCards(self, from_stack, cards):
            return False
        # this stack don't have cards: check base rank of other stacks
        for s in self.game.s.foundations:
            if s.cards:
                base_card = s.cards[0]
                return base_card.rank == cards[0].rank
        return True                     # all foundations is empty

    def varyGetBaseCard(self):
        rank = None
        for s in self.game.s.foundations:
            if s.cards:
                rank = s.cards[0].rank
        return self._getBaseCard(rank=rank)


# A SameSuit_FoundationStack is the typical Foundation stack.
# It builds up in rank and suit.
class SS_FoundationStack(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if self.cards:
            # check the rank
            if ((self.cards[-1].rank + self.cap.dir) % self.cap.mod !=
                    cards[0].rank):
                return False
        return True

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Foundation. Build up by suit.')
        elif self.cap.dir < 0:
            return _('Foundation. Build down by suit.')
        else:
            return _('Foundation. Build by same rank.')


# A Rank_FoundationStack builds up in rank and ignores color and suit.
class RK_FoundationStack(SS_FoundationStack):
    def __init__(self, x, y, game, suit=ANY_SUIT, **cap):
        SS_FoundationStack.__init__(self, x, y, game, ANY_SUIT, **cap)

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Foundation. Build up regardless of suit.')
        elif self.cap.dir < 0:
            return _('Foundation. Build down regardless of suit.')
        else:
            return _('Foundation. Build by same rank.')


# A AlternateColor_FoundationStack builds up in rank and alternate color.
# It is used in only a few games.
class AC_FoundationStack(SS_FoundationStack):
    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, base_suit=suit)
        SS_FoundationStack.__init__(self, x, y, game, ANY_SUIT, **cap)

    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if self.cards:
            # check the color
            if cards[0].color == self.cards[-1].color:
                return False
        return True

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Foundation. Build up by alternate color.')
        elif self.cap.dir < 0:
            return _('Foundation. Build down by alternate color.')
        else:
            return _('Foundation. Build by same rank.')


# A SameColor_FoundationStack builds up in rank and alternate color.
# It is used in only a few games.
class SC_FoundationStack(SS_FoundationStack):
    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, base_suit=suit)
        SS_FoundationStack.__init__(self, x, y, game, ANY_SUIT, **cap)

    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if self.cards:
            # check the color
            if cards[0].color != self.cards[-1].color:
                return False
        return True

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Foundation. Build up by color.')
        elif self.cap.dir < 0:
            return _('Foundation. Build down by color.')
        else:
            return _('Foundation. Build by same rank.')


# Spider-type foundations
class Spider_SS_Foundation(AbstractFoundationStack):
    def __init__(self, x, y, game, suit=ANY_SUIT, **cap):
        kwdefault(cap, dir=-1, base_rank=KING,
                  min_accept=13, max_accept=13, max_move=0)
        AbstractFoundationStack.__init__(self, x, y, game, suit, **cap)

    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # now check the cards
        return isSameSuitSequence(cards, self.cap.mod, self.cap.dir)


class Spider_AC_Foundation(Spider_SS_Foundation):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # now check the cards
        return isAlternateColorSequence(cards, self.cap.mod, self.cap.dir)


class Spider_RK_Foundation(Spider_SS_Foundation):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # now check the cards
        return isRankSequence(cards, self.cap.mod, self.cap.dir)


# ************************************************************************
# * Abstract classes for row stacks.
# ************************************************************************


# Abstract class.
class SequenceStack_StackMethods:
    def _isSequence(self, cards):
        # Are the cards in a basic sequence for our stack ?
        raise SubclassResponsibility

    def _isAcceptableSequence(self, cards):
        return self._isSequence(cards)

    def _isMoveableSequence(self, cards):
        # import pdb; pdb.set_trace()
        return self._isSequence(cards)

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return False
        # cards must be an acceptable sequence
        if not self._isAcceptableSequence(cards):
            return False
        # [topcard + cards] must be an acceptable sequence
        if (self.cards and not
                self._isAcceptableSequence([self.cards[-1]] + cards)):
            return False
        return True

    def canMoveCards(self, cards):
        return self.basicCanMoveCards(cards) and \
            self._isMoveableSequence(cards)


# Abstract class.
class BasicRowStack(OpenStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, dir=-1, base_rank=ANY_RANK)
        OpenStack.__init__(self, x, y, game, **cap)
        self.CARD_YOFFSET = game.app.images.CARD_YOFFSET

    def getHelp(self):
        if self.cap.max_accept == 0:
            return _('Tableau. No building.')
        return ''

    # def getBaseCard(self):
    #    return self._getBaseCard()

    def spiderCanDropCards(self, stacks):
        # drop whole sequence
        if len(self.cards) < 13:
            return (None, 0)
        cards = self.cards[-13:]
        for s in stacks:
            if s is not self and s.acceptsCards(self, cards):
                return (s, 13)
        return (None, 0)

    def getReserveBottomImage(self):
        return self.game.app.images.getReserveBottom()


# Abstract class.
class SequenceRowStack(SequenceStack_StackMethods, BasicRowStack):
    # canMoveCards = OpenStack.canMoveCards

    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=999999, max_accept=999999)
        BasicRowStack.__init__(self, x, y, game, **cap)

    def getBaseCard(self):
        return self._getBaseCard()


# ************************************************************************
# * Row stacks (the main playing stacks on the Tableau).
# ************************************************************************

#
# Implementation of common row stacks follows here.
#

# An AlternateColor_RowStack builds down by rank and alternate color.
# e.g. Klondike
class AC_RowStack(SequenceRowStack):
    def _isSequence(self, cards):
        return isAlternateColorSequence(cards, self.cap.mod, self.cap.dir)

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Tableau. Build up by alternate color.')
        elif self.cap.dir < 0:
            return _('Tableau. Build down by alternate color.')
        else:
            return _('Tableau. Build by same rank.')


# A SameColor_RowStack builds down by rank and same color.
# e.g. Klondike
class SC_RowStack(SequenceRowStack):
    def _isSequence(self, cards):
        return isSameColorSequence(cards, self.cap.mod, self.cap.dir)

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Tableau. Build up by color.')
        elif self.cap.dir < 0:
            return _('Tableau. Build down by color.')
        else:
            return _('Tableau. Build by same rank.')


# A SameSuit_RowStack builds down by rank and suit.
class SS_RowStack(SequenceRowStack):
    def _isSequence(self, cards):
        return isSameSuitSequence(cards, self.cap.mod, self.cap.dir)

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Tableau. Build up by suit.')
        elif self.cap.dir < 0:
            return _('Tableau. Build down by suit.')
        else:
            return _('Tableau. Build by same rank.')


# A Rank_RowStack builds down by rank ignoring suit.
class RK_RowStack(SequenceRowStack):
    def _isSequence(self, cards):
        return isRankSequence(cards, self.cap.mod, self.cap.dir)

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Tableau. Build up regardless of suit.')
        elif self.cap.dir < 0:
            return _('Tableau. Build down regardless of suit.')
        else:
            return _('Tableau. Build by same rank.')


# ButOwn_RowStack
class BO_RowStack(SequenceRowStack):
    def _isSequence(self, cards):
        return isAnySuitButOwnSequence(cards, self.cap.mod, self.cap.dir)

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Tableau. Build up in any suit but the same.')
        elif self.cap.dir < 0:
            return _('Tableau. Build down in any suit but the same.')
        else:
            return _('Tableau. Build by same rank.')


# A Freecell_AlternateColor_RowStack
class FreeCell_AC_RowStack(AC_RowStack):
    def canMoveCards(self, cards):
        max_move = getNumberOfFreeStacks(self.game.s.reserves) + 1
        return len(cards) <= max_move and AC_RowStack.canMoveCards(self, cards)


# A Freecell_SameSuit_RowStack (i.e. Baker's Game)
class FreeCell_SS_RowStack(SS_RowStack):
    def canMoveCards(self, cards):
        max_move = getNumberOfFreeStacks(self.game.s.reserves) + 1
        return len(cards) <= max_move and SS_RowStack.canMoveCards(self, cards)


# A Freecell_Rank_RowStack
class FreeCell_RK_RowStack(RK_RowStack):
    def canMoveCards(self, cards):
        max_move = getNumberOfFreeStacks(self.game.s.reserves) + 1
        return len(cards) <= max_move and RK_RowStack.canMoveCards(self, cards)


# A Spider_AlternateColor_RowStack builds down by rank and alternate color,
# but accepts sequences that match by rank only.
class Spider_AC_RowStack(AC_RowStack):
    def _isAcceptableSequence(self, cards):
        return isRankSequence(cards, self.cap.mod, self.cap.dir)

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Tableau. Build up regardless of suit. '
                     'Sequences of cards in alternate color '
                     'can be moved as a unit.')
        elif self.cap.dir < 0:
            return _('Tableau. Build down regardless of suit. '
                     'Sequences of cards in alternate color can be moved '
                     'as a unit.')
        else:
            return _('Tableau. Build by same rank.')


# A Spider_SameSuit_RowStack builds down by rank and suit,
# but accepts sequences that match by rank only.
class Spider_SS_RowStack(SS_RowStack):
    def _isAcceptableSequence(self, cards):
        return isRankSequence(cards, self.cap.mod, self.cap.dir)

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Tableau. Build up regardless of suit. '
                     'Sequences of cards in the same suit can be moved '
                     'as a unit.')
        elif self.cap.dir < 0:
            return _('Tableau. Build down regardless of suit. '
                     'Sequences of cards in the same suit can be moved '
                     'as a unit.')
        else:
            return _('Tableau. Build by same rank.')


# A Yukon_AlternateColor_RowStack builds down by rank and alternate color,
# but can move any face-up cards regardless of sequence.
class Yukon_AC_RowStack(BasicRowStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=999999, max_accept=999999)
        BasicRowStack.__init__(self, x, y, game, **cap)

    def _isSequence(self, c1, c2):
        return ((c1.rank + self.cap.dir) % self.cap.mod == c2.rank and
                c1.color != c2.color)

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return False
        # [topcard + card[0]] must be acceptable
        if self.cards and not self._isSequence(self.cards[-1], cards[0]):
            return False
        return True

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Tableau. Build up by alternate color, '
                     'can move any face-up cards regardless of sequence.')
        elif self.cap.dir < 0:
            return _('Tableau. Build down by alternate color, '
                     'can move any face-up cards regardless of sequence.')
        else:
            return _('Tableau. Build by same rank, can move '
                     'any face-up cards regardless of sequence.')

    def getBaseCard(self):
        return self._getBaseCard()


# A Yukon_SameSuit_RowStack builds down by rank and suit,
# but can move any face-up cards regardless of sequence.
class Yukon_SS_RowStack(Yukon_AC_RowStack):
    def _isSequence(self, c1, c2):
        return ((c1.rank + self.cap.dir) % self.cap.mod == c2.rank and
                c1.suit == c2.suit)

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Tableau. Build up by suit, can move any face-up cards '
                     'regardless of sequence.')
        elif self.cap.dir < 0:
            return _('Tableau. Build down by suit, can move any '
                     'face-up cards regardless of sequence.')
        else:
            return _('Tableau. Build by same rank, can move any '
                     'face-up cards regardless of sequence.')


# A Yukon_Rank_RowStack builds down by rank
# but can move any face-up cards regardless of sequence.
class Yukon_RK_RowStack(Yukon_AC_RowStack):
    def _isSequence(self, c1, c2):
        return (c1.rank + self.cap.dir) % self.cap.mod == c2.rank

    def getHelp(self):
        if self.cap.dir > 0:
            return _('Tableau. Build up regardless of suit, '
                     'can move any face-up cards regardless of sequence.')
        elif self.cap.dir < 0:
            return _('Tableau. Build up regardless of suit, can move any '
                     'face-up cards regardless of sequence.')
        else:
            return _('Tableau. Build by same rank, can move any '
                     'face-up cards regardless of sequence.')

#
# King-versions of some of the above stacks: they accepts only Kings or
# sequences starting with a King as base_rank cards (i.e. when empty).
#


class KingAC_RowStack(AC_RowStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, base_rank=KING)
        AC_RowStack.__init__(self, x, y, game, **cap)


class KingSS_RowStack(SS_RowStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, base_rank=KING)
        SS_RowStack.__init__(self, x, y, game, **cap)


class KingRK_RowStack(RK_RowStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, base_rank=KING)
        RK_RowStack.__init__(self, x, y, game, **cap)


# up or down by color
class UD_SC_RowStack(SequenceRowStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=1, max_accept=1)
        SequenceRowStack.__init__(self, x, y, game, **cap)

    def _isSequence(self, cards):
        return (isSameColorSequence(cards, self.cap.mod, 1) or
                isSameColorSequence(cards, self.cap.mod, -1))

    def getHelp(self):
        return _('Tableau. Build up or down by color.')


# up or down by alternate color
class UD_AC_RowStack(SequenceRowStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=1, max_accept=1)
        SequenceRowStack.__init__(self, x, y, game, **cap)

    def _isSequence(self, cards):
        return (isAlternateColorSequence(cards, self.cap.mod, 1) or
                isAlternateColorSequence(cards, self.cap.mod, -1))

    def getHelp(self):
        return _('Tableau. Build up or down by alternate color.')


# up or down by suit
class UD_SS_RowStack(SequenceRowStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=1, max_accept=1)
        SequenceRowStack.__init__(self, x, y, game, **cap)

    def _isSequence(self, cards):
        return (isSameSuitSequence(cards, self.cap.mod, 1) or
                isSameSuitSequence(cards, self.cap.mod, -1))

    def getHelp(self):
        return _('Tableau. Build up or down by suit.')


# up or down by rank ignoring suit
class UD_RK_RowStack(SequenceRowStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=1, max_accept=1)
        SequenceRowStack.__init__(self, x, y, game, **cap)

    def _isSequence(self, cards):
        return (isRankSequence(cards, self.cap.mod, 1) or
                isRankSequence(cards, self.cap.mod, -1))

    def getHelp(self):
        return _('Tableau. Build up or down regardless of suit.')


# To simplify playing we also consider the number of free rows.
# See also the "SuperMove" section in the FreeCell FAQ.
class SuperMoveStack_StackMethods:
    def _getMaxMove(self, to_stack_ncards):
        max_move = getNumberOfFreeStacks(self.game.s.reserves) + 1
        if self.cap.base_rank != ANY_RANK:
            return max_move
        n = getNumberOfFreeStacks(self.game.s.rows)
        if to_stack_ncards == 0:
            n -= 1
        return max_move << max(n, 0)

    def _getNumSSSeq(self, cards):
        # num of same-suit sequences (for SuperMoveSpider_RowStack)
        if not cards:
            return 0
        n = 1
        suit = cards[-1].suit
        for c in cards[-2::-1]:
            if c.suit != suit:
                suit = c.suit
                n += 1
        return n


class SuperMoveSS_RowStack(SuperMoveStack_StackMethods, SS_RowStack):
    def canMoveCards(self, cards):
        if not SS_RowStack.canMoveCards(self, cards):
            return False
        return len(cards) <= self._getMaxMove(1)

    def acceptsCards(self, from_stack, cards):
        if not SS_RowStack.acceptsCards(self, from_stack, cards):
            return False
        return len(cards) <= self._getMaxMove(len(self.cards))


class SuperMoveAC_RowStack(SuperMoveStack_StackMethods, AC_RowStack):
    def canMoveCards(self, cards):
        if not AC_RowStack.canMoveCards(self, cards):
            return False
        return len(cards) <= self._getMaxMove(1)

    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        return len(cards) <= self._getMaxMove(len(self.cards))


class SuperMoveRK_RowStack(SuperMoveStack_StackMethods, RK_RowStack):
    def canMoveCards(self, cards):
        if not RK_RowStack.canMoveCards(self, cards):
            return False
        return len(cards) <= self._getMaxMove(1)

    def acceptsCards(self, from_stack, cards):
        if not RK_RowStack.acceptsCards(self, from_stack, cards):
            return False
        return len(cards) <= self._getMaxMove(len(self.cards))


class SuperMoveSC_RowStack(SuperMoveStack_StackMethods, SC_RowStack):
    def canMoveCards(self, cards):
        if not SC_RowStack.canMoveCards(self, cards):
            return False
        return len(cards) <= self._getMaxMove(1)

    def acceptsCards(self, from_stack, cards):
        if not SC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        return len(cards) <= self._getMaxMove(len(self.cards))


class SuperMoveBO_RowStack(SuperMoveStack_StackMethods, BO_RowStack):
    def canMoveCards(self, cards):
        if not BO_RowStack.canMoveCards(self, cards):
            return False
        return len(cards) <= self._getMaxMove(1)

    def acceptsCards(self, from_stack, cards):
        if not BO_RowStack.acceptsCards(self, from_stack, cards):
            return False
        return len(cards) <= self._getMaxMove(len(self.cards))


# ************************************************************************
# * WasteStack (a helper stack for the Talon, e.g. in Klondike)
# ************************************************************************

class WasteStack(OpenStack):
    def getHelp(self):
        return _('Waste.')


class WasteTalonStack(TalonStack):
    # A single click moves the top cards to the game's waste and
    # moves it face up; if we're out of cards, it moves the waste
    # back to the talon and increases the number of rounds (redeals).
    def __init__(self, x, y, game, max_rounds, num_deal=1, waste=None, **cap):
        TalonStack.__init__(self, x, y, game, max_rounds, num_deal, **cap)
        self.waste = waste

    def prepareStack(self):
        TalonStack.prepareStack(self)
        if self.waste is None:
            self.waste = self.game.s.waste

    def canDealCards(self):
        waste = self.waste
        if self.cards:
            num_cards = min(len(self.cards), self.num_deal)
            return len(waste.cards) + num_cards <= waste.cap.max_cards
        elif waste.cards and self.round != self.max_rounds:
            return True
        return False

    def dealCards(self, sound=False, shuffle=False):
        old_state = self.game.enterState(self.game.S_DEAL)
        num_cards = 0
        waste = self.waste
        if self.cards:
            if sound and not self.game.demo:
                self.game.playSample("dealwaste")
            num_cards = min(len(self.cards), self.num_deal)
            assert len(waste.cards) + num_cards <= waste.cap.max_cards
            for i in range(num_cards):
                if not self.cards[-1].face_up:
                    if 1:
                        self.game.flipAndMoveMove(self, waste)
                    else:
                        self.game.flipMove(self)
                        self.game.moveMove(1, self, waste, frames=4, shadow=0)
                else:
                    self.game.moveMove(1, self, waste, frames=4, shadow=0)
                self.fillStack()
                if TOOLKIT == 'kivy':
                    self.game.top.waitAnimation()
        elif waste.cards and self.round != self.max_rounds:
            if sound:
                self.game.playSample("turnwaste", priority=20)
            num_cards = len(waste.cards)
            self.game.turnStackMove(waste, self)
            if shuffle:
                # shuffle
                self.game.shuffleStackMove(self)
            self.game.nextRoundMove(self)
        self.game.leaveState(old_state)
        return num_cards

    def shuffleAndDealCards(self, sound=False):
        WasteTalonStack.dealCards(self, sound=sound, shuffle=True)


class FaceUpWasteTalonStack(WasteTalonStack):
    def canFlipCard(self):
        return len(self.cards) > 0 and not self.cards[-1].face_up

    def fillStack(self):
        if self.canFlipCard():
            self.game.singleFlipMove(self)
        self.game.fillStack(self)

    def dealCards(self, sound=False):
        retval = WasteTalonStack.dealCards(self, sound=sound)
        if self.canFlipCard():
            self.flipMove()
        return retval


class OpenTalonStack(TalonStack, OpenStack):
    canMoveCards = OpenStack.canMoveCards
    canDropCards = OpenStack.canDropCards
    releaseHandler = OpenStack.releaseHandler

    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=1)
        TalonStack.__init__(self, x, y, game, **cap)

    def canDealCards(self):
        return False

    def canFlipCard(self):
        return len(self.cards) > 0 and not self.cards[-1].face_up

    def fillStack(self):
        if self.canFlipCard():
            self.game.singleFlipMove(self)
        self.game.fillStack(self)

    def clickHandler(self, event):
        if self.canDealCards():
            return TalonStack.clickHandler(self, event)
        else:
            return OpenStack.clickHandler(self, event)


# ************************************************************************
# * ReserveStack (free cell)
# ************************************************************************

class ReserveStack(OpenStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_accept=1, max_cards=1)
        OpenStack.__init__(self, x, y, game, **cap)

    getBottomImage = Stack._getReserveBottomImage

    def getHelp(self):
        if self.cap.max_accept == 0:
            return _('Reserve. No building.')
        return _('Free cell.')


# ************************************************************************
# * InvisibleStack (an internal off-screen stack to hold cards)
# ************************************************************************

class InvisibleStack(Stack):
    def __init__(self, game, **cap):
        x, y = game.getInvisibleCoords()
        kwdefault(cap, max_move=0, max_accept=0)
        Stack.__init__(self, x, y, game, cap=cap)

    def assertStack(self):
        Stack.assertStack(self)
        assert not self.is_visible

    # no bindings
    def initBindings(self):
        pass

    # no bottom
    getBottomImage = Stack._getNoneBottomImage


# ************************************************************************
# * ArbitraryStack (stack with arbitrary access)
# *
# * NB: don't support hint and demo for non-top cards
# * NB: this stack only for CARD_XOFFSET == 0
# ************************************************************************

class ArbitraryStack(OpenStack):

    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_accept=0)
        OpenStack.__init__(self, x, y, game, **cap)
        self.CARD_YOFFSET = game.app.images.CARD_YOFFSET

    def canMoveCards(self, cards):
        return True

    def getDragCards(self, index):
        return [self.cards[index]]

    def startDrag(self, event, sound=True):
        OpenStack.startDrag(self, event, sound=sound)
        if self.game.app.opt.mouse_type == 'point-n-click':
            self.cards[self.game.drag.index].tkraise()
            self.game.drag.shadows[0].tkraise()
        else:
            for c in self.cards[self.game.drag.index+1:]:
                c.moveBy(0, -self.CARD_YOFFSET[0])

    def doubleclickHandler(self, event):
        # flip or drop a card
        flipstacks, dropstacks, quickstacks = self.game.getAutoStacks(event)
        if self in flipstacks and self.canFlipCard():
            self.playFlipMove(animation=True)
            return -1               # continue this event (start a drag)
        if self in dropstacks:
            i = self._findCard(event)
            if i < 0:
                return 0
            cards = [self.cards[i]]
            for s in self.game.s.foundations:
                if s is not self and s.acceptsCards(self, cards):
                    self.game.playSample("autodrop", priority=30)
                    self.playSingleCardMove(i, s, sound=False)
                    return 1
        return 0

    def moveCardsBackHandler(self, event, drag):
        i = self.cards.index(drag.cards[0])
        for card in self.cards[i:]:
            self._position(card)
            card.tkraise()

    def singleCardMove(self, index, to_stack, frames=-1, shadow=-1):
        self.game.singleCardMove(
            self, to_stack, index, frames=frames, shadow=shadow)
        self.fillStack()

    def dragMove(self, drag, to_stack, sound=True):
        self.playSingleCardMove(drag.index, to_stack, frames=0, sound=sound)

    def playSingleCardMove(self, index, to_stack, frames=-1, shadow=-1,
                           sound=True):
        if sound:
            if to_stack in self.game.s.foundations:
                self.game.playSample("drop", priority=30)
            else:
                self.game.playSample("move", priority=10)
        self.singleCardMove(index, to_stack, frames=frames, shadow=shadow)
        if not self.game.checkForWin():
            # let the player put cards back from the foundations
            if self not in self.game.s.foundations:
                self.game.autoPlay()
        self.game.finishMove()

    def quickPlayHandler(self, event, from_stacks=None, to_stacks=None):
        if to_stacks is None:
            to_stacks = self.game.s.foundations + self.game.sg.dropstacks
        if not self.cards:
            return 0
        #
        moves = []
        i = self._findCard(event)
        if i < 0:
            return 0
        pile = [self.cards[i]]
        for s in to_stacks:
            if s is not self and s.acceptsCards(self, pile):
                score = self.game.getQuickPlayScore(1, self, s)
                moves.append((score, -len(moves), i, s))
        #
        if moves:
            moves.sort()
            # from pprint import pprint; pprint(moves)
            score, len_moves, index, to_stack = moves[-1]
            if score >= 0:
                # self.game.playSample("startdrag")
                self.playSingleCardMove(index, to_stack)
                return 1
        return 0


# ************************************************************************
# * A StackWrapper is a functor (function object) that creates a
# * new stack when called, i.e. it wraps the constructor.
# *
# * "cap" are the capabilites, see class Stack above.
# ************************************************************************

# self.cap override any call-time cap
class StackWrapper:
    def __init__(self, stack_class, **cap):
        assert issubclass(stack_class, Stack)
        self.stack_class = stack_class
        self.cap = cap

    # return a new stack (an instance of the stack class)
    def __call__(self, x, y, game, **cap):
        # must preserve self.cap, so create a shallow copy
        c = self.cap.copy()
        kwdefault(c, **cap)
        return self.stack_class(x, y, game, **c)


# call-time cap override self.cap
class WeakStackWrapper(StackWrapper):
    def __call__(self, x, y, game, **cap):
        kwdefault(cap, **self.cap)
        return self.stack_class(x, y, game, **cap)


# self.cap only, call-time cap is completely ignored
class FullStackWrapper(StackWrapper):
    def __call__(self, x, y, game, **cap):
        return self.stack_class(x, y, game, **self.cap)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


import imp

import pysollib.settings
from pysollib.mfxutil import Struct, print_err
from pysollib.mygettext import _, n_
from pysollib.resource import CSI

import six

# ************************************************************************
# * constants
# ************************************************************************


# GameInfo constants
class GI:
    # game category - these *must* match the cardset CSI.TYPE_xxx
    GC_FRENCH = CSI.TYPE_FRENCH
    GC_HANAFUDA = CSI.TYPE_HANAFUDA
    GC_TAROCK = CSI.TYPE_TAROCK
    GC_MAHJONGG = CSI.TYPE_MAHJONGG
    GC_HEXADECK = CSI.TYPE_HEXADECK
    GC_MUGHAL_GANJIFA = CSI.TYPE_MUGHAL_GANJIFA
    GC_NAVAGRAHA_GANJIFA = CSI.TYPE_NAVAGRAHA_GANJIFA
    GC_DASHAVATARA_GANJIFA = CSI.TYPE_DASHAVATARA_GANJIFA
    GC_TRUMP_ONLY = CSI.TYPE_TRUMP_ONLY

    # game type
    GT_1DECK_TYPE = 0
    GT_2DECK_TYPE = 1
    GT_3DECK_TYPE = 2
    GT_4DECK_TYPE = 3
    GT_BAKERS_DOZEN = 4
    GT_BELEAGUERED_CASTLE = 5
    GT_CANFIELD = 6
    GT_DASHAVATARA_GANJIFA = 7
    GT_FAN_TYPE = 8
    GT_FORTY_THIEVES = 9
    GT_FREECELL = 10
    GT_GOLF = 11
    GT_GYPSY = 12
    GT_HANAFUDA = 13
    GT_HEXADECK = 14
    GT_KLONDIKE = 15
    GT_MAHJONGG = 16
    GT_MATRIX = 17
    GT_MEMORY = 18
    GT_MONTANA = 19
    GT_MUGHAL_GANJIFA = 20
    GT_NAPOLEON = 21
    GT_NAVAGRAHA_GANJIFA = 22
    GT_NUMERICA = 23
    GT_PAIRING_TYPE = 24
    GT_POKER_TYPE = 25
    GT_PUZZLE_TYPE = 26
    GT_RAGLAN = 27
    GT_ROW_TYPE = 28
    GT_SIMPLE_TYPE = 29
    GT_SPIDER = 30
    GT_TAROCK = 31
    GT_TERRACE = 32
    GT_YUKON = 33
    GT_SHISEN_SHO = 34
    GT_CUSTOM = 40
    # extra flags
    GT_BETA = 1 << 12      # beta version of game driver
    GT_CHILDREN = 1 << 13      # *not used*
    GT_CONTRIB = 1 << 14      # contributed games under the GNU GPL
    GT_HIDDEN = 1 << 15      # not visible in menus, but games can be loaded
    GT_OPEN = 1 << 16
    GT_ORIGINAL = 1 << 17
    GT_POPULAR = 1 << 18      # *not used*
    GT_RELAXED = 1 << 19
    GT_SCORE = 1 << 20      # game has some type of scoring
    GT_SEPARATE_DECKS = 1 << 21
    GT_XORIGINAL = 1 << 22      # original games by other people, not playable
    # skill level
    SL_LUCK = 1
    SL_MOSTLY_LUCK = 2
    SL_BALANCED = 3
    SL_MOSTLY_SKILL = 4
    SL_SKILL = 5
    #
    TYPE_NAMES = {
        GT_BAKERS_DOZEN:        n_("Baker's Dozen"),
        GT_BELEAGUERED_CASTLE:  n_("Beleaguered Castle"),
        GT_CANFIELD:            n_("Canfield"),
        GT_FAN_TYPE:            n_("Fan"),
        GT_FORTY_THIEVES:       n_("Forty Thieves"),
        GT_FREECELL:            n_("FreeCell"),
        GT_GOLF:                n_("Golf"),
        GT_GYPSY:               n_("Gypsy"),
        GT_KLONDIKE:            n_("Klondike"),
        GT_MONTANA:             n_("Montana"),
        GT_NAPOLEON:            n_("Napoleon"),
        GT_NUMERICA:            n_("Numerica"),
        GT_PAIRING_TYPE:        n_("Pairing"),
        GT_RAGLAN:              n_("Raglan"),
        GT_SIMPLE_TYPE:         n_("Simple games"),
        GT_SPIDER:              n_("Spider"),
        GT_TERRACE:             n_("Terrace"),
        GT_YUKON:               n_("Yukon"),
        GT_1DECK_TYPE:          n_("One-Deck games"),
        GT_2DECK_TYPE:          n_("Two-Deck games"),
        GT_3DECK_TYPE:          n_("Three-Deck games"),
        GT_4DECK_TYPE:          n_("Four-Deck games"),
    }

    #      SELECT_GAME_BY_TYPE = []
    #      for gt, name in TYPE_NAMES.items():
    #          if not name.endswith('games'):
    #              name = name+n_(' type')
    #          SELECT_GAME_BY_TYPE.append(
    #              (name, lambda gi, gt=gt: gi.si.game_type == gt))
    #      SELECT_GAME_BY_TYPE = tuple(SELECT_GAME_BY_TYPE)

    SELECT_GAME_BY_TYPE = (
        (n_("Baker's Dozen type"), lambda gi,
            gt=GT_BAKERS_DOZEN: gi.si.game_type == gt),
        (n_("Beleaguered Castle type"),
            lambda gi, gt=GT_BELEAGUERED_CASTLE: gi.si.game_type == gt),
        (n_("Canfield type"),
            lambda gi, gt=GT_CANFIELD: gi.si.game_type == gt),
        (n_("Fan type"), lambda gi, gt=GT_FAN_TYPE: gi.si.game_type == gt),
        (n_("Forty Thieves type"),
            lambda gi, gt=GT_FORTY_THIEVES: gi.si.game_type == gt),
        (n_("FreeCell type"),
            lambda gi, gt=GT_FREECELL: gi.si.game_type == gt),
        (n_("Golf type"), lambda gi, gt=GT_GOLF: gi.si.game_type == gt),
        (n_("Gypsy type"), lambda gi, gt=GT_GYPSY: gi.si.game_type == gt),
        (n_("Klondike type"),
            lambda gi, gt=GT_KLONDIKE: gi.si.game_type == gt),
        (n_("Montana type"), lambda gi, gt=GT_MONTANA: gi.si.game_type == gt),
        (n_("Napoleon type"),
            lambda gi, gt=GT_NAPOLEON: gi.si.game_type == gt),
        (n_("Numerica type"),
            lambda gi, gt=GT_NUMERICA: gi.si.game_type == gt),
        (n_("Pairing type"),
            lambda gi, gt=GT_PAIRING_TYPE: gi.si.game_type == gt),
        (n_("Raglan type"), lambda gi, gt=GT_RAGLAN: gi.si.game_type == gt),
        (n_("Simple games"),
            lambda gi, gt=GT_SIMPLE_TYPE: gi.si.game_type == gt),
        (n_("Spider type"), lambda gi, gt=GT_SPIDER: gi.si.game_type == gt),
        (n_("Terrace type"), lambda gi, gt=GT_TERRACE: gi.si.game_type == gt),
        (n_("Yukon type"), lambda gi, gt=GT_YUKON: gi.si.game_type == gt),
        (n_("One-Deck games"),
            lambda gi, gt=GT_1DECK_TYPE: gi.si.game_type == gt),
        (n_("Two-Deck games"),
            lambda gi, gt=GT_2DECK_TYPE: gi.si.game_type == gt),
        (n_("Three-Deck games"),
            lambda gi, gt=GT_3DECK_TYPE: gi.si.game_type == gt),
        (n_("Four-Deck games"),
            lambda gi, gt=GT_4DECK_TYPE: gi.si.game_type == gt),
    )

    SELECT_ORIGINAL_GAME_BY_TYPE = (
        (n_("French type"), lambda gi, gf=GT_ORIGINAL,
            gt=(
                GT_HANAFUDA,
                GT_HEXADECK, GT_MUGHAL_GANJIFA, GT_NAVAGRAHA_GANJIFA,
                GT_DASHAVATARA_GANJIFA, GT_TAROCK,): gi.si.game_flags & gf and
            gi.si.game_type not in gt),
        (n_("Ganjifa type"), lambda gi, gf=GT_ORIGINAL,
            gt=(GT_MUGHAL_GANJIFA, GT_NAVAGRAHA_GANJIFA,
                GT_DASHAVATARA_GANJIFA,): gi.si.game_flags & gf and
            gi.si.game_type in gt),
        (n_("Hanafuda type"), lambda gi, gf=GT_ORIGINAL, gt=GT_HANAFUDA:
            gi.si.game_flags & gf and gi.si.game_type == gt),
        (n_("Hex A Deck type"), lambda gi, gf=GT_ORIGINAL, gt=GT_HEXADECK:
            gi.si.game_flags & gf and gi.si.game_type == gt),
        (n_("Tarock type"), lambda gi, gf=GT_ORIGINAL, gt=GT_TAROCK:
            gi.si.game_flags & gf and gi.si.game_type == gt),
    )

    SELECT_CONTRIB_GAME_BY_TYPE = (
        (n_("French type"), lambda gi, gf=GT_CONTRIB,
            gt=(GT_HANAFUDA, GT_HEXADECK, GT_MUGHAL_GANJIFA,
                GT_NAVAGRAHA_GANJIFA, GT_DASHAVATARA_GANJIFA, GT_TAROCK,):
            gi.si.game_flags & gf and gi.si.game_type not in gt),
        (n_("Ganjifa type"), lambda gi, gf=GT_CONTRIB,
            gt=(GT_MUGHAL_GANJIFA, GT_NAVAGRAHA_GANJIFA,
                GT_DASHAVATARA_GANJIFA,):
            gi.si.game_flags & gf and gi.si.game_type in gt),
        (n_("Hanafuda type"), lambda gi, gf=GT_CONTRIB, gt=GT_HANAFUDA:
            gi.si.game_flags & gf and gi.si.game_type == gt),
        (n_("Hex A Deck type"), lambda gi, gf=GT_CONTRIB, gt=GT_HEXADECK:
            gi.si.game_flags & gf and gi.si.game_type == gt),
        (n_("Tarock type"), lambda gi, gf=GT_CONTRIB, gt=GT_TAROCK:
            gi.si.game_flags & gf and gi.si.game_type == gt),
    )

    SELECT_ORIENTAL_GAME_BY_TYPE = (
        (n_("Dashavatara Ganjifa type"), lambda gi, gt=GT_DASHAVATARA_GANJIFA:
            gi.si.game_type == gt),
        (n_("Ganjifa type"), lambda gi,
            gt=(GT_MUGHAL_GANJIFA, GT_NAVAGRAHA_GANJIFA,
                GT_DASHAVATARA_GANJIFA,): gi.si.game_type in gt),
        (n_("Hanafuda type"),
            lambda gi, gt=GT_HANAFUDA: gi.si.game_type == gt),
        (n_("Mughal Ganjifa type"),
            lambda gi, gt=GT_MUGHAL_GANJIFA: gi.si.game_type == gt),
        (n_("Navagraha Ganjifa type"),
            lambda gi, gt=GT_NAVAGRAHA_GANJIFA: gi.si.game_type == gt),
    )

    SELECT_SPECIAL_GAME_BY_TYPE = (
        (n_("Shisen-Sho"), lambda gi, gt=GT_SHISEN_SHO: gi.si.game_type == gt),
        (n_("Hex A Deck type"),
            lambda gi, gt=GT_HEXADECK: gi.si.game_type == gt),
        (n_("Matrix type"), lambda gi, gt=GT_MATRIX: gi.si.game_type == gt),
        (n_("Memory type"), lambda gi, gt=GT_MEMORY: gi.si.game_type == gt),
        (n_("Poker type"), lambda gi, gt=GT_POKER_TYPE: gi.si.game_type == gt),
        (n_("Puzzle type"),
            lambda gi, gt=GT_PUZZLE_TYPE: gi.si.game_type == gt),
        (n_("Tarock type"), lambda gi, gt=GT_TAROCK: gi.si.game_type == gt),
    )

    # These obsolete gameids have been used in previous versions of
    # PySol and are no longer supported because of internal changes
    # (mainly rule changes). The game has been assigned a new id.
    PROTECTED_GAMES = {
         22:  106,              # Double Canfield
         32:  901,              # La Belle Lucie (Midnight Oil)
         52:  903,              # Aces Up
         72:  115,              # Little Forty
         75:  126,              # Red and Black
         82:  901,              # La Belle Lucie (Midnight Oil)
         # 155: 5034,              # Mahjongg - Flying Dragon
         # 156: 5035,              # Mahjongg - Fortress Towers
         262:  105,              # Canfield
         902:   88,              # Trefoil
         904:   68,              # Lexington Harp
         297:  631,              # Alternation/Alternations
    }

    GAMES_BY_COMPATIBILITY = (
        # Atari ST Patience game v2.13 (we have 10 out of 10 games)
        ("Atari ST Patience", (1, 3, 4, 7, 12, 14, 15, 16, 17, 39,)),

        #  Gnome AisleRiot 1.0.51 (we have 28 out of 32 games)
        #    still missing: Camelot, Clock, Thieves, Thirteen
        # ("Gnome AisleRiot 1.0.51", (
        #     2, 8, 11, 19, 27, 29, 33, 34, 35, 40,
        #     41, 42, 43, 58, 59, 92, 93, 94, 95, 96,
        #     100, 105, 111, 112, 113, 130, 200, 201,
        # )),
        #  Gnome AisleRiot 1.4.0.1 (we have XX out of XX games)
        # ("Gnome AisleRiot", (
        #     1, 2, 8, 11, 19, 27, 29, 33, 34, 35, 40,
        #     41, 42, 43, 58, 59, 92, 93, 94, 95, 96,
        #     100, 105, 111, 112, 113, 130, 200, 201,
        # )),
        # Gnome AisleRiot 2.2.0 (we have 61 out of 70 games)
        #   still missing:
        #         Gay gordons, Helsinki,
        #         Isabel, Labyrinth, Quatorze, Thieves,
        #         Treize, Valentine, Yeld.
        ("Gnome AisleRiot", (
            1, 2, 8, 9, 11, 12, 19, 24, 27, 29, 31, 33, 34, 35, 36, 40,
            41, 42, 43, 45, 48, 58, 59, 67, 89, 91, 92, 93, 94, 95, 96,
            100, 105, 111, 112, 113, 130, 139, 144, 146, 147, 148, 200,
            201, 206, 224, 225, 229, 230, 233, 257, 258, 280, 281, 282,
            283, 284, 551, 552, 553, 737,
        )),

        #  KDE Patience 0.7.3 from KDE 1.1.2 (we have 6 out of 9 games)
        # ("KDE Patience 0.7.3", (2, 7, 8, 18, 256, 903,)),
        #  KDE Patience 2.0 from KDE 2.1.2 (we have 11 out of 13 games)
        # ("KDE Patience", (1, 2, 7, 8, 18, 19, 23, 50, 256, 261, 903,)),
        #  KDE Patience 2.0 from KDE 2.2beta1 (we have 12 out of 14 games)
        # ("KDE Patience", (1, 2, 7, 8, 18, 19, 23, 36, 50, 256, 261, 903,)),
        # KDE Patience 2.0 from KDE 3.1.1 (we have 15 out of 15 games)
        ("KDE Patience", (1, 2, 7, 8, 18, 19, 23, 36, 50,
                          256, 261, 277, 278, 279, 903,)),

        # xpat2 1.06 (we have 14 out of 16 games)
        #   still missing: Michael's Fantasy, modCanfield
        ("xpat2", (
            1, 2, 8, 9, 11, 31, 54, 63, 89, 105, 901, 256, 345, 903,
        )),
    )

    GAMES_BY_INVENTORS = (
        ("Paul Alfille", (8,)),
        ("C.L. Baker", (45,)),
        ("David Bernazzani", (314,)),
        ("Gordon Bower", (763,)),
        ("Art Cabral", (9,)),
        ("Robert Harbin", (381,)),
        ("Robert Hogue", (22216,)),
        ("Charles Jewell", (220, 309,)),
        ("Michael Keller", (592,)),
        ("Fred Lunde", (459,)),
        ("Albert Morehead and Geoffrey Mott-Smith", (25, 42, 48, 173, 282,
                                                     303, 362, 547, 738)),
        ("David Parlett", (64, 98, 294, 338, 654, 674,)),
        ("Randy Rasa", (187, 190, 191, 192,)),
        ("Captain Jeffrey T. Spaulding", (400,)),
        ("Adam Selene", (366,)),
        ("John Stoneham", (201,)),
        ("Bryan Stout", (655,)),
        ("Bill Taylor", (349,)),
        ("Thomas Warfield", (189, 264, 300, 320, 336, 337, 359,
                             415, 427, 458, 495, 496, 497, 508,)),
        )

    GAMES_BY_PYSOL_VERSION = (
        ("1.00", (1, 2, 3, 4)),
        ("1.01", (5, 6)),
        ("1.02", (7, 8, 9)),
        ("1.03", (10, 11, 12, 13)),
        ("1.10", (14,)),
        ("1.11", (15, 16, 17)),
        ("2.00", (256, 257)),
        ("2.01", (258, 259, 260, 261)),
        ("2.02", (105,)),
        ("2.90", (18, 19, 20, 21, 106, 23, 24, 25, 26, 27,
                  28, 29, 30, 31, 901, 33, 34, 35, 36)),
        ("2.99", (37,)),
        ("3.00", (38, 39,
                  40, 41, 42, 43,     45, 46, 47, 48, 49,
                  50, 51, 903, 53, 54, 55, 56, 57, 58, 59,
                  60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
                  70, 71, 115, 73, 74, 126, 76, 77, 78, 79,
                  80, 81,     83, 84, 85, 86, 87, 88, 89,
                  90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
                  100, 101, 102, 103, 104, 107, 108,)),
        ("3.10", (109, 110, 111, 112, 113, 114, 116, 117, 118, 119,
                  120, 121, 122, 123, 124, 125, 127)),
        ("3.20", (128, 129, 130, 131, 132, 133, 134, 135, 136, 137,
                  138, 139, 140, 141, 142,
                  12345, 12346, 12347, 12348, 12349, 12350, 12351, 12352)),
        ("3.21", (143, 144)),
        ("3.30", (145, 146, 147, 148, 149, 150, 151)),
        ("3.40", (152, 153, 154)),
        ("4.00", (157, 158, 159, 160, 161, 162, 163, 164)),
        ("4.20", (165, 166, 167, 168, 169, 170, 171, 172, 173, 174,
                  175, 176, 177, 178)),
        ("4.30", (179, 180, 181, 182, 183, 184)),
        ("4.41", (185, 186, 187, 188, 189, 190, 191, 192, 193, 194,
                  195, 196, 197, 198, 199)),
        ("4.60", (200, 201, 202, 203, 204, 205,
                  206, 207, 208, 209,
                  210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
                  220, 221, 222, 223, 224, 225, 226, 227, 228, 229,
                  230, 231, 232, 233, 234, 235, 236)),
        ("4.70", (237,)),
        ('fc-0.5.0', (  # moved from Ultrasol
                      # 121, 122, 187, 188, 189, 190, 191, 192, 194, 197, 198,
                      5301, 5302, 9011, 11001, 11002, 11003, 11004, 11005,
                      11006, 12353, 12354, 12355, 12356, 12357, 12358, 12359,
                      12360, 12361, 12362, 12363, 12364, 12365, 12366, 12367,
                      12368, 12369, 12370, 12371, 12372, 12373, 12374, 12375,
                      12376, 12377, 12378, 12379, 12380, 12381, 12382, 12383,
                      12384, 12385, 13001, 13002, 13003, 13004, 13005, 13006,
                      13007, 13008, 13009, 13010, 13011, 13012, 13013, 13014,
                      13163, 13164, 13165, 13166, 13167, 14401, 14402, 14403,
                      14404, 14405, 14406, 14407, 14408, 14409, 14410, 14411,
                      14412, 14413, 15406, 15407, 15408, 15409, 15410, 15411,
                      15412, 15413, 15414, 15415, 15416, 15417, 15418, 15419,
                      15420, 15421, 15422, 16000, 16001, 16002, 16003, 16004,
                      16666, 16667, 16668, 16669, 16670, 16671, 16672, 16673,
                      16674, 16675, 16676, 16677, 16678, 16679, 16680, 22216,
                      22223, 22224, 22225, 22226, 22227, 22228, 22229, 22230,
                      22231, 22232,)),
        ('fc-0.8.0', tuple(range(263, 323))),  # exclude 297
        ('fc-0.9.0', tuple(range(323, 421))),
        ('fc-0.9.1', tuple(range(421, 441))),
        ('fc-0.9.2', tuple(range(441, 466))),
        ('fc-0.9.3', tuple(range(466, 661))),
        ('fc-0.9.4', tuple(range(661, 671))),
        ('fc-1.0',   tuple(range(671, 711))),
        ('fc-1.1',   tuple(range(711, 759))),
        ('fc-2.0',   tuple(range(11011, 11014)) + tuple(range(759, 767))),
    )

    # deprecated - the correct way is to or a GI.GT_XXX flag
    # in the registerGame() call
    _CHILDREN_GAMES = [16, 33, 55, 90, 91, 96, 97, 176, 903, ]

    _OPEN_GAMES = []

    _POPULAR_GAMES = [
        1,     # Gypsy
        2,     # Klondike
        7,     # Picture Galary
        8,     # FreeCell
        9,     # Seahaven Towers
        11,    # Spider
        12,    # Braid
        13,    # Forty Thieves
        14,    # Grounds for a Divorce
        19,    # Yukon
        31,    # Baker's Dozen
        36,    # Golf
        38,    # Pyramid
        105,   # Canfield
        158,   # Imperial Trumps
        279,   # Kings
        903,   # Ace Up
        5034,  # Mahjongg Flying Dragon
        5401,  # Mahjongg Taipei
        12345,  # Oonsoo
    ]


# ************************************************************************
# * core games database
# ************************************************************************

class GameInfoException(Exception):
    pass


class GameInfo(Struct):
    def __init__(self, id, gameclass, name,
                 game_type, decks, redeals,
                 skill_level=None,
                 # keyword arguments:
                 si={}, category=0,
                 short_name=None, altnames=(),
                 suits=list(range(4)), ranks=list(range(13)), trumps=(),
                 rules_filename=None,
                 ):
        #
        def to_unicode(s):
            if isinstance(s, six.text_type):
                return s
            try:
                s = six.text_type(s, 'utf-8')
            except UnicodeDecodeError as err:
                print_err(err)
                s = six.text_type(s, 'utf-8', 'ignore')
            return s
        ncards = decks * (len(suits) * len(ranks) + len(trumps))
        game_flags = game_type & ~1023
        game_type = game_type & 1023
        name = to_unicode(name)
        en_name = name                  # for app.getGameRulesFilename
        if pysollib.settings.TRANSLATE_GAME_NAMES:
            name = _(name)
        if not short_name:
            short_name = name
        else:
            short_name = to_unicode(short_name)
            if pysollib.settings.TRANSLATE_GAME_NAMES:
                short_name = _(short_name)
        if isinstance(altnames, six.string_types):
            altnames = (altnames,)
        altnames = [to_unicode(n) for n in altnames]
        if pysollib.settings.TRANSLATE_GAME_NAMES:
            altnames = [_(n) for n in altnames]
        #
        if not (1 <= category <= 9):
            if game_type == GI.GT_HANAFUDA:
                category = GI.GC_HANAFUDA
            elif game_type == GI.GT_TAROCK:
                category = GI.GC_TAROCK
            elif game_type == GI.GT_MAHJONGG:
                category = GI.GC_MAHJONGG
            elif game_type == GI.GT_HEXADECK:
                category = GI.GC_HEXADECK
            elif game_type == GI.GT_MUGHAL_GANJIFA:
                category = GI.GC_MUGHAL_GANJIFA
            elif game_type == GI.GT_NAVAGRAHA_GANJIFA:
                category = GI.GC_NAVAGRAHA_GANJIFA
            elif game_type == GI.GT_DASHAVATARA_GANJIFA:
                category = GI.GC_DASHAVATARA_GANJIFA
            else:
                category = GI.GC_FRENCH
        #
        if not (1 <= id <= 999999):
            raise GameInfoException(name+": invalid game ID "+str(id))
        if category == GI.GC_MAHJONGG:
            if decks % 4:
                raise GameInfoException(name+": invalid number of decks " +
                                        str(id))
        else:
            if not (1 <= decks <= 4):
                raise GameInfoException(
                    name+": invalid number of decks "+str(id))
        if not name:
            raise GameInfoException(name+": invalid game name")
        if GI.PROTECTED_GAMES.get(id):
            raise GameInfoException(name+": protected game ID "+str(id))
        #
        for f, l in ((GI.GT_CHILDREN, GI._CHILDREN_GAMES),
                     (GI.GT_OPEN, GI._OPEN_GAMES),
                     (GI.GT_POPULAR, GI._POPULAR_GAMES)):
            if (game_flags & f) and (id not in l):
                l.append(id)
            elif not (game_flags & f) and (id in l):
                game_flags = game_flags | f
        # si is the SelectionInfo struct that will be queried by
        # the "select game" dialogs. It can be freely modified.
        gi_si = Struct(game_type=game_type, game_flags=game_flags,
                       decks=decks, redeals=redeals, ncards=ncards)
        gi_si.update(si)
        #
        Struct.__init__(self, id=id, gameclass=gameclass,
                        name=name, short_name=short_name,
                        altnames=tuple(altnames), en_name=en_name,
                        decks=decks, redeals=redeals, ncards=ncards,
                        category=category, skill_level=skill_level,
                        suits=tuple(suits), ranks=tuple(ranks),
                        trumps=tuple(trumps),
                        si=gi_si, rules_filename=rules_filename)


class GameManager:
    def __init__(self):
        self.__selected_key = -1
        self.__games = {}
        self.__gamenames = {}
        self.__games_by_id = None
        self.__games_by_name = None
        self.__games_by_short_name = None
        self.__games_by_altname = None
        self.__all_games = {}           # includes hidden games
        self.__all_gamenames = {}       # includes hidden games
        self.__games_for_solver = []
        self.check_game = True
        self.current_filename = None
        self.registered_game_types = {}
        self.callback = None            # update progress-bar (see main.py)
        self._num_games = 0             # for callback only

    def setCallback(self, func):
        self.callback = func

    def getSelected(self):
        return self.__selected_key

    def setSelected(self, gameid):
        assert gameid in self.__all_games
        self.__selected_key = gameid

    def get(self, key):
        return self.__all_games.get(key)

    def _check_game(self, gi):
        # print 'check game:', gi.id, gi.short_name.encode('utf-8')
        if gi.id in self.__all_games:
            raise GameInfoException("duplicate game ID %s: %s and %s" %
                                    (gi.id, str(gi.gameclass),
                                     str(self.__all_games[gi.id].gameclass)))
        if gi.name in self.__all_gamenames:
            gameclass = self.__all_gamenames[gi.name].gameclass
            raise GameInfoException("duplicate game name %s: %s and %s" %
                                    (gi.name, str(gi.gameclass),
                                     str(gameclass)))
        if 1:
            for id, game in self.__all_games.items():
                if gi.gameclass is game.gameclass:
                    raise GameInfoException(
                        "duplicate game class %s: %s and %s" %
                        (gi.id, str(gi.gameclass), str(game.gameclass)))
        for n in gi.altnames:
            if n in self.__all_gamenames:
                raise GameInfoException("duplicate game altname %s: %s" %
                                        (gi.id, n))

    def register(self, gi):
        # print gi.id, gi.short_name.encode('utf-8')
        if not isinstance(gi, GameInfo):
            raise GameInfoException("wrong GameInfo class")
        if self.check_game and pysollib.settings.CHECK_GAMES:
            self._check_game(gi)
        # if 0 and gi.si.game_flags & GI.GT_XORIGINAL:
        #     return
        # print gi.id, gi.name
        self.__all_games[gi.id] = gi
        self.__all_gamenames[gi.name] = gi
        for n in gi.altnames:
            self.__all_gamenames[n] = gi
        if not (gi.si.game_flags & GI.GT_HIDDEN):
            self.__games[gi.id] = gi
            self.__gamenames[gi.name] = gi
            for n in gi.altnames:
                self.__gamenames[n] = gi
            # invalidate sorted lists
            self.__games_by_id = None
            self.__games_by_name = None
            # update registry
            k = gi.si.game_type
            self.registered_game_types[k] = \
                self.registered_game_types.get(k, 0) + 1
#              if not gi.si.game_type == GI.GT_MAHJONGG:
#                  for v, k in GI.GAMES_BY_PYSOL_VERSION:
#                      if gi.id in k: break
#                  else:
#                      print gi.id
            if hasattr(gi.gameclass, 'Solver_Class') and \
               gi.gameclass.Solver_Class is not None:
                self.__games_for_solver.append(gi.id)
        if self.current_filename is not None:
            gi.gameclass.MODULE_FILENAME = self.current_filename

        if self.callback and self._num_games % 10 == 0:
            self.callback()
        self._num_games += 1

    #
    # access games database - we do not expose hidden games
    #

    def getAllGames(self):
        # return self.__all_games
        return list(self.__games.values())

    def getGamesIdSortedById(self):
        if self.__games_by_id is None:
            lst = list(self.__games.keys())
            lst.sort()
            self.__games_by_id = tuple(lst)
        return self.__games_by_id

    def getGamesIdSortedByName(self):
        if self.__games_by_name is None:
            l1, l2, l3 = [], [], []
            for id, gi in self.__games.items():
                name = gi.name  # .lower()
                l1.append((name, id))
                if gi.name != gi.short_name:
                    name = gi.short_name  # .lower()
                l2.append((name, id))
                for n in gi.altnames:
                    name = n  # .lower()
                    l3.append((name, id, n))
            l1.sort()
            l2.sort()
            l3.sort()
            self.__games_by_name = tuple([i[1] for i in l1])
            self.__games_by_short_name = tuple([i[1] for i in l2])
            self.__games_by_altname = tuple([i[1:] for i in l3])
        return self.__games_by_name

    def getGamesIdSortedByShortName(self):
        if self.__games_by_name is None:
            self.getGamesIdSortedByName()
        return self.__games_by_short_name

    # note: this contains tuples as entries
    def getGamesTuplesSortedByAlternateName(self):
        if self.__games_by_name is None:
            self.getGamesIdSortedByName()
        return self.__games_by_altname

    # find game by name
    def getGameByName(self, name):
        gi = self.__all_gamenames.get(name)
        if gi:
            return gi.id
        return None

    def getGamesForSolver(self):
        return self.__games_for_solver


# ************************************************************************
# *
# ************************************************************************

# the global game database (the single instance of class GameManager)
GAME_DB = GameManager()


def registerGame(gameinfo):
    GAME_DB.register(gameinfo)
    return gameinfo


def loadGame(modname, filename, check_game=False):
    # print "load game", modname, filename
    GAME_DB.check_game = check_game
    GAME_DB.current_filename = filename
    imp.load_source(modname, filename)
    # execfile(filename, globals(), globals())
    GAME_DB.current_filename = None
#! /usr/bin/env python
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright © 2019 Shlomi Fish <shlomif@cpan.org>
#
# Distributed under terms of the MIT license.

"""

"""


class NewStruct(object):
    """docstring for NewStruct"""
    def copy(self):
        ret = self.__class__()
        ret.__dict__.update(self.__dict__)
        return ret

    def addattr(self, **kw):
        for k in kw.keys():
            if k in self.__dict__:
                raise AttributeError(k)
        self.__dict__.update(kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


# imports
import re

import pysol_cards
assert getattr(pysol_cards, 'VERSION', (0, 0, 0)) >= (0, 8, 17), (
    "Newer version of https://pypi.org/project/pysol-cards is required.")
import pysol_cards.random  # noqa: I100
import pysol_cards.random_base  # noqa: I100
from pysol_cards.random import LCRandom31, match_ms_deal_prefix  # noqa: I100
from pysol_cards.random import CUSTOM_BIT, MS_LONG_BIT  # noqa: I100


class CustomRandom(pysol_cards.random_base.RandomBase):
    def __init__(self, seed=None):
        self.initial_seed = self.seed = MS_LONG_BIT | CUSTOM_BIT
        self.origin = self.ORIGIN_UNKNOWN
        self.setSeedAsStr('Custom')

    def reset(self):
        pass

    def shuffle(self, seq):
        pass


PysolRandom = pysol_cards.random.MTRandom


# ************************************************************************
# * PySol support code
# ************************************************************************


# construct Random from seed string
def constructRandom(s):
    if s == 'Custom':
        return CustomRandom()
    m = match_ms_deal_prefix(s)
    if m is not None:
        seed = m
        if 0 <= seed <= LCRandom31.MAX_SEED:
            ret = LCRandom31(seed)
            assert ret.seed
            assert ret.seedx
            assert ret.initial_seed
            # ret.setSeedAsStr(s)
            return ret
        else:
            raise ValueError("ms seed out of range")
    # cut off "L" from possible conversion to int
    s = re.sub(r"L$", "", str(s))
    s = re.sub(r"[\s\#\-\_\.\,]", "", s.lower())
    if not s:
        return None
    seed = int(s)
    if 0 <= seed < 32000:
        return LCRandom31(seed)
    # print("MTRandom", seed)
    ret = pysol_cards.random.MTRandom(seed)
    return ret


# test
if __name__ == '__main__':
    r = constructRandom('12345')
    print(r.randint(0, 100))
    print(r.random())
    print(type(r))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


import os
import re
import sys
import traceback
from pickle import UnpicklingError

import pysollib.app_stat
from pysollib.actions import PysolMenubar
from pysollib.actions import PysolToolbar
from pysollib.app_stat_result import GameStatResult
from pysollib.app_statistics import Statistics
from pysollib.gamedb import GAME_DB, GI, loadGame
from pysollib.help import destroy_help_html, help_about
from pysollib.images import Images, SubsampledImages
from pysollib.mfxutil import Struct, destruct
from pysollib.mfxutil import USE_PIL
from pysollib.mfxutil import getprefdir, getusername
from pysollib.mfxutil import latin1_normalize, print_err
from pysollib.mfxutil import pickle, unpickle
from pysollib.mygettext import _
from pysollib.options import Options
from pysollib.pysolrandom import PysolRandom, constructRandom
from pysollib.pysoltk import HTMLViewer
from pysollib.pysoltk import HelpStatusbar, PysolStatusbar
from pysollib.pysoltk import MfxDialog, MfxExceptionDialog, MfxMessageDialog
from pysollib.pysoltk import MfxScrolledCanvas, TclError
from pysollib.pysoltk import PysolProgressBar
from pysollib.pysoltk import SelectCardsetDialogWithPreview
from pysollib.pysoltk import SelectDialogTreeData
from pysollib.pysoltk import destroy_find_card_dialog
from pysollib.pysoltk import loadImage, wm_withdraw
from pysollib.resource import CSI, Cardset, CardsetConfig, CardsetManager
from pysollib.resource import Music, MusicManager
from pysollib.resource import Sample, SampleManager
from pysollib.resource import Tile, TileManager
from pysollib.settings import DEBUG
from pysollib.settings import PACKAGE, VERSION_TUPLE, WIN_SYSTEM
from pysollib.settings import TOOLKIT
from pysollib.util import IMAGE_EXTENSIONS
from pysollib.winsystems import TkSettings
if TOOLKIT == 'tk':
    from pysollib.ui.tktile.solverdialog import destroy_solver_dialog
else:
    from pysollib.pysoltk import destroy_solver_dialog
if TOOLKIT == 'kivy':
    import logging

_GameStatResult = GameStatResult
GameStat = pysollib.app_stat.GameStat


# ************************************************************************
# * Application
# * This is the glue between the toplevel window and a Game.
# * Also handles all global resources.
# ************************************************************************

image_ext_re_str = "(" + "|".join(
    ["(?:\\" + e + ")" for e in IMAGE_EXTENSIONS]) + ")$"
image_ext_re = re.compile(image_ext_re_str, re.I | re.U)


class Application:
    def __init__(self):
        self.gdb = GAME_DB
        self.opt = Options()
        self.startup_opt = self.opt.copy()
        self.stats = Statistics()
        self.splashscreen = 1
        # visual components
        self.top = None                 # the root toplevel window
        self.top_bg = None              # default background
        self.top_cursor = None          # default cursor
        self.menubar = None
        self.toolbar = None
        self.canvas = None              # MfxCanvas
        self.scrolled_canvas = None     # MfxScrolledCanvas
        self.statusbar = None
        #
        self.game = None
        self.dataloader = None
        self.audio = None
        self.images = None
        self.subsampled_images = None
        self.gimages = Struct(          # global images
            demo=[],                  # demo logos
            pause=[],                 # pause logos
            logos=[],
            redeal=[],
        )
        # self.progress_bg = None
        self.progress_images = []
        self.cardset_manager = CardsetManager()
        self.cardset = None             # current cardset
        self.cardsets_cache = {}
        self.tabletile_manager = TileManager()
        self.tabletile_index = 0        # current table tile
        self.sample_manager = SampleManager()
        self.music_manager = MusicManager()
        self.music_playlist = []
        self.intro = Struct(
            progress=None,            # progress bar
        )
        # directory names
        config = os.path.normpath(getprefdir(PACKAGE))
        self.dn = Struct(
            config=config,
            plugins=os.path.join(config, "plugins"),
            savegames=os.path.join(config, "savegames"),
            maint=os.path.join(config, "maint"),          # debug
        )
        for k, v in self.dn.__dict__.items():
            #             if os.name == "nt":
            #                 v = os.path.normcase(v)
            v = os.path.normpath(v)
            self.dn.__dict__[k] = v
        # file names
        self.fn = Struct(
            opt=os.path.join(self.dn.config, "options.dat"),
            opt_cfg=os.path.join(self.dn.config, "options.cfg"),
            stats=os.path.join(self.dn.config, "statistics.dat"),
            holdgame=os.path.join(self.dn.config, "holdgame.dat"),
            comments=os.path.join(self.dn.config, "comments.dat"),
        )
        for k, v in self.dn.__dict__.items():
            if os.name == "nt":
                v = os.path.normcase(v)
            v = os.path.normpath(v)
            self.fn.__dict__[k] = v
        # random generators
        self.gamerandom = PysolRandom()
        self.miscrandom = PysolRandom()
        # player
        player = getusername()
        if not player:
            player = "unknown"
        player = player[:30]
        self.opt.player = player
        # misc
        self.nextgame = Struct(
            id=0,                     # start this game
            random=None,              # use this random generator
            loadedgame=None,          # data for loaded game
            startdemo=0,              # start demo ?
            cardset=None,             # use this cardset
            holdgame=0,               # hold this game on exit ?
            bookmark=None,            # goto this bookmark (load new cardset)
        )
        self.commandline = Struct(
            loadgame=None,            # load a game ?
            game=None,
            gameid=None,
            deal=None,
        )
        self.demo_counter = 0

    # the PySol mainloop
    def mainloop(self):
        try:
            approc = self.mainproc()  # setup process
            approc.send(None)				# and go
        except StopIteration:
            pass

    def gameproc(self):
        while True:
            logging.info('App: gameproc waiting for game to start')
            (id_, random) = yield
            logging.info('App: game started {},{}'.format(id_, random))
            self.runGame(id_, random)

    def _load_held_or_saved_game(self, tmpgame):
        """docstring for _load_held_or_saved_game"""
        if self.opt.game_holded > 0 and not self.nextgame.loadedgame:
            game = None
            try:
                game = tmpgame._loadGame(self.fn.holdgame, self)
            except Exception:
                traceback.print_exc()
                game = None
            if game:
                if game.id == self.opt.game_holded and game.gstats.holded:
                    game.gstats.loaded = game.gstats.loaded - 1
                    game.gstats.holded = 0
                    self.nextgame.loadedgame = game
                else:
                    # not a holded game
                    game.destruct()
                    destruct(game)

    def _main_loop(self):
        """docstring for _main_loop"""
        try:
            # this is the mainloop
            while 1:
                assert self.cardset is not None
                id_, random = self.nextgame.id, self.nextgame.random
                self.nextgame.id, self.nextgame.random = 0, None
                try:
                    if TOOLKIT == 'kivy':
                        self.gproc.send((id_, random))
                        logging.info('App: sent for game to start')
                        yield
                        logging.info('App: game proc stopped')
                    else:
                        self.runGame(id_, random)
                except Exception:
                    # try Klondike if current game fails
                    if id_ == 2:
                        raise           # internal error?
                    if DEBUG:
                        raise
                    traceback.print_exc()
                    self.nextgame.id = 2
                    self.freeGame()
                    continue
                if self.nextgame.holdgame:
                    assert self.nextgame.id <= 0
                    try:
                        self.game.gstats.holded = 1
                        self.game._saveGame(self.fn.holdgame)
                        self.opt.game_holded = self.game.id
                    except Exception:
                        traceback.print_exc()
                        pass
                self.wm_save_state()
                # save game geometry
                geom = (self.canvas.winfo_width(), self.canvas.winfo_height())
                if self.opt.save_games_geometry and not self.opt.wm_maximized:
                    self.opt.games_geometry[self.game.id] = geom
                self.opt.game_geometry = geom
                self.freeGame()
                #
                if self.nextgame.id <= 0:
                    break
                # load new cardset
                if self.nextgame.cardset is not self.cardset:
                    self.loadCardset(
                        self.nextgame.cardset, id=self.nextgame.id,
                        update=7+256)
                else:
                    self.requestCompatibleCardsetType(self.nextgame.id)

        except Exception:
            traceback.print_exc()
            pass

        finally:
            # hide main window
            self.wm_withdraw()
            #
            destroy_help_html()
            destroy_find_card_dialog()
            destroy_solver_dialog()
            # update options
            self.opt.last_gameid = id_
            # save options
            try:
                self.saveOptions()
            except Exception:
                traceback.print_exc()
                pass
            # save statistics
            try:
                self.saveStatistics()
            except Exception:
                traceback.print_exc()
                pass
            # shut down audio
            try:
                self.audio.destroy()
            except Exception:
                traceback.print_exc()
                pass
            if TOOLKIT == 'kivy':
                self.top.quit()
                while True:
                    logging.info('App: mainloop end position')
                    yield

    def mainproc(self):
        # copy startup options
        self.startup_opt = self.opt.copy()
        # try to load statistics
        try:
            self.loadStatistics()
        except Exception:
            traceback.print_exc()
            pass
        # startup information
        if self.getGameClass(self.opt.last_gameid):
            self.nextgame.id = self.opt.last_gameid
        # load a holded or saved game
        tmpgame = self.constructGame(self.gdb.getGamesIdSortedByName()[0])
        self._load_held_or_saved_game(tmpgame)
        if not self.nextgame.loadedgame:
            if self.commandline.loadgame:
                try:
                    self.nextgame.loadedgame = tmpgame._loadGame(
                        self.commandline.loadgame, self)
                    self.nextgame.loadedgame.gstats.holded = 0
                except Exception:
                    traceback.print_exc()
                    self.nextgame.loadedgame = None
            elif self.commandline.game is not None:
                gameid = self.gdb.getGameByName(self.commandline.game)
                if gameid is None:
                    print_err(_("can't find game: %(game)s") % {
                        'game': self.commandline.game})
                    sys.exit(-1)
                else:
                    self.nextgame.id = gameid
                    deal = self.commandline.deal
                    self.nextgame.random = \
                        None if deal is None else constructRandom(deal)
            elif self.commandline.gameid is not None:
                self.nextgame.id, self.nextgame.random = \
                    self.commandline.gameid, None
        self.opt.game_holded = 0
        tmpgame.destruct()
        destruct(tmpgame)
        tmpgame = None
        #
        # widgets
        #
        # create the menubar
        if self.intro.progress:
            self.intro.progress.update(step=1)
        self.menubar = PysolMenubar(self, self.top,
                                    progress=self.intro.progress)
        # create the statusbar(s)
        self.statusbar = PysolStatusbar(self.top)
        self.statusbar.show(self.opt.statusbar)
        self.statusbar.config('gamenumber', self.opt.statusbar_game_number)
        self.statusbar.config('stuck', self.opt.statusbar_stuck)
        self.helpbar = HelpStatusbar(self.top)
        self.helpbar.show(self.opt.helpbar)
        # create the canvas
        self.scrolled_canvas = MfxScrolledCanvas(self.top, propagate=True)
        self.canvas = self.scrolled_canvas.canvas
        padx, pady = TkSettings.canvas_padding
        self.scrolled_canvas.grid(row=1, column=1, sticky='nsew',
                                  padx=padx, pady=pady)
        self.top.grid_columnconfigure(1, weight=1)
        self.top.grid_rowconfigure(1, weight=1)
        self.setTile(self.tabletile_index, force=True)
        # create the toolbar
        dirname = self.getToolbarImagesDir()
        self.toolbar = PysolToolbar(self.top, self.menubar, dir=dirname,
                                    size=self.opt.toolbar_size,
                                    relief=self.opt.toolbar_relief,
                                    compound=self.opt.toolbar_compound)
        self.toolbar.show(self.opt.toolbar)
        if TOOLKIT == 'tk':
            for w, v in self.opt.toolbar_vars.items():
                self.toolbar.config(w, v)
        #
        if self.intro.progress:
            self.intro.progress.update(step=1)
        #

        if TOOLKIT == 'kivy':
            self.gproc = self.gameproc()
            self.gproc.send(None)
        return self._main_loop()

    def runGame(self, id_, random=None):
        self.top.connectApp(self)
        # create game instance
        g = self.getGameClass(id_)
        if g is None:
            id_ = 2          # start Klondike as default game
            random = None
            g = self.getGameClass(id_)
            if g is None:
                # start first available game
                id_ = self.gdb.getGamesIdSortedByName()[0]
                g = self.getGameClass(id_)
        gi = self.getGameInfo(id_)
        assert gi is not None and gi.id == id_
        self.game = self.constructGame(id_)
        self.gdb.setSelected(id_)
        self.game.busy = 1
        # create stacks and layout
        self.game.create(self)
        # connect with game
        self.menubar.connectGame(self.game)
        if self.toolbar:  # ~
            self.toolbar.connectGame(self.game)
        self.game.updateStatus(player=self.opt.player)
        # update "Recent games" menubar entry
        if id_ in self.opt.recent_gameid:
            self.opt.recent_gameid.remove(id_)
        self.opt.recent_gameid.insert(0, id_)
        del self.opt.recent_gameid[self.opt.num_recent_games:]
        self.menubar.updateRecentGamesMenu(self.opt.recent_gameid)
        self.menubar.updateFavoriteGamesMenu()
        # hide/show "Shuffle" button
        self.toolbar.config(
            'shuffle',
            self.opt.toolbar_vars['shuffle'] and self.game.canShuffle())
        # delete intro progress bar
        if self.intro.progress:
            self.intro.progress.destroy()
            destruct(self.intro.progress)
            self.intro.progress = None
        # prepare game
        autoplay = 0
        if self.nextgame.loadedgame is not None:
            self.stats.gameid_balance = 0
            self.game.restoreGame(self.nextgame.loadedgame)
            destruct(self.nextgame.loadedgame)
        elif self.nextgame.bookmark is not None:
            self.game.restoreGameFromBookmark(self.nextgame.bookmark)
        else:
            self.stats.gameid_balance = 0
            self.game.newGame(random=random, autoplay=0)
            autoplay = 1
        self.nextgame.loadedgame = None
        self.nextgame.bookmark = None
        # splash screen
        if self.opt.splashscreen and self.splashscreen > 0:
            status = help_about(self, timeout=20000, sound=0)
            if status == 2:                 # timeout - start a demo
                if autoplay:
                    self.nextgame.startdemo = 1
        self.splashscreen = 0
        # start demo/autoplay
        if self.nextgame.startdemo:
            self.nextgame.startdemo = 0
            self.game.startDemo()
            self.game.createDemoInfoText()
        elif autoplay:
            self.game.autoPlay()
            self.game.stats.player_moves = 0
        # enter the Tk mainloop
        self.game.busy = 0
        self.top.mainloop()

    # free game
    def freeGame(self):
        # disconnect from game
        self.menubar.connectGame(None)
        self.toolbar.connectGame(None)
        # clean up the canvas
        self.canvas.deleteAllItems()
        self.canvas.update_idletasks()
        # destruct the game
        if self.game:
            self.game.destruct()
            destruct(self.game)
        self.game = None
        self.top.connectApp(None)

    #
    # UI support
    #

    def wm_save_state(self):
        if self.top:
            s = self.top.wm_state()
            # print "wm_save_state", s
            if s == "zoomed":  # Windows only
                self.opt.wm_maximized = True
            elif s == "normal":
                self.opt.wm_maximized = False

    def wm_withdraw(self):
        if self.intro.progress:
            self.intro.progress.destroy()
            destruct(self.intro.progress)
            self.intro.progress = None
        if self.top:
            wm_withdraw(self.top)
            self.top.busyUpdate()

    def loadImages1(self):
        # load dialog images
        dirname = os.path.join("images", "logos")
        for f in ("joker07_40_774",
                  "joker08_40_774",
                  "joker07_50_774",
                  "joker08_50_774",
                  "joker11_100_774",
                  "joker10_100",):
            self.gimages.logos.append(self.dataloader.findImage(f, dirname))
        if WIN_SYSTEM == 'win32':
            dirname = os.path.join('images', 'dialog', 'default')
        else:
            dirname = os.path.join('images', 'dialog', 'bluecurve')
        for f in ('error', 'info', 'question', 'warning'):
            fn = self.dataloader.findImage(f, dirname)
            im = loadImage(fn)
            MfxMessageDialog.img[f] = im

        # load button images
        if 0 and TOOLKIT == 'tk':
            dirname = os.path.join('images', 'buttons', 'bluecurve')
            for n, f in (
                (_('&OK'), 'ok'),
                (_('&Cancel'), 'cancel'),
                (_('&New game'), 'new'),
            ):
                fn = self.dataloader.findImage(f, dirname)
                im = loadImage(fn)
                MfxDialog.button_img[n] = im

    def loadImages2(self):
        # load canvas images
        dirname = "images"
        # for f in ("noredeal", "redeal",):
        for f in ("stopsign", "redeal",):
            self.gimages.redeal.append(self.dataloader.findImage(f, dirname))
        dirname = os.path.join("images", "demo")
        for f in ("demo01", "demo02", "demo03", "demo04", "demo05",):
            self.gimages.demo.append(self.dataloader.findImage(f, dirname))
        dirname = os.path.join("images", "pause")
        for f in ("pause01", "pause02", "pause03",):
            self.gimages.pause.append(self.dataloader.findImage(f, dirname))
        # dirname = os.path.join("images", "stats")
        # for f in ("barchart",):
        #     self.gimages.stats.append(self.dataloader.findImage(f, dirname))

    def loadImages3(self):
        # load treeview images
        SelectDialogTreeData.img = []
        dirname = os.path.join('images', 'tree')
        for f in ('folder', 'openfolder', 'node', 'emptynode'):
            fn = self.dataloader.findImage(f, dirname)
            im = loadImage(fn)
            SelectDialogTreeData.img.append(im)

        # load htmlviewer images
        dirname = os.path.join('images', 'htmlviewer')
        fn = self.dataloader.findImage('disk', dirname)
        HTMLViewer.symbols_fn['disk'] = fn

    def loadImages4(self):
        # load all remaining images
        for k, v in self.gimages.__dict__.items():
            if isinstance(v, list):
                for i in range(len(v)):
                    if isinstance(v[i], str):
                        v[i] = loadImage(v[i])
                        if self.intro.progress:
                            self.intro.progress.update(step=1)
                self.gimages.__dict__[k] = tuple(v)

    def _getImagesDir(self, *dirs, **kwargs):
        check = kwargs.get('check', True)
        dirs = [str(d) for d in dirs]   # XXX: don't use unicode
        d = os.path.join(self.dataloader.dir, 'images', *dirs)
        if check:
            if os.path.exists(d):
                return d
            return None
        return d

    def getFindCardImagesDir(self):
        return self._getImagesDir('cards')

    def getToolbarImagesDir(self):
        if self.opt.toolbar_size:
            size = 'large'
        else:
            size = 'small'
        style = self.opt.toolbar_style
        if TOOLKIT == 'kivy':
            size = 'xlarge'
            style = 'bluecurve'
        d = self._getImagesDir('toolbar', style, size)
        if d:
            return d
        return self._getImagesDir('toolbar', 'default', size, check=False)

    def setTile(self, i, force=0):
        if self.scrolled_canvas.setTile(self, i, force):
            tile = self.tabletile_manager.get(i)
            if i == 0:
                self.opt.colors['table'] = tile.color
                self.opt.tabletile_name = None
            else:
                self.opt.tabletile_name = tile.basename
            self.tabletile_index = i
            self.tabletile_manager.setSelected(i)
            return True
        return False

    def getFont(self, name):
        return self.opt.fonts.get(name)

    #
    # cardset
    #

    def updateCardset(self, id=0, update=7):
        cs = self.images.cs
        self.cardset = cs
        self.nextgame.cardset = cs
        # update settings
        self.cardset_manager.setSelected(cs.index)
        # update options
        self.images.setNegative(self.opt.negative_bottom)
        self.subsampled_images.setNegative(self.opt.negative_bottom)
        if update & 1:
            self.opt.cardset[0] = (cs.name, cs.backname)
        if update & 2:
            self.opt.cardset[cs.si.type] = (cs.name, cs.backname)
        gi = self.getGameInfo(id)
        if gi:
            if update & 256:
                try:
                    del self.opt.cardset[(1, gi.id)]
                except KeyError:
                    pass
            t = self.checkCompatibleCardsetType(gi, cs)
            if not t[1]:
                if update & 4:
                    self.opt.cardset[gi.category] = (cs.name, cs.backname)
                if update & 8:
                    self.opt.cardset[(1, gi.id)] = (cs.name, cs.backname)
        # from pprint import pprint; pprint(self.opt.cardset)

    def loadCardset(self, cs, id=0, update=7, progress=None):
        # print 'loadCardset', cs.ident
        r = 0
        if cs is None or cs.error:
            return 0
        if cs is self.cardset:
            self.updateCardset(id, update=update)
            return 1
        # cache carsets
        # self.cardsets_cache:
        #   key: Cardset.type
        #   value: (Cardset.ident, Images, SubsampledImages)
        c = self.cardsets_cache.get(cs.type)
        if c and c[0] == cs.ident:
            # print 'load from cache', c
            self.images, self.subsampled_images = c[1], c[2]
            self.updateCardset(id, update=update)
            if self.menubar is not None:
                self.menubar.updateBackgroundImagesMenu()
            return 1
        #
        if progress is None:
            self.wm_save_state()
            self.wm_withdraw()
            title = _("Loading cardset %s...") % cs.name
            color = self.opt.colors['table']
            if self.tabletile_index > 0:
                color = "#008200"
            progress = PysolProgressBar(self, self.top, title=title,
                                        color=color,
                                        images=self.progress_images)
        images = Images(self.dataloader, cs)
        try:
            if not images.load(app=self, progress=progress):
                raise Exception("Invalid or damaged cardset")
            simages = SubsampledImages(images)
            if self.opt.save_cardsets:
                c = self.cardsets_cache.get(cs.type)
                if c:
                    # c[1].destruct()
                    destruct(c[1])
                self.cardsets_cache[cs.type] = (cs.ident, images, simages)
            elif self.images is not None:
                # self.images.destruct()
                destruct(self.images)
            #
            if self.cardset:
                if self.cardset.ident != cs.ident:
                    if self.cardset.type == cs.type:
                        # clear saved games geometry
                        self.opt.games_geometry = {}
            # update
            self.images = images
            self.subsampled_images = simages
            self.updateCardset(id, update=update)
            r = 1
        except (Exception, TclError, UnpicklingError) as ex:
            traceback.print_exc()
            cs.error = 1
            # restore settings
            self.nextgame.cardset = self.cardset
            if self.cardset:
                self.cardset_manager.setSelected(self.cardset.index)
            # images.destruct()
            destruct(images)
            MfxExceptionDialog(
                self.top, ex, title=_("Cardset load error"),
                text=_("Error while loading cardset"))
        self.intro.progress = progress
        if r and self.menubar is not None:
            self.menubar.updateBackgroundImagesMenu()
        return r

    def checkCompatibleCardsetType(self, gi, cs):
        assert gi is not None
        assert cs is not None
        gc = gi.category
        cs_type = cs.si.type
        t0, t1 = None, None
        if gc == GI.GC_FRENCH:
            t0 = "French"
            if cs_type not in (CSI.TYPE_FRENCH,
                               # CSI.TYPE_TAROCK,
                               ):
                t1 = t0
        elif gc == GI.GC_HANAFUDA:
            t0 = "Hanafuda"
            if cs_type not in (CSI.TYPE_HANAFUDA,):
                t1 = t0
        elif gc == GI.GC_TAROCK:
            t0 = "Tarock"
            if cs_type not in (CSI.TYPE_TAROCK,):
                t1 = t0
        elif gc == GI.GC_MAHJONGG:
            t0 = "Mahjongg"
            if cs_type not in (CSI.TYPE_MAHJONGG,):
                t1 = t0
        elif gc == GI.GC_HEXADECK:
            t0 = "Hex A Deck"
            if cs_type not in (CSI.TYPE_HEXADECK,):
                t1 = t0
        elif gc == GI.GC_MUGHAL_GANJIFA:
            t0 = "Mughal Ganjifa"
            if cs_type not in (CSI.TYPE_MUGHAL_GANJIFA,
                               CSI.TYPE_NAVAGRAHA_GANJIFA,
                               CSI.TYPE_DASHAVATARA_GANJIFA,):
                t1 = t0
        elif gc == GI.GC_NAVAGRAHA_GANJIFA:
            t0 = "Navagraha Ganjifa"
            if cs_type not in (CSI.TYPE_NAVAGRAHA_GANJIFA,
                               CSI.TYPE_DASHAVATARA_GANJIFA,):
                t1 = t0
        elif gc == GI.GC_DASHAVATARA_GANJIFA:
            t0 = "Dashavatara Ganjifa"
            if cs_type not in (CSI.TYPE_DASHAVATARA_GANJIFA,):
                t1 = t0
        elif gc == GI.GC_TRUMP_ONLY:
            t0 = "Trump only"
            if cs_type not in (CSI.TYPE_TRUMP_ONLY,):
                t1 = t0
            elif len(cs.trumps) < gi.ncards:    # not enough cards
                t1 = t0
        else:
            # we should not come here
            t0 = t1 = "Unknown"
        return t0, t1

    def getCompatibleCardset(self, gi, cs):
        if gi is None:
            return cs, 1
        # try current
        if cs:
            t = self.checkCompatibleCardsetType(gi, cs)
            if not t[1]:
                return cs, 1
        # try by gameid / category
        for key, flag in (((1, gi.id), 8), (gi.category, 4)):
            c = self.opt.cardset.get(key)
            if not c or len(c) != 2:
                continue
            cs = self.cardset_manager.getByName(c[0])
            if not cs:
                continue
            t = self.checkCompatibleCardsetType(gi, cs)
            if not t[1]:
                cs.updateCardback(backname=c[1])
                return cs, flag
        # ask
        return None, 0

    def requestCompatibleCardsetType(self, id):
        gi = self.getGameInfo(id)
        #
        cs, cs_update_flag = self.getCompatibleCardset(gi, self.cardset)
        if cs is self.cardset:
            return 0
        if cs is not None:
            self.loadCardset(cs, update=1)
            return 1
        #
        t = self.checkCompatibleCardsetType(gi, self.cardset)
        MfxMessageDialog(
            self.top, title=_("Incompatible cardset"),
            bitmap="warning",
            text=_('''The currently selected cardset %(cardset)s
is not compatible with the game
%(game)s

Please select a %(correct_type)s type cardset.
''') % {'cardset': self.cardset.name, 'game': gi.name, 'correct_type': t[0]},
            strings=(_("&OK"),), default=0)
        cs = self.__selectCardsetDialog(t)
        if cs is None:
            return -1
        self.loadCardset(cs, id=id)
        return 1

    def selectCardset(self, title, key):
        d = SelectCardsetDialogWithPreview(
            self.top, title=title, app=self,
            manager=self.cardset_manager, key=key)
        cs = self.cardset_manager.get(d.key)
        if d.status != 0 or d.button != 0 or d.key < 0 or cs is None:
            return None
        changed = False
        if USE_PIL:
            if (self.opt.scale_x, self.opt.scale_y,
                self.opt.auto_scale, self.opt.preserve_aspect_ratio) != \
                d.scale_values or \
                    (cs.CARD_XOFFSET, cs.CARD_YOFFSET) != d.cardset_values:
                changed = True
        if d.key == self.cardset.index and not changed:
            return None
        if USE_PIL:
            (self.opt.scale_x,
             self.opt.scale_y,
             self.opt.auto_scale,
             self.opt.preserve_aspect_ratio) = d.scale_values
            if not self.opt.auto_scale:
                self.images.resize(self.opt.scale_x, self.opt.scale_y)
            if d.cardset_values:
                cs.CARD_XOFFSET, cs.CARD_YOFFSET = d.cardset_values
                self.opt.offsets[cs.ident] = d.cardset_values
                self.images.setOffsets()
        return cs

    def __selectCardsetDialog(self, t):
        cs = self.selectCardset(
            _("Please select a %s type cardset") % t[0],
            self.cardset.index)
        return cs

    #
    # load & save options, and statistics
    #

    def loadOptions(self):
        self.opt.setDefaults(self.top)
        if os.path.exists(self.fn.opt):
            # for backwards compatibility
            opt = unpickle(self.fn.opt)
            if opt:
                self.opt.__dict__.update(opt.__dict__)
            try:
                os.remove(self.fn.opt)
            except Exception:
                pass
        self.opt.load(self.fn.opt_cfg)
        self.opt.setConstants()

    def loadStatistics(self):
        if not os.path.exists(self.fn.stats):
            return
        stats = unpickle(self.fn.stats)
        if stats:
            # print "loaded:", stats.__dict__
            self.stats.__dict__.update(stats.__dict__)
        # start a new session
        self.stats.session_games = {}
        self.stats.session_balance = {}
        self.stats.gameid_balance = 0

    def __saveObject(self, obj, fn):
        obj.version_tuple = VERSION_TUPLE
        obj.saved += 1
        pickle(obj, fn, protocol=-1)

    def saveOptions(self):
        self.opt.save(self.fn.opt_cfg)

    def saveStatistics(self):
        self.__saveObject(self.stats, self.fn.stats)

    #
    # access games database
    #

    def constructGame(self, id):
        gi = self.gdb.get(id)
        if gi is None:
            raise Exception("Unknown game (id %d)" % id)
        return gi.gameclass(gi)

    def getGamesIdSortedById(self):
        return self.gdb.getGamesIdSortedById()

    def getGamesIdSortedByName(self, player=''):
        return self.gdb.getGamesIdSortedByName()

    ##
    def getGamesIdSortedByPlayed(self, player=''):
        if player == '':
            player = self.opt.player

        def _key(a):
            wa, la, ta, ma = self.stats.getFullStats(player, a)
            return wa+la
        games = list(self.gdb.getGamesIdSortedByName())
        games.sort(key=_key)
        return games[::-1]

    def getGamesIdSortedByWon(self, player=''):
        if player == '':
            player = self.opt.player

        def _key(a):
            wa, la, ta, ma = self.stats.getFullStats(player, a)
            return wa
        games = list(self.gdb.getGamesIdSortedByName())
        games.sort(key=_key)
        return games[::-1]

    def getGamesIdSortedByLost(self, player=''):
        if player == '':
            player = self.opt.player

        def _key(a):
            wa, la, ta, ma = self.stats.getFullStats(player, a)
            return la
        games = list(self.gdb.getGamesIdSortedByName())
        games.sort(key=_key)
        return games[::-1]

    def getGamesIdSortedByPercent(self, player=''):
        if player == '':
            player = self.opt.player

        def _key(a):
            wa, la, ta, ma = self.stats.getFullStats(player, a)
            return float(wa)/(1 if wa+la == 0 else wa+la)
        games = list(self.gdb.getGamesIdSortedByName())
        games.sort(key=_key)
        return games[::-1]

    def getGamesIdSortedByPlayingTime(self, player=''):
        if player == '':
            player = self.opt.player

        def _key(a):
            wa, la, ta, ma = self.stats.getFullStats(player, a)
            return ta
        games = list(self.gdb.getGamesIdSortedByName())
        games.sort(key=_key)
        return games[::-1]

    def getGamesIdSortedByMoves(self, player=''):
        if player == '':
            player = self.opt.player

        def _key(a):
            wa, la, ta, ma = self.stats.getFullStats(player, a)
            return ma
        games = list(self.gdb.getGamesIdSortedByName())
        games.sort(key=_key)
        return games[::-1]

    def getGameInfo(self, id):
        return self.gdb.get(id)

    def getGameClass(self, id):
        gi = self.gdb.get(id)
        if gi is None:
            return None
        return gi.gameclass

    def getGameTitleName(self, id):
        gi = self.gdb.get(id)
        if gi is None:
            return None
        return gi.name

    def getGameMenuitemName(self, id):
        gi = self.gdb.get(id)
        if gi is None:
            return None
        return gi.short_name

    def getGameRulesFilename(self, id):
        gi = self.gdb.get(id)
        if gi is None:
            return None
        if gi.rules_filename is not None:
            return gi.rules_filename
        n = latin1_normalize(gi.en_name) + '.html'        # english name
        f = os.path.join(self.dataloader.dir, "html", "rules", n)
        if not os.path.exists(f):
            n = ''
        gi.rules_filename = n    # cache the filename for next use
        return n

    def getGameSaveName(self, id):
        if os.path.supports_unicode_filenames:
            return self.getGameTitleName(id)
        n = self.gdb.get(id).en_name                  # english name
        if not n:
            return None
        return re.sub(r"[\s]", "_", latin1_normalize(n))

    def _choice(self, lst):
        return self.miscrandom.choice(lst)

    def chooseRandomOutOfGames(self, games):
        return self._choice(games)

    def getRandomGameId(self):
        return self._choice(self.gdb.getGamesIdSortedById())

    def getAllUserNames(self):
        names = []
        for n in self.stats.games_stats.keys():
            if n is None:               # demo
                continue
            if self.stats.games_stats[n]:
                names.append(n)
        if self.opt.player not in names:
            names.append(self.opt.player)
        names.sort()
        return names

    def getGamesForSolver(self):
        return self.gdb.getGamesForSolver()

    #
    # plugins
    #

    def loadPlugins(self, dirname):
        for name in self._my_list_dir(dirname):
            m = re.search(r"^(.+)\.py$", name)
            n = os.path.join(dirname, name)
            if m and os.path.isfile(n):
                try:
                    loadGame(m.group(1), n)
                except Exception as ex:
                    if DEBUG:
                        traceback.print_exc()
                    print_err(_("error loading plugin %(file)s: %(err)s") %
                              {'file': n, 'err': ex})

    #
    # init cardsets
    #

    # read & parse a cardset config.txt file - see class Cardset in resource.py
    def _readCardsetConfig(self, dirname, filename):
        with open(filename, "r") as f:
            lines = f.readlines()
        lines = [l.strip() for l in lines]
        if not lines[0].startswith("PySol"):
            return None
        config = CardsetConfig()
        if not self._parseCardsetConfig(config, lines):
            # print filename, 'invalid config'
            return None
        if config.CARDD > self.top.winfo_screendepth():
            return None
        cs = Cardset()
        cs.dir = dirname
        cs.update(config.__dict__)
        return cs

    def _parseCardsetConfig(self, cs, line):
        def perr(line, field=None, msg=''):
            if not DEBUG:
                return
            if field:
                print_err('_parseCardsetConfig error: line #%d, field #%d %s'
                          % (line, field, msg))
            else:
                print_err('_parseCardsetConfig error: line #%d: %s'
                          % (line, msg))
        if len(line) < 6:
            perr(1, msg='number of lines')
            return 0
        # line[0]: magic identifier, possible version information
        fields = [f.strip() for f in line[0].split(';')]
        if len(fields) >= 2:
            m = re.search(r"^(\d+)$", fields[1])
            if m:
                cs.version = int(m.group(1))
        if cs.version >= 3:
            if len(fields) < 5:
                perr(1, msg='number of fields')
                return 0
            cs.ext = fields[2]
            m = re.search(r"^(\d+)$", fields[3])
            if not m:
                perr(1, 3, 'not integer')
                return 0
            cs.type = int(m.group(1))
            m = re.search(r"^(\d+)$", fields[4])
            if not m:
                perr(1, 4, 'not integer')
                return 0
            cs.ncards = int(m.group(1))
        if cs.version >= 4:
            if len(fields) < 6:
                perr(1, msg='number of fields')
                return 0
            styles = fields[5].split(",")
            for s in styles:
                m = re.search(r"^\s*(\d+)\s*$", s)
                if not m:
                    perr(1, 5, 'not integer')
                    return 0
                s = int(m.group(1))
                if s not in cs.styles:
                    cs.styles.append(s)
        if cs.version >= 5:
            if len(fields) < 7:
                perr(1, msg='number of fields')
                return 0
            m = re.search(r"^(\d+)$", fields[6])
            if not m:
                perr(1, 6, 'not integer')
                return 0
            cs.year = int(m.group(1))
        if len(cs.ext) < 2 or cs.ext[0] != ".":
            perr(1, msg='invalid extention')
            return 0
        # line[1]: identifier/name
        if not line[1]:
            perr(2, msg='empty line')
            return 0
        cs.ident = line[1]
        m = re.search(r"^(.*;)?([^;]+)$", cs.ident)
        if not m:
            perr(2, msg='invalid format')
            return 0
        cs.name = m.group(2).strip()
        # line[2]: CARDW, CARDH, CARDD
        m = re.search(r"^(\d+)\s+(\d+)\s+(\d+)", line[2])
        if not m:
            perr(3, msg='invalid format')
            return 0
        cs.CARDW, cs.CARDH, cs.CARDD = \
            int(m.group(1)), int(m.group(2)), int(m.group(3))
        # line[3]: CARD_UP_YOFFSET, CARD_DOWN_YOFFSET,
        # SHADOW_XOFFSET, SHADOW_YOFFSET
        m = re.search(r"^(\d+)\s+(\d+)\s+(\d+)\s+(\d+)", line[3])
        if not m:
            perr(4, msg='invalid format')
            return 0
        cs.CARD_XOFFSET = int(m.group(1))
        cs.CARD_YOFFSET = int(m.group(2))
        cs.SHADOW_XOFFSET = int(m.group(3))
        cs.SHADOW_YOFFSET = int(m.group(4))
        # line[4]: default background
        back = line[4]
        if not back:
            perr(5, msg='empty line')
            return 0
        # line[5]: all available backgrounds
        cs.backnames = [f.strip() for f in line[5].split(';')]
        if back in cs.backnames:
            cs.backindex = cs.backnames.index(back)
        else:
            cs.backnames.insert(0, back)
            cs.backindex = 0
        # set offsets from options.cfg
        if cs.ident in self.opt.offsets:
            cs.CARD_XOFFSET, cs.CARD_YOFFSET = self.opt.offsets[cs.ident]
        # if cs.type != 1: print cs.type, cs.name
        return 1

    def initCardsets(self):
        manager = self.cardset_manager
        # find all available cardsets
        dirs = manager.getSearchDirs(self, ("cardsets", ""), "PYSOL_CARDSETS")
        if DEBUG:
            dirs += manager.getSearchDirs(self, "cardsets-*")
        # print dirs
        found, t = [], {}
        fnames = {}  # (to check for duplicates)
        for dirname in dirs:
            dirname = dirname.strip()
            try:
                names = []
                if dirname and os.path.isdir(dirname) and dirname not in t:
                    t[dirname] = 1
                    names = os.listdir(dirname)
                    names.sort()
                for name in names:
                    if not name.startswith('cardset-'):
                        continue
                    d = os.path.join(dirname, name)
                    if not os.path.isdir(d):
                        continue
                    f = os.path.join(d, "config.txt")
                    if os.path.isfile(f):
                        try:
                            cs = self._readCardsetConfig(d, f)
                            if cs:
                                # from pprint import pprint
                                # print cs.name
                                # pprint(cs.__dict__)
                                back = cs.backnames[cs.backindex]
                                f1 = os.path.join(d, back)
                                f2 = os.path.join(d, "shade" + cs.ext)
                                if (cs.ext in IMAGE_EXTENSIONS and
                                        cs.name not in fnames and
                                        os.path.isfile(f1) and
                                        os.path.isfile(f2)):
                                    found.append(cs)
                                    # print '+', cs.name
                                    fnames[cs.name] = 1
                            else:
                                print_err('fail _readCardsetConfig: %s %s'
                                          % (d, f))
                                pass
                        except Exception:
                            # traceback.print_exc()
                            pass
            except EnvironmentError:
                pass
        # register cardsets
        for obj in found:
            if not manager.getByName(obj.name):
                manager.register(obj)
                # print obj.index, obj.name

    #
    # init tiles
    #
    def _init_tiles_process_dir(self, dirname, found, t):
        """docstring for _init_tiles_process_die"""
        names = []
        if dirname and os.path.isdir(dirname):
            names = os.listdir(dirname)
        for name in names:
            if not name or not image_ext_re.search(name):
                continue
            f = os.path.join(dirname, name)
            if not os.path.isfile(f):
                continue
            tile = Tile()
            tile.filename = f
            n = image_ext_re.sub("", name)
            if os.path.split(dirname)[-1] == 'stretch':
                tile.stretch = 1
            if os.path.split(dirname)[-1] == 'save-aspect':
                tile.stretch = 1
                tile.save_aspect = 1
            # n = re.sub("[-_]", " ", n)
            n = n.replace('_', ' ')
            tile.name = n
            key = n.lower()
            if key not in t:
                t.add(key)
                found.append((n, tile))

    def initTiles(self):
        manager = self.tabletile_manager
        # find all available tiles
        dirs = manager.getSearchDirs(
            self,
            ("tiles-*",
                os.path.join("tiles", "stretch"),
                os.path.join("tiles", "save-aspect")),
            "PYSOL_TILES")
        # print dirs
        found, t = [], set()
        for dirname in dirs:
            try:
                self._init_tiles_process_dir(dirname, found, t)
            except EnvironmentError:
                pass
        # register tiles
        found.sort()
        for f in found:
            obj = f[1]
            if not manager.getByName(obj.name):
                manager.register(obj)

    def _my_list_dir(self, dirname):
        """docstring for _my_list_dir"""
        if dirname and os.path.isdir(dirname):
            names = os.listdir(dirname)
            names = list(map(os.path.normcase, names))
            names.sort()
            return names
        else:
            return []

    #
    # init samples / music
    #

    def initResource(self, manager, dirs, ext_re, Resource_Class):
        found, t = [], set()
        for dirname in dirs:
            dirname = dirname.strip()
            if dirname:
                dirname = os.path.normpath(dirname)
            try:
                for name in self._my_list_dir(dirname):
                    if not name or not ext_re.search(name):
                        continue
                    f = os.path.join(dirname, name)
                    f = os.path.normpath(f)
                    if not os.path.isfile(f):
                        continue
                    obj = Resource_Class()
                    obj.filename = f
                    n = ext_re.sub("", name.strip())
                    obj.name = n
                    key = n.lower()
                    if key not in t:
                        t.add(key)
                        found.append((n, obj))
            except EnvironmentError:
                pass
        # register songs
        found.sort()
        if manager:
            for f in found:
                obj = f[1]
                if not manager.getByName(obj.name):
                    manager.register(obj)
        return found

    def initSamples(self):
        manager = self.sample_manager
        # find all available samples
        dirs = manager.getSearchDirs(
            self, ("sound", os.path.join("sound", "extra")))
        # print dirs
        ext_re = re.compile(r"\.((wav))$", re.I)
        self.initResource(manager, dirs, ext_re, Sample)

    def initMusic(self):
        manager = self.music_manager
        # find all available music songs
        dirs = manager.getSearchDirs(self, "music-*", "PYSOL_MUSIC")
        # print dirs
        ext_re = re.compile(self.audio.EXTENSIONS)
        self.initResource(manager, dirs, ext_re, Music)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mygettext import n_

presets = {
    'None': {
        'preset': 'None',
        'name': n_('My Game'),
        },

    'Klondike': {
        'preset': 'Klondike',
        'name': n_('My Klondike'),
        'layout': 'Klondike',
        'talon': 'Deal to waste',
        'redeals': 'Unlimited redeals',
        'rows_num': 7,
        'rows_base_card': 'King',
        'reserves_num': 0,
        'deal_type': 'Triangle',
        'deal_face_down': 6,
        'deal_face_up': 1,
        },

    'FreeCell': {
        'preset': 'FreeCell',
        'name': n_('My FreeCell'),
        'skill_level': 'Mostly skill',
        'rows_max_move': 'Top card',
        'rows_super_move': 1,
        'deal_face_up': 6,
        },

    'Spider': {
        'preset': 'Spider',
        'name': n_('My Spider'),
        'skill_level': 'Mostly skill',
        'decks': 'Two',
        'layout': 'Klondike',
        'talon': 'Spider',
        'found_type': 'Spider same suit',
        'found_max_move': 'None',
        'rows_num': 10,
        'rows_type': 'Spider same suit',
        'reserves_num': 0,
        'deal_face_down': 5,
        'deal_face_up': 1,
        'deal_max_cards': 54,
        },

    'Gypsy': {
        'preset': 'Gypsy',
        'name': n_('My Gypsy'),
        'skill_level': 'Mostly skill',
        'decks': 'Two',
        'layout': 'Gypsy',
        'talon': 'Deal to tableau',
        'found_max_move': 'None',
        'reserves_num': 0,
        'deal_face_down': 2,
        'deal_face_up': 1,
        },

    'Grounds for a Divorce': {
        'preset': 'Grounds for a Divorce',
        'name': n_('My Grounds for a Divorce'),
        'skill_level': 'Mostly skill',
        'decks': 'Two',
        'layout': 'Harp',
        'talon': 'Grounds for a Divorce',
        'found_type': 'Spider same suit',
        'found_base_card': 'Any',
        'found_equal': 0,
        'rows_num': 10,
        'rows_type': 'Spider same suit',
        'rows_wrap': 1,
        'reserves_num': 0,
        'deal_face_up': 5,
        },

    'Double Klondike': {
        'preset': 'Double Klondike',
        'name': n_('My Double Klondike'),
        'decks': 'Two',
        'layout': 'Harp',
        'talon': 'Deal to waste',
        'redeals': 'Unlimited redeals',
        'rows_num': 9,
        'rows_base_card': 'King',
        'reserves_num': 0,
        'deal_type': 'Triangle',
        'deal_face_down': 8,
        'deal_face_up': 1,
        },

    'Simple Simon': {
        'preset': 'Simple Simon',
        'name': n_('My Simple Simon'),
        'skill_level': 'Mostly skill',
        'found_type': 'Spider same suit',
        'found_max_move': 'None',
        'rows_num': 10,
        'rows_type': 'Spider same suit',
        'reserves_num': 0,
        'deal_type': 'Triangle',
        },

}
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.app_stat import GameStat
from pysollib.settings import VERSION_TUPLE


class Statistics:
    def __init__(self):
        self.version_tuple = VERSION_TUPLE
        self.saved = 0
        # a dictionary of dictionaries of GameStat (keys: player and gameid)
        self.games_stats = {}
        # a dictionary of lists of tuples (key: player)
        self.prev_games = {}
        self.all_prev_games = {}
        self.session_games = {}
        # some simple balance scores (key: gameid)
        self.total_balance = {}     # a dictionary of integers
        self.session_balance = {}   # reset per session
        self.gameid_balance = 0     # reset when changing the gameid

    def new(self):
        return Statistics()

    #
    # player & demo statistics
    #

    def resetStats(self, player, gameid):
        self.__resetPrevGames(player, self.prev_games, gameid)
        self.__resetPrevGames(player, self.session_games, gameid)
        if player not in self.games_stats:
            return
        if gameid == 0:
            # remove all games
            try:
                del self.games_stats[player]
            except KeyError:
                pass
        else:
            try:
                del self.games_stats[player][gameid]
            except KeyError:
                pass

    def __resetPrevGames(self, player, games, gameid):
        if player not in games:
            return
        if gameid == 0:
            del games[player]
        else:
            games[player] = [g for g in games[player] if g[0] != gameid]

    def getStats(self, player, gameid):
        # returned (won, lost)
        return self.getFullStats(player, gameid)[:2]

    def getFullStats(self, player, gameid):
        # returned (won, lost, playing time, moves)
        stats = self.games_stats
        if player in stats and gameid in stats[player]:
            s = self.games_stats[player][gameid]
            return (s.num_won+s.num_perfect,
                    s.num_lost,
                    s.time_result.average,
                    s.moves_result.average,)
        return (0, 0, 0, 0)

    def getSessionStats(self, player, gameid):
        games = self.session_games.get(player, [])
        games = [g for g in games if g[0] == gameid]
        won = len([g for g in games if g[2] > 0])
        lost = len([g for g in games if g[2] == 0])
        return won, lost

    def updateStats(self, player, game, status):
        ret = None
        log = (game.id, game.getGameNumber(format=0), status,
               game.gstats.start_time, game.gstats.total_elapsed_time,
               VERSION_TUPLE, game.getGameScore(), game.getGameScoreCasino(),
               game.GAME_VERSION)
        # full log
        if status >= 0:
            if player is None:
                # demo
                ret = self.updateGameStat(player, game, status)
            else:
                # player
                if player not in self.prev_games:
                    self.prev_games[player] = []
                self.prev_games[player].append(log)
                if player not in self.all_prev_games:
                    self.all_prev_games[player] = []
                self.all_prev_games[player].append(log)
                ret = self.updateGameStat(player, game, status)
        # session log
        if player not in self.session_games:
            self.session_games[player] = []
        self.session_games[player].append(log)
        return ret

    def updateGameStat(self, player, game, status):
        #
        if player not in self.games_stats:
            self.games_stats[player] = {}
        if game.id not in self.games_stats[player]:
            game_stat = GameStat(game.id)
            self.games_stats[player][game.id] = game_stat
        else:
            game_stat = self.games_stats[player][game.id]
        if 'all' not in self.games_stats[player]:
            all_games_stat = GameStat('all')
            self.games_stats[player]['all'] = all_games_stat
        else:
            all_games_stat = self.games_stats[player]['all']
        all_games_stat.update(game, status)
        return game_stat.update(game, status)

#      def __setstate__(self, state):      # for backward compatible
#          if 'gameid' not in state:
#              self.gameid = None
#          self.__dict__.update(state)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.settings import TOOLKIT, USE_TILE

if TOOLKIT == 'tk':
    from pysollib.ui.tktile.tkconst import *  # noqa: F401,F403
    from pysollib.ui.tktile.tkutil import *  # noqa: F401,F403
    from pysollib.ui.tktile.card import *  # noqa: F401,F403
    from pysollib.ui.tktile.tkcanvas import *  # noqa: F401,F403
    from pysollib.ui.tktile.tkwrap import *  # noqa: F401,F403
    from pysollib.ui.tktile.findcarddialog import *  # noqa: F401,F403
    if USE_TILE:
        from pysollib.tile.tkwidget import *  # noqa: F401,F403
        from pysollib.tile.tkhtml import *  # noqa: F401,F403
        from pysollib.tile.edittextdialog import *  # noqa: F401,F403
        from pysollib.tile.tkstats import *  # noqa: F401,F403
        from pysollib.tile.playeroptionsdialog import *  # noqa: F401,F403
        from pysollib.tile.soundoptionsdialog import *  # noqa: F401,F403
        from pysollib.tile.timeoutsdialog import *  # noqa: F401,F403
        from pysollib.tile.colorsdialog import *  # noqa: F401,F403
        from pysollib.tile.fontsdialog import *  # noqa: F401,F403
        from pysollib.tile.solverdialog import *  # noqa: F401,F403
        from pysollib.tile.gameinfodialog import *  # noqa: F401,F403
        from pysollib.tile.toolbar import *  # noqa: F401,F403
        from pysollib.tile.statusbar import *  # noqa: F401,F403
        from pysollib.tile.progressbar import *  # noqa: F401,F403
        from pysollib.tile.menubar import *  # noqa: F401,F403
        from pysollib.tile.selectcardset import *  # noqa: F401,F403
        from pysollib.tile.selecttree import *  # noqa: F401,F403
    else:
        from pysollib.tk.tkwidget import *  # noqa: F401,F403
        from pysollib.tk.tkhtml import *  # noqa: F401,F403
        from pysollib.tk.edittextdialog import *  # noqa: F401,F403
        from pysollib.tk.tkstats import *  # noqa: F401,F403
        from pysollib.tk.playeroptionsdialog import *  # noqa: F401,F403
        from pysollib.tk.soundoptionsdialog import *  # noqa: F401,F403
        from pysollib.tk.timeoutsdialog import *  # noqa: F401,F403
        from pysollib.tk.colorsdialog import *  # noqa: F401,F403
        from pysollib.tk.fontsdialog import *  # noqa: F401,F403
        from pysollib.tk.solverdialog import *  # noqa: F401,F403
        from pysollib.tk.gameinfodialog import *  # noqa: F401,F403
        from pysollib.tk.toolbar import *  # noqa: F401,F403
        from pysollib.tk.statusbar import *  # noqa: F401,F403
        from pysollib.tk.progressbar import *  # noqa: F401,F403
        from pysollib.tk.menubar import *  # noqa: F401,F403
        from pysollib.tk.selectcardset import *  # noqa: F401,F403
        from pysollib.tk.selecttree import *  # noqa: F401,F403

elif TOOLKIT == 'kivy':
    from pysollib.kivy.tkconst import *  # noqa: F401,F403
    from pysollib.kivy.tkutil import *  # noqa: F401,F403
    from pysollib.kivy.card import *  # noqa: F401,F403
    from pysollib.kivy.tkcanvas import *  # noqa: F401,F403
    from pysollib.kivy.tkwrap import *  # noqa: F401,F403
    from pysollib.kivy.findcarddialog import *  # noqa: F401,F403
    from pysollib.kivy.tkwidget import *  # noqa: F401,F403
    from pysollib.kivy.tkhtml import *  # noqa: F401,F403
    from pysollib.kivy.edittextdialog import *  # noqa: F401,F403
    from pysollib.kivy.tkstats import *  # noqa: F401,F403
    from pysollib.kivy.playeroptionsdialog import *  # noqa: F401,F403
    # from pysollib.kivy.soundoptionsdialog import *  # noqa: F401,F403
    from pysollib.kivy.timeoutsdialog import *  # noqa: F401,F403
    from pysollib.kivy.colorsdialog import *  # noqa: F401,F403
    from pysollib.kivy.fontsdialog import *  # noqa: F401,F403
    from pysollib.kivy.solverdialog import *  # noqa: F401,F403
    from pysollib.kivy.gameinfodialog import *  # noqa: F401,F403
    from pysollib.kivy.toolbar import *  # noqa: F401,F403
    from pysollib.kivy.statusbar import *  # noqa: F401,F403
    from pysollib.kivy.progressbar import *  # noqa: F401,F403
    from pysollib.kivy.menubar import *  # noqa: F401,F403
    from pysollib.kivy.selectcardset import *  # noqa: F401,F403
    from pysollib.kivy.selecttree import *  # noqa: F401,F403

else:  # gtk
    from pysollib.pysolgtk.tkconst import *  # noqa: F401,F403
    from pysollib.pysolgtk.tkutil import *  # noqa: F401,F403
    from pysollib.pysolgtk.tkcanvas import *  # noqa: F401,F403
    from pysollib.pysolgtk.tkwrap import *  # noqa: F401,F403
    from pysollib.pysolgtk.tkwidget import *  # noqa: F401,F403
    from pysollib.pysolgtk.tkhtml import *  # noqa: F401,F403
    from pysollib.pysolgtk.edittextdialog import *  # noqa: F401,F403
    from pysollib.pysolgtk.tkstats import *  # noqa: F401,F403
    from pysollib.pysolgtk.playeroptionsdialog import *  # noqa: F401,F403
    from pysollib.pysolgtk.soundoptionsdialog import *  # noqa: F401,F403
    from pysollib.pysolgtk.timeoutsdialog import *  # noqa: F401,F403
    from pysollib.pysolgtk.colorsdialog import *  # noqa: F401,F403
    from pysollib.pysolgtk.fontsdialog import *  # noqa: F401,F403
    from pysollib.pysolgtk.findcarddialog import *  # noqa: F401,F403
    from pysollib.pysolgtk.solverdialog import *  # noqa: F401,F403
    from pysollib.pysolgtk.gameinfodialog import *  # noqa: F401,F403
    from pysollib.pysolgtk.toolbar import *  # noqa: F401,F403
    from pysollib.pysolgtk.statusbar import *  # noqa: F401,F403
    from pysollib.pysolgtk.progressbar import *  # noqa: F401,F403
    from pysollib.pysolgtk.menubar import *  # noqa: F401,F403
    from pysollib.pysolgtk.card import *  # noqa: F401,F403
    from pysollib.pysolgtk.selectcardset import *  # noqa: F401,F403
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# imports
import os
try:
    import site
except Exception:
    class Dummy:
        def __init__(self):
            self.PREFIXES = []
    site = Dummy()
import sys

# PySol imports
from pysollib.mfxutil import Image
from pysollib.mygettext import _
from pysollib.settings import DATA_DIRS, TOOLKIT

# ************************************************************************
# * constants
# ************************************************************************

# Suits values are 0-3. This maps to colors 0-1.
SUITS = (_("Club"), _("Spade"), _("Heart"), _("Diamond"))
COLORS = (_("black"), _("red"))

# Card ranks are 0-12.  We also define symbolic names for the picture cards.
RANKS = (_("Ace"), "2", "3", "4", "5", "6", "7", "8", "9", "10",
         _("Jack"), _("Queen"), _("King"))
ACE = 0
JACK = 10
QUEEN = 11
KING = 12

# Special values for Stack.cap:
ANY_SUIT = -1
ANY_COLOR = -1
ANY_RANK = -1
NO_SUIT = 999999            # no card can ever match this suit
NO_COLOR = 999999           # no card can ever match this color
NO_RANK = 999999            # no card can ever match this rank
UNLIMITED_MOVES = 999999    # for max_move
UNLIMITED_ACCEPTS = 999999  # for max_accept
UNLIMITED_CARDS = 999999    # for max_cards
#
NO_REDEAL = 0
UNLIMITED_REDEALS = -1
VARIABLE_REDEALS = -2

CARDSET = _("cardset")

IMAGE_EXTENSIONS = (".gif", ".ppm", ".png")
if 1 and os.name == "nt":
    IMAGE_EXTENSIONS = (".png", ".gif", ".ppm", ".jpg",)
    pass

if Image:
    IMAGE_EXTENSIONS = (".png", ".gif", ".jpg", ".ppm", ".bmp")

if TOOLKIT == 'kivy':
    IMAGE_EXTENSIONS = (".png", ".bmp", ".ppm", ".jpg", ".tiff")

# ************************************************************************
# * DataLoader
# ************************************************************************


class DataLoader:
    def __init__(self, argv0, filenames, path=[]):
        self.dir = None
        if isinstance(filenames, str):
            filenames = (filenames,)
        assert isinstance(filenames, (tuple, list))
        # init path
        path = path[:]
        head, tail = os.path.split(argv0)
        if not head:
            head = os.curdir
        # dir where placed startup script
        path.append(head)
        path.append(os.path.join(head, "data"))
        path.append(os.path.join(head, os.pardir, "data"))
        # dir where placed pysol package
        path.append(os.path.join(sys.path[0], "data"))
        path.append(os.path.join(sys.path[0], "pysollib", "data"))
        # from settings.py
        path.extend(DATA_DIRS)
        # py2app compatibility, see
        # https://github.com/shlomif/PySolFC/issues/100
        _prefixes = []
        try:
            _prefixes = site.PREFIXES
        except Exception:
            _prefixes = []
        # itz 2018-10-21 in case of venv installation
        # (or even homedir installation), path[0] will be quite wrong.
        # Just directly use the location where setup.py puts the data.
        for pref in _prefixes:
            path.append(os.path.join(pref, 'share', 'PySolFC'))
        # check path for valid directories
        self.path = []
        for p in path:
            if not p:
                continue
            np = os.path.abspath(p)
            if np and (np not in self.path) and os.path.isdir(np):
                self.path.append(np)
        # now try to find all filenames along path
        for p in self.path:
            if all(os.path.isfile(os.path.join(p, fn)) for fn in filenames):
                self.dir = p
                break
        else:
            raise OSError(str(argv0)+": DataLoader could not find " +
                          str(filenames))

    def __findFile(self, func, filename, subdirs=None, do_raise=1):
        if subdirs is None:
            subdirs = ("",)
        elif isinstance(subdirs, str):
            subdirs = (subdirs,)
        for dir in subdirs:
            f = os.path.join(self.dir, dir, filename)
            f = os.path.normpath(f)
            if func(f):
                return f
        if do_raise:
            raise OSError("DataLoader could not find "+filename+" in " +
                          self.dir+" "+str(subdirs))
        return None

    def findFile(self, filename, subdirs=None):
        return self.__findFile(os.path.isfile, filename, subdirs)

    def findImage(self, filename, subdirs=None):
        for ext in IMAGE_EXTENSIONS:
            f = self.__findFile(os.path.isfile, filename+ext, subdirs, 0)
            if f:
                return f
        raise OSError("DataLoader could not find image "+filename +
                      " in "+self.dir+" "+str(subdirs))

    def findAllIconSizes(self, filename='pysol.png'):
        try:
            icondir = self.findDir(os.path.join('images', 'icons'))
            icons = [os.path.join(icondir, subdir, filename) for subdir in
                     os.listdir(icondir)]
        except OSError:
            try:
                # pysol06.png is known to have transparent borders around it
                # which is unsuitable for a window icon
                icon_blacklist = ('pysol06.png',)
                miscdir = self.findDir(os.path.join('images', 'misc'))
                icons = [os.path.join(miscdir, f) for f in os.listdir(miscdir)
                         if f not in icon_blacklist]
            except OSError:
                icons = []
        return filter(os.path.isfile, icons)

    def findDir(self, filename, subdirs=None):
        return self.__findFile(os.path.isdir, filename, subdirs)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
#  Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
#  Copyright (C) 2003 Mt. Hood Playing Card Co.
#  Copyright (C) 2005-2009 Skomoroh
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import gettext
import locale
import os
import subprocess
import sys

try:
    import jnius
except ImportError:
    jnius = None

import pysollib.settings

# ************************************************************************
# * init
# ************************************************************************


def init():

    if 'LANG' not in os.environ:
        if os.name == 'nt':
            lang, enc = locale.getdefaultlocale()
            os.environ['LANG'] = lang
        elif jnius:  # android
            Locale = jnius.autoclass('java.util.Locale')
            os.environ['LANG'] = Locale.getDefault().getLanguage()
    locale.setlocale(locale.LC_ALL, '')

    # install gettext
    locale_locations = (
        # locale/ next to the pysol.py script
        sys.path[0],
        # locale/ next to library.zip (py2exe)
        os.path.dirname(sys.path[0]),
        # locale/ in curdir (works for e.g. py2app)
        os.curdir)
    # leaving the domain unbound means sys.prefix+'/share/locale'

    for par in locale_locations:
        locale_dir = os.path.join(par, 'locale')
        if os.path.isdir(locale_dir):
            gettext.bindtextdomain('pysol', locale_dir)
            break

    gettext.textdomain('pysol')

    # debug
    if 'PYSOL_CHECK_GAMES' in os.environ or 'PYSOL_DEBUG' in os.environ:
        pysollib.settings.CHECK_GAMES = True
        print('PySol debugging: set CHECK_GAMES to True')
    if 'PYSOL_DEBUG' in os.environ:
        try:
            pysollib.settings.DEBUG = int(os.environ['PYSOL_DEBUG'])
        except Exception:
            pysollib.settings.DEBUG = 1
        print(('PySol debugging: set DEBUG to', pysollib.settings.DEBUG))

    # init toolkit
    if '--gtk' in sys.argv:
        pysollib.settings.TOOLKIT = 'gtk'
        sys.argv.remove('--gtk')
    elif '--tk' in sys.argv:
        pysollib.settings.TOOLKIT = 'tk'
        pysollib.settings.USE_TILE = False
        sys.argv.remove('--tk')
    elif '--tile' in sys.argv:
        pysollib.settings.TOOLKIT = 'tk'
        pysollib.settings.USE_TILE = True
        sys.argv.remove('--tile')
    elif '--kivy' in sys.argv:
        pysollib.settings.TOOLKIT = 'kivy'
        pysollib.settings.USE_TILE = False
        pysollib.settings.SELECT_GAME_MENU = False
        sys.argv.remove('--kivy')

    if pysollib.settings.TOOLKIT == 'tk':
        from six.moves import tkinter
        root = tkinter.Tk(className=pysollib.settings.TITLE)
        root.withdraw()
        if tkinter.TkVersion < 8.4:
            # we need unicode support
            sys.exit("%s needs Tcl/Tk 8.4 or better (you have %s)" %
                     (pysollib.settings.TITLE, str(tkinter.TkVersion)))
        pysollib.settings.WIN_SYSTEM = root.tk.call('tk', 'windowingsystem')
        if pysollib.settings.WIN_SYSTEM == 'aqua':
            # TkAqua displays the console automatically in application
            # bundles, so we hide it here.
            from pysollib.macosx.appSupport import hideTkConsole
            hideTkConsole(root)
        #
        if pysollib.settings.USE_TILE == 'auto':
            # check Tile
            pysollib.settings.USE_TILE = False
            try:
                root.tk.eval('package require tile 0.7.8')
            except tkinter.TclError:
                pass
            else:
                pysollib.settings.USE_TILE = True
        # "can't invoke event <<ThemeChanged>>: application has been destroyed"
        # root.destroy()
        tkinter._default_root = None

    # check FreeCell-Solver
    pysollib.settings.USE_FREECELL_SOLVER = False
    if os.name == 'nt':
        if sys.path[0] and not os.path.isdir(sys.path[0]):  # i.e. library.zip
            d = os.path.dirname(sys.path[0])
            os.chdir(d)                 # for read presets
            fcs_command = os.path.join(
                'freecell-solver', 'bin', 'fc-solve.exe')
            pysollib.settings.FCS_COMMAND = fcs_command
            f = os.path.join('freecell-solver', 'presetrc')
            os.environ['FREECELL_SOLVER_PRESETRC'] = f
    if os.name in ('posix', 'nt'):
        try:
            kw = {'shell': True,
                  'stdout': subprocess.PIPE,
                  'stderr': subprocess.PIPE,
                  'stdin': subprocess.PIPE, }
            if os.name != 'nt':
                kw['close_fds'] = True
            p = subprocess.Popen(pysollib.settings.FCS_COMMAND+' --help', **kw)
            p.stdin.close()
            line = p.stdout.readline()
            if sys.version_info >= (3,):
                line = line.decode("utf-8")
            if line.startswith('fc-solve'):
                pysollib.settings.USE_FREECELL_SOLVER = True
            if os.name == 'posix':
                os.wait()               # kill zombi
        except Exception:
            # traceback.print_exc()
            pass
    os.environ['FREECELL_SOLVER_QUIET'] = '1'

    # run app without games menus (more fast start)
    if '--no-games-menu' in sys.argv:
        sys.argv.remove('--no-games-menu')
        pysollib.settings.SELECT_GAME_MENU = False
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import time

from pysollib.gamedb import GI
from pysollib.mfxutil import format_time
from pysollib.mygettext import _

from six.moves import range

# ************************************************************************
# *
# ************************************************************************


class PysolStatsFormatter:

    def getStatHeader(self):
        return (_("Game"),
                _("Played"),
                _("Won"),
                _("Lost"),
                _('Playing time'),
                _('Moves'),
                _("% won"))

    def getStatResults(self, player, sort_by='name'):
        app = self.app
        #
        sort_functions = {
            'name':    app.getGamesIdSortedByName,
            'played':  app.getGamesIdSortedByPlayed,
            'won':     app.getGamesIdSortedByWon,
            'lost':    app.getGamesIdSortedByLost,
            'time':    app.getGamesIdSortedByPlayingTime,
            'moves':   app.getGamesIdSortedByMoves,
            'percent': app.getGamesIdSortedByPercent,
            }
        sort_func = sort_functions[sort_by]
        g = sort_func(player=player)
        t_won, tlost, tgames, ttime, tmoves = 0, 0, 0, 0, 0
        for id in g:
            won, lost, time, moves = app.stats.getFullStats(player, id)
            tot = won + lost
            if tot > 0 or id == app.game.id:
                # yield only played games
                name = app.getGameTitleName(id)
                t_won, tlost = t_won + won, tlost + lost
                ttime, tmoves = ttime+time, tmoves+moves
                perc = "%.1f" % (100.0 * won / tot) if tot > 0 else '0.0'
                t = format_time(time)
                m = str(round(moves, 1))
                yield [name, won+lost, won, lost, t, m, perc, id]
                tgames += 1
        # summary
        won, lost = t_won, tlost
        if won + lost > 0:
            if won > 0:
                time = format_time(ttime/tgames)
                moves = round(tmoves/tgames, 1)
            else:
                time = format_time(0)
                moves = 0
            perc = "%.1f" % (100.0*won/(won+lost))
        else:
            perc = "0.0"
        self.total_games = len(g)
        self.played_games = tgames
        self.won_games = won
        self.lost_games = lost
        self.avrg_time = time
        self.avrg_moves = moves
        self.percent = perc
        # yield (_("Total (%d out of %d games)") % (tgames, len(g)),
        #       won+lost, won, lost, time, moves, perc, '')

    def getStatSummary(self):
        return self.total_games, \
               self.played_games, \
               self.won_games, \
               self.lost_games, \
               self.avrg_time, \
               self.avrg_moves, \
               self.percent

    def getLogHeader(self):
        return _("Game"), _("Game number"), _("Started at"), _("Status")

    def getLogResults(self, player, prev_games):
        t_won, tlost = 0, 0
        for pg in prev_games:
            if not isinstance(pg, tuple):
                continue
            if len(pg) == 5:
                pg = pg + ("", None, None, 1)
            elif len(pg) == 7:
                pg = pg + (None, 1)
            elif len(pg) == 8:
                pg = pg + (1,)
            if len(pg) < 8:
                continue
            gameid = pg[0]
            if not isinstance(gameid, int):
                continue
            gi = self.app.getGameInfo(gameid)
            if not gi:
                gi = self.app.getGameInfo(GI.PROTECTED_GAMES.get(gameid))
            if gi:
                name = gi.name
            else:
                name = _("** UNKNOWN %d **") % gameid
            f = pg[1]
            if len(f) == 16:
                # gamenumber = "%s-%s-%s-%s" % \
                #   (f[0:4], f[4:8], f[8:12], f[12:16])
                gamenumber = "%s-%s-%s" % (f[4:8], f[8:12], f[12:16])
            elif len(f) <= 20:
                gamenumber = f
            else:
                gamenumber = _("** ERROR **")
            date = time.strftime("%Y-%m-%d  %H:%M", time.localtime(pg[3]))
            if pg[2] >= 0:
                won = pg[2] > 0
                t_won, tlost = t_won + won, tlost + (1 - won)
            status = "*error*"
            if -2 <= pg[2] <= 2:
                status = (_("Loaded"), _("Not won"), _("Lost"),
                          _("Won"), _("Perfect"))[pg[2]+2]
            # writer.plog(name, gamenumber, date, status, gameid=gameid,
            #   won=pg[2])
            yield [name, gamenumber, date, status, pg[2], gameid]

    #
    #
    #

    def writeStats(self, player, sort_by='name'):
        pass

    def writeFullLog(self, player):
        pass

    def writeSessionLog(self, player):
        pass


class FileStatsFormatter(PysolStatsFormatter):

    def __init__(self, app, file):
        self.app = app
        self.file = file

    def p(self, s):
        self.file.write(s.encode('utf-8'))

    def nl(self, count=1):
        self.p("\n" * count)

    def pheader(self, s):
        self.p(s)

    def pstats(self, *args, **kwargs):
        s = "%-30s %7s %7s %7s %7s %7s %7s\n" % args
        self.p(s)

    def plog(self, gamename, gamenumber, date, status, gameid=-1, won=-1):
        self.p("%-25s %-20s  %17s  %s\n" %
               (gamename, gamenumber, date, status))

    def writeHeader(self, header, pagewidth=72):
        date = time.ctime(time.time())
        date = time.strftime("%Y-%m-%d  %H:%M", time.localtime(time.time()))
        blanks = max(pagewidth - len(header) - len(date), 1)
        self.pheader(header + " "*blanks + date + "\n")
        self.pheader("-" * pagewidth + "\n")
        self.pheader("\n")

    def writeStats(self, player, sort_by='name'):
        if player is None:
            player = _('Demo')
        header = _("Statistics for %(player)s") % {'player': player}
        self.writeHeader(header, 62)
        header = self.getStatHeader()
        self.pstats(*header)
        self.nl()
        for result in self.getStatResults(player, sort_by):
            gameid = result.pop()
            self.pstats(gameid=gameid, *result)
        self.nl()
        total, played, won, lost, time, moves, perc = self.getStatSummary()
        self.pstats(_("Total (%(played)d out of %(total)d games)") %
                    {'played': played, 'total': total},
                    won+lost, won, lost, time, moves, perc)
        self.nl(2)
        return played

    def writeLog(self, player, header, prev_games):
        if not player or not prev_games:
            return 0
        self.writeHeader(header, 71)
        header = self.getLogHeader()
        self.plog(*header)
        self.nl()
        for result in self.getLogResults(player, prev_games):
            gameid = result.pop()
            won = result.pop()
            self.plog(gameid=gameid, won=won, *result)
        self.nl(2)
        return 1

    def writeFullLog(self, player):
        if player is None:
            player = _('Demo')
        header = _("Full log for %(player)s") % {'player': player}
        prev_games = self.app.stats.prev_games.get(player)
        return self.writeLog(player, header, prev_games)

    def writeSessionLog(self, player):
        if player is None:
            player = _('Demo')
        header = _("Session log for %(player)s") % {'player': player}
        prev_games = self.app.stats.session_games.get(player)
        return self.writeLog(player, header, prev_games)


# ************************************************************************
# *
# ************************************************************************

class ProgressionFormatter:

    def __init__(self, app, player, gameid):

        all_results = {}      # key: (year, month, day);  value: [played, won]
        self.all_results = all_results
        game_results = {}
        self.game_results = game_results
        games = app.stats.prev_games.get(player)
        if not games:
            return
        for g in games:
            id = g[0]
            status = g[2]
            start_time = g[3]
            t = time.localtime(start_time)[:3]
            if t not in all_results:
                all_results[t] = [0, 0]
            all_results[t][0] += 1
            if status > 0:
                all_results[t][1] += 1
            if id == gameid:
                if t not in game_results:
                    game_results[t] = [0, 0]
                game_results[t][0] += 1
                if status > 0:
                    game_results[t][1] += 1
        # from pprint import pprint; pprint(all_results)

    def norm_time(self, t):
        if len(t) == 3:
            t = list(t)+[0, 0, 0, -1, -1, -1]
        return list(time.localtime(time.mktime(tuple(t))))

    def getResults(self, interval, all_games=True):
        if all_games:
            results = self.all_results
        else:
            results = self.game_results
        t = list(time.localtime())
        if interval == 'week':
            t[2] -= 7
            lt = self.norm_time(t)
            marks = None
            delta = 1
            format = '%d.%m'
        elif interval == 'month':
            tt = t[:]
            t[1] -= 1
            lt = self.norm_time(t)
            marks = [lt[:3], tt[:3]]
            tt[2] -= 10
            marks.append(self.norm_time(tt)[:3])
            tt[2] -= 10
            marks.append(self.norm_time(tt)[:3])
            delta = 1
            format = '%d.%m'
        elif interval == 'year':
            tt = t[:]
            t[0] -= 1
            lt = self.norm_time(t)
            marks = [lt[:3], tt[:3]]
            for i in range(5):
                tt[1] -= 2
                marks.append(self.norm_time(tt)[:3])
            delta = 7
            format = '%d.%m.%y'
        else:                           # all
            tt = t[:]
            tt[1] -= 1
            tt = self.norm_time(tt)
            if results:
                lt = self.norm_time(min(results.keys()))
                lt = min(lt, tt)        # min 1 month
            else:
                lt = tt
            dt = time.time()-time.mktime(tuple(lt))
            if dt > 63072000:           # 2 years
                d = 6
            elif dt > 31536000:         # 1 year
                d = 4
            elif dt > 10512000:         # 4 month
                d = 2
            else:
                d = 1
            marks = [lt[:3], t[:3]]
            while t > lt:
                t[1] -= d
                t = self.norm_time(t)
                marks.append(t[:3])
            delta = 7
            format = '%d.%m.%y'

        res = []
        ct = list(time.localtime())
        while lt <= ct:
            # assert type(lt) is type(ct)
            played = 0
            won = 0
            text = None
            for i in range(delta):
                if (not marks) or ct[:3] in marks:
                    text = time.strftime(format, tuple(ct))
                t = tuple(ct[:3])
                if t in results:
                    played += results[t][0]
                    won += results[t][1]
                ct[2] -= 1
                ct = self.norm_time(ct)
            res.append((text, played, won))
        res.reverse()
        # from pprint import pprint; pprint(res)
        return res
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.tk.basetkmfxdialog import BaseTkMfxDialog
from pysollib.ui.tktile.solverdialog import BaseSolverDialog, solver_dialog

from six.moves import range, tkinter

# ************************************************************************
# *
# ************************************************************************

solver_dialog = solver_dialog


class SolverDialog(BaseSolverDialog, BaseTkMfxDialog):
    def _createGamesVar(self, frame, row):
        var = tkinter.StringVar()
        om = tkinter.OptionMenu(frame, var, command=self.gameSelected,
                                *(self.gamenames))
        om.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
        n = len(self.gamenames)
        cb_max = int(self.top.winfo_screenheight()//23)
        cb_max = n // (n//cb_max+1)
        for i in range(cb_max, n, cb_max):
            om['menu'].entryconfig(i, columnbreak=True)
        return var

    def _createPresetVar(self, frame, row):
        var = tkinter.StringVar()
        var.set('none')
        om = tkinter.OptionMenu(frame, var, *(self.presets))
        om.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
        var.trace('w', self._OnAssignToPreset)
        return var

    def _createShowProgressButton(self, frame):
        return self._calcToolkit().Checkbutton(
            frame, variable=self.progress_var,
            text=_('Show progress'), anchor='w')

    def initKw(self, kw):
        strings = [_('&Start'), _('&Play'), _('&New'), _('&Close'), ]
        kw = KwStruct(kw,
                      strings=strings,
                      default=0,
                      )
        return self._calc_MfxDialog().initKw(self, kw)

    def connectGame(self, game):
        name = self.app.getGameTitleName(game.id)
        if name in self.gamenames:
            self.start_button.config(state='normal')
            self.games_var.set(name)
        else:
            self.start_button.config(state='disabled')
            self.games_var.set('')
        self.play_button.config(state='disabled')


def create_solver_dialog(parent, game):
    global solver_dialog
    try:
        solver_dialog.top.wm_deiconify()
        solver_dialog.top.tkraise()
    except Exception:
        # traceback.print_exc()
        solver_dialog = SolverDialog(parent, game)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os
import sys

from pysollib.mygettext import _
from pysollib.settings import WIN_SYSTEM

import six
from six.moves import tkinter

from .tkwidget import MfxTooltip

if __name__ == '__main__':
    d = os.path.abspath(os.path.join(sys.path[0], os.pardir, os.pardir))
    sys.path.append(d)
    import gettext
    gettext.install('pysol', d, unicode=True)


# ************************************************************************
# *
# ************************************************************************

class MfxStatusbar:
    def __init__(self, top, row, column, columnspan):
        self.top = top
        self._show = True
        self._widgets = []
        self._tooltips = []
        #
        self._row = row
        self._column = column
        self._columnspan = columnspan
        self._label_column = 0
        #
        self.padx = 1
        self.label_relief = 'sunken'
        self.frame = tkinter.Frame(self.top, bd=1)
        self.frame.grid(row=self._row, column=self._column,
                        columnspan=self._columnspan, sticky='ew',
                        padx=1, pady=1)
        if WIN_SYSTEM == 'win32':
            self.frame.config(relief='raised')
            self.padx = 0
        if 0:
            self.frame.config(bd=0)
            self.label_relief = 'flat'
            self.padx = 0

    # util
    def _createLabel(self, name, expand=False, width=0, tooltip=None):
        label = tkinter.Label(self.frame, width=width,
                              relief=self.label_relief, bd=1,
                              highlightbackground='black'
                              )
        label.grid(row=0, column=self._label_column,
                   sticky='nsew', padx=self.padx)
        if expand:
            self.frame.grid_columnconfigure(self._label_column,
                                            weight=1)
        self._label_column += 1
        setattr(self, name + '_label', label)
        self._widgets.append(label)
        if tooltip:
            b = MfxTooltip(label)
            self._tooltips.append(b)
            b.setText(tooltip)
        return label

    #
    # public methods
    #

    def updateText(self, **kw):
        for k, v in kw.items():
            label = getattr(self, k + '_label')
            text = six.text_type(v)
            width = label['width']
            if width and len(text) > width:
                label['width'] = len(text)
            label['text'] = text

    def config(self, name, show):
        label = getattr(self, name + '_label')
        if show:
            label.grid()
        else:
            label.grid_remove()

    def configLabel(self, name, **kw):
        label = getattr(self, name + '_label')
        label.config(**kw)

    def show(self, show=True, resize=False):
        if self._show == show:
            return False
        if resize:
            self.top.wm_geometry('')    # cancel user-specified geometry
        if not show:
            # hide
            self.frame.grid_forget()
        else:
            # show
            self.frame.grid(row=self._row, column=self._column,
                            columnspan=self._columnspan, sticky='ew')
        self._show = show
        return True

    def hide(self, resize=False):
        self.show(False, resize)

    def destroy(self):
        for w in self._tooltips:
            if w:
                w.destroy()
        self._tooltips = []
        for w in self._widgets:
            if w:
                w.destroy()
        self._widgets = []


class PysolStatusbar(MfxStatusbar):
    def __init__(self, top):
        MfxStatusbar.__init__(self, top, row=4, column=0, columnspan=3)
        #
        for n, t, w in (
            ('stuck',       _("'You Are Stuck' indicator"), 3),
            ('time',        _('Playing time'),            10),
            ('moves',       _('Moves/Total moves'),       10),
            ('gamenumber',  _('Game number'),             26),
            ('stats',       _('Games played: won/lost'),  12),
                ):
            self._createLabel(n, tooltip=t, width=w)
        #
        label = self._createLabel('info', expand=True)
        label.config(padx=8)


class HelpStatusbar(MfxStatusbar):
    def __init__(self, top):
        MfxStatusbar.__init__(self, top, row=4, column=0, columnspan=3)
        label = self._createLabel('info', expand=True)
        label.config(justify='left', anchor='w', padx=8)


class HtmlStatusbar(MfxStatusbar):
    def __init__(self, top, row, column, columnspan):
        MfxStatusbar.__init__(
            self, top, row=row, column=column, columnspan=columnspan)
        label = self._createLabel('url', expand=True)
        label.config(justify='left', anchor='w', padx=8)


# ************************************************************************
# *
# ************************************************************************


class TestStatusbar(PysolStatusbar):
    def __init__(self, top, args):
        PysolStatusbar.__init__(self, top)
        # test some settings
        self.updateText(moves=999, gamenumber='#0123456789ABCDEF0123')
        self.updateText(info='Some info text.')


def statusbar_main(args):
    tk = tkinter.Tk()
    TestStatusbar(tk, args)
    tk.mainloop()
    return 0


if __name__ == '__main__':
    sys.exit(statusbar_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct, Struct
from pysollib.mygettext import _
from pysollib.ui.tktile.tkutil import bind

from six.moves import tkinter

from .tkwidget import MfxDialog


class SelectUserNameDialog(MfxDialog):
    def __init__(self, parent, title, usernames=[], **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        listbox = tkinter.Listbox(top_frame)
        listbox.pack(side='left', fill='both', expand=True)
        scrollbar = tkinter.Scrollbar(top_frame)
        scrollbar.pack(side='right', fill='y')
        listbox.configure(yscrollcommand=scrollbar.set)
        scrollbar.configure(command=listbox.yview)

        self.username = None
        self.listbox = listbox
        bind(listbox, '<<ListboxSelect>>', self.updateUserName)
        #
        for un in usernames:
            listbox.insert('end', un)
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

        # if listbox.curselection():
        #    self.username = listbox.get(listbox.curselection())

    def updateUserName(self, *args):
        self.username = self.listbox.get(self.listbox.curselection())

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")), default=0,
                      separator=False,
                      resizable=False,
                      padx=10, pady=10,
                      buttonpadx=10, buttonpady=5,
                      )
        return MfxDialog.initKw(self, kw)


class PlayerOptionsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        self.app = app
        #
        self.update_stats_var = tkinter.BooleanVar()
        self.update_stats_var.set(app.opt.update_player_stats != 0)
        self.confirm_var = tkinter.BooleanVar()
        self.confirm_var.set(app.opt.confirm != 0)
        self.win_animation_var = tkinter.BooleanVar()
        self.win_animation_var.set(app.opt.win_animation != 0)
        #
        frame = tkinter.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        widget = tkinter.Label(frame, text=_("\nPlease enter your name"),
                               # justify='left', anchor='w',
                               takefocus=0)
        widget.grid(row=0, column=0, columnspan=2, sticky='ew', padx=0, pady=5)
        w = kw.get("e_width", 30)    # width in characters
        self.player_var = tkinter.Entry(frame, exportselection=1, width=w)
        self.player_var.insert(0, app.opt.player)
        self.player_var.grid(row=1, column=0, sticky='ew', padx=0, pady=5)
        widget = tkinter.Button(frame, text=_('Choose...'),
                                command=self.selectUserName)
        widget.grid(row=1, column=1, padx=5, pady=5)
        widget = tkinter.Checkbutton(frame, variable=self.confirm_var,
                                     anchor='w', text=_("Confirm quit"))
        widget.grid(row=2, column=0, columnspan=2, sticky='ew', padx=0, pady=5)
        widget = tkinter.Checkbutton(frame, variable=self.update_stats_var,
                                     anchor='w',
                                     text=_("Update statistics and logs"))
        widget.grid(row=3, column=0, columnspan=2, sticky='ew', padx=0, pady=5)
        #  widget = tkinter.Checkbutton(frame, variable=self.win_animation_var,
        #                               text="Win animation")
        #  widget.pack(side='top', padx=kw.padx, pady=kw.pady)
        frame.columnconfigure(0, weight=1)
        #
        self.player = self.player_var.get()
        self.confirm = self.confirm_var.get()
        self.update_stats = self.update_stats_var.get()
        self.win_animation = self.win_animation_var.get()
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def selectUserName(self, *args):
        names = self.app.getAllUserNames()
        d = SelectUserNameDialog(self.top, _("Select name"), names)
        if d.status == 0 and d.button == 0 and d.username:
            self.player_var.delete(0, 'end')
            self.player_var.insert(0, d.username)

    def mDone(self, button):
        self.button = button
        self.player = self.player_var.get()
        self.confirm = self.confirm_var.get()
        self.update_stats = self.update_stats_var.get()
        self.win_animation = self.win_animation_var.get()
        raise SystemExit

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")), default=0,
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)


# ************************************************************************
# *
# ************************************************************************


def playeroptionsdialog_main(args):
    from pysollib.ui.tktile.tkutil import wm_withdraw
    opt = Struct(player="Test", update_player_stats=1)
    app = Struct(opt=opt)
    tk = tkinter.Tk()
    wm_withdraw(tk)
    tk.update()
    d = PlayerOptionsDialog(tk, "Player options", app)
    print(d.status, d.button, ":", d.player, d.update_stats)
    return 0


if __name__ == "__main__":
    import sys
    sys.exit(playeroptionsdialog_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os

from pysollib.mfxutil import Image, ImageTk
from pysollib.mygettext import _, n_
from pysollib.settings import TITLE
from pysollib.ui.tktile.menubar import MfxMenu, createToolbarMenu
from pysollib.ui.tktile.tkconst import EVENT_HANDLED
from pysollib.util import IMAGE_EXTENSIONS
from pysollib.winsystems import TkSettings

from six.moves import tkinter

from .tkwidget import MfxTooltip


class AbstractToolbarButton:
    def __init__(self, parent, toolbar, toolbar_name, position):
        self.toolbar = toolbar
        self.toolbar_name = toolbar_name
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        padx, pady = 2, 2
        if orient == 'horizontal':
            self.grid(row=0,
                      column=self.position,
                      ipadx=padx, ipady=pady,
                      sticky='nsew')
        else:
            self.grid(row=self.position,
                      column=0,
                      ipadx=padx, ipady=pady,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()


class ToolbarCheckbutton(AbstractToolbarButton, tkinter.Checkbutton):
    def __init__(self, parent, toolbar, toolbar_name, position, **kwargs):
        tkinter.Checkbutton.__init__(self, parent, kwargs)
        AbstractToolbarButton.__init__(
            self, parent, toolbar, toolbar_name, position)


class ToolbarButton(AbstractToolbarButton, tkinter.Button):
    def __init__(self, parent, toolbar, toolbar_name, position, **kwargs):
        tkinter.Button.__init__(self, parent, kwargs)
        AbstractToolbarButton.__init__(
            self, parent, toolbar, toolbar_name, position)


class ToolbarSeparator(tkinter.Frame):
    def __init__(self, parent, toolbar, position, **kwargs):
        tkinter.Frame.__init__(self, parent, kwargs)
        self.toolbar = toolbar
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        width = 4
        height = 4
        padx = 6
        pady = 6
        if orient == 'horizontal':
            self.config(width=width, height=height)
            self.grid(row=0,
                      column=self.position,
                      padx=padx, pady=pady,
                      sticky='ns')
        else:
            self.config(width=height, height=width)
            self.grid(row=self.position,
                      column=0,
                      padx=pady, pady=padx,
                      sticky='ew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()


class ToolbarFlatSeparator(ToolbarSeparator):
    pass


class ToolbarLabel(tkinter.Message):
    def __init__(self, parent, toolbar, toolbar_name, position, **kwargs):
        tkinter.Message.__init__(self, parent, **kwargs)
        self.toolbar = toolbar
        self.toolbar_name = toolbar_name
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        padx, pady = TkSettings.toolbar_label_padding
        if orient == 'horizontal':
            self.grid(row=0,
                      column=self.position,
                      padx=padx, pady=pady,
                      sticky='nsew')
        else:
            self.grid(row=self.position,
                      column=0,
                      padx=padx, pady=pady,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()


# ************************************************************************
# * Note: Applications should call show/hide after constructor.
# ************************************************************************

class PysolToolbarTk:

    def __init__(self, top, menubar, dir,
                 size=0, relief='flat', compound='none'):
        self.top = top
        self.menubar = menubar
        self.side = -1
        self._tooltips = []
        self._widgets = []
        self.dir = dir
        self.size = size
        self.compound = compound
        self.orient = 'horizontal'
        self.button_pad = 2
        #
        self.frame = tkinter.Frame(top, relief=TkSettings.toolbar_relief,
                                   bd=TkSettings.toolbar_borderwidth)
        #
        for label, f, t in (
            (n_("New"),      self.mNewGame,   _("New game")),
            (n_("Restart"),  self.mRestart,   _("Restart the\ncurrent game")),
            (None,           None,            None),
            (n_("Open"),     self.mOpen,      _("Open a\nsaved game")),
            (n_("Save"),     self.mSave,      _("Save game")),
            (None,           None,            None),
            (n_("Undo"),     self.mUndo,      _("Undo last move")),
            (n_("Redo"),     self.mRedo,      _("Redo last move")),
            (n_("Autodrop"), self.mDrop,      _("Auto drop cards")),
            (n_("Shuffle"),  self.mShuffle,   _("Shuffle tiles")),
            (n_("Pause"),    self.mPause,     _("Pause game")),
            (None,           None,            None),
            (n_("Statistics"), self.mPlayerStats, _("View statistics")),
            (n_("Rules"),    self.mHelpRules, _("Rules for this game")),
            (None,           None,            None),
            (n_("Quit"),     self.mQuit,      _("Quit %s") % TITLE),
                ):
            if label is None:
                sep = self._createSeparator()
                sep.bind("<1>", self.clickHandler)
                sep.bind("<3>", self.rightclickHandler)
            elif label == 'Pause':
                self._createButton(label, f, check=True, tooltip=t)
            else:
                self._createButton(label, f, tooltip=t)
        self.pause_button.config(variable=menubar.tkopt.pause)

        sep = self._createFlatSeparator()
        sep.bind("<1>", self.clickHandler)
        sep.bind("<3>", self.rightclickHandler)
        self._createLabel("player", label=n_('Player'),
                          tooltip=_("Player options"))
        #
        self.player_label.bind("<1>", self.mOptPlayerOptions)
        # self.player_label.bind("<3>",self.mOptPlayerOptions)
        self.popup = MfxMenu(master=None, label=n_('Toolbar'), tearoff=0)
        createToolbarMenu(menubar, self.popup)
        self.frame.bind("<1>", self.clickHandler)
        self.frame.bind("<3>", self.rightclickHandler)
        #
        self.setCompound(compound, force=True)

    def config(self, w, v):
        if w == 'player':
            # label
            if v:
                self.player_label.show(orient=self.orient)
            else:
                self.player_label.hide()
        else:
            # button
            widget = getattr(self, w+'_button')
            if v:
                widget.show(orient=self.orient)
            else:
                widget.hide()
        #
        prev_visible = None
        last_visible = None
        for w in self._widgets:
            if isinstance(w, ToolbarSeparator):
                if prev_visible is None or isinstance(prev_visible,
                                                      ToolbarSeparator):
                    w.hide()
                else:
                    w.show(orient=self.orient)
            elif isinstance(w, ToolbarFlatSeparator):
                if isinstance(prev_visible, ToolbarSeparator):
                    prev_visible.hide()
            if w.visible:
                prev_visible = w
                if not isinstance(w, ToolbarLabel):
                    last_visible = w
        if isinstance(last_visible, ToolbarSeparator):
            last_visible.hide()

    # util
    def _loadImage(self, name):
        file = os.path.join(self.dir, name)
        image = None
        for ext in IMAGE_EXTENSIONS:
            file = os.path.join(self.dir, name+ext)
            if os.path.isfile(file):
                if Image:
                    image = ImageTk.PhotoImage(Image.open(file))
                else:
                    image = tkinter.PhotoImage(file=file)
                break
        return image

    def _createSeparator(self):
        position = len(self._widgets)
        sep = ToolbarSeparator(self.frame,
                               position=position,
                               toolbar=self,
                               bd=1,
                               highlightthickness=1,
                               width=4,
                               takefocus=0,
                               relief=TkSettings.toolbar_separator_relief)
        sep.show(orient=self.orient)
        self._widgets.append(sep)
        return sep

    def _createFlatSeparator(self):
        position = len(self._widgets)
        sep = ToolbarFlatSeparator(self.frame,
                                   position=position,
                                   toolbar=self,
                                   bd=1,
                                   highlightthickness=1,
                                   width=5,
                                   takefocus=0,
                                   relief='flat')
        sep.show(orient=self.orient)
        self.frame.rowconfigure(position, weight=1)
        self.frame.columnconfigure(position, weight=1)
        self._widgets.append(sep)
        return sep

    def _createButton(self, label, command, check=False, tooltip=None):
        name = label.lower()
        image = self._loadImage(name)
        position = len(self._widgets)
        button_relief = TkSettings.toolbar_button_relief
        bd = TkSettings.toolbar_button_borderwidth
        padx, pady = TkSettings.toolbar_button_padding
        kw = {
            'position': position,
            'toolbar': self,
            'toolbar_name': name,
            'command': command,
            'takefocus': 0,
            'text': _(label),
            'bd': bd,
            'relief': button_relief,
            'padx': padx,
            'pady': pady,
            'overrelief': 'raised',
            }
        if image:
            kw['image'] = image
        if check:
            kw['offrelief'] = button_relief
            kw['indicatoron'] = False
            kw['selectcolor'] = ''
            button = ToolbarCheckbutton(self.frame, **kw)
        else:
            button = ToolbarButton(self.frame, **kw)
        button.show(orient=self.orient)
        setattr(self, name + "_image", image)
        setattr(self, name + "_button", button)
        self._widgets.append(button)
        if tooltip:
            b = MfxTooltip(button)
            self._tooltips.append(b)
            b.setText(tooltip)
        return button

    def _createLabel(self, name, label=None, tooltip=None):
        aspect = (400, 300)[self.getSize() != 0]
        position = len(self._widgets)
        label = ToolbarLabel(self.frame,
                             position=position,
                             toolbar=self,
                             toolbar_name=name,
                             relief="ridge",
                             justify="center",
                             aspect=aspect)
        label.show(orient=self.orient)
        setattr(self, name + "_label", label)
        self._widgets.append(label)
        if tooltip:
            b = MfxTooltip(label)
            self._tooltips.append(b)
            b.setText(tooltip)
        return label

    def _busy(self):
        if not self.side or not self.game or not self.menubar:
            return 1
        self.game.stopDemo()
        self.game.interruptSleep()
        return self.game.busy

    #
    # public methods
    #

    def show(self, side=1, resize=1):
        if self.side == side:
            return 0
        if resize:
            self.top.wm_geometry("")    # cancel user-specified geometry
        if not side:
            # hide
            self.frame.grid_forget()
        else:
            # show
            pack_func = self.frame.grid_configure

            if side == 1:
                # top
                pack_func(row=0, column=1, sticky='ew')
            elif side == 2:
                # bottom
                pack_func(row=2, column=1, sticky='ew')
            elif side == 3:
                # left
                pack_func(row=1, column=0, sticky='ns')
            else:
                # right
                pack_func(row=1, column=2, sticky='ns')
            # set orient
            orient = side in (1, 2) and 'horizontal' or 'vertical'
            self._setOrient(orient)
        self.side = side
        return 1

    def hide(self, resize=1):
        self.show(0, resize)

    def destroy(self):
        for w in self._tooltips:
            if w:
                w.destroy()
        self._tooltips = []
        for w in self._widgets:
            if w:
                w.destroy()
        self._widgets = []

    def setCursor(self, cursor):
        if self.side:
            self.frame.config(cursor=cursor)
            self.frame.update_idletasks()

    def updateText(self, **kw):
        for name in kw.keys():
            label = getattr(self, name + "_label")
            label["text"] = kw[name]

    def updateImages(self, dir, size):
        if dir == self.dir and size == self.size:
            return 0
        if not os.path.isdir(dir):
            return 0
        old_dir, old_size = self.dir, self.size
        self.dir, self.size = dir, size
        data = []
        try:
            for w in self._widgets:
                if not isinstance(w, (ToolbarButton, ToolbarCheckbutton)):
                    continue
                name = w.toolbar_name
                image = self._loadImage(name)
                data.append((name, w, image))
        except Exception:
            self.dir, self.size = old_dir, old_size
            return 0
        label = self.player_label
        aspect = (400, 300)[size != 0]
        label.config(aspect=aspect)
        for name, w, image in data:
            w.config(image=image)
            setattr(self, name + "_image", image)
        self.setCompound(self.compound, force=True)
        return 1

    def setCompound(self, compound, force=False):
        if not force and self.compound == compound:
            return False
        for w in self._widgets:
            if not isinstance(w, (ToolbarButton, ToolbarCheckbutton)):
                continue
            if compound == 'text':
                w.config(compound='none', image='')
            else:
                image = getattr(self, w.toolbar_name+'_image')
                w.config(compound=compound, image=image)
        self.compound = compound
        return True

    def _setOrient(self, orient='horizontal', force=False):
        if not force and self.orient == orient:
            return False
        for w in self._widgets:
            if w.visible:
                w.show(orient=orient, force=True)
        self.orient = orient
        return True

    #
    # Mouse event handlers
    #

    def clickHandler(self, event):
        if self._busy():
            return EVENT_HANDLED
        return EVENT_HANDLED

    def rightclickHandler(self, event):
        if self._busy():
            return EVENT_HANDLED
        if self.popup:
            self.popup.tk_popup(event.x_root, event.y_root)
        return EVENT_HANDLED

    def middleclickHandler(self, event):
        if self._busy():
            return EVENT_HANDLED
        if 1 <= self.side <= 2:
            self.menubar.setToolbarSide(3 - self.side)
        return EVENT_HANDLED

    def getSize(self):
        if self.compound == 'text':
            return 0
        size = self.size
        comp = int(self.compound in ('top', 'bottom'))
        return int((size+comp) != 0)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


from pysollib.ui.tktile.selecttree import \
        BaseSelectDialogTreeCanvas, \
        BaseSelectDialogTreeLeaf, \
        BaseSelectDialogTreeNode

from .tktree import MfxTreeInCanvas, MfxTreeLeaf, MfxTreeNode

# ************************************************************************
# * Nodes
# ************************************************************************


class SelectDialogTreeLeaf(MfxTreeLeaf, BaseSelectDialogTreeLeaf):
    pass


class SelectDialogTreeNode(MfxTreeNode, BaseSelectDialogTreeNode):
    pass

# ************************************************************************
# * Canvas that shows the tree (left side)
# ************************************************************************


class SelectDialogTreeCanvas(MfxTreeInCanvas, BaseSelectDialogTreeCanvas):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------


from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _

from six.moves import tkinter

from .tkwidget import MfxDialog


class TimeoutsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        # self.createBitmaps(top_frame, kw)

        frame = tkinter.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        self.demo_sleep_var = tkinter.DoubleVar()
        self.demo_sleep_var.set(app.opt.timeouts['demo'])
        self.hint_sleep_var = tkinter.DoubleVar()
        self.hint_sleep_var.set(app.opt.timeouts['hint'])
        self.raise_card_sleep_var = tkinter.DoubleVar()
        self.raise_card_sleep_var.set(app.opt.timeouts['raise_card'])
        self.highlight_piles_sleep_var = tkinter.DoubleVar()
        self.highlight_piles_sleep_var.set(app.opt.timeouts['highlight_piles'])
        self.highlight_cards_sleep_var = tkinter.DoubleVar()
        self.highlight_cards_sleep_var.set(app.opt.timeouts['highlight_cards'])
        self.highlight_samerank_sleep_var = tkinter.DoubleVar()
        self.highlight_samerank_sleep_var.set(
            app.opt.timeouts['highlight_samerank'])
        #
        # tkinter.Label(frame, text='Set delays in seconds').grid(
        #   row=0, column=0, columnspan=2)
        row = 0
        for title, var in ((_('Demo:'), self.demo_sleep_var),
                           (_('Hint:'), self.hint_sleep_var),
                           (_('Raise card:'), self.raise_card_sleep_var),
                           (_('Highlight piles:'),
                               self.highlight_piles_sleep_var),
                           (_('Highlight cards:'),
                               self.highlight_cards_sleep_var),
                           (_('Highlight same rank:'),
                               self.highlight_samerank_sleep_var),
                           ):
            tkinter.Label(frame, text=title, anchor='w'
                          ).grid(row=row, column=0, sticky='we')
            widget = tkinter.Scale(frame, from_=0.2, to=9.9,
                                   resolution=0.1, orient='horizontal',
                                   length="3i", variable=var, takefocus=0)
            widget.grid(row=row, column=1)
            row += 1
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)
        #
        self.demo_timeout = self.demo_sleep_var.get()
        self.hint_timeout = self.hint_sleep_var.get()
        self.raise_card_timeout = self.raise_card_sleep_var.get()
        self.highlight_piles_timeout = self.highlight_piles_sleep_var.get()
        self.highlight_cards_timeout = self.highlight_cards_sleep_var.get()
        self.highlight_samerank_timeout = \
            self.highlight_samerank_sleep_var.get()

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")), default=0,
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.pysolaudio import pysolsoundserver
from pysollib.settings import TITLE
from pysollib.ui.tktile.tkconst import EVENT_HANDLED

from six.moves import tkinter

from .tkwidget import MfxDialog, MfxMessageDialog

# ************************************************************************
# *
# ************************************************************************


class SoundOptionsDialog(MfxDialog):

    def __init__(self, parent, title, app, **kw):
        self.app = app
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.saved_opt = app.opt.copy()
        self.sound = tkinter.BooleanVar()
        self.sound.set(app.opt.sound != 0)
        self.sound_mode = tkinter.BooleanVar()
        self.sound_mode.set(app.opt.sound_mode != 0)
        self.sample_volume = tkinter.IntVar()
        self.sample_volume.set(app.opt.sound_sample_volume)
        self.music_volume = tkinter.IntVar()
        self.music_volume.set(app.opt.sound_music_volume)
        self.samples = [
            ('areyousure',    _('Are You Sure'),   tkinter.BooleanVar()),

            ('deal',          _('Deal'),           tkinter.BooleanVar()),
            ('dealwaste',     _('Deal waste'),     tkinter.BooleanVar()),

            ('turnwaste',     _('Turn waste'),     tkinter.BooleanVar()),
            ('startdrag',     _('Start drag'),     tkinter.BooleanVar()),

            ('drop',          _('Drop'),           tkinter.BooleanVar()),
            ('droppair',      _('Drop pair'),      tkinter.BooleanVar()),
            ('autodrop',      _('Auto drop'),      tkinter.BooleanVar()),

            ('flip',          _('Flip'),           tkinter.BooleanVar()),
            ('autoflip',      _('Auto flip'),      tkinter.BooleanVar()),
            ('move',          _('Move'),           tkinter.BooleanVar()),
            ('nomove',        _('No move'),        tkinter.BooleanVar()),

            ('undo',          _('Undo'),           tkinter.BooleanVar()),
            ('redo',          _('Redo'),           tkinter.BooleanVar()),

            ('autopilotlost', _('Autopilot lost'), tkinter.BooleanVar()),
            ('autopilotwon',  _('Autopilot won'),  tkinter.BooleanVar()),

            ('gamefinished',  _('Game finished'),  tkinter.BooleanVar()),
            ('gamelost',      _('Game lost'),      tkinter.BooleanVar()),
            ('gamewon',       _('Game won'),       tkinter.BooleanVar()),
            ('gameperfect',   _('Perfect game'),   tkinter.BooleanVar()),
            ]

        #
        frame = tkinter.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=5)
        frame.columnconfigure(1, weight=1)
        #
        row = 0
        w = tkinter.Checkbutton(frame, variable=self.sound,
                                text=_("Sound enabled"), anchor='w')
        w.grid(row=row, column=0, columnspan=2, sticky='ew')
        #
        if os.name == "nt" and pysolsoundserver:
            row += 1
            w = tkinter.Checkbutton(frame, variable=self.sound_mode,
                                    text=_("Use DirectX for sound playing"),
                                    command=self.mOptSoundDirectX, anchor='w')
            w.grid(row=row, column=0, columnspan=2, sticky='ew')
        #
        if app.audio.CAN_PLAY_MUSIC:  # and app.startup_opt.sound_mode > 0:
            row += 1
            w = tkinter.Label(frame, text=_('Sample volume:'))
            w.grid(row=row, column=0, sticky='w', padx=5)
            w = tkinter.Scale(frame, from_=0, to=128, resolution=1,
                              orient='horizontal', takefocus=0,
                              length="3i",  # label=_('Sample volume'),
                              variable=self.sample_volume)
            w.grid(row=row, column=1, sticky='ew', padx=5)
            row += 1
            w = tkinter.Label(frame, text=_('Music volume:'))
            w.grid(row=row, column=0, sticky='w', padx=5)
            w = tkinter.Scale(frame, from_=0, to=128, resolution=1,
                              orient='horizontal', takefocus=0,
                              length="3i",  # label=_('Music volume'),
                              variable=self.music_volume)
            w.grid(row=row, column=1, sticky='ew', padx=5)

        else:
            # remove "Apply" button
            kw.strings[1] = None
        #
        frame = tkinter.LabelFrame(top_frame, text=_('Enable samles'),
                                   padx=5, pady=5)
        frame.pack(expand=True, fill='both', padx=5, pady=5)
        frame.columnconfigure(0, weight=1)
        frame.columnconfigure(1, weight=1)
        #
        row = 0
        col = 0
        for n, t, v in self.samples:
            v.set(app.opt.sound_samples[n])
            w = tkinter.Checkbutton(frame, text=t, anchor='w', variable=v)
            w.grid(row=row, column=col, sticky='ew')
            if col == 1:
                col = 0
                row += 1
            else:
                col = 1
        #
        top_frame.columnconfigure(1, weight=1)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        strings = [_("&OK"), _("&Apply"), _("&Cancel"), ]
        kw = KwStruct(kw,
                      strings=strings,
                      default=0,
                      padx=10, pady=10,
                      buttonpadx=10, buttonpady=5,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if button == 0 or button == 1:
            self.app.opt.sound = self.sound.get()
            self.app.opt.sound_mode = int(self.sound_mode.get())
            self.app.opt.sound_sample_volume = self.sample_volume.get()
            self.app.opt.sound_music_volume = self.music_volume.get()
            for n, t, v in self.samples:
                self.app.opt.sound_samples[n] = v.get()
        elif button == 2:
            self.app.opt = self.saved_opt
        if self.app.audio:
            self.app.audio.updateSettings()
            if button == 1:
                self.app.audio.playSample("drop", priority=1000)
        if button == 1:
            return EVENT_HANDLED
        return MfxDialog.mDone(self, button)

    def mCancel(self, *event):
        return self.mDone(2)

    def wmDeleteWindow(self, *event):
        return self.mDone(0)

    def mOptSoundDirectX(self, *event):
        # print self.sound_mode.get()
        MfxMessageDialog(
            self.top, title=_("Sound preferences info"),
            text=_("""\
Changing DirectX settings will take effect
the next time you restart """)+TITLE,
            bitmap="warning",
            default=0, strings=(_("&OK"),))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.tk.basetkmfxdialog import BaseTkMfxDialog
from pysollib.ui.tktile.colorsdialog import BaseColorsDialog


class ColorsDialog(BaseColorsDialog, BaseTkMfxDialog):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os
import time

from pysollib.mfxutil import KwStruct, kwdefault
from pysollib.mfxutil import format_time
from pysollib.mygettext import _
from pysollib.settings import TOP_TITLE
from pysollib.stats import ProgressionFormatter, PysolStatsFormatter
from pysollib.ui.tktile.tkutil import bind, loadImage

from six.moves import tkinter
from six.moves import tkinter_font

from .tkwidget import MfxDialog, MfxMessageDialog
from .tkwidget import MfxScrolledCanvas

# FIXME - this file is a quick hack and needs a rewrite


class SingleGame_StatsDialog(MfxDialog):
    def __init__(self, parent, title, app, player, gameid, **kw):
        self.app = app
        self.selected_game = None
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.top_frame = top_frame
        self.createBitmaps(top_frame, kw)
        #
        self.player = player or _("Demo games")
        self.top.wm_minsize(200, 200)
        self.button = kw.default
        #
        # createChart = self.create3DBarChart
        createChart = self.createPieChart
        # createChart = self.createSimpleChart
        #  if parent.winfo_screenwidth() < 800 or parent.winfo_screenheight() <
        #        600:
        #      createChart = self.createPieChart
        #      createChart = self.createSimpleChart
        #
        self.font = self.app.getFont("default")
        self.tk_font = tkinter_font.Font(self.top, self.font)
        self.font_metrics = self.tk_font.metrics()
        self._calc_tabs()
        #
        won, lost = app.stats.getStats(player, gameid)
        createChart(app, won, lost, _("Total"))
        won, lost = app.stats.getSessionStats(player, gameid)
        createChart(app, won, lost, _("Current session"))
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    #
    # helpers
    #

    def _calc_tabs(self):
        #
        font = self.tk_font
        t0 = 160
        t = ''
        for i in (_("Won:"),
                  _("Lost:"),
                  _("Total:")):
            if len(i) > len(t):
                t = i
        t1 = font.measure(t)
        #  t1 = max(font.measure(_("Won:")),
        #           font.measure(_("Lost:")),
        #           font.measure(_("Total:")))
        t1 += 10
        # t2 = font.measure('99999')+10
        t2 = 45
        # t3 = font.measure('100%')+10
        t3 = 45
        tx = (t0, t0+t1+t2, t0+t1+t2+t3)
        #
        ls = self.font_metrics['linespace']
        ls += 5
        ls = max(ls, 20)
        ty = (ls, 2*ls, 3*ls+15, 3*ls+25)
        #
        self.tab_x, self.tab_y = tx, ty

    def _getPwon(self, won, lost):
        pwon, plost = 0.0, 0.0
        if won + lost > 0:
            pwon = float(won) / (won + lost)
            pwon = min(max(pwon, 0.00001), 0.99999)
            plost = 1.0 - pwon
        return pwon, plost

    def _createChartInit(self, text):
        w, h = self.tab_x[-1]+20, self.tab_y[-1]+20
        c = tkinter.Canvas(self.top_frame, width=w, height=h)
        c.pack(side='top', fill='both', expand=False, padx=20, pady=10)
        self.canvas = c
        # self.fg = c.cget("insertbackground")
        self.fg = c.option_get('foreground', '') or c.cget("insertbackground")
        #
        c.create_rectangle(2, 7, w, h, fill="", outline="#7f7f7f")
        label = tkinter.Label(c, text=text, font=self.font, bd=0, padx=3,
                              pady=1)
        dy = int(self.font_metrics['ascent']) - 10
        dy //= 2
        c.create_window(20, -dy, window=label, anchor="nw")

    def _createChartTexts(self, tx, ty, won, lost):
        c, tfont, fg = self.canvas, self.font, self.fg
        pwon, plost = self._getPwon(won, lost)
        #
        x = tx[0]
        dy = int(self.font_metrics['ascent']) - 10
        dy //= 2
        c.create_text(
            x, ty[0]-dy, text=_("Won:"), anchor="nw", font=tfont, fill=fg)
        c.create_text(
            x, ty[1]-dy, text=_("Lost:"), anchor="nw", font=tfont, fill=fg)
        c.create_text(
            x, ty[2]-dy, text=_("Total:"), anchor="nw", font=tfont, fill=fg)
        x = tx[1] - 16
        c.create_text(
            x, ty[0]-dy, text="%d" % won, anchor="ne", font=tfont, fill=fg)
        c.create_text(
            x, ty[1]-dy, text="%d" % lost, anchor="ne", font=tfont, fill=fg)
        c.create_text(
            x, ty[2]-dy, text="%d" % (won + lost), anchor="ne", font=tfont,
            fill=fg)
        y = ty[2] - 11
        c.create_line(tx[0], y, x, y, fill=fg)
        if won + lost > 0:
            x = tx[2]
            pw = int(round(100.0 * pwon))
            c.create_text(
                x, ty[0]-dy, text="%d%%" % pw, anchor="ne",
                font=tfont, fill=fg)
            c.create_text(
                x, ty[1]-dy, text="%d%%" % (100-pw), anchor="ne", font=tfont,
                fill=fg)

#      def _createChart3DBar(self, canvas, perc, x, y, p, col):
#          if perc < 0.005:
#              return
#          # translate and scale
#          p = list(p[:])
#          for i in (0, 1, 2, 3):
#              p[i] = (x + p[i][0], y + p[i][1])
#              j = i + 4
#              dx = int(round(p[j][0] * perc))
#              dy = int(round(p[j][1] * perc))
#              p[j] = (p[i][0] + dx, p[i][1] + dy)
#          # draw rects
#          def draw_rect(a, b, c, d, col, canvas=canvas, p=p):
#              points = (p[a][0], p[a][1], p[b][0], p[b][1],
#                        p[c][0], p[c][1], p[d][0], p[d][1])
#              canvas.create_polygon(points, fill=col)
#          draw_rect(0, 1, 5, 4, col[0])
#          draw_rect(1, 2, 6, 5, col[1])
#          draw_rect(4, 5, 6, 7, col[2])
#          # draw lines
#          def draw_line(a, b, canvas=canvas, p=p):
#              # print a, b, p[a], p[b]
#              canvas.create_line(p[a][0], p[a][1], p[b][0], p[b][1])
#          draw_line(0, 1)
#          draw_line(1, 2)
#          draw_line(0, 4)
#          draw_line(1, 5)
#          draw_line(2, 6)
#          #  draw_line(3, 7)     # test
#          draw_line(4, 5)
#          draw_line(5, 6)
#          draw_line(6, 7)
#          draw_line(7, 4)
#      def createSimpleChart(self, app, won, lost, text):
#          #c, tfont, fg = self._createChartInit(frame, 300, 100, text)
#          self._createChartInit(300, 100, text)
#          c, tfont, fg = self.canvas, self.font, self.fg
#          #
#          tx = (90, 180, 210)
#          ty = (21, 41, 75)
#          self._createChartTexts(tx, ty, won, lost)
#      def create3DBarChart(self, app, won, lost, text):
#          image = app.gimages.stats[0]
#          iw, ih = image.width(), image.height()
#          #c, tfont, fg = self._createChartInit(frame, iw+160, ih, text)
#          self._createChartInit(iw+160, ih, text)
#          c, tfont, fg = self.canvas, self.font, self.fg
#          pwon, plost = self._getPwon(won, lost)
#          #
#          tx = (iw+20, iw+110, iw+140)
#          yy = ih//2 # + 7
#          ty = (yy+21-46, yy+41-46, yy+75-46)
#          #
#          c.create_image(0, 7, image=image, anchor="nw")
#          #
#          p = ((0, 0), (44, 6), (62, -9), (20, -14),
#               (-3, -118), (-1, -120), (-1, -114), (-4, -112))
#          col = ("#00ff00", "#008200", "#00c300")
#          self._createChart3DBar(c, pwon,  102, 145+7, p, col)
#          p = ((0, 0), (49, 6), (61, -10), (15, -15),
#               (1, -123), (3, -126), (4, -120), (1, -118))
#          col = ("#ff0000", "#860400", "#c70400")
#          self._createChart3DBar(c, plost, 216, 159+7, p, col)
#          #
#          self._createChartTexts(tx, ty, won, lost)
#          c.create_text(tx[0], ty[0]-48, text=self.player, anchor="nw",
#          font=tfont, fill=fg)

    def createPieChart(self, app, won, lost, text):
        # c, tfont, fg = self._createChartInit(frame, 300, 100, text)
        #
        self._createChartInit(text)
        c, tfont = self.canvas, self.font
        pwon, plost = self._getPwon(won, lost)
        #
        # tx = (160, 250, 280)
        # ty = (21, 41, 75)
        #
        tx, ty = self.tab_x, self.tab_y
        if won + lost > 0:
            # s, ewon, elost = 90.0, -360.0 * pwon, -360.0 * plost
            s, ewon, elost = 0.0, 360.0 * pwon, 360.0 * plost
            c.create_arc(
                20, 25+9, 110, 75+9,  fill="#007f00", start=s, extent=ewon)
            c.create_arc(
                20, 25+9, 110, 75+9,  fill="#7f0000", start=s+ewon,
                extent=elost)
            c.create_arc(
                20, 25,   110, 75,    fill="#00ff00", start=s, extent=ewon)
            c.create_arc(
                20, 25,   110, 75,    fill="#ff0000", start=s+ewon,
                extent=elost)
            x, y = tx[0] - 25, ty[0]
            c.create_rectangle(x, y, x+10, y+10, fill="#00ff00")
            y = ty[1]
            c.create_rectangle(x, y, x+10, y+10, fill="#ff0000")
        else:
            c.create_oval(20, 25+10, 110, 75+10, fill="#7f7f7f")
            c.create_oval(20, 25,    110, 75,    fill="#f0f0f0")
            c.create_text(
                65, 50, text=_("No games"), anchor="center",
                font=tfont, fill="#bfbfbf")
        #
        self._createChartTexts(tx, ty, won, lost)

    #
    #
    #

    def initKw(self, kw):
        kw = KwStruct(
            kw,
            strings=(_("&OK"),
                     (_("&All games..."), 102),
                     (TOP_TITLE+"...", 105),
                     (_("&Reset..."), 302)), default=0,
            image=self.app.gimages.logos[5],
            padx=10, pady=10,
        )
        return MfxDialog.initKw(self, kw)


# ************************************************************************
# *
# ************************************************************************

class CanvasFormatter(PysolStatsFormatter):
    def __init__(self, app, canvas, parent_window, font, w, h):
        self.app = app
        self.canvas = canvas
        self.parent_window = parent_window
        # self.fg = canvas.cget("insertbackground")
        self.fg = canvas.option_get('foreground', '') or \
            canvas.cget("insertbackground")
        self.font = font
        self.w = w
        self.h = h
        # self.x = self.y = 0
        self.gameid = None
        self.gamenumber = None
        self.canvas.config(yscrollincrement=h)
        self._tabs = None

    def _addItem(self, id):
        self.canvas.dialog.nodes[id] = (self.gameid, self.gamenumber)

    def _calc_tabs(self, arg):
        tw = 15*self.w
        # tw = 160
        self._tabs = [tw]
        font = tkinter_font.Font(self.canvas, self.font)
        for t in arg[1:]:
            tw = font.measure(t)+20
            self._tabs.append(tw)
        self._tabs.append(10)

    def pstats(self, y, args, gameid=None):
        x = 1
        t1, t2, t3, t4, t5, t6, t7 = args
        self.gameid = gameid
        if gameid is None:              # header
            self.gameid = 'header'
        for var, text, anchor, tab in (
            ('name',    t1, 'nw', self._tabs[0]+self._tabs[1]),
            ('played',  t2, 'ne', self._tabs[2]),
            ('won',     t3, 'ne', self._tabs[3]),
            ('lost',    t4, 'ne', self._tabs[4]),
            ('time',    t5, 'ne', self._tabs[5]),
            ('moves',   t6, 'ne', self._tabs[6]),
            ('percent', t7, 'ne', self._tabs[7]),
                ):
            self.gamenumber = None
            if gameid is None:          # header
                self.gamenumber = var
            id = self.canvas.create_text(x, y, text=text, anchor=anchor,
                                         font=self.font, fill=self.fg)
            self._addItem(id)
            x += tab
        self.pstats_perc(x, y, t7)

    def pstats_perc(self, x, y, t):
        if not (t and "0" <= t[0] <= "9"):
            return
        perc = int(round(float(str(t))))
        if perc < 1:
            return
        rx, ry, rw, rh = x, y+1, 2 + 8*10, self.h-5
        if 1:
            w = int(round(rw*perc/100.0))
            if 1 and w < 1:
                return
            if w > 0:
                w = max(3, w)
                w = min(rw - 2, w)
                self.canvas.create_rectangle(
                    rx, ry, rx+w, ry+rh, width=1,
                    fill="#00ff00", outline="#000000")
            if w < rw:
                self.canvas.create_rectangle(
                    rx+w, ry, rx+rw, ry+rh, width=1,
                    fill="#ff0000", outline="#000000")
            return
        # fill = "#ffffff"
        # fill = self.canvas["bg"]
        fill = None
        self.canvas.create_rectangle(rx, ry, rx+rw, ry+rh, width=1,
                                     fill=fill, outline="#808080")
        if 1:
            rx, rw = rx + 1, rw - 1
            ry, rh = ry + 1, rh - 1
            w = int(round(rw*perc/100.0))
            if w > 0:
                self.canvas.create_rectangle(rx, ry, rx+w, ry+rh, width=0,
                                             fill="#00ff00", outline="")
            if w < rw:
                self.canvas.create_rectangle(
                    rx+w, ry, rx+rw, ry+rh, width=0,
                    fill="#ff0000", outline="")
            return
        p = 1.0
        ix = rx + 2
        for i in (1, 11, 21, 31, 41, 51, 61, 71, 81, 91):
            if perc < i:
                break
            # c = "#ff8040"
            r, g, b = 255, 128*p, 64*p
            c = "#%02x%02x%02x" % (int(r), int(g), int(b))
            self.canvas.create_rectangle(ix, ry+2, ix+6, ry+rh-2, width=0,
                                         fill=c, outline=c)
            ix = ix + 8
            p = max(0.0, p - 0.1)

    def writeStats(self, player, sort_by='name'):
        header = self.getStatHeader()
        y = 0
        if self._tabs is None:
            self._calc_tabs(header)
        self.pstats(y, header)
        #
        y += 2*self.h
        for result in self.getStatResults(player, sort_by):
            gameid = result.pop()
            self.pstats(y, result, gameid)
            y += self.h
        #
        y += self.h
        total, played, won, lost, time_, moves, perc = self.getStatSummary()
        s = _("Total (%(played)d out of %(total)d games)") % {
            'played': played, 'total': total}
        self.pstats(y, (s, won+lost, won, lost, time_, moves, perc))

    def writeLog(self, player, prev_games):
        y = 0
        header = self.getLogHeader()
        t1, t2, t3, t4 = header
        s = "%-25s %-20s  %-17s  %s" % header
        id = self.canvas.create_text(1, y, text=s, anchor="nw",
                                     font=self.font, fill=self.fg)
        self._addItem(id)
        y += 2*self.h
        if not player or not prev_games:
            return 0
        for result in self.getLogResults(player, prev_games):
            s = "%-25s %-20s  %-17s  %s" % tuple(result[:4])
            id = self.canvas.create_text(1, y, text=s, anchor="nw",
                                         font=self.font, fill=self.fg)
            y += self.h
        return 1

    def writeFullLog(self, player):
        prev_games = self.app.stats.prev_games.get(player)
        return self.writeLog(player, prev_games)

    def writeSessionLog(self, player):
        prev_games = self.app.stats.session_games.get(player)
        return self.writeLog(player, prev_games)


# ************************************************************************
# *
# ************************************************************************

class AllGames_StatsDialogScrolledCanvas(MfxScrolledCanvas):
    pass


class AllGames_StatsDialog(MfxDialog):

    YVIEW = 0
    FONT_TYPE = "default"

    def __init__(self, parent, title, app, player, **kw):
        lines = 25
        # if parent and parent.winfo_screenheight() < 600:
        #    lines = 20
        #
        self.font = app.getFont(self.FONT_TYPE)
        font = tkinter_font.Font(parent, self.font)
        self.font_metrics = font.metrics()
        self.CHAR_H = self.font_metrics['linespace']
        self.CHAR_W = font.measure('M')
        self.app = app
        #
        self.player = player
        self.title = title
        self.sort_by = 'name'
        self.selected_game = None
        #
        kwdefault(kw, width=self.CHAR_W*64, height=lines*self.CHAR_H)
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.top.wm_minsize(200, 200)
        self.button = kw.default
        #
        self.sc = AllGames_StatsDialogScrolledCanvas(
            top_frame, width=kw.width, height=kw.height)
        self.sc.pack(fill='both', expand=True, padx=kw.padx, pady=kw.pady)
        #
        self.nodes = {}
        self.canvas = self.sc.canvas
        self.canvas.dialog = self
        bind(self.canvas, "<1>", self.singleClick)
        self.fillCanvas(player, title)
        bbox = self.canvas.bbox("all")
        # print bbox
        # self.canvas.config(scrollregion=bbox)
        dx, dy = 4, 0
        self.canvas.config(scrollregion=(-dx, -dy, bbox[2]+dx, bbox[3]+dy))
        self.canvas.xview_moveto(-dx)
        self.canvas.yview_moveto(self.YVIEW)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(
            kw,
            strings=(_("&OK"),
                     (_("&Save to file"), 202),
                     (_("&Reset all..."), 301),),
            default=0,
            resizable=True,
            padx=10, pady=10,
            # width=900,
        )
        return MfxDialog.initKw(self, kw)

    def destroy(self):
        self.app = None
        self.canvas.dialog = None
        self.nodes = {}
        self.sc.destroy()
        MfxDialog.destroy(self)

    def rearrange(self, sort_by):
        if self.sort_by == sort_by:
            return
        self.sort_by = sort_by
        self.fillCanvas(self.player, self.title)

    def singleClick(self, event=None):
        id = self.canvas.find_withtag('current')
        if not id:
            return
        # print 'singleClick:', id, self.nodes.get(id[0])
        gameid, gamenumber = self.nodes.get(id[0], (None, None))
        if gameid == 'header':
            if self.sort_by == gamenumber:
                return
            self.sort_by = gamenumber
            self.fillCanvas(self.player, self.title)
            return
        #  FIXME / TODO
        return
        if gameid and gamenumber:
            print(gameid, gamenumber)
        elif gameid:
            print(gameid)

    #
    #
    #

    def fillCanvas(self, player, header):
        self.canvas.delete('all')
        self.nodes = {}
        writer = CanvasFormatter(self.app, self.canvas, self,
                                 self.font, self.CHAR_W, self.CHAR_H)
        writer.writeStats(player, self.sort_by)


# ************************************************************************
# *
# ************************************************************************

class FullLog_StatsDialog(AllGames_StatsDialog):
    YVIEW = 1
    FONT_TYPE = "fixed"

    def fillCanvas(self, player, header):
        writer = CanvasFormatter(self.app, self.canvas, self,
                                 self.font, self.CHAR_W, self.CHAR_H)
        writer.writeFullLog(player)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), (_("Session &log..."), 104),
                               (_("&Save to file"), 203)), default=0,
                      width=76*self.CHAR_W,
                      )
        return AllGames_StatsDialog.initKw(self, kw)


class SessionLog_StatsDialog(FullLog_StatsDialog):
    def fillCanvas(self, player, header):
        PysolStatsFormatter()
        writer = CanvasFormatter(self.app, self.canvas, self,
                                 self.font, self.CHAR_W, self.CHAR_H)
        writer.writeSessionLog(player)

    def initKw(self, kw):
        kw = KwStruct(
            kw,
            strings=(_("&OK"), (_("&Full log..."), 103),
                     (_("&Save to file"), 204)),
            default=0,)
        return FullLog_StatsDialog.initKw(self, kw)

# ************************************************************************
# *
# ************************************************************************


class Status_StatsDialog(MfxMessageDialog):
    def __init__(self, parent, game):
        stats, gstats = game.stats, game.gstats
        w1 = w2 = ""
        n = 0
        for s in game.s.foundations:
            n = n + len(s.cards)
        w1 = (_("Highlight piles: ") + str(stats.highlight_piles) + "\n" +
              _("Highlight cards: ") + str(stats.highlight_cards) + "\n" +
              _("Highlight same rank: ") + str(stats.highlight_samerank) +
              "\n")
        if game.s.talon:
            if game.gameinfo.redeals != 0:
                w2 = w2 + _("\nRedeals: ") + str(game.s.talon.round - 1)
            w2 = w2 + _("\nCards in Talon: ") + str(len(game.s.talon.cards))
        if game.s.waste and game.s.waste not in game.s.foundations:
            w2 = w2 + _("\nCards in Waste: ") + str(len(game.s.waste.cards))
        if game.s.foundations:
            w2 = w2 + _("\nCards in Foundations: ") + str(n)
        #
        date = time.strftime(
            "%Y-%m-%d %H:%M",
            time.localtime(game.gstats.start_time))
        MfxMessageDialog.__init__(
            self, parent, title=_("Game status"),
            text=game.getTitleName() + "\n" +
            game.getGameNumber(format=1) + "\n" +
            _("Playing time: ") + game.getTime() + "\n" +
            _("Started at: ") + date + "\n\n" +
            _("Moves: ") + str(game.moves.index) + "\n" +
            _("Undo moves: ") + str(stats.undo_moves) + "\n" +
            _("Bookmark moves: ") + str(gstats.goto_bookmark_moves) + "\n" +
            _("Demo moves: ") + str(stats.demo_moves) + "\n" +
            _("Total player moves: ") + str(stats.player_moves) + "\n" +
            _("Total moves in this game: ") + str(stats.total_moves) + "\n" +
            _("Hints: ") + str(stats.hints) + "\n" +
            "\n" +
            w1 + w2,
            strings=(_("&OK"),
                     (_("&Statistics..."), 101),
                     (TOP_TITLE+"...", 105), ),
            image=game.app.gimages.logos[3],
            image_side="left", image_padx=20,
            padx=20,
            )

# ************************************************************************
# *
# ************************************************************************


class _TopDialog(MfxDialog):
    def __init__(self, parent, title, top, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        cnf = {'master': top_frame,
               'highlightthickness': 1,
               'highlightbackground': 'black',
               }
        frame = tkinter.Frame(**cnf)
        frame.pack(expand=True, fill='both', padx=10, pady=10)
        frame.columnconfigure(0, weight=1)
        cnf['master'] = frame
        cnf['text'] = _('N')
        label = tkinter.Label(**cnf)
        label.grid(row=0, column=0, sticky='ew')
        cnf['text'] = _('Game number')
        label = tkinter.Label(**cnf)
        label.grid(row=0, column=1, sticky='ew')
        cnf['text'] = _('Started at')
        label = tkinter.Label(**cnf)
        label.grid(row=0, column=2, sticky='ew')
        cnf['text'] = _('Result')
        label = tkinter.Label(**cnf)
        label.grid(row=0, column=3, sticky='ew')

        row = 1
        for i in top:
            # N
            cnf['text'] = str(row)
            label = tkinter.Label(**cnf)
            label.grid(row=row, column=0, sticky='ew')
            # Game number
            cnf['text'] = '#'+str(i.game_number)
            label = tkinter.Label(**cnf)
            label.grid(row=row, column=1, sticky='ew')
            # Start time
            t = time.strftime(
                '%Y-%m-%d %H:%M', time.localtime(i.game_start_time))
            cnf['text'] = t
            label = tkinter.Label(**cnf)
            label.grid(row=row, column=2, sticky='ew')
            # Result
            if isinstance(i.value, float):
                # time
                s = format_time(i.value)
            else:
                # moves
                s = str(i.value)
            cnf['text'] = s
            label = tkinter.Label(**cnf)
            label.grid(row=row, column=3, sticky='ew')
            row += 1

        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw, strings=(_('&OK'),), default=0, separator=True)
        return MfxDialog.initKw(self, kw)


class Top_StatsDialog(MfxDialog):
    def __init__(self, parent, title, app, player, gameid, **kw):
        self.app = app
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = tkinter.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=10, pady=10)
        frame.columnconfigure(0, weight=1)

        if (player in app.stats.games_stats and
            gameid in app.stats.games_stats[player] and
                app.stats.games_stats[player][gameid].time_result.top):

            tkinter.Label(frame, text=_('Minimum')).grid(row=0, column=1)
            tkinter.Label(frame, text=_('Maximum')).grid(row=0, column=2)
            tkinter.Label(frame, text=_('Average')).grid(row=0, column=3)
            # tkinter.Label(frame, text=_('Total')).grid(row=0, column=4)

            s = app.stats.games_stats[player][gameid]
            row = 1
            ll = [
                (_('Playing time:'),
                 format_time(s.time_result.min),
                 format_time(s.time_result.max),
                 format_time(s.time_result.average),
                 format_time(s.time_result.total),
                 s.time_result.top,
                 ),
                (_('Moves:'),
                 s.moves_result.min,
                 s.moves_result.max,
                 round(s.moves_result.average, 2),
                 s.moves_result.total,
                 s.moves_result.top,
                 ),
                (_('Total moves:'),
                 s.total_moves_result.min,
                 s.total_moves_result.max,
                 round(s.total_moves_result.average, 2),
                 s.total_moves_result.total,
                 s.total_moves_result.top,
                 ),
                ]
            #  if s.score_result.min:
            #      ll.append(('Score:',
            #                 s.score_result.min,
            #                 s.score_result.max,
            #                 round(s.score_result.average, 2),
            #                 s.score_result.top,
            #                 ))
            #  if s.score_casino_result.min:
            #      ll.append(('Casino Score:',
            #                 s.score_casino_result.min,
            #                 s.score_casino_result.max,
            #                 round(s.score_casino_result.average, 2), ))
            for l, min, max, avr, tot, top in ll:
                tkinter.Label(frame, text=l).grid(row=row, column=0)
                tkinter.Label(frame, text=str(min)).grid(row=row, column=1)
                tkinter.Label(frame, text=str(max)).grid(row=row, column=2)
                tkinter.Label(frame, text=str(avr)).grid(row=row, column=3)
                # tkinter.Label(frame, text=str(tot)).grid(row=row, column=4)
                b = tkinter.Button(frame, text=TOP_TITLE+' ...', width=10,
                                   command=lambda top=top: self.showTop(top))
                b.grid(row=row, column=5)
                row += 1
        else:
            tkinter.Label(frame, text=_('No TOP for this game')).pack()

        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def showTop(self, top):
        # print top
        _TopDialog(self.top, TOP_TITLE, top)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_('&OK'),),
                      default=0,
                      image=self.app.gimages.logos[4],
                      separator=True,
                      )
        return MfxDialog.initKw(self, kw)


# ************************************************************************
# *
# ************************************************************************

class ProgressionDialog(MfxDialog):
    def __init__(self, parent, title, app, player, gameid, **kw):

        font_name = app.getFont('default')
        font = tkinter_font.Font(parent, font_name)
        tkfont = tkinter_font.Font(parent, font)
        font_metrics = font.metrics()
        measure = tkfont.measure
        self.text_height = font_metrics['linespace']
        self.text_width = measure('XX.XX.XX')

        self.items = []
        self.formatter = ProgressionFormatter(app, player, gameid)

        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = tkinter.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        # constants
        self.canvas_width, self.canvas_height = 600, 250
        if parent.winfo_screenwidth() < 800 or \
                parent.winfo_screenheight() < 600:
            self.canvas_width, self.canvas_height = 400, 200
        self.xmargin, self.ymargin = 10, 10
        self.graph_dx, self.graph_dy = 10, 10
        self.played_color = '#ff7ee9'
        self.won_color = '#00dc28'
        self.percent_color = 'blue'
        # create canvas
        self.canvas = canvas = tkinter.Canvas(frame, bg='#dfe8ff',
                                              highlightthickness=1,
                                              highlightbackground='black',
                                              width=self.canvas_width,
                                              height=self.canvas_height)
        canvas.pack(side='left', padx=5)
        #
        dir = os.path.join('images', 'stats')
        try:
            fn = app.dataloader.findImage('progression', dir)
            self.bg_image = loadImage(fn)
            canvas.create_image(0, 0, image=self.bg_image, anchor='nw')
        except Exception:
            pass
        #
        tw = max(measure(_('Games/day')),
                 measure(_('Games/week')),
                 measure(_('% won')))
        self.left_margin = self.xmargin+tw//2
        self.right_margin = self.xmargin+tw//2
        self.top_margin = 15+self.text_height
        self.bottom_margin = 15+self.text_height+10+self.text_height
        #
        x0, y0 = self.left_margin, self.canvas_height-self.bottom_margin
        x1, y1 = self.canvas_width-self.right_margin, self.top_margin
        canvas.create_rectangle(x0, y0, x1, y1, fill='white')
        # horizontal axis
        canvas.create_line(x0, y0, x1, y0, width=3)

        # left vertical axis
        canvas.create_line(x0, y0, x0, y1, width=3)
        t = _('Games/day')
        self.games_text_id = canvas.create_text(x0-4, y1-4, anchor='s', text=t)

        # right vertical axis
        canvas.create_line(x1, y0, x1, y1, width=3)
        canvas.create_text(x1+4, y1-4, anchor='s', text=_('% won'))

        # caption
        d = self.text_height
        x, y = self.xmargin, self.canvas_height-self.ymargin
        canvas.create_rectangle(x, y, x+d, y-d, outline='black',
                                fill=self.played_color)
        x += d+5
        canvas.create_text(x, y, anchor='sw', text=_('Played'))
        x += measure(_('Played'))+20
        canvas.create_rectangle(x, y, x+d, y-d, outline='black',
                                fill=self.won_color)
        x += d+5
        canvas.create_text(x, y, anchor='sw', text=_('Won'))
        x += measure(_('Won'))+20
        canvas.create_rectangle(x, y, x+d, y-d, outline='black',
                                fill=self.percent_color)
        x += d+5
        canvas.create_text(x, y, anchor='sw', text=_('% won'))

        # right frame
        right_frame = tkinter.Frame(frame)
        right_frame.pack(side='left', fill='x', padx=5)
        self.all_games_variable = var = tkinter.StringVar()
        var.set('all')
        b = tkinter.Radiobutton(right_frame, text=_('All games'),
                                variable=var, value='all',
                                command=self.updateGraph,
                                justify='left', anchor='w'
                                )
        b.pack(fill='x', expand=True, padx=3, pady=1)
        b = tkinter.Radiobutton(right_frame, text=_('Current game'),
                                variable=var, value='current',
                                command=self.updateGraph,
                                justify='left', anchor='w'
                                )
        b.pack(fill='x', expand=True, padx=3, pady=1)
        label_frame = tkinter.LabelFrame(right_frame, text=_('Statistics for'))
        label_frame.pack(side='top', fill='x', pady=10)
        self.variable = var = tkinter.StringVar()
        var.set('week')
        for v, t in (
            ('week',  _('Last 7 days')),
            ('month', _('Last month')),
            ('year',  _('Last year')),
            ('all',   _('All time')),
                ):
            b = tkinter.Radiobutton(label_frame, text=t, variable=var, value=v,
                                    command=self.updateGraph,
                                    justify='left', anchor='w'
                                    )
            b.pack(fill='x', expand=True, padx=3, pady=1)
        label_frame = tkinter.LabelFrame(right_frame, text=_('Show graphs'))
        label_frame.pack(side='top', fill='x')
        self.played_graph_var = tkinter.BooleanVar()
        self.played_graph_var.set(True)
        b = tkinter.Checkbutton(label_frame, text=_('Played'),
                                command=self.updateGraph,
                                variable=self.played_graph_var,
                                justify='left', anchor='w'
                                )
        b.pack(fill='x', expand=True, padx=3, pady=1)
        self.won_graph_var = tkinter.BooleanVar()
        self.won_graph_var.set(True)
        b = tkinter.Checkbutton(label_frame, text=_('Won'),
                                command=self.updateGraph,
                                variable=self.won_graph_var,
                                justify='left', anchor='w'
                                )
        b.pack(fill='x', expand=True, padx=3, pady=1)
        self.percent_graph_var = tkinter.BooleanVar()
        self.percent_graph_var.set(True)
        b = tkinter.Checkbutton(label_frame, text=_('% won'),
                                command=self.updateGraph,
                                variable=self.percent_graph_var,
                                justify='left', anchor='w'
                                )
        b.pack(fill='x', expand=True, padx=3, pady=1)

        self.updateGraph()

        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw, strings=(_('&OK'),), default=0, separator=True)
        return MfxDialog.initKw(self, kw)

    def updateGraph(self, *args):
        interval = self.variable.get()
        canvas = self.canvas
        if self.items:
            canvas.delete(*self.items)
        self.items = []

        all_games = (self.all_games_variable.get() == 'all')
        result = self.formatter.getResults(interval, all_games)

        if interval in ('week', 'month'):
            t = _('Games/day')
        else:
            t = _('Games/week')
        canvas.itemconfig(self.games_text_id, text=t)

        graph_width = self.canvas_width-self.left_margin-self.right_margin
        graph_height = self.canvas_height-self.top_margin-self.bottom_margin
        dx = (graph_width-2*self.graph_dx)//(len(result)-1)
        graph_dx = (graph_width-(len(result)-1)*dx)//2
        dy = (graph_height-self.graph_dy)//5
        x0, y0 = self.left_margin, self.canvas_height-self.bottom_margin
        x1, y1 = self.canvas_width-self.right_margin, self.top_margin
        td = self.text_height//2

        # vertical scale
        x = x0+graph_dx
        xx = -100
        for res in result:
            if res[0] is not None and x > xx+self.text_width+4:
                # id = canvas.create_line(x, y0, x, y0-5, width=3)
                # self.items.append(id)
                id = canvas.create_line(x, y0, x, y1, stipple='gray50')
                self.items.append(id)
                id = canvas.create_text(x, y0+td, anchor='n', text=res[0])
                self.items.append(id)
                xx = x
            else:
                id = canvas.create_line(x, y0, x, y0-3, width=1)
                self.items.append(id)
            x += dx

        # horizontal scale
        max_games = max([i[1] for i in result])
        games_delta = max_games//5+1
        percent = 0
        games = 0
        for y in range(y0, y1, -dy):
            if y != y0:
                id = canvas.create_line(x0, y, x1, y, stipple='gray50')
                self.items.append(id)
            id = canvas.create_text(x0-td, y, anchor='e', text=str(games))
            self.items.append(id)
            id = canvas.create_text(x1+td, y, anchor='w', text=str(percent))
            self.items.append(id)
            games += games_delta
            percent += 20

        # draw result
        games_resolution = float(dy)/games_delta
        percent_resolution = float(dy)/20
        played_coords = []
        won_coords = []
        percent_coords = []
        x = x0+graph_dx
        for res in result:
            played, won = res[1], res[2]
            y = y0 - int(games_resolution*played)
            played_coords += [x, y]
            y = y0 - int(games_resolution*won)
            won_coords += [x, y]
            if played > 0:
                percent = int(100.*won/played)
            else:
                percent = 0
            y = y0 - int(percent_resolution*percent)
            percent_coords += [x, y]
            x += dx
        if self.played_graph_var.get():
            id = canvas.create_line(fill=self.played_color, width=3,
                                    *played_coords)
            self.items.append(id)
        if self.won_graph_var.get():
            id = canvas.create_line(fill=self.won_color, width=3,
                                    *won_coords)
            self.items.append(id)
        if self.percent_graph_var.get():
            id = canvas.create_line(fill=self.percent_color, width=3,
                                    *percent_coords)
            self.items.append(id)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os
import sys

from pysollib.mfxutil import Struct
from pysollib.mygettext import _
from pysollib.ui.tktile.tkhtml import Base_HTMLViewer

from six.moves import tkinter

from .statusbar import HtmlStatusbar
from .tkwidget import MfxMessageDialog

if __name__ == '__main__':
    d = os.path.abspath(os.path.join(sys.path[0], '..', '..'))
    sys.path.append(d)
    import gettext
    gettext.install('pysol', d, unicode=True)


# ************************************************************************
# *
# ************************************************************************

class HTMLViewer(Base_HTMLViewer):
    symbols_fn = {}  # filenames, loaded in Application.loadImages3
    symbols_img = {}

    def _calc_MfxMessageDialog(self):
        return MfxMessageDialog

    def __init__(self, parent, app=None, home=None):
        self.parent = parent
        self.app = app
        self.home = home
        self.url = None
        self.history = Struct(
            list=[],
            index=0,
        )
        self.visited_urls = []
        # need to keep a reference because of garbage collection
        self.images = {}
        self.defcursor = parent["cursor"]
        # self.defcursor = 'xterm'
        self.handcursor = "hand2"

        # create buttons
        button_width = 8
        self.homeButton = tkinter.Button(parent, text=_("Index"),
                                         width=button_width,
                                         command=self.goHome)
        self.homeButton.grid(row=0, column=0, sticky='w')
        self.backButton = tkinter.Button(parent, text=_("Back"),
                                         width=button_width,
                                         command=self.goBack)
        self.backButton.grid(row=0, column=1, sticky='w')
        self.forwardButton = tkinter.Button(parent, text=_("Forward"),
                                            width=button_width,
                                            command=self.goForward)
        self.forwardButton.grid(row=0, column=2, sticky='w')
        self.closeButton = tkinter.Button(parent, text=_("Close"),
                                          width=button_width,
                                          command=self.destroy)
        self.closeButton.grid(row=0, column=3, sticky='e')

        # create text widget
        text_frame = tkinter.Frame(parent)
        text_frame.grid(row=1, column=0, columnspan=4, sticky='nsew')
        text_frame.grid_propagate(False)
        vbar = tkinter.Scrollbar(text_frame)
        vbar.pack(side='right', fill='y')
        self.text = tkinter.Text(text_frame,
                                 fg='black', bg='white',
                                 bd=1, relief='sunken',
                                 cursor=self.defcursor,
                                 wrap='word', padx=10)
        self.text.pack(side='left', fill='both', expand=True)
        self.text["yscrollcommand"] = vbar.set
        vbar["command"] = self.text.yview

        # statusbar
        self.statusbar = HtmlStatusbar(parent, row=2, column=0, columnspan=4)

        parent.columnconfigure(2, weight=1)
        parent.rowconfigure(1, weight=1)

        # load images
        for name, fn in self.symbols_fn.items():
            self.symbols_img[name] = self.getImage(fn)

        self.initBindings()


# ************************************************************************
# *
# ************************************************************************


def tkhtml_main(args):
    try:
        url = args[1]
    except Exception:
        url = os.path.join(os.pardir, os.pardir, "data", "html", "index.html")
    top = tkinter.Tk()
    top.wm_minsize(400, 200)
    viewer = HTMLViewer(top)
    viewer.app = None
    viewer.display(url)
    top.mainloop()
    return 0


if __name__ == "__main__":
    sys.exit(tkhtml_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import USE_PIL
from pysollib.mygettext import _
from pysollib.ui.tktile.findcarddialog import \
        connect_game_find_card_dialog, \
        destroy_find_card_dialog
from pysollib.ui.tktile.menubar import PysolMenubarTkCommon
from pysollib.ui.tktile.solverdialog import connect_game_solver_dialog
from pysollib.util import CARDSET

from .selectcardset import SelectCardsetDialogWithPreview
from .selectgame import SelectGameDialog, SelectGameDialogWithPreview
from .selecttile import SelectTileDialogWithPreview
from .soundoptionsdialog import SoundOptionsDialog
from .tkwidget import MfxMessageDialog

# ************************************************************************
# * - create menubar
# * - update menubar
# * - menu actions
# ************************************************************************


class PysolMenubarTk(PysolMenubarTkCommon):
    def __init__(self, app, top, progress=None):
        PysolMenubarTkCommon.__init__(self, app, top, progress)

    def _connect_game_find_card_dialog(self, game):
        return connect_game_find_card_dialog(game)

    def _destroy_find_card_dialog(self):
        return destroy_find_card_dialog()

    def _connect_game_solver_dialog(self, game):
        return connect_game_solver_dialog(game)

    def _calcWizardDialog(self):
        from .wizarddialog import WizardDialog
        return WizardDialog

    def _calcSelectGameDialog(self):
        return SelectGameDialog

    def _calcSelectGameDialogWithPreview(self):
        return SelectGameDialogWithPreview

    def _calcSoundOptionsDialog(self):
        return SoundOptionsDialog

    def _calcSelectTileDialogWithPreview(self):
        return SelectTileDialogWithPreview

    def _calc_MfxMessageDialog(self):
        return MfxMessageDialog

    #
    # create the menubar
    #

    def createThemesMenu(self, menu):
        return

    def mSelectCardsetDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        # strings, default = ("&OK", "&Load", "&Cancel"), 0
        strings, default = (None, _("&Load"), _("&Cancel"),), 1
        strings, default = (None, _("&Load"), _("&Cancel"), _("&Info..."),), 1
        t = CARDSET
        key = self.app.nextgame.cardset.index
        d = SelectCardsetDialogWithPreview(
            self.top, title=_("Select ")+t,
            app=self.app, manager=self.app.cardset_manager, key=key,
            strings=strings, default=default)
        cs = self.app.cardset_manager.get(d.key)
        if d.status != 0 or d.button != 1 or cs is None:
            return
        if USE_PIL:
            changed = (self.app.opt.scale_x,
                       self.app.opt.scale_y,
                       self.app.opt.auto_scale,
                       self.app.opt.preserve_aspect_ratio) != d.scale_values
        else:
            changed = False
        if d.key == self.app.cardset.index and not changed:
            return
        if d.key >= 0:
            self.app.nextgame.cardset = cs
            if USE_PIL:
                (self.app.opt.scale_x,
                 self.app.opt.scale_y,
                 self.app.opt.auto_scale,
                 self.app.opt.preserve_aspect_ratio) = d.scale_values
                if not self.app.opt.auto_scale:
                    self.app.images.resize(self.app.opt.scale_x,
                                           self.app.opt.scale_y)
            self._cancelDrag()
            self.game.endGame(bookmark=1)
            self.game.quitGame(bookmark=1)

    def setToolbarRelief(self, relief):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_relief = relief
        self.tkopt.toolbar_relief.set(relief)           # update radiobutton
        self.app.toolbar.setRelief(relief)
        self.top.update_idletasks()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os

from pysollib.ui.tktile.tkutil import bind

from six.moves import tkinter

from .tkwidget import MfxScrolledCanvas


class MfxTreeBaseNode:
    def __init__(self, tree, parent_node, text, key):
        self.tree = tree
        self.parent_node = parent_node
        self.text = text
        self.key = key
        # state
        self.selected = 0
        self.subnodes = None
        # canvas item ids
        self.symbol_id = None
        self.text_id = None
        self.textrect_id = None

    def registerKey(self):
        if self.key is not None:
            lst = self.tree.keys.get(self.key, [])
            lst.append(self)
            self.tree.keys[self.key] = lst

    def whoami(self):
        if self.parent_node is None:
            return (self.text, )
        else:
            return self.parent_node.whoami() + (self.text, )

    def draw(self, x, y, lastx=None, lasty=None):
        canvas, style = self.tree.canvas, self.tree.style
        topleftx = x + style.distx
        toplefty = y - style.height // 2  # +++
        # draw the horizontal line
        if lastx is not None:
            canvas.create_line(
                x, y, topleftx, y, stipple=style.linestyle,
                fill=style.linecolor)
        # draw myself - ugly, ugly...
        self.selected = 0
        self.symbol_id = -1
        self.drawSymbol(topleftx, toplefty)
        linestart = style.distx + style.width + 5
        self.text_id = -1
        self.drawText(x + linestart, y)
        return x, y, x, y + style.disty

    #
    #
    #

    def drawText(self, x, y):
        canvas, style = self.tree.canvas, self.tree.style
        if self.selected:
            fg, bg = style.text_selected_fg, style.text_selected_bg
        else:
            fg, bg = style.text_normal_fg, style.text_normal_bg
        #
        if self.tree.nodes.get(self.text_id) is self:
            canvas.itemconfig(self.text_id, fill=fg)
        else:
            # note: I don't use Label + canvas.create_window here
            #   because it doesn't propagate events to the canvas
            #   and has some other re-display annoyances
            # print 'style.font:', style.font
            self.text_id = canvas.create_text(x+1, y, text=self.text,
                                              anchor="w", justify="left",
                                              font=style.font,
                                              fill=fg)
            self.tree.nodes[self.text_id] = self
        #
        if self.tree.nodes.get(self.textrect_id) is self:
            try:
                # _tkinter.TclError: unknown option "-fill" ???
                canvas.itemconfig(self.textrect_id, fill=bg)
            except tkinter.TclError:
                pass
        elif self.selected:
            b = canvas.bbox(self.text_id)
            self.textrect_id = canvas.create_rectangle(
                b[0]-1, b[1]-1, b[2]+1, b[3]+1,
                fill=bg, outline="")
            canvas.tag_lower(self.textrect_id, self.text_id)
            self.tree.nodes[self.textrect_id] = self

    def updateText(self):
        if self.tree.nodes.get(self.text_id) is self:
            self.drawText(-1, -1)

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        canvas, style = self.tree.canvas, self.tree.style
        color = kw.get("color")
        if color is None:
            if self.selected:
                color = "darkgreen"
            else:
                color = "green"
        # note: rectangle outline is one pixel
        if self.tree.nodes.get(self.symbol_id) is self:
            canvas.itemconfig(self.symbol_id, fill=color)
        else:
            self.symbol_id = canvas.create_rectangle(
                x+1, y+1, x + style.width, y + style.height, fill=color)
            self.tree.nodes[self.symbol_id] = self

    def updateSymbol(self):
        if self.tree.nodes.get(self.symbol_id) is self:
            self.drawSymbol(-1, -1)


# ************************************************************************
# * Terminal and non-terminal nodes
# ************************************************************************

class MfxTreeLeaf(MfxTreeBaseNode):
    def drawText(self, x, y):
        if self.text_id < 0:
            self.registerKey()
        MfxTreeBaseNode.drawText(self, x, y)


class MfxTreeNode(MfxTreeBaseNode):
    def __init__(self, tree, parent_node, text, key, expanded=0):
        MfxTreeBaseNode.__init__(self, tree, parent_node, text, key)
        self.expanded = expanded

    def drawChildren(self, x, y, lastx, lasty):
        # get subnodes
        self.subnodes = self.tree.getContents(self)
        # draw subnodes
        lx, ly = lastx, lasty
        nx, ny = x, y
        for node in self.subnodes:
            # update tree
            node.tree = self.tree
            # draw node
            lx, ly, nx, ny = node.draw(nx, ny, lx, ly)
        # draw the vertical line
        if self.subnodes:
            style = self.tree.style
            dy = (style.disty-style.width)//2
            y = y-style.disty//2-dy
            self.tree.canvas.create_line(x, y, nx, ly,
                                         stipple=style.linestyle,
                                         fill=style.linecolor)
        return ny

    def draw(self, x, y, ilastx=None, ilasty=None):
        # draw myself
        lx, ly, nx, ny = MfxTreeBaseNode.draw(self, x, y, ilastx, ilasty)
        if self.expanded:
            style = self.tree.style
            childx = nx + style.distx + style.width // 2
            childy = ny
            clastx = nx + style.distx + style.width // 2
            clasty = ly + style.height // 2
            ny = self.drawChildren(childx, childy, clastx, clasty)
        return lx, ly, x, ny

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        color = kw.get("color")
        if color is None:
            if self.expanded:
                color = "red"
            else:
                color = "pink"
        MfxTreeBaseNode.drawSymbol(self, x, y, color=color)


# ************************************************************************
# *
# ************************************************************************

class MfxTreeInCanvas(MfxScrolledCanvas):
    class Style:
        def __init__(self):
            self.distx = 16
            self.disty = 18
            self.width = 16         # width of symbol
            self.height = 16        # height of symbol
            self.originx = 0
            self.originy = 0
            self.text_normal_fg = "black"
            self.text_normal_bg = "white"
            self.text_selected_fg = "white"
            self.text_selected_bg = "#00008b"       # "darkblue"
            self.font = None
            self.linestyle = "gray50"
            self.linecolor = "black"

    def __init__(self, parent, rootnodes, **kw):
        bg = kw["bg"] = kw.get("bg") or parent.cget("bg")
        kw['bd'] = 0
        MfxScrolledCanvas.__init__(self, parent, **kw)
        #
        self.rootnodes = rootnodes
        self.updateNodesWithTree(self.rootnodes, self)
        self.selection_key = None
        self.nodes = {}
        self.keys = {}
        #
        self.style = self.Style()
        # self.style.text_normal_fg = self.canvas.cget("insertbackground")
        self.style.text_normal_fg = self.canvas.option_get('foreground', '') \
            or self.canvas.cget("insertbackground")
        self.style.text_normal_bg = bg
        #
        bind(self.canvas, "<ButtonPress-1>", self.singleClick)
        bind(self.canvas, "<Double-Button-1>", self.doubleClick)
        # bind(self.canvas, "<ButtonRelease-1>", xxx)
        self.pack(fill='both', expand=True)

    def destroy(self):
        for node in self.keys.get(self.selection_key, []):
            node.selected = 0
        MfxScrolledCanvas.destroy(self)

    def findNode(self, event=None):
        id = self.canvas.find_withtag('current')
        if id:
            return self.nodes.get(id[0])
        return None

    #
    # draw nodes
    #

    def draw(self):
        nx, ny = self.style.originx, self.style.originy
        # Account for initial offsets, see topleft[xy] in BaseNode.draw().
        # We do this so that our bounding box always starts at (0,0)
        # and the yscrollincrement works nicely.
        nx = nx - self.style.distx
        ny = ny + self.style.height // 2
        for node in self.rootnodes:
            # update tree
            node.tree = self
            # draw
            try:
                lx, ly, nx, ny = node.draw(nx, ny, None, None)
            except tkinter.TclError:
                # FIXME: Tk bug ???
                raise
        # set scroll region
        bbox = self.canvas.bbox("all")
        # self.canvas.config(scrollregion=bbox)
        self.canvas.config(scrollregion=(0, 0, bbox[2], bbox[3]))
        self.canvas.config(yscrollincrement=self.style.disty)

    def clear(self):
        self.nodes = {}
        self.keys = {}
        self.canvas.delete("all")

    def redraw(self):
        oldcur = self.canvas["cursor"]
        self.canvas["cursor"] = "watch"
        self.canvas.update_idletasks()
        self.clear()
        self.draw()
        self.updateSelection(self.selection_key)
        self.canvas["cursor"] = oldcur

    #
    #
    #

    def getContents(self, node):
        # Overload this, supposed to return a list of subnodes of node.
        pass

    def singleClick(self, event=None):
        # Overload this if you want to know when a node is clicked on.
        pass

    def doubleClick(self, event=None):
        # Overload this if you want to know when a node is d-clicked on.
        self.singleClick(event)

    #
    #
    #

    def updateSelection(self, key):
        l1 = self.keys.get(self.selection_key, [])
        l2 = self.keys.get(key, [])
        for node in l1:
            if node.selected and node not in l2:
                node.selected = 0
                node.updateSymbol()
                node.updateText()
        for node in l2:
            if not node.selected:
                node.selected = 1
                node.updateSymbol()
                node.updateText()
        self.selection_key = key

    def updateNodesWithTree(self, nodes, tree):
        for node in nodes:
            node.tree = tree
            if node.subnodes:
                self.updateNodesWithTree(node.subnodes, tree)


# ************************************************************************
# *
# ************************************************************************


class DirectoryBrowser(MfxTreeInCanvas):
    def __init__(self, parent, dirs):
        nodes = []
        if isinstance(dirs, str):
            dirs = (dirs,)
        for dir in dirs:
            self.addNode(nodes, None, dir, dir)
        # note: best results if height is a multiple of style.disty
        MfxTreeInCanvas.__init__(self, parent, nodes, height=25*18)
        self.draw()

    def addNode(self, list, node, filename, text):
        try:
            if os.path.isdir(filename):
                list.append(MfxTreeNode(self, node, text, key=filename))
            else:
                list.append(MfxTreeLeaf(self, node, text, key=filename))
        except EnvironmentError:
            pass

    def getContents(self, node):
        # use cached values
        if node.subnodes is not None:
            return node.subnodes
        #
        dir = node.key
        print("Getting %s" % dir)
        try:
            filenames = os.listdir(dir)
            filenames.sort()
        except EnvironmentError:
            return ()
        contents = []
        for filename in filenames:
            self.addNode(contents, node, os.path.join(dir, filename), filename)
        # print "gotten"
        return contents

    def singleClick(self, event=None):
        node = self.findNode(event)
        if not node:
            return
        print("Clicked node %s %s" % (node.text, node.key))
        if isinstance(node, MfxTreeLeaf):
            self.updateSelection(key=node.key)
        elif isinstance(node, MfxTreeNode):
            node.expanded = not node.expanded
            self.redraw()
        return "break"


if __name__ == "__main__":
    tk = tkinter.Tk()
    if os.name == "nt":
        app = DirectoryBrowser(tk, ("c:\\", "c:\\windows"))
    else:
        app = DirectoryBrowser(tk, ("/", "/home"))
    tk.mainloop()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.tk.tkwidget import MfxDialog
from pysollib.ui.tktile.tkutil import bind

from six.moves import tkinter
from six.moves import tkinter_font


class FontChooserDialog(MfxDialog):
    def __init__(self, parent, title, init_font, **kw):
        # print init_font
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        self.font_family = 'Helvetica'
        self.font_size = 12
        self.font_weight = 'normal'
        self.font_slant = 'roman'

        if init_font is not None:
            assert 2 <= len(init_font) <= 4
            assert isinstance(init_font[1], int)
            self.font_family, self.font_size = init_font[:2]
            if len(init_font) > 2:
                if init_font[2] in ['bold', 'normal']:
                    self.font_weight = init_font[2]
                elif init_font[2] in ['italic', 'roman']:
                    self.font_slant = init_font[2]
                else:
                    raise ValueError('invalid font style: '+init_font[2])
                if len(init_font) > 3:
                    if init_font[3] in ['bold', 'normal']:
                        self.font_weight = init_font[3]
                    elif init_font[2] in ['italic', 'roman']:
                        self.font_slant = init_font[3]
                    else:
                        raise ValueError('invalid font style: '+init_font[3])

        # self.family_var = tkinter.StringVar()
        self.weight_var = tkinter.BooleanVar()
        self.slant_var = tkinter.BooleanVar()
        self.size_var = tkinter.IntVar()

        frame = tkinter.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)
        # frame.rowconfigure(1, weight=1)
        self.entry = tkinter.Entry(frame, bg='white')
        self.entry.grid(row=0, column=0, columnspan=2, sticky='news')
        self.entry.insert('end', _('abcdefghABCDEFGH'))
        self.list_box = tkinter.Listbox(frame, width=36, exportselection=False)
        sb = tkinter.Scrollbar(frame)
        self.list_box.configure(yscrollcommand=sb.set)
        sb.configure(command=self.list_box.yview)
        self.list_box.grid(row=1, column=0, sticky='news')  # rowspan=4
        sb.grid(row=1, column=1, sticky='ns')
        bind(self.list_box, '<<ListboxSelect>>', self.fontupdate)
        # self.list_box.focus()
        cb1 = tkinter.Checkbutton(frame, anchor='w', text=_('Bold'),
                                  command=self.fontupdate,
                                  variable=self.weight_var)
        cb1.grid(row=2, column=0, columnspan=2, sticky='we')
        cb2 = tkinter.Checkbutton(frame, anchor='w', text=_('Italic'),
                                  command=self.fontupdate,
                                  variable=self.slant_var)
        cb2.grid(row=3, column=0, columnspan=2, sticky='we')

        sc = tkinter.Scale(frame, from_=6, to=40, resolution=1,
                           # label='Size',
                           orient='horizontal',
                           command=self.fontupdate, variable=self.size_var)
        sc.grid(row=4, column=0, columnspan=2, sticky='news')
        #
        self.size_var.set(self.font_size)
        self.weight_var.set(self.font_weight == 'bold')
        self.slant_var.set(self.font_slant == 'italic')
        font_families = list(tkinter_font.families())
        font_families.sort()
        selected = -1
        n = 0
        self.list_box.insert('end', *font_families)
        for font in font_families:
            if font.lower() == self.font_family.lower():
                selected = n
                break
            n += 1
        if selected >= 0:
            self.list_box.select_set(selected)
            self.list_box.see(selected)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

        self.font = (self.font_family, self.font_size,
                     self.font_slant, self.font_weight)

    def fontupdate(self, *args):
        if self.list_box.curselection():
            self.font_family = self.list_box.get(self.list_box.curselection())
        self.font_weight = self.weight_var.get() and 'bold' or 'normal'
        self.font_slant = self.slant_var.get() and 'italic' or 'roman'
        self.font_size = self.size_var.get()
        self.entry.configure(font=(self.font_family, self.font_size,
                                   self.font_slant, self.font_weight))

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")),
                      default=0,
                      padx=10, pady=10,
                      buttonpadx=10, buttonpady=5,
                      )
        return MfxDialog.initKw(self, kw)

# ************************************************************************
# *
# ************************************************************************


class FontsDialog(MfxDialog):
    def _font2title(self, font):
        return ' '.join(
            [str(i) for i in font if i not in ('roman', 'normal')])

    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = tkinter.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        self.fonts = {}
        row = 0
        for fn, title in (  # ('default',        _('Default')),
                          ('sans',           _('HTML: ')),
                          ('small',          _('Small: ')),
                          ('fixed',          _('Fixed: ')),
                          ('canvas_default', _('Tableau default: ')),
                          ('canvas_fixed',   _('Tableau fixed: ')),
                          ('canvas_large',   _('Tableau large: ')),
                          ('canvas_small',   _('Tableau small: ')),
                          ):
            font = app.opt.fonts[fn]
            self.fonts[fn] = font
            tkinter.Label(frame, text=title, anchor='w'
                          ).grid(row=row, column=0, sticky='we')
            if font:
                title = self._font2title(font)
            elif font is None:
                title = 'Default'
            label = tkinter.Label(frame, font=font, text=title)
            label.grid(row=row, column=1)
            b = tkinter.Button(frame, text=_('Change...'), width=10,
                               command=lambda label=label,
                               fn=fn: self.selectFont(label, fn))
            b.grid(row=row, column=2)
            row += 1
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def selectFont(self, label, fn):
        d = FontChooserDialog(self.top, _('Select font'), self.fonts[fn])
        if d.status == 0 and d.button == 0:
            self.fonts[fn] = d.font
            title = self._font2title(d.font)
            label.configure(font=d.font, text=title)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_('&OK'), _('&Cancel')),
                      default=0,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------
"""
a couple of classes for implementing partial tabbed-page like behaviour
"""

from six.moves import tkinter

MYRIDGE, MYRAISED = tkinter.RAISED, tkinter.RIDGE
# MYRIDGE, MYRAISED = tkinter.RIDGE, tkinter.RAISED


class InvalidTabPage(Exception):
    pass


class AlreadyExists(Exception):
    pass


class PageTab(tkinter.Frame):
    """
    a 'page tab' like framed button
    """
    def __init__(self, parent):
        tkinter.Frame.__init__(self, parent, borderwidth=2, relief=MYRIDGE)
        self.button = tkinter.Radiobutton(
            self, padx=5, pady=5, takefocus=0,
            indicatoron=tkinter.FALSE, highlightthickness=0,
            borderwidth=0, selectcolor=self.cget('bg'))
        self.button.pack()


class TabPageSet(tkinter.Frame):
    """
    a set of 'pages' with TabButtons for controlling their display
    """
    def __init__(self, parent, pageNames=[], **kw):
        """
        pageNames - a list of strings, each string will be the dictionary key
        to a page's data, and the name displayed on the page's tab. Should be
        specified in desired page order. The first page will be the default
        and first active page.
        """
        tkinter.Frame.__init__(self, parent, kw)
        self.grid_location(0, 0)
        self.columnconfigure(0, weight=1)
        self.rowconfigure(1, weight=1)
        self.tabBar = tkinter.Frame(self)
        self.tabBar.grid(row=0, column=0, sticky=tkinter.EW)
        self.activePage = tkinter.StringVar(self)
        self.defaultPage = ''
        self.pages = {}
        for name in pageNames:
            self.AddPage(name)

    def ChangePage(self, pageName=None):
        if pageName:
            if pageName in self.pages.keys():
                self.activePage.set(pageName)
            else:
                raise InvalidTabPage('Invalid TabPage Name')
        # pop up the active 'tab' only
        for page in self.pages.keys():
            self.pages[page]['tab'].config(relief=MYRIDGE)
        self.pages[self.GetActivePage()]['tab'].config(relief=MYRAISED)
        # switch page
        self.pages[self.GetActivePage()]['page'].lift()

    def GetActivePage(self):
        return self.activePage.get()

    def AddPage(self, pageName):
        if pageName in self.pages.keys():
            raise AlreadyExists('TabPage Name Already Exists')
        self.pages[pageName] = {
            'tab': PageTab(self.tabBar),
            'page': tkinter.Frame(self, borderwidth=2, relief=tkinter.RAISED)
            }
        self.pages[pageName]['tab'].button.config(
            text=pageName,
            command=self.ChangePage,
            variable=self.activePage,
            value=pageName
            )
        self.pages[pageName]['tab'].pack(side=tkinter.LEFT)
        self.pages[pageName]['page'].grid(row=1, column=0, sticky=tkinter.NSEW)
        if len(self.pages) == 1:  # adding first page
            self.defaultPage = pageName
            self.activePage.set(self.defaultPage)
            self.ChangePage()

    def RemovePage(self, pageName):
        if pageName not in self.pages.keys():
            raise InvalidTabPage('Invalid TabPage Name')
        self.pages[pageName]['tab'].pack_forget()
        self.pages[pageName]['page'].grid_forget()
        self.pages[pageName]['tab'].destroy()
        self.pages[pageName]['page'].destroy()
        del(self.pages[pageName])
        # handle removing last remaining, or default, or active page
        if not self.pages:  # removed last remaining page
            self.defaultPage = ''
            return
        if pageName == self.defaultPage:  # set a new default page
            self.defaultPage = \
                self.tabBar.winfo_children()[0].button.cget('text')
        if pageName == self.GetActivePage():  # set a new active page
            self.activePage.set(self.defaultPage)
        self.ChangePage()


if __name__ == '__main__':
    # test dialog
    root = tkinter.Tk()
    tabPage = TabPageSet(root, pageNames=['Foobar', 'Baz'])
    tabPage.pack(expand=tkinter.TRUE, fill=tkinter.BOTH)
    tkinter.Label(tabPage.pages['Foobar']['page'], text='Foo', pady=20).pack()
    tkinter.Label(tabPage.pages['Foobar']['page'], text='Bar', pady=20).pack()
    tkinter.Label(tabPage.pages['Baz']['page'], text='Baz').pack()
    entryPgName = tkinter.Entry(root)
    buttonAdd = tkinter.Button(
        root, text='Add Page',
        command=lambda: tabPage.AddPage(entryPgName.get()))
    buttonRemove = tkinter.Button(
        root, text='Remove Page',
        command=lambda: tabPage.RemovePage(entryPgName.get()))
    labelPgName = tkinter.Label(root, text='name of page to add/remove:')
    buttonAdd.pack(padx=5, pady=5)
    buttonRemove.pack(padx=5, pady=5)
    labelPgName.pack(padx=5)
    entryPgName.pack(padx=5)
    tabPage.ChangePage()
    root.mainloop()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.ui.tktile.selecttree import SelectDialogTreeData

import six
from six.moves import tkinter, tkinter_colorchooser

from .selecttree import SelectDialogTreeCanvas
from .selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from .tkwidget import MfxDialog, MfxScrolledCanvas


# ************************************************************************
# * Nodes
# ************************************************************************

class SelectTileLeaf(SelectDialogTreeLeaf):
    pass


class SelectTileNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        for obj in self.tree.data.all_objects:
            if self.select_func(obj):
                node = SelectTileLeaf(
                    self.tree, self, text=obj.name, key=obj.index)
                contents.append(node)
        return contents or self.tree.data.no_contents


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectTileData(SelectDialogTreeData):
    def __init__(self, manager, key):
        SelectDialogTreeData.__init__(self)
        self.all_objects = manager.getAllSortedByName()
        self.all_objects = [obj for obj in self.all_objects if not obj.error]
        self.all_objects = [tile for tile in self.all_objects
                            if tile.index > 0 and tile.filename]
        self.no_contents = [SelectTileLeaf(
            None, None, _("(no tiles)"), key=None), ]
        e1 = isinstance(key, str) or len(self.all_objects) <= 17
        e2 = 1
        self.rootnodes = (
            SelectTileNode(None, _("Solid Colors"), (
                SelectTileLeaf(None, None, _("Blue"), key="#0082df"),
                SelectTileLeaf(None, None, _("Green"), key="#008200"),
                SelectTileLeaf(None, None, _("Navy"), key="#000086"),
                SelectTileLeaf(None, None, _("Olive"), key="#868200"),
                SelectTileLeaf(None, None, _("Orange"), key="#f79600"),
                SelectTileLeaf(None, None, _("Teal"), key="#008286"),
            ), expanded=e1),
            SelectTileNode(
                None, _("All Backgrounds"), lambda tile: 1, expanded=e2),
        )


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************

class SelectTileTree(SelectDialogTreeCanvas):
    data = None


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectTileDialogWithPreview(MfxDialog):
    Tree_Class = SelectTileTree
    TreeDataHolder_Class = SelectTileTree
    TreeData_Class = SelectTileData

    def __init__(self, parent, title, app, manager, key=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        if key is None:
            key = manager.getSelected()
        self.app = app
        self.manager = manager
        self.key = key
        self.table_color = app.opt.colors['table']
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(manager, key)
        #
        self.top.wm_minsize(400, 200)
        if self.top.winfo_screenwidth() >= 800:
            w1, w2 = 200, 400
        else:
            w1, w2 = 200, 300
        font = app.getFont("default")
        padx, pady = 4, 4
        frame = tkinter.Frame(top_frame)
        frame.pack(fill='both', expand=True,
                   padx=kw.padx-padx, pady=kw.pady-pady)
        self.tree = self.Tree_Class(self, frame, key=key,
                                    default=kw.default,
                                    font=font, width=w1)
        self.tree.frame.pack(side="left", fill='both', expand=False,
                             padx=padx, pady=pady)
        self.preview = MfxScrolledCanvas(frame, width=w2, hbar=0, vbar=0)
        self.preview.pack(side="right", fill='both', expand=True,
                          padx=padx, pady=pady)
        self.preview.canvas.preview = 1
        # create a preview of the current state
        self.preview_key = -1
        self.updatePreview(key)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def destroy(self):
        self.tree.updateNodesWithTree(self.tree.rootnodes, None)
        self.tree.destroy()
        self.preview.unbind_all()
        MfxDialog.destroy(self)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Solid color..."), _("&Cancel"),),
                      default=0,
                      resizable=True,
                      font=None,
                      padx=10, pady=10,
                      buttonpadx=10, buttonpady=5,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if button == 0:        # "OK" or double click
            if isinstance(self.tree.selection_key, six.string_types):
                self.key = str(self.tree.selection_key)
            else:
                self.key = self.tree.selection_key
            self.tree.n_expansions = 1  # save xyview in any case
        if button == 1:        # "Solid color..."
            try:
                c = tkinter_colorchooser.askcolor(
                    master=self.top,
                    initialcolor=self.table_color,
                    title=_("Select table color"))
            except tkinter.TclError:
                pass
            else:
                if c and c[1]:
                    color = str(c[1])
                    self.key = color.lower()
                    self.table_color = self.key
                    self.tree.updateSelection(self.key)
                    self.updatePreview(self.key)
            return
        MfxDialog.mDone(self, button)

    def updatePreview(self, key):
        # print key
        if key == self.preview_key:
            return
        canvas = self.preview.canvas
        canvas.deleteAllItems()
        if isinstance(key, six.string_types):
            # solid color
            canvas.config(bg=key)
            canvas.setTile(None)
            canvas.setTextColor(None)
            self.preview_key = key
            self.table_color = key
        else:
            # image
            tile = self.manager.get(key)
            if tile:
                if self.preview.setTile(self.app, key):
                    return
            self.preview_key = -1
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.ui.tktile.tkconst import EVENT_HANDLED
from pysollib.ui.tktile.tkutil import makeToplevel, setTransient

from six.moves import tkinter

# ************************************************************************
# * a simple progress bar
# ************************************************************************


class PysolProgressBar:
    def __init__(self, app, parent, title=None, images=None, color="blue",
                 width=300, height=25, show_text=1, norm=1):
        self.parent = parent
        self.percent = 0
        self.top = makeToplevel(parent, title=title)
        self.top.wm_protocol("WM_DELETE_WINDOW", self.wmDeleteWindow)
        self.top.wm_group(parent)
        self.top.wm_resizable(False, False)
        self.frame = tkinter.Frame(self.top, relief='flat', bd=0,
                                   takefocus=0)
        self.cframe = tkinter.Frame(self.frame, relief='sunken', bd=1,
                                    takefocus=0)
        self.canvas = tkinter.Canvas(self.cframe, width=width, height=height,
                                     takefocus=0, bd=0, highlightthickness=0)
        self.scale = self.canvas.create_rectangle(-10, -10, 0, height,
                                                  outline=color, fill=color)
        self.text = -1
        if show_text:
            self.text = self.canvas.create_text(0, 0, anchor=tkinter.CENTER)
        self.cframe.grid_configure(column=0, row=0, sticky="ew")
        if images:
            self.f1 = tkinter.Label(self.frame, image=images[0])
            self.f1.grid_configure(
                column=0, row=0, sticky="ew", ipadx=8, ipady=4)
            self.cframe.grid_configure(column=1, row=0, sticky="ew", padx=8)
            self.f2 = tkinter.Label(self.frame, image=images[1])
            self.f2.grid_configure(
                column=2, row=0, sticky="ew", ipadx=8, ipady=4)
        self.top.config(cursor="watch")
        self.pack()
        if 1:
            setTransient(self.top, None, relx=0.5, rely=0.5)
        else:
            self.update(percent=0)
        self.norm = norm
        self.steps_sum = 0

    def wmDeleteWindow(self):
        return EVENT_HANDLED

    def destroy(self):
        if self.top is None:        # already destroyed
            return
        self.top.wm_withdraw()
        self.top.quit()
        self.top.destroy()
        self.top = None

    def pack(self, **kw):
        self.canvas.pack(fill=tkinter.X, expand=False)
        self.frame.pack(**kw)

    def reset(self, percent=0):
        self.percent = percent

    def update(self, percent=None, step=1):
        self.steps_sum += step
        # print self.steps_sum
        step //= self.norm
        if self.top is None:        # already destroyed
            return
        if percent is None:
            self.percent = self.percent + step
        elif percent > self.percent:
            self.percent = percent
        else:
            return
        self.percent = min(100, max(0, self.percent))
        c = self.canvas
        width, height = c.winfo_reqwidth(), c.winfo_reqheight()
        c.coords(self.scale, -10, -10,
                 (self.percent * width) / 100.0, height)
        if self.text >= 0:
            c.coords(self.text, width//2, height//2)
            c.itemconfig(self.text, text="%d %%" % int(round(self.percent)))
        c.update()


# ************************************************************************
# *
# ************************************************************************


class TestProgressBar:
    def __init__(self, parent):
        self.parent = parent
        self.progress = PysolProgressBar(
            None, parent, title="Progress", color="#008200")
        self.progress.pack(ipadx=10, ipady=10)
        self.progress.frame.after(1000, self.update)

    def update(self, event=None):
        if self.progress.percent >= 100:
            self.parent.after_idle(self.progress.destroy)
            return
        self.progress.update(step=1)
        self.progress.frame.after(30, self.update)


def progressbar_main(args):
    from pysollib.ui.tktile.tkutil import wm_withdraw
    tk = tkinter.Tk()
    wm_withdraw(tk)
    TestProgressBar(tk)
    tk.mainloop()
    return 0


if __name__ == "__main__":
    import sys
    sys.exit(progressbar_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import time
import traceback

from pysollib.mfxutil import KwStruct, destruct, kwdefault, openURL
from pysollib.mygettext import _
from pysollib.settings import WIN_SYSTEM
from pysollib.ui.tktile.tkcanvas import MfxCanvas
from pysollib.ui.tktile.tkutil import after, after_cancel
from pysollib.ui.tktile.tkutil import bind, unbind_destroy
from pysollib.ui.tktile.tkutil import makeToplevel, setTransient

import six
from six.moves import tkinter
from six.moves import tkinter_font

# ************************************************************************
# * abstract base class for the dialogs in this module
# ************************************************************************


class MfxDialog:  # ex. _ToplevelDialog
    img = {}
    button_img = {}

    def __init__(self, parent, title="", resizable=False, default=-1):
        self.parent = parent
        self.status = 0
        self.button = default
        self.timer = None
        self.buttons = []
        self.accel_keys = {}
        self.top = makeToplevel(parent, title=title)
        self.top.wm_resizable(resizable, resizable)
        # w, h = self.top.winfo_screenwidth(), self.top.winfo_screenheight()
        # self.top.wm_maxsize(w-4, h-32)
        bind(self.top, "WM_DELETE_WINDOW", self.wmDeleteWindow)
        #

    def mainloop(self, focus=None, timeout=0, transient=True):
        bind(self.top, "<Escape>", self.mCancel)
        bind(self.top, '<Alt-Key>', self.altKeyEvent)  # for accelerators
        if focus is not None:
            focus.focus()
        if transient:
            setTransient(self.top, self.parent)
            try:
                self.top.grab_set()
            except tkinter.TclError:
                if traceback:
                    traceback.print_exc()
                pass
            if timeout > 0:
                self.timer = after(self.top, timeout, self.mTimeout)
            try:
                self.top.mainloop()
            except SystemExit:
                pass
            self.destroy()

    def destroy(self):
        after_cancel(self.timer)
        unbind_destroy(self.top)
        try:
            self.top.wm_withdraw()
        except Exception:
            if traceback:
                traceback.print_exc()
            pass
        try:
            self.top.destroy()
        except Exception:
            if traceback:
                traceback.print_exc()
            pass
        # destruct(self.top)
        if 1 and self.parent:  # ???
            try:
                # self.parent.update_idletasks()
                # FIXME: why do we need this under Windows ?
                if hasattr(self.parent, "busyUpdate"):
                    self.parent.busyUpdate()
                else:
                    self.parent.update()
            except Exception:
                if traceback:
                    traceback.print_exc()
                pass
        self.top = None
        self.parent = None

    def wmDeleteWindow(self, *event):
        self.status = 1
        raise SystemExit
        # return EVENT_HANDLED

    def mCancel(self, *event):
        self.status = 1
        raise SystemExit

    def mTimeout(self, *event):
        self.status = 2
        raise SystemExit

    def mDone(self, button):
        self.button = button
        raise SystemExit

    def altKeyEvent(self, event):
        key = event.char
        key = six.text_type(key, 'utf-8')
        key = key.lower()
        button = self.accel_keys.get(key)
        if button is not None:
            self.mDone(button)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      timeout=0, resizable=False,
                      text="", justify="center",
                      strings=(_("&OK"),),
                      default=0,
                      width=0,
                      padx=20, pady=20,
                      bitmap=None, bitmap_side="left",
                      bitmap_padx=10, bitmap_pady=20,
                      image=None, image_side="left",
                      image_padx=10, image_pady=20,
                      )
        # default to separator if more than one button
        sep = len(kw.strings) > 1
        kwdefault(kw.__dict__, separator=sep)
        return kw

    def createFrames(self, kw):
        bottom_frame = tkinter.Frame(self.top)
        bottom_frame.pack(side='bottom', fill='both', expand=False,
                          ipadx=3, ipady=3)
        if kw.separator:
            separator = tkinter.Frame(
                self.top, relief="sunken",
                height=2, width=2, borderwidth=1)
            separator.pack(side='bottom', fill='x')
        top_frame = tkinter.Frame(self.top)
        top_frame.pack(side='top', fill='both', expand=True)
        return top_frame, bottom_frame

    def createBitmaps(self, frame, kw):
        if kw.bitmap:  # in ("error", "info", "question", "warning")
            img = self.img.get(kw.bitmap)
            b = tkinter.Label(frame, image=img)
            b.pack(side=kw.bitmap_side, padx=kw.bitmap_padx,
                   pady=kw.bitmap_pady)
        elif kw.image:
            b = tkinter.Label(frame, image=kw.image)
            b.pack(side=kw.image_side, padx=kw.image_padx, pady=kw.image_pady)

    def createButtons(self, frame, kw):
        button = -1
        column = 0
        padx, pady = kw.get("buttonpadx", 10), kw.get("buttonpady", 10)
        focus = None
        max_len = 0
        for s in kw.strings:
            if isinstance(s, tuple):
                s = s[0]
            if s:
                # if os.name == 'posix':
                #    s = s.replace('...', '.')
                s = s.replace('&', '')
                max_len = max(max_len, len(s))
            # print s, len(s)
        if max_len > 12 and WIN_SYSTEM == 'x11':
            button_width = max_len
        elif max_len > 9:
            button_width = max_len+1
        elif max_len > 6:
            button_width = max_len+2
        else:
            button_width = 8
        # print 'button_width =', button_width
        #
        #
        for s in kw.strings:
            xbutton = button = button + 1
            if isinstance(s, tuple):
                assert len(s) == 2
                button = int(s[1])
                s = s[0]
            if s is None:
                continue
            accel_indx = s.find('&')
            s = s.replace('&', '')
            if button < 0:
                b = tkinter.Button(frame, text=s, state="disabled")
                button = xbutton
            else:
                b = tkinter.Button(
                    frame, text=s, default="normal",
                    command=(lambda self=self, button=button:
                             self.mDone(button)))
                if button == kw.default:
                    focus = b
                    focus.config(default="active")
            self.buttons.append(b)
            #
            b.config(width=button_width)
            if accel_indx >= 0:
                # key accelerator
                b.config(underline=accel_indx)
                key = s[accel_indx]
                self.accel_keys[key.lower()] = button
            #
            #  img = None
            #  if self.button_img:
            #      img = self.button_img.get(s)
            #  b.config(compound='left', image=img)
            column += 1
            b.grid(column=column, row=0, sticky="ns", padx=padx, pady=pady)
        if focus is not None:
            cb = (lambda event=None, self=self, button=kw.default:
                  self.mDone(button))
            bind(self.top, "<Return>", cb)
            bind(self.top, "<KP_Enter>", cb)
        frame.columnconfigure(0, weight=1)
        frame.columnconfigure(99, weight=1)
        return focus


# ************************************************************************
# * replacement for the tk_dialog script
# ************************************************************************

class MfxMessageDialog(MfxDialog):
    def __init__(self, parent, title, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.button = kw.default
        msg = tkinter.Label(top_frame, text=kw.text, justify=kw.justify,
                            width=kw.width)
        msg.pack(fill='both', expand=True, padx=kw.padx, pady=kw.pady)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)


# ************************************************************************
# *
# ************************************************************************

class MfxExceptionDialog(MfxMessageDialog):
    def __init__(self, parent, ex, title="Error", **kw):
        kw = KwStruct(kw, bitmap="error")
        text = kw.get("text", "")
        if not text.endswith("\n"):
            text = text + "\n"
        text = text + "\n"
        if isinstance(ex, EnvironmentError) and ex.filename is not None:
            t = "[Errno %s] %s:\n%s" % \
                (ex.errno, ex.strerror, repr(ex.filename))
        else:
            t = str(ex)
        kw.text = text + six.text_type(t, errors='replace')
        MfxMessageDialog.__init__(self, parent, title, **kw.getKw())


# ************************************************************************
# *
# ************************************************************************

class PysolAboutDialog(MfxMessageDialog):
    def __init__(self, app, parent, title, **kw):
        self._url = kw['url']
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.button = kw.default
        frame = tkinter.Frame(top_frame)
        frame.pack(fill='both', expand=True, padx=kw.padx, pady=kw.pady)
        msg = tkinter.Label(frame, text=kw.text, justify=kw.justify,
                            width=kw.width)
        msg.pack(fill='both', expand=True)

        font = tkinter_font.Font(parent, app.getFont('default'))
        font.configure(underline=True)
        url_label = tkinter.Label(frame, text=kw.url, font=font,
                                  foreground='blue', cursor='hand2')
        url_label.pack()
        url_label.bind('<1>', self._urlClicked)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def _urlClicked(self, event):
        openURL(self._url)


# ************************************************************************
# *
# ************************************************************************

class MfxSimpleEntry(MfxDialog):
    def __init__(self, parent, title, label, value, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.value = value
        if label:
            label = tkinter.Label(top_frame, text=label, takefocus=0)
            label.pack(pady=5)
        w = kw.get("e_width", 0)    # width in characters
        self.var = tkinter.Entry(top_frame, exportselection=1, width=w)
        self.var.insert(0, value)
        self.var.pack(side='top', padx=kw.padx, pady=kw.pady)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.var
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")), default=0,
                      separator=False,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        self.button = button
        self.value = self.var.get()
        raise SystemExit


# ************************************************************************
# * a simple tooltip
# ************************************************************************

class MfxTooltip:
    last_leave_time = 0

    def __init__(self, widget):
        # private vars
        self.widget = widget
        self.text = None
        self.timer = None
        self.cancel_timer = None
        self.tooltip = None
        self.label = None
        self.bindings = []
        self.bindings.append(self.widget.bind("<Enter>", self._enter))
        self.bindings.append(self.widget.bind("<Leave>", self._leave))
        self.bindings.append(self.widget.bind("<ButtonPress>", self._leave))
        # user overrideable settings
        self.timeout = 800                    # milliseconds
        self.cancel_timeout = 5000
        self.leave_timeout = 400
        self.relief = 'solid'
        self.justify = 'left'
        self.fg = "#000000"
        self.bg = "#ffffe0"
        self.xoffset = 0
        self.yoffset = 4

    def setText(self, text):
        self.text = text

    def _unbind(self):
        if self.bindings and self.widget:
            self.widget.unbind("<Enter>", self.bindings[0])
            self.widget.unbind("<Leave>", self.bindings[1])
            self.widget.unbind("<ButtonPress>", self.bindings[2])
            self.bindings = []

    def destroy(self):
        self._unbind()
        self._leave()

    def _enter(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.cancel_timer = None
        if time.time() - MfxTooltip.last_leave_time < self.leave_timeout/1000.:
            self._showTip()
        else:
            self.timer = after(self.widget, self.timeout, self._showTip)

    def _leave(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.timer = self.cancel_timer = None
        if self.tooltip:
            self.label.destroy()
            destruct(self.label)
            self.label = None
            self.tooltip.destroy()
            destruct(self.tooltip)
            self.tooltip = None
            MfxTooltip.last_leave_time = time.time()

    def _showTip(self):
        self.timer = None
        if self.tooltip or not self.text:
            return
        #  if isinstance(self.widget, (tkinter.Button, tkinter.Checkbutton)):
        #      if self.widget["state"] == 'disabled':
        #          return
        # x = self.widget.winfo_rootx()
        x = self.widget.winfo_pointerx()
        y = self.widget.winfo_rooty() + self.widget.winfo_height()
        x += self.xoffset
        y += self.yoffset
        self.tooltip = tkinter.Toplevel()
        self.tooltip.wm_iconify()
        self.tooltip.wm_overrideredirect(1)
        self.tooltip.wm_protocol("WM_DELETE_WINDOW", self.destroy)
        self.label = tkinter.Label(self.tooltip, text=self.text,
                                   relief=self.relief, justify=self.justify,
                                   fg=self.fg, bg=self.bg, bd=1, takefocus=0)
        self.label.pack(ipadx=1, ipady=1)
        self.tooltip.wm_geometry("%+d%+d" % (x, y))
        self.tooltip.wm_deiconify()
        self.cancel_timer = after(
            self.widget, self.cancel_timeout, self._leave)
        # self.tooltip.tkraise()


# ************************************************************************
# * A canvas widget with scrollbars and some useful bindings.
# ************************************************************************

class MfxScrolledCanvas:
    def __init__(self, parent, hbar=True, vbar=True, propagate=False, **kw):
        kwdefault(kw, highlightthickness=0, bd=1, relief='sunken')
        self.parent = parent
        self.createFrame(kw)
        self.canvas = None
        self.hbar = None
        self.vbar = None
        self.hbar_show = False
        self.vbar_show = False
        self.createCanvas(kw)
        self.frame.grid_rowconfigure(0, weight=1)
        self.frame.grid_columnconfigure(0, weight=1)
        self.frame.grid_propagate(propagate)
        if hbar:
            self.createHbar()
            self.bindHbar()
        if vbar:
            self.createVbar()
            self.bindVbar()
        # self.canvas.focus_set()

    #
    #
    #

    def destroy(self):
        self.unbind_all()
        self.canvas.destroy()
        self.frame.destroy()

    def pack(self, **kw):
        self.frame.pack(**kw)

    def grid(self, **kw):
        self.frame.grid(**kw)

    #
    #
    #

    def setTile(self, app, i, force=False):
        tile = app.tabletile_manager.get(i)
        if tile is None or tile.error:
            return False
        # print i, tile
        if i == 0:
            assert tile.color
            assert tile.filename is None
        else:
            assert tile.color is None
            assert tile.filename
            assert tile.basename
        if not force:
            if i == app.tabletile_index and \
                   tile.color == app.opt.colors['table']:
                return False
        #
        if not self.canvas.setTile(
                tile.filename, tile.stretch, tile.save_aspect):
            tile.error = True
            return False

        if i == 0:
            self.canvas.config(bg=tile.color)
            # app.top.config(bg=tile.color)
        else:
            self.canvas.config(bg=app.top_bg)
            # app.top.config(bg=app.top_bg)

        self.canvas.setTextColor(app.opt.colors['text'])

        return True

    #
    #
    #

    def unbind_all(self):
        unbind_destroy(self.hbar)
        unbind_destroy(self.vbar)
        unbind_destroy(self.canvas)
        unbind_destroy(self.frame)

    def createFrame(self, kw):
        width = kw.get("width")
        height = kw.get("height")
        self.frame = tkinter.Frame(self.parent, width=width, height=height)

    def createCanvas(self, kw):
        bd = kw['bd']
        kw['bd'] = 0
        relief = kw['relief']
        del kw['relief']
        frame = tkinter.Frame(self.frame, bd=bd, relief=relief)
        frame.grid(row=0, column=0, sticky="news")
        self.canvas = MfxCanvas(frame, **kw)
        self.canvas.pack(expand=True, fill='both')

    def createHbar(self):
        self.hbar = tkinter.Scrollbar(self.frame, takefocus=0,
                                      orient="horizontal")
        self.canvas["xscrollcommand"] = self._setHbar
        self.hbar["command"] = self.canvas.xview
        self.hbar.grid(row=1, column=0, sticky="we")
        self.hbar.grid_remove()

    def createVbar(self):
        self.vbar = tkinter.Scrollbar(self.frame, takefocus=0)
        self.canvas["yscrollcommand"] = self._setVbar
        self.vbar["command"] = self.canvas.yview
        self.vbar.grid(row=0, column=1, sticky="ns")
        self.vbar.grid_remove()

    def bindHbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Left>", self.unit_left)
        bind(w, "<KeyPress-Right>", self.unit_right)

    def bindVbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Prior>", self.page_up)
        bind(w, "<KeyPress-Next>", self.page_down)
        bind(w, "<KeyPress-Up>", self.unit_up)
        bind(w, "<KeyPress-Down>", self.unit_down)
        bind(w, "<KeyPress-Begin>", self.scroll_top)
        bind(w, "<KeyPress-Home>", self.scroll_top)
        bind(w, "<KeyPress-End>", self.scroll_bottom)
        # mousewheel support
        if WIN_SYSTEM == 'x11':
            bind(w, '<4>', self.mouse_wheel_up)
            bind(w, '<5>', self.mouse_wheel_down)
        # don't work on Linux
        # bind(w, '<MouseWheel>', self.mouse_wheel)

    def mouse_wheel(self, *args):
        print('MfxScrolledCanvas.mouse_wheel', args)

    def _setHbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.hbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.hbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.hbar_show = True
        sb.set(first, last)

    def _setVbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.vbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.vbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.vbar_show = True
        sb.set(first, last)

    def _xview(self, *args):
        if self.hbar_show:
            self.canvas.xview(*args)
        return 'break'

    def _yview(self, *args):
        if self.vbar_show:
            self.canvas.yview(*args)
        return 'break'

    def page_up(self, *event):
        return self._yview('scroll', -1, 'page')

    def page_down(self, *event):
        return self._yview('scroll', 1, 'page')

    def unit_up(self, *event):
        return self._yview('scroll', -1, 'unit')

    def unit_down(self, *event):
        return self._yview('scroll', 1, 'unit')

    def mouse_wheel_up(self, *event):
        return self._yview('scroll', -5, 'unit')

    def mouse_wheel_down(self, *event):
        return self._yview('scroll', 5, 'unit')

    def page_left(self, *event):
        return self._xview('scroll', -1, 'page')

    def page_right(self, *event):
        return self._xview('scroll', 1, 'page')

    def unit_left(self, *event):
        return self._xview('scroll', -1, 'unit')

    def unit_right(self, *event):
        return self._xview('scroll', 1, 'unit')

    def scroll_top(self, *event):
        return self._yview('moveto', 0)

    def scroll_bottom(self, *event):
        return self._yview('moveto', 1)


# ************************************************************************
# *
# ************************************************************************

class StackDesc:

    def __init__(self, game, stack):
        self.game = game
        self.stack = stack
        self.canvas = game.canvas
        self.bindings = []

        font = game.app.getFont('canvas_small')
        # print self.app.cardset.CARDW, self.app.images.CARDW
        cardw = game.app.images.CARDW
        x, y = stack.x+cardw/2, stack.y
        text = stack.getHelp()+'\n'+stack.getBaseCard()
        text = text.strip()
        if text:
            frame = tkinter.Frame(self.canvas)
            self.frame = frame
            label = tkinter.Message(frame, font=font, text=text,
                                    width=cardw-8, relief='solid',
                                    fg='#000000', bg='#ffffe0', bd=1)
            label.pack()
            self.label = label
            self.id = self.canvas.create_window(x, y, window=frame, anchor='n')
            self.bindings.append(
                label.bind('<ButtonPress>', self._buttonPressEvent))
            # self.bindings.append(label.bind('<Enter>', self._enterEvent))
        else:
            self.id = None

    def _buttonPressEvent(self, *event):
        # self.game.deleteStackDesc()
        self.frame.tkraise()

    def _enterEvent(self, *event):
        self.frame.tkraise()

    def delete(self):
        if self.id:
            self.canvas.delete(self.id)
            for b in self.bindings:
                self.label.unbind('<ButtonPress>', b)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.wizardpresets import presets
from pysollib.wizardutil import WizardWidgets

import six
from six.moves import tkinter

from .tabpage import TabPageSet
from .tkwidget import MfxDialog


class WizardDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = tkinter.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=10, pady=10)
        frame.columnconfigure(0, weight=1)

        notebook = TabPageSet(frame)
        notebook.pack(expand=True, fill='both')

        for w in WizardWidgets:
            if isinstance(w, six.string_types):
                notebook.AddPage(w)
                frame = tkinter.Frame(notebook.pages[w]['page'])
                frame.pack(expand=True, fill='both', padx=2, pady=4)
                frame.columnconfigure(1, weight=1)
                row = 0
                continue

            tkinter.Label(frame, text=w.label).grid(row=row, column=0, padx=2)

            if w.widget == 'preset':
                if w.variable is None:
                    w.variable = tkinter.StringVar()
                values = [_(v) for v in w.values]
                default = _(w.default)
                values.remove(default)
                values.sort()
                values.insert(0, default)

                def callback(v, w=w):
                    return self.presetSelected(v, w)
                om = tkinter.OptionMenu(frame, w.variable,
                                        command=callback, *values)
                om.grid(row=row, column=1, sticky='ew', padx=2)
            elif w.widget == 'entry':
                if w.variable is None:
                    w.variable = tkinter.StringVar()
                en = tkinter.Entry(frame, textvariable=w.variable)
                en.grid(row=row, column=1, sticky='ew', padx=2)
            elif w.widget == 'menu':
                if w.variable is None:
                    w.variable = tkinter.StringVar()
                values = [_(v) for v in w.values]
                om = tkinter.OptionMenu(frame, w.variable, *values)
                om.grid(row=row, column=1, sticky='ew', padx=2)
            elif w.widget == 'spin':
                if w.variable is None:
                    w.variable = tkinter.IntVar()
                from_, to = w.values
                s = tkinter.Scale(frame, from_=from_, to=to, resolution=1,
                                  orient='horizontal', length=200,
                                  variable=w.variable)
                s.grid(row=row, column=1, sticky='ew', padx=2)
            elif w.widget == 'check':
                if w.variable is None:
                    w.variable = tkinter.BooleanVar()
                ch = tkinter.Checkbutton(frame, variable=w.variable,
                                         takefocus=False, anchor='w')
                ch.grid(row=row, column=1, sticky='ew', padx=2, pady=2)

            if w.current_value is None:
                v = w.default
            else:
                v = w.current_value
            if w.widget in ('menu', 'preset', 'entry'):
                v = _(v)
            w.variable.set(v)

            row += 1

        notebook.ChangePage()

        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def presetSelected(self, v, w):
        n = w.translation_map[v]
        p = presets[n]
        for w in WizardWidgets:
            if isinstance(w, six.string_types):
                continue
            if w.var_name in p:
                v = p[w.var_name]
            else:
                v = w.default
            if w.widget in ('menu', 'preset', 'entry'):
                v = _(v)
            w.variable.set(v)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_('&OK'), _('&Cancel')),
                      default=0,
                      separator=False,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import pysollib.ui.tktile.gameinfodialog
from pysollib.tk.basetkmfxdialog import BaseTkMfxDialog


class GameInfoDialog(pysollib.ui.tktile.gameinfodialog.BaseGameInfoDialog,
                     BaseTkMfxDialog):
    True
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# imports

# Toolkit imports
from pysollib.tk.basetkmfxdialog import BaseTkMfxDialog
from pysollib.ui.tktile.edittextdialog import BaseEditTextDialog

# ************************************************************************
# *
# ************************************************************************


class EditTextDialog(BaseEditTextDialog, BaseTkMfxDialog):
    def _calc_Resizable(self):
        return True
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os

from pysollib.mfxutil import KwStruct, USE_PIL
from pysollib.mygettext import _
from pysollib.resource import CSI
from pysollib.ui.tktile.selecttree import SelectDialogTreeData
from pysollib.ui.tktile.tkcanvas import MfxCanvasImage
from pysollib.ui.tktile.tkutil import loadImage
from pysollib.util import CARDSET

from six.moves import tkinter

from .selecttree import SelectDialogTreeCanvas
from .selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from .tkwidget import MfxDialog, MfxScrolledCanvas


# ************************************************************************
# * Nodes
# ************************************************************************

class SelectCardsetLeaf(SelectDialogTreeLeaf):
    pass


class SelectCardsetNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        for obj in self.tree.data.all_objects:
            if self.select_func(obj):
                node = SelectCardsetLeaf(
                    self.tree, self, text=obj.name, key=obj.index)
                contents.append(node)
        return contents or self.tree.data.no_contents


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectCardsetData(SelectDialogTreeData):
    def __init__(self, manager, key):
        SelectDialogTreeData.__init__(self)
        self.all_objects = manager.getAllSortedByName()
        self.all_objects = [obj for obj in self.all_objects if not obj.error]
        self.no_contents = [SelectCardsetLeaf(
            None, None, _("(no cardsets)"), key=None), ]
        #
        select_by_type = None
        items = list(CSI.TYPE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_types.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key == cs.si.type))
        if nodes:
            select_by_type = SelectCardsetNode(
                None, _("by Type"), tuple(nodes), expanded=1)
        #
        select_by_style = None
        items = list(CSI.STYLE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_styles.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key in cs.si.styles))
        if nodes:
            nodes.append(
                SelectCardsetNode(
                    None, _("Uncategorized"), lambda cs: not cs.si.styles))
            select_by_style = SelectCardsetNode(
                None, _("by Style"), tuple(nodes))
        #
        select_by_nationality = None
        items = list(CSI.NATIONALITY.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_nationalities.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name,
                        lambda cs, key=key: key in cs.si.nationalities))
        if nodes:
            nodes.append(
                SelectCardsetNode(
                    None, _("Uncategorized"),
                    lambda cs: not cs.si.nationalities))
            select_by_nationality = SelectCardsetNode(
                None, _("by Nationality"), tuple(nodes))
        #
        select_by_date = None
        items = list(CSI.DATE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_dates.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key in cs.si.dates))
        if nodes:
            nodes.append(
                SelectCardsetNode(
                    None, _("Uncategorized"), lambda cs: not cs.si.dates))
            select_by_date = SelectCardsetNode(
                None, _("by Date"), tuple(nodes))
        #
        self.rootnodes = [_f for _f in (
            SelectCardsetNode(
                None, _("All Cardsets"),
                lambda cs: 1, expanded=len(self.all_objects) <= 12),
            SelectCardsetNode(None, _("by Size"), (
                SelectCardsetNode(
                    None, _("Tiny cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_TINY),
                SelectCardsetNode(
                    None, _("Small cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_SMALL),
                SelectCardsetNode(
                    None, _("Medium cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_MEDIUM),
                SelectCardsetNode(
                    None, _("Large cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_LARGE),
                SelectCardsetNode(
                    None, _("XLarge cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_XLARGE),
            ), expanded=1),
            select_by_type,
            select_by_style,
            select_by_date,
            select_by_nationality,
        ) if _f]


class SelectCardsetByTypeData(SelectDialogTreeData):
    def __init__(self, manager, key):
        SelectDialogTreeData.__init__(self)
        self.all_objects = manager.getAllSortedByName()
        self.no_contents = [SelectCardsetLeaf(
            None, None, _("(no cardsets)"), key=None), ]
        #
        items = list(CSI.TYPE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_types.get(key):
                nodes.append(SelectCardsetNode(
                    None, name, lambda cs, key=key: key == cs.si.type))
        select_by_type = SelectCardsetNode(
            None, _("by Type"), tuple(nodes), expanded=1)
        #
        self.rootnodes = [_f for _f in (
            select_by_type,
        ) if _f]


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************

class SelectCardsetTree(SelectDialogTreeCanvas):
    data = None


class SelectCardsetByTypeTree(SelectDialogTreeCanvas):
    data = None


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectCardsetDialogWithPreview(MfxDialog):
    Tree_Class = SelectCardsetTree
    TreeDataHolder_Class = SelectCardsetTree
    TreeData_Class = SelectCardsetData

    def __init__(self, parent, title, app, manager, key=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        if key is None:
            key = manager.getSelected()
        self.manager = manager
        self.key = key
        self.app = app
        # padx, pady = kw.padx, kw.pady
        padx, pady = 5, 5
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(manager, key)
        #
        self.top.wm_minsize(400, 200)
        if self.top.winfo_screenwidth() >= 800:
            w1, w2 = 240, 400
        else:
            w1, w2 = 200, 300
        paned_window = tkinter.PanedWindow(top_frame)
        paned_window.pack(expand=True, fill='both')
        left_frame = tkinter.Frame(paned_window)
        right_frame = tkinter.Frame(paned_window)
        paned_window.add(left_frame)
        paned_window.add(right_frame)

        font = app.getFont("default")
        self.tree = self.Tree_Class(self, left_frame, key=key,
                                    default=kw.default,
                                    font=font, width=w1)
        self.tree.frame.grid(row=0, column=0, sticky='nsew',
                             padx=padx, pady=pady)
        if USE_PIL:
            #
            var = tkinter.DoubleVar()
            var.set(app.opt.scale_x)
            self.scale_x = tkinter.Scale(
                left_frame, label=_('Scale X:'),
                from_=0.5, to=4.0, resolution=0.1,
                orient='horizontal', variable=var,
                # value=app.opt.scale_x,
                command=self._updateScale)
            self.scale_x.grid(
                row=1, column=0, sticky='ew', padx=padx, pady=pady)
            #
            var = tkinter.DoubleVar()
            var.set(app.opt.scale_y)
            self.scale_y = tkinter.Scale(
                left_frame, label=_('Scale Y:'),
                from_=0.5, to=4.0, resolution=0.1,
                orient='horizontal', variable=var,
                # value=app.opt.scale_y,
                command=self._updateScale)
            self.scale_y.grid(
                row=2, column=0, sticky='ew', padx=padx, pady=pady)
            #
            self.auto_scale = tkinter.BooleanVar()
            self.auto_scale.set(app.opt.auto_scale)
            check = tkinter.Checkbutton(
                left_frame, text=_('Auto scaling'),
                variable=self.auto_scale,
                takefocus=False,
                command=self._updateAutoScale
                )
            check.grid(row=3, column=0, columnspan=2, sticky='w',
                       padx=padx, pady=pady)
            #
            self.preserve_aspect = tkinter.BooleanVar()
            self.preserve_aspect.set(app.opt.preserve_aspect_ratio)
            self.aspect_check = tkinter.Checkbutton(
                left_frame, text=_('Preserve aspect ratio'),
                variable=self.preserve_aspect,
                takefocus=False,
                # command=self._updateScale
                )
            self.aspect_check.grid(row=4, column=0, sticky='w',
                                   padx=padx, pady=pady)
            self._updateAutoScale()
        #
        left_frame.rowconfigure(0, weight=1)
        left_frame.columnconfigure(0, weight=1)
        #
        self.preview = MfxScrolledCanvas(right_frame, width=w2)
        self.preview.setTile(app, app.tabletile_index, force=True)
        self.preview.pack(fill='both', expand=True, padx=padx, pady=pady)
        self.preview.canvas.preview = 1
        # create a preview of the current state
        self.preview_key = -1
        self.preview_images = []
        self.scale_images = []
        self.updatePreview(key)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def destroy(self):
        self.tree.updateNodesWithTree(self.tree.rootnodes, None)
        self.tree.destroy()
        self.preview.unbind_all()
        self.preview_images = []
        MfxDialog.destroy(self)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Load"), _("&Cancel"),),
                      default=0,
                      resizable=True,
                      padx=10, pady=10,
                      buttonpadx=10, buttonpady=5,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if button in (0, 1):            # Load/Cancel
            self.key = self.tree.selection_key
            self.tree.n_expansions = 1  # save xyview in any case
            if USE_PIL:
                auto_scale = bool(self.auto_scale.get())
                if button == 1:
                    self.app.menubar.tkopt.auto_scale.set(auto_scale)
                if auto_scale:
                    self.scale_values = (self.app.opt.scale_x,
                                         self.app.opt.scale_y,
                                         auto_scale,
                                         bool(self.preserve_aspect.get()))
                else:
                    self.scale_values = (self.scale_x.get(),
                                         self.scale_y.get(),
                                         auto_scale,
                                         self.app.opt.preserve_aspect_ratio)
        if button in (3, 4):
            cs = self.manager.get(self.tree.selection_key)
            if not cs:
                return
            # title = CARDSET+" "+cs.name
            title = CARDSET.capitalize()+" "+cs.name
            CardsetInfoDialog(
                self.top, title=title, cardset=cs, images=self.preview_images)
            return
        MfxDialog.mDone(self, button)

    def _updateAutoScale(self, v=None):
        if self.auto_scale.get():
            self.aspect_check.config(state='normal')
            self.scale_x.config(state='disabled')
            self.scale_y.config(state='disabled')
        else:
            self.aspect_check.config(state='disabled')
            self.scale_x.config(state='normal')
            self.scale_y.config(state='normal')

    def _updateScale(self, v):
        self.updatePreview()

    def updatePreview(self, key=None):
        if key == self.preview_key:
            return
        if key is None:
            key = self.key
        canvas = self.preview.canvas
        canvas.deleteAllItems()
        self.preview_images = []
        cs = self.manager.get(key)
        if not cs:
            self.preview_key = -1
            return
        names, columns = cs.getPreviewCardNames()
        try:
            # ???names, columns = cs.getPreviewCardNames()
            for n in names:
                f = os.path.join(cs.dir, n + cs.ext)
                self.preview_images.append(loadImage(file=f))
        except Exception:
            self.preview_key = -1
            self.preview_images = []
            return
        i, x, y, sx, sy, dx, dy = 0, 10, 10, 0, 0, cs.CARDW + 10, cs.CARDH + 10
        if USE_PIL:
            xf = self.scale_x.get()
            yf = self.scale_y.get()
            dx = int(dx*xf)
            dy = int(dy*yf)
            self.scale_images = []
        for image in self.preview_images:
            if USE_PIL:
                image = image.resize(xf, yf)
                self.scale_images.append(image)
            MfxCanvasImage(canvas, x, y, anchor="nw", image=image)
            sx, sy = max(x, sx), max(y, sy)
            i = i + 1
            if i % columns == 0:
                x, y = 10, y + dy
            else:
                x = x + dx
        canvas.config(scrollregion=(0, 0, sx+dx, sy+dy),
                      width=sx+dx, height=sy+dy)
        # canvas.config(xscrollincrement=dx, yscrollincrement=dy)
        canvas.event_generate('<Configure>')  # update bg image
        self.preview_key = key
        self.key = key


class SelectCardsetByTypeDialogWithPreview(SelectCardsetDialogWithPreview):
    Tree_Class = SelectCardsetByTypeTree
    TreeDataHolder_Class = SelectCardsetByTypeTree
    TreeData_Class = SelectCardsetByTypeData

# ************************************************************************
# * Cardset Info
# ************************************************************************


class CardsetInfoDialog(MfxDialog):
    def __init__(self, parent, title, cardset, images, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        frame = tkinter.Frame(top_frame)
        frame.pack(fill="both", expand=True, padx=5, pady=10)
        #
        #
        info_frame = tkinter.LabelFrame(frame, text=_('About cardset'))
        info_frame.grid(row=0, column=0, columnspan=2, sticky='ew',
                        padx=0, pady=5, ipadx=5, ipady=5)
        styles = nationalities = year = None
        if cardset.si.styles:
            styles = '\n'.join([CSI.STYLE[i] for i in cardset.si.styles])
        if cardset.si.nationalities:
            nationalities = '\n'.join([CSI.NATIONALITY[i]
                                       for i in cardset.si.nationalities])
        if cardset.year:
            year = str(cardset.year)
        row = 0
        for n, t in (
            # ('Version:', str(cardset.version)),
            (_('Type:'),          CSI.TYPE[cardset.type]),
            (_('Styles:'),        styles),
            (_('Nationality:'),   nationalities),
            (_('Year:'),          year),
            # (_('Number of cards:'), str(cardset.ncards)),
            (_('Size:'), '%d x %d' % (cardset.CARDW, cardset.CARDH)),
                ):
            if t is not None:
                label = tkinter.Label(info_frame, text=n,
                                      anchor='w', justify='left')
                label.grid(row=row, column=0, sticky='nw')
                label = tkinter.Label(info_frame, text=t,
                                      anchor='w', justify='left')
                label.grid(row=row, column=1, sticky='nw')
                row += 1
        if images:
            try:
                from random import choice
                im = choice(images)
                f = os.path.join(cardset.dir, cardset.backname)
                self.back_image = loadImage(file=f)
                canvas = tkinter.Canvas(info_frame,
                                        width=2*im.width()+30,
                                        height=im.height()+2)
                canvas.create_image(10, 1, image=im, anchor='nw')
                canvas.create_image(im.width()+20, 1,
                                    image=self.back_image, anchor='nw')
                canvas.grid(row=0, column=2, rowspan=row+1, sticky='ne')
                info_frame.columnconfigure(2, weight=1)
                info_frame.rowconfigure(row, weight=1)
            except Exception:
                pass
        # bg = top_frame["bg"]
        bg = 'white'
        text_w = tkinter.Text(frame, bd=1, relief="sunken", wrap="word",
                              padx=4, width=64, height=16, bg=bg)
        text_w.grid(row=1, column=0, sticky='nsew')
        sb = tkinter.Scrollbar(frame)
        sb.grid(row=1, column=1, sticky='ns')
        text_w.configure(yscrollcommand=sb.set)
        sb.configure(command=text_w.yview)
        frame.columnconfigure(0, weight=1)
        frame.rowconfigure(1, weight=1)
        #
        text = ''
        f = os.path.join(cardset.dir, "COPYRIGHT")
        try:
            text = open(f).read()
        except Exception:
            pass
        if text:
            text_w.config(state="normal")
            text_w.insert("insert", text)
        text_w.config(state="disabled")
        #
        focus = self.createButtons(bottom_frame, kw)
        # focus = text_w
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"),),
                      default=0,
                      resizable=True,
                      separator=True,
                      padx=10, pady=10,
                      buttonpadx=10, buttonpady=5,
                      )
        return MfxDialog.initKw(self, kw)
from pysollib.tk.tkwidget import MfxDialog

from six.moves import tkinter


class BaseTkMfxDialog(MfxDialog):
    def _calcToolkit(self):
        return tkinter

    def _calc_MfxDialog(self):
        return MfxDialog
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.gamedb import GI
from pysollib.mfxutil import KwStruct, Struct, destruct
from pysollib.mfxutil import format_time
from pysollib.mygettext import _
from pysollib.resource import CSI
from pysollib.ui.tktile.selecttree import SelectDialogTreeData
from pysollib.ui.tktile.tkutil import unbind_destroy

from six.moves import UserList
from six.moves import tkinter

from .selecttree import SelectDialogTreeCanvas
from .selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from .tkwidget import MfxDialog, MfxScrolledCanvas

# ************************************************************************
# * Nodes
# ************************************************************************


class SelectGameLeaf(SelectDialogTreeLeaf):
    pass


class SelectGameNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        if isinstance(self.select_func, UserList):
            # key/value pairs
            for id, name in self.select_func:
                if id and name:
                    node = SelectGameLeaf(self.tree, self, name, key=id)
                    contents.append(node)
        else:
            for gi in self.tree.data.all_games_gi:
                if gi and self.select_func is None:
                    # All games
                    # name = '%s (%s)' % (gi.name, CSI.TYPE_NAME[gi.category])
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
                elif gi and self.select_func(gi):
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
        return contents or self.tree.data.no_games


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectGameData(SelectDialogTreeData):
    def __init__(self, app):
        SelectDialogTreeData.__init__(self)
        self.all_games_gi = list(map(
            app.gdb.get,
            app.gdb.getGamesIdSortedByName()))
        self.no_games = [SelectGameLeaf(None, None, _("(no games)"), None), ]
        #
        s_by_type = s_oriental = s_special = s_original = s_contrib = \
            s_mahjongg = None
        g = []
        for data in (GI.SELECT_GAME_BY_TYPE,
                     GI.SELECT_ORIENTAL_GAME_BY_TYPE,
                     GI.SELECT_SPECIAL_GAME_BY_TYPE,
                     GI.SELECT_ORIGINAL_GAME_BY_TYPE,
                     GI.SELECT_CONTRIB_GAME_BY_TYPE,
                     ):
            gg = []
            for name, select_func in data:
                if name is None or not list(filter(
                        select_func, self.all_games_gi)):
                    continue
                gg.append(SelectGameNode(None, _(name), select_func))
            g.append(gg)

        def select_mahjongg_game(gi):
            return gi.si.game_type == GI.GT_MAHJONGG

        gg = None
        if list(filter(select_mahjongg_game, self.all_games_gi)):
            gg = SelectGameNode(None, _("Mahjongg Games"),
                                select_mahjongg_game)
        g.append(gg)
        if g[0]:
            s_by_type = SelectGameNode(None, _("French games"),
                                       tuple(g[0]), expanded=1)
        if g[1]:
            s_oriental = SelectGameNode(None, _("Oriental Games"),
                                        tuple(g[1]))
        if g[2]:
            s_special = SelectGameNode(None, _("Special Games"),
                                       tuple(g[2]))
        if g[3]:
            s_original = SelectGameNode(None, _("Original Games"),
                                        tuple(g[3]))
        # if g[4]:
        #   s_contrib = SelectGameNode(None, "Contributed Games", tuple(g[4]))
        if g[5]:
            s_mahjongg = g[5]
        #
        s_by_compatibility, gg = None, []
        for name, games in GI.GAMES_BY_COMPATIBILITY:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_compatibility = SelectGameNode(None, _("by Compatibility"),
                                                tuple(gg))
        #
        s_by_pysol_version, gg = None, []
        for name, games in GI.GAMES_BY_PYSOL_VERSION:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            name = _("New games in v. %(version)s") % {'version': name}
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_pysol_version = SelectGameNode(None, _("by PySol version"),
                                                tuple(gg))
        s_by_inventors, gg = None, []
        for name, games in GI.GAMES_BY_INVENTORS:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_inventors = SelectGameNode(None, _("by Inventors"),
                                            tuple(gg))
        #
        ul_alternate_names = UserList(
            list(app.gdb.getGamesTuplesSortedByAlternateName()))
        #
        self.rootnodes = [_f for _f in (
            SelectGameNode(None, _("All Games"), None, expanded=0),
            SelectGameNode(None, _("Alternate Names"), ul_alternate_names),
            SelectGameNode(None, _("Popular Games"),
                           lambda gi: gi.si.game_flags & GI.GT_POPULAR),
            s_by_type,
            s_mahjongg,
            s_oriental,
            s_special,
            SelectGameNode(None, _("Custom Games"),
                           lambda gi: gi.si.game_type == GI.GT_CUSTOM),
            SelectGameNode(None, _('by Skill Level'), (
                SelectGameNode(None, _('Luck only'),
                               lambda gi: gi.skill_level == GI.SL_LUCK),
                SelectGameNode(None, _('Mostly luck'),
                               lambda gi: gi.skill_level == GI.SL_MOSTLY_LUCK),
                SelectGameNode(None, _('Balanced'),
                               lambda gi: gi.skill_level == GI.SL_BALANCED),
                SelectGameNode(
                    None, _('Mostly skill'),
                    lambda gi: gi.skill_level == GI.SL_MOSTLY_SKILL),
                SelectGameNode(None, _('Skill only'),
                               lambda gi: gi.skill_level == GI.SL_SKILL),
                )),
            SelectGameNode(None, _("by Game Feature"), (
                SelectGameNode(None, _("by Number of Cards"), (
                    SelectGameNode(None, _("32 cards"),
                                   lambda gi: gi.si.ncards == 32),
                    SelectGameNode(None, _("48 cards"),
                                   lambda gi: gi.si.ncards == 48),
                    SelectGameNode(None, _("52 cards"),
                                   lambda gi: gi.si.ncards == 52),
                    SelectGameNode(None, _("64 cards"),
                                   lambda gi: gi.si.ncards == 64),
                    SelectGameNode(None, _("78 cards"),
                                   lambda gi: gi.si.ncards == 78),
                    SelectGameNode(None, _("104 cards"),
                                   lambda gi: gi.si.ncards == 104),
                    SelectGameNode(None, _("144 cards"),
                                   lambda gi: gi.si.ncards == 144),
                    SelectGameNode(
                        None, _("Other number"),
                        lambda gi: gi.si.ncards not in (32, 48, 52,
                                                        64, 78, 104, 144)),
                )),
                SelectGameNode(None, _("by Number of Decks"), (
                    SelectGameNode(None, _("1 deck games"),
                                   lambda gi: gi.si.decks == 1),
                    SelectGameNode(None, _("2 deck games"),
                                   lambda gi: gi.si.decks == 2),
                    SelectGameNode(None, _("3 deck games"),
                                   lambda gi: gi.si.decks == 3),
                    SelectGameNode(None, _("4 deck games"),
                                   lambda gi: gi.si.decks == 4),
                )),
                SelectGameNode(None, _("by Number of Redeals"), (
                    SelectGameNode(None, _("No redeal"),
                                   lambda gi: gi.si.redeals == 0),
                    SelectGameNode(None, _("1 redeal"),
                                   lambda gi: gi.si.redeals == 1),
                    SelectGameNode(None, _("2 redeals"),
                                   lambda gi: gi.si.redeals == 2),
                    SelectGameNode(None, _("3 redeals"),
                                   lambda gi: gi.si.redeals == 3),
                    SelectGameNode(None, _("Unlimited redeals"),
                                   lambda gi: gi.si.redeals == -1),
                    SelectGameNode(
                        None, _("Other number of redeals"),
                        lambda gi: gi.si.redeals not in (-1, 0, 1, 2, 3)),
                )),
                s_by_compatibility,
            )),
            s_by_pysol_version,
            s_by_inventors,
            SelectGameNode(None, _("Other Categories"), (
                SelectGameNode(None, _("Games for Children (very easy)"),
                               lambda gi: gi.si.game_flags & GI.GT_CHILDREN),
                SelectGameNode(None, _("Games with Scoring"),
                               lambda gi: gi.si.game_flags & GI.GT_SCORE),
                SelectGameNode(
                    None, _("Games with Separate Decks"),
                    lambda gi: gi.si.game_flags & GI.GT_SEPARATE_DECKS),
                SelectGameNode(None, _("Open Games (all cards visible)"),
                               lambda gi: gi.si.game_flags & GI.GT_OPEN),
                SelectGameNode(None, _("Relaxed Variants"),
                               lambda gi: gi.si.game_flags & GI.GT_RELAXED),
            )),
            s_original,
            s_contrib,
        ) if _f]


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************

class SelectGameTreeWithPreview(SelectDialogTreeCanvas):
    data = None


class SelectGameTree(SelectGameTreeWithPreview):
    def singleClick(self, event=None):
        self.doubleClick(event)


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectGameDialog(MfxDialog):
    Tree_Class = SelectGameTree
    TreeDataHolder_Class = SelectGameTreeWithPreview
    TreeData_Class = SelectGameData

    def __init__(self, parent, title, app, gameid, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.app = app
        self.gameid = gameid
        self.random = None
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(app)
        #
        self.top.wm_minsize(200, 200)
        font = app.getFont("default")
        self.tree = self.Tree_Class(self, top_frame, key=gameid,
                                    font=font, default=kw.default)
        self.tree.frame.pack(fill='both', expand=True,
                             padx=kw.padx, pady=kw.pady)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(None, None, _("&Cancel"),), default=0,
                      resizable=True,
                      separator=True,
                      padx=10, pady=10,
                      buttonpadx=10, buttonpady=5,
                      )
        return MfxDialog.initKw(self, kw)

    def destroy(self):
        self.app = None
        self.tree.updateNodesWithTree(self.tree.rootnodes, None)
        self.tree.destroy()
        MfxDialog.destroy(self)

    def mDone(self, button):
        if button == 0:                 # Ok or double click
            self.gameid = self.tree.selection_key
            self.tree.n_expansions = 1  # save xyview in any case
        if button == 1:                # Rules
            doc = self.app.getGameRulesFilename(self.tree.selection_key)
            if not doc:
                return
            dir = os.path.join("html", "rules")
            from pysollib.help import help_html
            help_html(self.app, doc, dir, self.top)
            return
        MfxDialog.mDone(self, button)


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectGameDialogWithPreview(SelectGameDialog):
    Tree_Class = SelectGameTreeWithPreview

    def __init__(self, parent, title, app, gameid, bookmark=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.app = app
        self.gameid = gameid
        self.bookmark = bookmark
        self.random = None
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(app)
        #
        self.top.wm_minsize(400, 200)
        sw = self.top.winfo_screenwidth()
        if sw >= 1100:
            w1, w2 = 250, 600
        elif sw >= 900:
            w1, w2 = 250, 500
        elif sw >= 800:
            w1, w2 = 220, 480
        else:
            w1, w2 = 200, 300
        # print sw, w1, w2
        w2 = max(200, min(w2, 10 + 12*(app.subsampled_images.CARDW+10)))
        # print sw, w1, w2
        # padx, pady = kw.padx, kw.pady
        padx, pady = kw.padx//2, kw.pady//2
        # PanedWindow
        paned_window = tkinter.PanedWindow(top_frame)
        paned_window.pack(expand=True, fill='both')
        left_frame = tkinter.Frame(paned_window)
        right_frame = tkinter.Frame(paned_window)
        paned_window.add(left_frame)
        paned_window.add(right_frame)
        # Tree
        font = app.getFont("default")
        self.tree = self.Tree_Class(self, left_frame, key=gameid,
                                    default=kw.default, font=font, width=w1)
        self.tree.frame.pack(padx=padx, pady=pady, expand=True, fill='both')
        # LabelFrame
        info_frame = tkinter.LabelFrame(right_frame, text=_('About game'))
        stats_frame = tkinter.LabelFrame(right_frame, text=_('Statistics'))
        info_frame.grid(row=0, column=0, padx=padx, pady=pady,
                        ipadx=padx, ipady=pady, sticky='nws')
        stats_frame.grid(row=0, column=1, padx=padx, pady=pady,
                         ipadx=padx, ipady=pady, sticky='nws')
        # Info
        self.info_labels = {}
        for n, t, f, row in (
            ('name',        _('Name:'),             info_frame,   0),
            ('altnames',    _('Alternate names:'),  info_frame,   1),
            ('category',    _('Category:'),         info_frame,   2),
            ('type',        _('Type:'),             info_frame,   3),
            ('skill_level', _('Skill level:'),      info_frame,   4),
            ('decks',       _('Decks:'),            info_frame,   5),
            ('redeals',     _('Redeals:'),          info_frame,   6),
            #
            ('played',      _('Played:'),           stats_frame,  0),
            ('won',         _('Won:'),              stats_frame,  1),
            ('lost',        _('Lost:'),             stats_frame,  2),
            ('time',        _('Playing time:'),     stats_frame,  3),
            ('moves',       _('Moves:'),            stats_frame,  4),
            ('percent',     _('% won:'),            stats_frame,  5),
                ):
            title_label = tkinter.Label(f, text=t, justify='left', anchor='w')
            title_label.grid(row=row, column=0, sticky='nw')
            text_label = tkinter.Label(f, justify='left', anchor='w')
            text_label.grid(row=row, column=1, sticky='nw')
            self.info_labels[n] = (title_label, text_label)
        # info_frame.columnconfigure(1, weight=1)
        info_frame.rowconfigure(6, weight=1)
        stats_frame.rowconfigure(6, weight=1)
        # Canvas
        self.preview = MfxScrolledCanvas(right_frame, width=w2)
        self.preview.setTile(app, app.tabletile_index, force=True)
        self.preview.grid(row=1, column=0, columnspan=3,
                          padx=padx, pady=pady, sticky='nsew')
        right_frame.columnconfigure(1, weight=1)
        right_frame.rowconfigure(1, weight=1)
        #
        focus = self.createButtons(bottom_frame, kw)
        # set the scale factor
        self.preview.canvas.preview = 2
        # create a preview of the current game
        self.preview_key = -1
        self.preview_game = None
        self.preview_app = None
        self.updatePreview(gameid, animations=0)
        # focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=((_("&Rules"), 10), 'sep',
                               _("&Select"), _("&Cancel"),),
                      default=0,
                      )
        return SelectGameDialog.initKw(self, kw)

    def destroy(self):
        self.deletePreview(destroy=1)
        self.preview.unbind_all()
        SelectGameDialog.destroy(self)

    def deletePreview(self, destroy=0):
        self.preview_key = -1
        # clean up the canvas
        if self.preview:
            unbind_destroy(self.preview.canvas)
            self.preview.canvas.deleteAllItems()
            if destroy:
                self.preview.canvas.delete("all")
        #
        # for l in self.info_labels.values():
        #    l.config(text='')
        # destruct the game
        if self.preview_game:
            self.preview_game.endGame()
            self.preview_game.destruct()
            destruct(self.preview_game)
        self.preview_game = None
        # destruct the app
        if destroy:
            if self.preview_app:
                destruct(self.preview_app)
            self.preview_app = None

    def updatePreview(self, gameid, animations=10):
        if gameid == self.preview_key:
            return
        self.deletePreview()
        canvas = self.preview.canvas
        #
        gi = self.app.gdb.get(gameid)
        if not gi:
            self.preview_key = -1
            return
        #
        if self.preview_app is None:
            self.preview_app = Struct(
                # variables
                audio=self.app.audio,
                canvas=canvas,
                cardset=self.app.cardset.copy(),
                gamerandom=self.app.gamerandom,
                gdb=self.app.gdb,
                gimages=self.app.gimages,
                images=self.app.subsampled_images,
                menubar=None,
                miscrandom=self.app.miscrandom,
                opt=self.app.opt.copy(),
                startup_opt=self.app.startup_opt,
                stats=self.app.stats.new(),
                top=None,
                top_cursor=self.app.top_cursor,
                toolbar=None,
                # methods
                constructGame=self.app.constructGame,
                getFont=self.app.getFont,
            )
            self.preview_app.opt.shadow = 0
            self.preview_app.opt.shade = 0
        #
        self.preview_app.audio = None    # turn off audio for initial dealing
        if animations >= 0:
            self.preview_app.opt.animations = animations
        #
        if self.preview_game:
            self.preview_game.endGame()
            self.preview_game.destruct()
        # self.top.wm_title("Select Game - " +
        #   self.app.getGameTitleName(gameid))
        title = self.app.getGameTitleName(gameid)
        self.top.wm_title(_("Playable Preview - %(game)s") % {'game': title})
        #
        self.preview_game = gi.gameclass(gi)
        self.preview_game.createPreview(self.preview_app)
        #
        random = None
        if gameid == self.gameid:
            random = self.app.game.random.copy()
        if gameid == self.gameid and self.bookmark:
            self.preview_game.restoreGameFromBookmark(self.bookmark)
        else:
            self.preview_game.newGame(random=random, autoplay=1)
        gw, gh = self.preview_game.width, self.preview_game.height
        canvas.config(scrollregion=(0, 0, gw, gh))
        canvas.xview_moveto(0)
        canvas.yview_moveto(0)
        #
        self.preview_app.audio = self.app.audio
        if self.app.opt.animations:
            self.preview_app.opt.animations = 10
        else:
            self.preview_app.opt.animations = 0
        # save seed
        self.random = self.preview_game.random.copy()
        self.random.origin = self.random.ORIGIN_PREVIEW
        self.preview_key = gameid
        #
        self.updateInfo(gameid)
        #
        rules_button = self.buttons[0]
        if self.app.getGameRulesFilename(gameid):
            rules_button.config(state="normal")
        else:
            rules_button.config(state="disabled")

    def updateInfo(self, gameid):
        gi = self.app.gdb.get(gameid)
        # info
        name = gi.name
        altnames = '\n'.join(gi.altnames)
        category = _(CSI.TYPE[gi.category])
        type = ''
        if gi.si.game_type in GI.TYPE_NAMES:
            type = _(GI.TYPE_NAMES[gi.si.game_type])
        sl = {
            GI.SL_LUCK:         _('Luck only'),
            GI.SL_MOSTLY_LUCK:  _('Mostly luck'),
            GI.SL_BALANCED:     _('Balanced'),
            GI.SL_MOSTLY_SKILL: _('Mostly skill'),
            GI.SL_SKILL:        _('Skill only'),
            }
        skill_level = sl.get(gi.skill_level)
        if gi.redeals == -2:
            redeals = _('variable')
        elif gi.redeals == -1:
            redeals = _('unlimited')
        else:
            redeals = str(gi.redeals)
        # stats
        won, lost, time, moves = self.app.stats.getFullStats(
            self.app.opt.player, gameid)
        if won+lost > 0:
            percent = "%.1f" % (100.0*won/(won+lost))
        else:
            percent = "0.0"
        time = format_time(time)
        moves = str(round(moves, 1))
        for n, t in (
            ('name',        name),
            ('altnames',    altnames),
            ('category',    category),
            ('type',        type),
            ('skill_level', skill_level),
            ('decks',       gi.decks),
            ('redeals',     redeals),
            ('played',      won+lost),
            ('won',         won),
            ('lost',        lost),
            ('time',        time),
            ('moves',       moves),
            ('percent',     percent),
                ):
            title_label, text_label = self.info_labels[n]
            if t in ('', None):
                title_label.grid_remove()
                text_label.grid_remove()
            else:
                title_label.grid()
                text_label.grid()
            text_label.config(text=t)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


def create_solver_dialog(parent, game):
    pass


def connect_game_solver_dialog(game):
    pass


def destroy_solver_dialog():
    pass
    # solver_dialog = None


def reset_solver_dialog():
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import gtk

from pysollib.mygettext import _

import six


class BasicStatusbar:
    def __init__(self, top, row, column, columnspan):
        self.top = top
        self._widgets = []
        self.hbox = gtk.HBox()
        top.table.attach(self.hbox,
                         column, column+columnspan,   row, row+1,
                         gtk.EXPAND | gtk.FILL,       0,
                         0,                           0)

    def createLabel(self, name, fill=False, expand=False,
                    tooltip=None, grip=False, width=0):
        label = gtk.Statusbar()
        self.hbox.pack_start(label, fill=fill, expand=expand)
        label.show()
        if not grip:
            label.set_has_resize_grip(False)
        setattr(self, name + "_label", label)
        label.set_size_request(width*7, -1)
        lb = label.get_children()[0].get_children()[0]
        lb.set_alignment(0.5, 0.0)
        self._widgets.append(label)
        # label.push(0, '')
        #  if tooltip:
        #      tt = gtk.Tooltips()
        #      tt.set_tip(label, tooltip, '')
        #      tt.enable()

    def updateText(self, **kw):
        for k, v in kw.items():
            label = getattr(self, k + "_label")
            label.pop(0)
            label.push(0, six.text_type(v))

    def config(self, name, show):
        # FIXME
        pass

    def configLabel(self, name, **kw):
        label = getattr(self, name + "_label")
        # FIXME kw['fg']
        label.pop(0)
        label.push(0, six.text_type(kw['text']))

    def show(self, show=True, resize=False):
        if show:
            self.hbox.show()
        else:
            self.hbox.hide()
        return True

    def hide(self, resize=False):
        self.show(False, resize)
        return True

    def destroy(self):
        pass


# ************************************************************************
# *
# ************************************************************************
class PysolStatusbar(BasicStatusbar):
    def __init__(self, top):
        BasicStatusbar.__init__(self, top, row=4, column=0, columnspan=3)
        #
        for n, t, w in (
            ("time",        _("Playing time"),            10),
            ("moves",       _('Moves/Total moves'),       10),
            ("gamenumber",  _("Game number"),             26),
            ("stats",       _("Games played: won/lost"),  12),
                ):
            self.createLabel(n, width=w, tooltip=t)
        #
        self.createLabel("info", fill=True, expand=True, grip=True)


class HelpStatusbar(BasicStatusbar):
    def __init__(self, top):
        BasicStatusbar.__init__(self, top, row=5, column=0, columnspan=3)
        self.createLabel("info", fill=True, expand=True)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import gobject

import gtk

from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _

# Toolkit imports
from tkwidget import MfxDialog


# ************************************************************************
# *
# ************************************************************************

class PlayerOptionsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, **kw)
        #
        top_box, bottom_box = self.createVBox()
        #
        label = gtk.Label('Please enter your name')
        label.show()
        top_box.pack_start(label)
        self.player_entry = gtk.Entry()
        self.player_entry.show()
        top_box.pack_start(self.player_entry, expand=False)
        completion = gtk.EntryCompletion()
        self.player_entry.set_completion(completion)
        model = gtk.ListStore(gobject.TYPE_STRING)
        for name in app.getAllUserNames():
            iter = model.append()
            model.set(iter, 0, name)
        completion.set_model(model)
        completion.set_text_column(0)
        self.player_entry.set_text(app.opt.player)
        #
        self.confirm_quit_check = gtk.CheckButton(_('Confirm quit'))
        self.confirm_quit_check.show()
        top_box.pack_start(self.confirm_quit_check)
        self.confirm_quit_check.set_active(app.opt.confirm != 0)
        #
        self.update_stats_check = gtk.CheckButton(
            _('Update statistics and logs'))
        self.update_stats_check.show()
        top_box.pack_start(self.update_stats_check)
        self.update_stats_check.set_active(app.opt.update_player_stats != 0)
        #
        self.createButtons(bottom_box, kw)
        self.show_all()
        gtk.main()

    def initKw(self, kw):
        kwdefault(kw,
                  strings=(_('&OK'), _('&Cancel'),),
                  default=0,
                  # resizable=1,
                  padx=10, pady=10,
                  # width=600, height=400,
                  # #~ buttonpadx=10, buttonpady=5,
                  )
        return MfxDialog.initKw(self, kw)

    def done(self, button):
        self.button = button.get_data('user_data')
        self.player = self.player_entry.get_text()
        self.confirm = self.confirm_quit_check.get_active()
        self.update_stats = self.update_stats_check.get_active()
        self.win_animation = False
        self.quit()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


# imports
import gtk

# PySol imports

# ************************************************************************
# *
# ************************************************************************


class PysolToolbarTk:
    def __init__(self, top, menubar, dir, size=0, relief=0, compound=None):
        self.top = top
        self.menubar = menubar
        self.dir = dir
        self.side = -1

        ui_manager = self.top.ui_manager  # created in menubar.py

        toolbar = ui_manager.get_widget("/toolbar")
        self.toolbar = toolbar
        toolbar.set_tooltips(True)
        toolbar.set_style(gtk.TOOLBAR_ICONS)

        self._attached = False

    #
    # wrappers
    #

    def _busy(self):
        return not (self.side and self.game and not self.game.busy and
                    self.menubar)

    def destroy(self):
        self.toolbar.destroy()

    #
    # public methods
    #

    def getSide(self):
        return self.side

    def getSize(self):
        return 0

    def hide(self, resize=1):
        self.show(0, resize)

    def show(self, side=1, resize=1):
        if self.side == side:
            return 0
        self.side = side
        if not side:
            # hide
            self.toolbar.hide()
            return 1
        # show
        if side == 1:
            # top
            x, y = 1, 1
        elif side == 2:
            # bottom
            x, y = 1, 3
        elif side == 3:
            # left
            x, y = 0, 2
        else:
            # right
            x, y = 2, 2
        # set orient
        if side in (1, 2):
            orient = gtk.ORIENTATION_HORIZONTAL
        else:
            orient = gtk.ORIENTATION_VERTICAL
        self.toolbar.set_orientation(orient)
        if self._attached:
            self.top.table.remove(self.toolbar)
        self.top.table.attach(self.toolbar,
                              x, x+1,     y, y+1,
                              gtk.FILL,   gtk.FILL,
                              0,          0)
        self.toolbar.show()
        self._attached = True
        return 1

    def setCursor(self, cursor):
        pass
        # if self.side:
        #     if self.toolbar.window:
        #         self.toolbar.window.set_cursor(gdk.Cursor(v))

    def setRelief(self, relief):
        # FIXME
        pass

    def updateText(self, **kw):
        # FIXME
        pass

    def config(self, w, v):
        # FIXME
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import gtk
import gtk.glade

from pysollib.mygettext import _

# ************************************************************************
# *
# ************************************************************************


class TimeoutsDialog:

    def __init__(self, parent, title, app, **kw):

        glade_file = app.dataloader.findFile('pysolfc.glade')
        self.widgets_tree = gtk.glade.XML(glade_file)

        keys = (
            'demo',
            'hint',
            'raise_card',
            'highlight_piles',
            'highlight_cards',
            'highlight_samerank',
            )

        dic = {}
        for n in keys:
            def callback(w, n=n):
                sp = self.widgets_tree.get_widget(n+'_spinbutton')
                sc = self.widgets_tree.get_widget(n+'_scale')
                sp.set_value(sc.get_value())
            dic[n+'_scale_value_changed'] = callback

            def callback(w, n=n):
                sp = self.widgets_tree.get_widget(n+'_spinbutton')
                sc = self.widgets_tree.get_widget(n+'_scale')
                sc.set_value(sp.get_value())
            dic[n+'_spinbutton_value_changed'] = callback
        self.widgets_tree.signal_autoconnect(dic)

        for n in keys:
            v = app.opt.timeouts[n]
            w = self.widgets_tree.get_widget(n+'_spinbutton')
            w.set_value(v)
            w = self.widgets_tree.get_widget(n+'_scale')
            w.set_value(v)

        self._translateLabels()

        dialog = self.widgets_tree.get_widget('timeouts_dialog')
        dialog.set_title(title)
        dialog.set_transient_for(parent)

        self.status = -1
        self.button = -1
        response = dialog.run()
        if response == gtk.RESPONSE_OK:
            self.status = 0
            self.button = 0
        for n in keys:
            w = self.widgets_tree.get_widget(n+'_spinbutton')
            setattr(self, n+'_timeout', w.get_value())

        dialog.destroy()

    def _translateLabels(self):
        for n in (
            'label25',
            'label26',
            'label27',
            'label28',
            'label29',
            'label30',
                ):
            w = self.widgets_tree.get_widget(n)
            w.set_text(_(w.get_text()))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import gobject

import gtk


class PysolTreeView:

    _expanded_rows = []
    _selected_row = None
    _vadjustment_position = None

    def __init__(self, parent, store, **kw):
        #
        sw = gtk.ScrolledWindow()
        self.scrolledwindow = sw
        sw.show()
        self.sw_vadjustment = sw.get_vadjustment()
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        #
        treeview = gtk.TreeView(store)
        self.treeview = treeview
        treeview.show()
        sw.add(treeview)
        treeview.set_rules_hint(True)
        treeview.set_headers_visible(False)
        renderer = gtk.CellRendererText()
        renderer.set_property('xalign', 0.0)
        column = gtk.TreeViewColumn('Column Name', renderer, text=0)
        column.set_clickable(True)
        treeview.append_column(column)
        selection = treeview.get_selection()
        selection.connect('changed', parent.showSelected)
        treeview.connect('unrealize', self._unrealizeEvent)

        self._restoreSettings()

    def _unrealizeEvent(self, w):
        self._saveSettings()

    def _saveSettings(self):
        self._saveExpandedRows()
        selection = self.treeview.get_selection()
        model, path = selection.get_selected_rows()
        if path:
            PysolTreeView._selected_row = path[0]
        PysolTreeView._vadjustment_position = self.sw_vadjustment.get_value()

    def _restoreSettings(self):
        self._loadExpandedRows()
        if self._selected_row:
            selection = self.treeview.get_selection()
            # selection.select_path(self._selected_row)
            # selection.unselect_all()
            gobject.idle_add(selection.select_path, self._selected_row)
        if self._vadjustment_position is not None:
            # self.sw_vadjustment.set_value(self._vadjustment_position)
            gobject.idle_add(self.sw_vadjustment.set_value,
                             self._vadjustment_position)

    def _saveExpandedRows(self):
        treeview = self.treeview
        PysolTreeView._expanded_rows = []
        treeview.map_expanded_rows(
            lambda tv, path, self=self:
                PysolTreeView._expanded_rows.append(path))

    def _loadExpandedRows(self):
        for path in self._expanded_rows:
            self.treeview.expand_to_path(path)

    def getSelected(self):
        selection = self.treeview.get_selection()
        model, path = selection.get_selected_rows()
        if not path:
            return None
        iter = model.get_iter(path[0])
        index = model.get_value(iter, 1)
        return index

    def unselectAll(self):
        selection = self.treeview.get_selection()
        selection.unselect_all()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


# imports
import gtk

# PySol imports
from pysollib.mygettext import _

# Toolkit imports


# ************************************************************************
# *
# ************************************************************************

class SoundOptionsDialog:
    def __init__(self, parent, title, app, **kw):
        saved_opt = app.opt.copy()

        glade_file = app.dataloader.findFile('pysolfc.glade')
        self.widgets_tree = gtk.glade.XML(glade_file)

        keys = [
            ('areyousure',    _('Are You Sure')),

            ('deal',          _('Deal')),
            ('dealwaste',     _('Deal waste')),

            ('turnwaste',     _('Turn waste')),
            ('startdrag',     _('Start drag')),

            ('drop',          _('Drop')),
            ('droppair',      _('Drop pair')),
            ('autodrop',      _('Auto drop')),

            ('flip',          _('Flip')),
            ('autoflip',      _('Auto flip')),
            ('move',          _('Move')),
            ('nomove',        _('No move')),

            ('undo',          _('Undo')),
            ('redo',          _('Redo')),

            ('autopilotlost', _('Autopilot lost')),
            ('autopilotwon',  _('Autopilot won')),

            ('gamefinished',  _('Game finished')),
            ('gamelost',      _('Game lost')),
            ('gamewon',       _('Game won')),
            ('gameperfect',   _('Perfect game')),
            ]

        table = self.widgets_tree.get_widget('samples_table')
        samples_checkbuttons = {}
        row = 0
        col = 0
        for n, t in keys:
            check = gtk.CheckButton(t)
            check.show()
            check.set_active(app.opt.sound_samples[n])
            samples_checkbuttons[n] = check
            table.attach(check,
                         col, col+1,              row, row+1,
                         gtk.FILL | gtk.EXPAND,     gtk.FILL,
                         4,                       4)
            if col == 1:
                col = 0
                row += 1
            else:
                col = 1

        w = self.widgets_tree.get_widget('enable_checkbutton')
        w.set_active(app.opt.sound)
        dic = {}
        for n in 'sample', 'music':
            def callback(w, n=n):
                sp = self.widgets_tree.get_widget(n+'_spinbutton')
                sc = self.widgets_tree.get_widget(n+'_scale')
                sp.set_value(sc.get_value())
            dic[n+'_scale_value_changed'] = callback

            def callback(w, n=n):
                sp = self.widgets_tree.get_widget(n+'_spinbutton')
                sc = self.widgets_tree.get_widget(n+'_scale')
                sc.set_value(sp.get_value())
            dic[n+'_spinbutton_value_changed'] = callback
        self.widgets_tree.signal_autoconnect(dic)
        w = self.widgets_tree.get_widget('sample_spinbutton')
        w.set_value(app.opt.sound_sample_volume)
        w = self.widgets_tree.get_widget('music_spinbutton')
        w.set_value(app.opt.sound_music_volume)

        self._translateLabels()

        dialog = self.widgets_tree.get_widget('sounds_dialog')
        dialog.set_title(title)
        dialog.set_transient_for(parent)

        while True:  # for `apply'
            response = dialog.run()
            if response in (gtk.RESPONSE_OK, gtk.RESPONSE_APPLY):
                w = self.widgets_tree.get_widget('enable_checkbutton')
                app.opt.sound = w.get_active()
                w = self.widgets_tree.get_widget('sample_spinbutton')
                app.opt.soun_sample_volume = w.get_value()
                w = self.widgets_tree.get_widget('music_spinbutton')
                app.opt.sound_music_volume = w.get_value()
                for n, t in keys:
                    w = samples_checkbuttons[n]
                    app.opt.sound_samples[n] = w.get_active()
            else:
                app.opt = saved_opt
            if app.audio:
                app.audio.updateSettings()
                if response == gtk.RESPONSE_APPLY:
                    app.audio.playSample('drop', priority=1000)
            if response != gtk.RESPONSE_APPLY:
                dialog.destroy()
                break

    def _translateLabels(self):
        for n in (
            'label76',
            'label77',
            'label78',
               ):
            w = self.widgets_tree.get_widget(n)
            w.set_text(_(w.get_text()))
        w = self.widgets_tree.get_widget('enable_checkbutton')
        w.set_label(_(w.get_label()))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import gtk
import gtk.glade
from gtk import gdk

from pysollib.mygettext import _

# ************************************************************************
# *
# ************************************************************************


class ColorsDialog:

    def __init__(self, parent, title, app, **kw):

        glade_file = app.dataloader.findFile('pysolfc.glade')
        self.widgets_tree = gtk.glade.XML(glade_file)

        keys = (
            'text',
            'piles',
            'cards_1',
            'cards_2',
            'samerank_1',
            'samerank_2',
            'hintarrow',
            'not_matching',
            )
        for n in keys:
            self._setColor(n, app.opt.colors[n])
            button = self.widgets_tree.get_widget(n+'_button')
            button.connect('clicked', self._changeColor, n)

        self._translateLabels()

        dialog = self.widgets_tree.get_widget('colors_dialog')
        self.dialog = dialog
        dialog.set_title(title)
        dialog.set_transient_for(parent)

        self.status = -1
        self.button = -1
        response = dialog.run()
        if response == gtk.RESPONSE_OK:
            self.status = 0
            self.button = 0
            for n in keys:
                w = self.widgets_tree.get_widget(n+'_label')
                c = w.get_data('user_data')
                setattr(self, n+'_color', c)

        dialog.destroy()

    def _setColor(self, name, color):
        label = self.widgets_tree.get_widget(name+'_label')
        eventbox = self.widgets_tree.get_widget(name+'_eventbox')
        eventbox.modify_bg(gtk.STATE_NORMAL, gdk.color_parse(color))
        label.set_data('user_data', color)
        label.set_text(color)

    def _changeColor(self, w, name):
        label = self.widgets_tree.get_widget(name+'_label')
        color = label.get_data('user_data')
        dialog = gtk.ColorSelectionDialog(_('Select color'))
        dialog.help_button.destroy()
        dialog.set_transient_for(self.dialog)
        dialog.set_position(gtk.WIN_POS_CENTER_ON_PARENT)
        dialog.colorsel.set_current_color(gdk.color_parse(color))
        response = dialog.run()
        if response == gtk.RESPONSE_OK:
            c = dialog.colorsel.get_current_color()
            c = '#%02x%02x%02x' % (c.red/256, c.green/256, c.blue/256)
            self._setColor(name, c)
        dialog.destroy()

    def _translateLabels(self):
        for n in (
            'label31',
            'label32',
            'label33',
            'label34',
            'label35',
            'label36',
            'label37',
            'label46',
            'label47',
            'label48',
            'label49',
            'label50',
            'label51',
            'label52',
            'label53',
            'label79',
               ):
            w = self.widgets_tree.get_widget(n)
            w.set_text(_(w.get_text()))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


import sys
import time

import gobject

import gtk
import gtk.glade

import pango

from pysollib.mfxutil import format_time
from pysollib.mygettext import _
from pysollib.settings import TITLE
from pysollib.stats import PysolStatsFormatter

from tkwidget import MfxMessageDialog

if sys.version_info > (3,):
    def cmp(a, b):
        return ((b > a)-(a > b))

# ************************************************************************
# *
# ************************************************************************


class StatsFormatter(PysolStatsFormatter):

    def __init__(self, app, store):
        self.app = app
        self.store = store

    def writeStats(self, player, sort_by='name'):
        for result in self.getStatResults(player, sort_by):
            iter = self.store.append(None)
            self.store.set(iter,
                           0, result[0],
                           1, result[1],
                           2, result[2],
                           3, result[3],
                           4, result[4],
                           5, result[5],
                           6, result[6],
                           7, result[7])
        total, played, won, lost, time, moves, perc = self.getStatSummary()
        text = _("Total (%(played)d out of %(total)d games)") % {
            'played': played, 'total': total}
        iter = self.store.append(None)
        self.store.set(iter,
                       0, text,
                       1, won+lost,
                       2, won,
                       3, lost,
                       4, time,
                       5, moves,
                       6, perc,
                       7, -1)
        return 1


class LogFormatter(PysolStatsFormatter):
    MAX_ROWS = 10000

    def __init__(self, app, store):
        self.app = app
        self.store = store
        self._num_rows = 0

    def writeLog(self, player, prev_games):
        if not player or not prev_games:
            return 0
        num_rows = 0
        for result in self.getLogResults(player, prev_games):
            iter = self.store.append(None)
            self.store.set(iter,
                           0, result[0],
                           1, result[1],
                           2, result[2],
                           3, result[3],
                           4, result[4])
            num_rows += 1
            if num_rows > self.MAX_ROWS:
                break
        return 1

    def writeFullLog(self, player):
        prev_games = self.app.stats.prev_games.get(player)
        return self.writeLog(player, prev_games)

    def writeSessionLog(self, player):
        prev_games = self.app.stats.session_games.get(player)
        return self.writeLog(player, prev_games)


class Game_StatsDialog:

    def __init__(self, parent, header, app, player, gameid):
        #
        self.app = app
        self.selected_game = None
        self.player = player
        self.gameid = gameid
        self.games = {}
        self.games_id = []  # sorted by name
        #
        glade_file = app.dataloader.findFile('pysolfc.glade')
        #
        games = app.gdb.getGamesIdSortedByName()
        n = 0
        for id in games:
            won, lost = self.app.stats.getStats(self.player, id)
            if won+lost > 0 or id == gameid:
                gi = app.gdb.get(id)
                self.games[n] = gi
                self.games_id.append(id)
                n += 1
        #
        self.widgets_tree = gtk.glade.XML(glade_file)
        #
        table = self.widgets_tree.get_widget('current_game_table')
        self._createGameCombo(table, 1, 0, self._currentComboChanged)
        # total
        self._createText('total')
        drawing = self.widgets_tree.get_widget('total_drawingarea')
        drawing.connect('expose_event', self._drawingExposeEvent, 'total')
        # current session
        self._createText('session')
        drawing = self.widgets_tree.get_widget('session_drawingarea')
        drawing.connect('expose_event', self._drawingExposeEvent, 'session')
        # top 10
        table = self.widgets_tree.get_widget('top_10_table')
        self._createGameCombo(table, 1, 0, self._top10ComboChanged)
        self._createTop()
        self._updateTop(gameid)
        # all games stat
        store = self._createStatsList()
        formatter = StatsFormatter(app, store)
        formatter.writeStats(player)
        # full log
        store = self._createLogList('full_log_treeview')
        formatter = LogFormatter(app, store)
        formatter.writeFullLog(player)
        # session log
        store = self._createLogList('session_log_treeview')
        formatter = LogFormatter(app, store)
        formatter.writeSessionLog(player)
        #
        self._translateLabels()
        dialog = self.widgets_tree.get_widget('stats_dialog')
        dialog.set_position(gtk.WIN_POS_CENTER_ON_PARENT)
        dialog.set_transient_for(parent)
        dialog.resize(500, 340)
        dialog.set_title(TITLE+' - '+_("Statistics"))
        #
        dialog.run()
        self.status = -1
        dialog.destroy()

    def _translateLabels(self):
        # mnemonic
        for n in (
            'label0',
            'label1',
            'label2',
            'label3',
            'label4',
            'label15',
            'label16',
            'label17',
            'label18',
                ):
            w = self.widgets_tree.get_widget(n)
            w.set_text_with_mnemonic(_(w.get_label()))
        # simple
        for n in (
            'label5',
            'label6',
            'label7',
            'label14'
                ):
            w = self.widgets_tree.get_widget(n)
            w.set_text(_(w.get_text()))
        # markup
        for n in (
            'label8',
            'label9',
            'label10',
            'label11',
            'label12',
            'label13',
            'label19',
            'label20',
            'label21',
            'label22',
            'label23',
            'label24',
                ):
            w = self.widgets_tree.get_widget(n)
            s = _(w.get_label())
            w.set_markup('<b>%s</b>' % s)

    def _createGameCombo(self, table, x, y, callback):
        combo = gtk.combo_box_new_text()
        combo.show()
        table.attach(combo,
                     x, x+1,                y, y+1,
                     gtk.FILL | gtk.EXPAND,   0,
                     4,                     4)
        #
        n = 0
        current = 0
        for id in self.games_id:
            gi = self.app.gdb.get(id)
            combo.append_text(gi.name)
            if id == self.gameid:
                current = n
            n += 1
        combo.set_active(current)
        combo.connect('changed', callback)  # self._comboChanged)

    def _currentComboChanged(self, w):
        gi = self.games[w.get_active()]
        self.gameid = gi.id
        self._createText('total')
        drawing = self.widgets_tree.get_widget('total_drawingarea')
        self._createChart(drawing, 'total')
        self._createText('session')
        drawing = self.widgets_tree.get_widget('session_drawingarea')
        self._createChart(drawing, 'session')

    def _top10ComboChanged(self, w):
        gi = self.games[w.get_active()]
        self._updateTop(gi.id)

    def _createText(self, name):
        if name == 'total':
            won, lost = self.app.stats.getStats(self.player, self.gameid)
        else:
            won, lost = self.app.stats.getSessionStats(
                self.player, self.gameid)
        pwon, plost = self._getPwon(won, lost)
        label = self.widgets_tree.get_widget(name+'_num_won_label')
        label.set_text(str(won))
        label = self.widgets_tree.get_widget(name+'_num_lost_label')
        label.set_text(str(lost))
        label = self.widgets_tree.get_widget(name+'_percent_won_label')
        label.set_text(str(int(round(pwon*100)))+'%')
        label = self.widgets_tree.get_widget(name+'_percent_lost_label')
        label.set_text(str(int(round(plost*100)))+'%')
        label = self.widgets_tree.get_widget(name+'_num_total_label')
        label.set_text(str(won+lost))

    def _drawingExposeEvent(self, drawing, e, frame):
        self._createChart(drawing, frame)

    def _createChart(self, drawing, frame):
        if frame == 'total':
            won, lost = self.app.stats.getStats(self.player, self.gameid)
        else:
            won, lost = self.app.stats.getSessionStats(
                self.player, self.gameid)
        pwon, plost = self._getPwon(won, lost)
        s, ewon, elost = 0, int(360.0*pwon), int(360.0*plost)

        win = drawing.window
        colormap = drawing.get_colormap()
        gc = win.new_gc()
        gc.set_colormap(colormap)

        alloc = drawing.allocation
        width, height = alloc.width, alloc.height
        w, h = 90, 50
        # x, y = 10, 10
        x, y = (width-w)//2, (height-h)//2
        dy = 9
        y -= dy//2

        if won+lost > 0:
            gc.set_foreground(colormap.alloc_color('#008000'))
            win.draw_arc(gc, True, x, y+dy, w, h, s*64, ewon*64)
            gc.set_foreground(colormap.alloc_color('black'))
            win.draw_arc(gc, False, x, y+dy, w, h, s*64, ewon*64)
            gc.set_foreground(colormap.alloc_color('#800000'))
            win.draw_arc(gc, True, x, y+dy, w, h, (s+ewon)*64, elost*64)
            gc.set_foreground(colormap.alloc_color('black'))
            win.draw_arc(gc, False, x, y+dy, w, h, (s+ewon)*64, elost*64)
            gc.set_foreground(colormap.alloc_color('#00ff00'))
            win.draw_arc(gc, True, x, y, w, h, s*64, ewon*64)
            gc.set_foreground(colormap.alloc_color('black'))
            win.draw_arc(gc, False, x, y, w, h, s*64, ewon*64)
            gc.set_foreground(colormap.alloc_color('#ff0000'))
            win.draw_arc(gc, True, x, y, w, h, (s+ewon)*64, elost*64)
            gc.set_foreground(colormap.alloc_color('black'))
            win.draw_arc(gc, False, x, y, w, h, (s+ewon)*64, elost*64)
        else:
            gc.set_foreground(colormap.alloc_color('#808080'))
            win.draw_arc(gc, True, x, y+dy, w, h, 0, 360*64)
            gc.set_foreground(colormap.alloc_color('black'))
            win.draw_arc(gc, False, x, y+dy, w, h, 0, 360*64)
            gc.set_foreground(colormap.alloc_color('#f0f0f0'))
            win.draw_arc(gc, True, x, y, w, h, 0, 360*64)
            gc.set_foreground(colormap.alloc_color('black'))
            win.draw_arc(gc, False, x, y, w, h, 0, 360*64)
            gc.set_foreground(colormap.alloc_color('#a0a0a0'))
            pangolayout = drawing.create_pango_layout(_('No games'))
            ext = pangolayout.get_extents()
            tw, th = ext[1][2]//pango.SCALE, ext[1][3]//pango.SCALE
            win.draw_layout(gc, x+w//2-tw//2, y+h//2-th//2, pangolayout)

    def _createTop(self):
        for n in ('top_10_time_treeview',
                  'top_10_moves_treeview',
                  'top_10_total_moves_treeview'):
            self._createTopList(n)

    def _updateTop(self, gameid):
        s = self.app.stats.games_stats
        cond = (self.player not in s or
                gameid not in s[self.player] or
                not s[self.player][gameid].time_result.top)
        if cond:
            return

        s = s[self.player][gameid]

        label = self.widgets_tree.get_widget('playing_time_minimum_label')
        label.set_text(format_time(s.time_result.min))
        label = self.widgets_tree.get_widget('playing_time_maximum_label')
        label.set_text(format_time(s.time_result.max))
        label = self.widgets_tree.get_widget('playing_time_average_label')
        label.set_text(format_time(s.time_result.average))

        label = self.widgets_tree.get_widget('moves_minimum_label')
        label.set_text(str(s.moves_result.min))
        label = self.widgets_tree.get_widget('moves_maximum_label')
        label.set_text(str(s.moves_result.max))
        label = self.widgets_tree.get_widget('moves_average_label')
        label.set_text(str(round(s.moves_result.average, 2)))

        label = self.widgets_tree.get_widget('total_moves_minimum_label')
        label.set_text(str(s.total_moves_result.min))
        label = self.widgets_tree.get_widget('total_moves_maximum_label')
        label.set_text(str(s.total_moves_result.max))
        label = self.widgets_tree.get_widget('total_moves_average_label')
        label.set_text(str(round(s.total_moves_result.average, 2)))

        for n, ss in (
            ('top_10_time_treeview',        s.time_result.top),
            ('top_10_moves_treeview',       s.moves_result.top),
            ('top_10_total_moves_treeview', s.total_moves_result.top)
                ):
            self._updateTopList(n, ss)

    def _createTopList(self, tv_name):
        treeview = self.widgets_tree.get_widget(tv_name)
        store = gtk.ListStore(gobject.TYPE_INT,    # N
                              gobject.TYPE_STRING,  # number
                              gobject.TYPE_STRING,  # started at
                              gobject.TYPE_STRING,  # result
                              gobject.TYPE_STRING,  # result
                              )
        treeview.set_model(store)
        n = 0
        for label in (
            _('N'),
            _('Game number'),
            _('Started at'),
            _('Result'),
                ):
            column = gtk.TreeViewColumn(label, gtk.CellRendererText(), text=n)
            column.set_resizable(True)
            # column.set_sort_column_id(n)
            treeview.append_column(column)
            n += 1

    def _updateTopList(self, tv_name, top):
        treeview = self.widgets_tree.get_widget(tv_name)
        store = treeview.get_model()
        store.clear()
        row = 1
        for i in top:
            t = time.strftime('%Y-%m-%d %H:%M',
                              time.localtime(i.game_start_time))
            if isinstance(i.value, float):
                # time
                r = format_time(i.value)
            else:
                # moves
                r = str(i.value)
            iter = store.append(None)
            store.set(iter, 0, row, 1, i.game_number, 2, t, 3, r)
            row += 1

    def _createStatsList(self):
        treeview = self.widgets_tree.get_widget('all_games_treeview')
        n = 0
        for label in (
            _('Game'),
            _('Played'),
            _('Won'),
            _('Lost'),
            _('Playing time'),
            _('Moves'),
            _('% won'),
                ):
            column = gtk.TreeViewColumn(label, gtk.CellRendererText(),
                                        text=n)
            column.set_resizable(True)
            column.set_sort_column_id(n)
            treeview.append_column(column)
            n += 1
        #
        store = gtk.ListStore(gobject.TYPE_STRING,  # name
                              gobject.TYPE_INT,    # played
                              gobject.TYPE_INT,    # won
                              gobject.TYPE_INT,    # lost
                              gobject.TYPE_STRING,  # playing time
                              gobject.TYPE_STRING,  # moves
                              gobject.TYPE_STRING,  # % won
                              gobject.TYPE_INT,    # gameid
                              )
        sortable = gtk.TreeModelSort(store)
        sortable.set_sort_func(4, self._cmpPlayingTime)
        sortable.set_sort_func(5, self._cmpMoves)
        sortable.set_sort_func(6, self._cmpPercent)
        treeview.set_model(sortable)
        treeview.set_rules_hint(True)
        return store

    def _createLogList(self, name):
        #
        treeview = self.widgets_tree.get_widget(name)
        n = 0
        for label in (
            _('Game'),
            _('Game number'),
            _('Started at'),
            _('Status'),
                ):
            column = gtk.TreeViewColumn(label, gtk.CellRendererText(),
                                        text=n)
            column.set_resizable(True)
            column.set_sort_column_id(n)
            treeview.append_column(column)
            n += 1
        #
        store = gtk.ListStore(gobject.TYPE_STRING,  # game name
                              gobject.TYPE_STRING,  # game number
                              gobject.TYPE_STRING,  # started at
                              gobject.TYPE_STRING,  # status
                              gobject.TYPE_INT,     # gameid
                              )
        treeview.set_model(store)
        treeview.set_rules_hint(True)
        return store

    def _getPwon(self, won, lost):
        pwon, plost = 0.0, 0.0
        if won + lost > 0:
            pwon = float(won) / (won + lost)
            pwon = min(max(pwon, 0.00001), 0.99999)
            plost = 1.0 - pwon
        return pwon, plost

    def _cmpPlayingTime(self, store, iter1, iter2):
        val1 = store.get_value(iter1, 4)
        val2 = store.get_value(iter2, 4)
        t1 = map(int, val1.split(':'))
        t2 = map(int, val2.split(':'))
        return cmp(len(t1), len(t2)) or cmp(t1, t2)

    def _cmpMoves(self, store, iter1, iter2):
        val1 = store.get_value(iter1, 5)
        val2 = store.get_value(iter2, 5)
        return cmp(float(val1), float(val2))

    def _cmpPercent(self, store, iter1, iter2):
        val1 = store.get_value(iter1, 6)
        val2 = store.get_value(iter2, 6)
        return cmp(float(val1), float(val2))


# ************************************************************************
# *
# ************************************************************************

SingleGame_StatsDialog = Game_StatsDialog
AllGames_StatsDialog = Game_StatsDialog
FullLog_StatsDialog = Game_StatsDialog
SessionLog_StatsDialog = Game_StatsDialog
Top_StatsDialog = Game_StatsDialog


# ************************************************************************
# *
# ************************************************************************

class Status_StatsDialog(MfxMessageDialog):  # MfxDialog
    def __init__(self, parent, game):
        stats, gstats = game.stats, game.gstats
        w1 = w2 = ''
        n = sum([len(s.cards) for s in game.s.foundations])
        w1 = (_('Highlight piles: ') + str(stats.highlight_piles) + '\n' +
              _('Highlight cards: ') + str(stats.highlight_cards) + '\n' +
              _('Highlight same rank: ') +
              str(stats.highlight_samerank) + '\n')
        if game.s.talon:
            if game.gameinfo.redeals != 0:
                w2 += _('\nRedeals: ') + str(game.s.talon.round - 1)
            w2 += _('\nCards in Talon: ') + str(len(game.s.talon.cards))
        if game.s.waste and game.s.waste not in game.s.foundations:
            w2 += _('\nCards in Waste: ') + str(len(game.s.waste.cards))
        if game.s.foundations:
            w2 += _('\nCards in Foundations: ') + str(n)
        #
        date = time.strftime('%Y-%m-%d %H:%M',
                             time.localtime(game.gstats.start_time))
        MfxMessageDialog.__init__(
            self, parent, title=_('Game status'),
            text=game.getTitleName() + '\n' +
            game.getGameNumber(format=1) + '\n' +
            _('Playing time: ') + game.getTime() + '\n' +
            _('Started at: ') + date + '\n\n' +
            _('Moves: ') + str(game.moves.index) + '\n' +
            _('Undo moves: ') + str(stats.undo_moves) + '\n' +
            _('Bookmark moves: ') + str(gstats.goto_bookmark_moves) + '\n' +
            _('Demo moves: ') + str(stats.demo_moves) + '\n' +
            _('Total player moves: ') + str(stats.player_moves) + '\n' +
            _('Total moves in this game: ') + str(stats.total_moves) + '\n' +
            _('Hints: ') + str(stats.hints) + '\n' +
            '\n' +
            w1 + w2,
            strings=(_('&OK'),
                     (_('&Statistics...'), 101), ),
            image=game.app.gimages.logos[3],
            image_side='left', image_padx=20,
            padx=20,
            )


class ProgressionDialog:
    # FIXME
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import formatter
import htmllib
import os
import sys
import traceback

import gobject

import gtk
from gtk import gdk

import pango

from pysollib.mfxutil import Struct, openURL
from pysollib.mygettext import _
from pysollib.settings import TITLE

import six

from tkwidget import MfxMessageDialog

if __name__ == '__main__':
    d = os.path.abspath(os.path.join(sys.path[0], '..', '..'))
    sys.path.append(d)
    import gettext
    gettext.install('pysol', d, unicode=True)

REMOTE_PROTOCOLS = ('ftp:', 'gopher:', 'http:', 'mailto:', 'news:', 'telnet:')


# ************************************************************************
# *
# ************************************************************************

class tkHTMLWriter(formatter.NullWriter):
    def __init__(self, text, viewer, app):
        formatter.NullWriter.__init__(self)

        self.text = text      # gtk.TextBuffer
        self.viewer = viewer  # HTMLViewer

        self.anchor = None
        self.anchor_mark = None

        self.font = None
        self.font_mark = None
        self.indent = ''

    def write(self, data):
        data = six.text_type(data)
        self.text.insert(self.text.get_end_iter(), data, len(data))

    def anchor_bgn(self, href, name, type):
        if href:
            # self.text.update_idletasks()   # update display during parsing
            self.anchor = (href, name, type)
            self.anchor_mark = self.text.get_end_iter().get_offset()

    def anchor_end(self):
        if self.anchor:
            href = self.anchor[0]
            tag_name = 'href_' + href
            if tag_name in self.viewer.anchor_tags:
                tag = self.viewer.anchor_tags[tag_name][0]
            else:
                tag = self.text.create_tag(tag_name, foreground='blue',
                                           underline=pango.UNDERLINE_SINGLE)
                self.viewer.anchor_tags[tag_name] = (tag, href)
                tag.connect('event', self.viewer.anchor_event, href)
            u = self.viewer.normurl(href, with_protocol=False)
            if u in self.viewer.visited_urls:
                tag.set_property('foreground', '#660099')
            start = self.text.get_iter_at_offset(self.anchor_mark)
            end = self.text.get_end_iter()
            # print 'apply_tag href >>', start.get_offset(), end.get_offset()
            self.text.apply_tag(tag, start, end)

            self.anchor = None

    def new_font(self, font):
        # end the current font
        if self.font:
            # print 'end_font(%s)' % `self.font`
            start = self.text.get_iter_at_offset(self.font_mark)
            end = self.text.get_end_iter()
            # print 'apply_tag font >>', start.get_offset(), end.get_offset()
            self.text.apply_tag_by_name(self.font, start, end)
            self.font = None
        # start the new font
        if font:
            # print 'start_font(%s)' % `font`
            self.font_mark = self.text.get_end_iter().get_offset()
            if font[0] in self.viewer.fontmap:
                self.font = font[0]
            elif font[3]:
                self.font = 'pre'
            elif font[2]:
                self.font = 'bold'
            elif font[1]:
                self.font = 'italic'
            else:
                self.font = None

    def new_margin(self, margin, level):
        self.indent = '    ' * level

    def send_label_data(self, data):
        # self.write(self.indent + data + ' ')
        self.write(self.indent)
        if data == '*':  # <li>
            img = self.viewer.symbols_img.get('disk')
            if img:
                self.text.insert_pixbuf(self.text.get_end_iter(), img)
            else:
                self.write('*')  # unichr(0x2022)
        else:
            self.write(data)
        self.write(' ')

    def send_paragraph(self, blankline):
        self.write('\n' * blankline)

    def send_line_break(self):
        self.write('\n')

    def send_hor_rule(self, *args):
        # ~ width = int(int(self.text['width']) * 0.9)
        width = 70
        self.write('_' * width)
        self.write('\n')

    def send_literal_data(self, data):
        self.write(data)

    def send_flowing_data(self, data):
        self.write(data)


# ************************************************************************
# *
# ************************************************************************

class tkHTMLParser(htmllib.HTMLParser):
    def anchor_bgn(self, href, name, type):
        self.formatter.flush_softspace()
        htmllib.HTMLParser.anchor_bgn(self, href, name, type)
        self.formatter.writer.anchor_bgn(href, name, type)

    def anchor_end(self):
        if self.anchor:
            self.anchor = None
        self.formatter.writer.anchor_end()

    def do_dt(self, attrs):
        self.formatter.end_paragraph(1)
        self.ddpop()

    def handle_image(self, src, alt, ismap, align, width, height):
        self.formatter.writer.viewer.showImage(
            src, alt, ismap, align, width, height)


# ************************************************************************
# *
# ************************************************************************

class HTMLViewer:
    symbols_fn = {}  # filenames, loaded in Application.loadImages3
    symbols_img = {}

    def __init__(self, parent, app=None, home=None):
        self.parent = parent
        self.app = app
        self.home = home
        self.url = None
        self.history = Struct(
            list=[],
            index=0,
        )
        self.visited_urls = []
        self.images = {}
        self.anchor_tags = {}

        # create buttons
        vbox = gtk.VBox()
        parent.table.attach(
            vbox,
            0, 1,                   0, 1,
            gtk.EXPAND | gtk.FILL,  gtk.EXPAND | gtk.FILL | gtk.SHRINK,
            0,                      0)

        buttons_box = gtk.HBox()
        vbox.pack_start(buttons_box, fill=True, expand=False)
        for name, label, callback in (
            ('homeButton',    _('Index'),   self.goHome),
            ('backButton',    _('Back'),    self.goBack),
            ('forwardButton', _('Forward'), self.goForward),
            ('closeButton',   _('Close'),   self.destroy)
                ):
            button = gtk.Button(label)
            button.show()
            button.connect('clicked', callback)
            buttons_box.pack_start(button, fill=True, expand=False)
            button.set_property('can-focus', False)
            setattr(self, name, button)

        # create text widget
        self.textview = gtk.TextView()
        self.textview.show()
        self.textview.set_left_margin(10)
        self.textview.set_right_margin(10)
        self.textview.set_cursor_visible(False)
        self.textview.set_editable(False)
        self.textview.set_wrap_mode(gtk.WRAP_WORD)
        self.textbuffer = self.textview.get_buffer()

        sw = gtk.ScrolledWindow()
        sw.set_property('hscrollbar-policy', gtk.POLICY_AUTOMATIC)
        sw.set_property('vscrollbar-policy', gtk.POLICY_AUTOMATIC)
        sw.set_property('border-width', 0)
        sw.add(self.textview)
        sw.show()
        vbox.pack_start(sw, fill=True, expand=True)
        self.vadjustment = sw.get_vadjustment()
        self.hadjustment = sw.get_hadjustment()

        # statusbar
        self.statusbar = gtk.Statusbar()
        self.statusbar.show()
        vbox.pack_start(self.statusbar, fill=True, expand=False)

        # load images
        for name, fn in self.symbols_fn.items():
            self.symbols_img[name] = self.getImage(fn)

        # bindings
        parent.connect('key-press-event', self.key_press_event)
        parent.connect('destroy', self.destroy)
        self.textview.connect('motion-notify-event', self.motion_notify_event)
        self.textview.connect('leave-notify-event', self.leave_event)
        self.textview.connect('enter-notify-event', self.motion_notify_event)

        self._changed_cursor = False

        self.createFontMap()

        # cursor
        self.defcursor = gdk.XTERM
        self.handcursor = gdk.HAND2
        # self.textview.realize()
        # window = self.textview.get_window(gtk.TEXT_WINDOW_TEXT)
        # window.set_cursor(gdk.Cursor(self.defcursor))

        parent.set_default_size(600, 440)
        parent.show_all()
        gobject.idle_add(gtk.main)

    def motion_notify_event(self, widget, event):
        x, y, _ = widget.window.get_pointer()
        x, y = widget.window_to_buffer_coords(gtk.TEXT_WINDOW_TEXT, x, y)
        tags = widget.get_iter_at_location(x, y).get_tags()
        is_over_anchor = False
        for tag, href in self.anchor_tags.values():
            if tag in tags:
                is_over_anchor = True
                break
        if is_over_anchor:
            if not self._changed_cursor:
                # print 'set cursor hand'
                window = widget.get_window(gtk.TEXT_WINDOW_TEXT)
                window.set_cursor(gdk.Cursor(self.handcursor))
                self._changed_cursor = True
            self.statusbar.pop(0)
            href = self.normurl(href)
            self.statusbar.push(0, href)
        else:
            if self._changed_cursor:
                # print 'set cursor xterm'
                window = widget.get_window(gtk.TEXT_WINDOW_TEXT)
                window.set_cursor(gdk.Cursor(self.defcursor))
                self._changed_cursor = False
            self.statusbar.pop(0)
        return False

    def leave_event(self, widget, event):
        if self._changed_cursor:
            # print 'set cursor xterm'
            window = widget.get_window(gtk.TEXT_WINDOW_TEXT)
            window.set_cursor(gdk.Cursor(self.defcursor))
            self._changed_cursor = False
        self.statusbar.pop(0)

    def anchor_event(self, tag, textview, event, iter, href):
        # print 'anchor_event:', args
        if event.type == gdk.BUTTON_PRESS and event.button == 1:
            self.updateHistoryXYView()
            self.display(href)
            return True
        return False

    def key_press_event(self, w, e):
        if gdk.keyval_name(e.keyval) == 'Escape':
            self.destroy()

    def createFontMap(self):
        try:  # if app
            default_font = self.app.getFont('sans')
            fixed_font = self.app.getFont('fixed')
        except Exception:
            traceback.print_exc()
            default_font = ('times new roman', 12)
            fixed_font = ('courier', 12)
        size = default_font[1]
        sign = 1
        if size < 0:
            sign = -1
        self.fontmap = {
            'h1': (default_font[0], size + 12*sign, 'bold'),
            'h2': (default_font[0], size + 8*sign, 'bold'),
            'h3': (default_font[0], size + 6*sign, 'bold'),
            'h4': (default_font[0], size + 4*sign, 'bold'),
            'h5': (default_font[0], size + 2*sign, 'bold'),
            'h6': (default_font[0], size + 1*sign, 'bold'),
            'bold': (default_font[0], size,           'bold'),
        }

        for tag_name in self.fontmap.keys():
            font = self.fontmap[tag_name]
            font = font[0]+' '+str(font[1])
            tag = self.textbuffer.create_tag(tag_name, font=font)
            tag.set_property('weight', pango.WEIGHT_BOLD)

        font = font[0]+' '+str(font[1])
        tag = self.textbuffer.create_tag('italic', style=pango.STYLE_ITALIC)
        self.fontmap['italic'] = (font[0], size, 'italic')
        font = fixed_font[0]+' '+str(fixed_font[1])
        self.textbuffer.create_tag('pre', font=font)
        self.fontmap['pre'] = fixed_font
        # set default font
        fd = pango.FontDescription(default_font[0]+' '+str(default_font[1]))
        if 'bold' in default_font:
            fd.set_weight(pango.WEIGHT_BOLD)
        if 'italic' in default_font:
            fd.set_style(pango.STYLE_ITALIC)
        self.textview.modify_font(fd)

    def destroy(self, *event):
        self.parent.destroy()
        self.parent = None

    def get_position(self):
        pos = self.hadjustment.get_value(), self.vadjustment.get_value()
        return pos

    def set_position(self, pos):
        def callback(pos, hadj, vadj):
            hadj.set_value(pos[0])
            vadj.set_value(pos[1])
        gobject.idle_add(callback, pos, self.hadjustment, self.vadjustment)

    # locate a file relative to the current self.url
    def basejoin(self, url, baseurl=None, relpath=1):
        if baseurl is None:
            baseurl = self.url
        if 0:
            import urllib
            url = urllib.pathname2url(url)
            if relpath and self.url:
                url = urllib.basejoin(baseurl, url)
        else:
            url = os.path.normpath(url)
            if relpath and baseurl and not os.path.isabs(url):
                h1, t1 = os.path.split(url)
                h2, t2 = os.path.split(baseurl)
                if h1 != h2:
                    url = os.path.join(h2, h1, t1)
                url = os.path.normpath(url)
        return url

    def normurl(self, url, with_protocol=True):
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                break
        else:
            url = self.basejoin(url)
            if with_protocol:
                if os.name == 'nt':
                    url = url.replace('\\', '/')
                url = 'file://'+url
        return url

    def openfile(self, url):
        if url[-1:] == '/' or os.path.isdir(url):
            url = os.path.join(url, 'index.html')
        url = os.path.normpath(url)
        return open(url, 'rb'), url

    def display(self, url, add=1, relpath=1, position=(0, 0)):
        # print 'display:', url, position
        # for some reason we have to stop the PySol demo
        # (is this a multithread problem with tkinter ?)
        try:
            # self.app.game.stopDemo()
            # self.app.game._cancelDrag()
            pass
        except Exception:
            pass

        # ftp: and http: would work if we use urllib, but this widget is
        # far too limited to display anything but our documentation...
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                if not openURL(url):
                    self.errorDialog(_('''%(app)s HTML limitation:
The %(protocol)s protocol is not supported yet.

Please use your standard web browser
to open the following URL:
%(url)s
''') % {'app': TITLE, 'protocol': p, 'url': url})
                return

        # locate the file relative to the current url
        url = self.basejoin(url, relpath=relpath)

        # read the file
        try:
            file = None
            if 0:
                import urllib
                file = urllib.urlopen(url)
            else:
                file, url = self.openfile(url)
            data = file.read()
            file.close()
            file = None
        except Exception as ex:
            if file:
                file.close()
            self.errorDialog(
                _('Unable to service request:\n') + url + '\n\n' + str(ex))
            return
        except Exception:
            if file:
                file.close()
            self.errorDialog(_('Unable to service request:\n') + url)
            return

        self.url = url
        if self.home is None:
            self.home = self.url
        if add:
            self.addHistory(self.url, position=position)

        # print self.history.index, self.history.list
        if self.history.index > 1:
            self.backButton.set_sensitive(True)
        else:
            self.backButton.set_sensitive(False)
        if self.history.index < len(self.history.list):
            self.forwardButton.set_sensitive(True)
        else:
            self.forwardButton.set_sensitive(False)

        start, end = self.textbuffer.get_bounds()
        self.textbuffer.delete(start, end)

        writer = tkHTMLWriter(self.textbuffer, self, self.app)
        fmt = formatter.AbstractFormatter(writer)
        parser = tkHTMLParser(fmt)
        parser.feed(data)
        parser.close()

        self.set_position(position)

        self.parent.set_title(parser.title)

    def addHistory(self, url, position=(0, 0)):
        if url not in self.visited_urls:
            self.visited_urls.append(url)
        if self.history.index > 0:
            u, pos = self.history.list[self.history.index-1]
            if u == url:
                self.updateHistoryXYView()
                return
        del self.history.list[self.history.index:]
        self.history.list.append((url, position))
        self.history.index = self.history.index + 1

    def updateHistoryXYView(self):
        if self.history.index > 0:
            url, position = self.history.list[self.history.index-1]
            position = self.get_position()
            self.history.list[self.history.index-1] = (url, position)

    def goBack(self, *event):
        if self.history.index > 1:
            self.updateHistoryXYView()
            self.history.index = self.history.index - 1
            url, position = self.history.list[self.history.index-1]
            self.display(url, add=0, relpath=0, position=position)

    def goForward(self, *event):
        if self.history.index < len(self.history.list):
            self.updateHistoryXYView()
            url, position = self.history.list[self.history.index]
            self.history.index = self.history.index + 1
            self.display(url, add=0, relpath=0, position=position)

    def goHome(self, *event):
        if self.home and self.home != self.url:
            self.updateHistoryXYView()
            self.display(self.home, relpath=0)

    def errorDialog(self, msg):
        MfxMessageDialog(
            self.parent, title=TITLE+' HTML Problem',
            text=msg, bitmap='warning',
            strings=(_('&OK'),), default=0)

    def getImage(self, fn):
        if fn in self.images:
            return self.images[fn]
        try:
            img = gdk.pixbuf_new_from_file(fn)
        except Exception:
            img = None
        self.images[fn] = img
        return img

    def showImage(self, src, alt, ismap, align, width, height):
        url = self.basejoin(src)
        img = self.getImage(url)
        if img:
            iter = self.textbuffer.get_end_iter()
            self.textbuffer.insert_pixbuf(iter, img)


# ************************************************************************
# *
# ************************************************************************


def tkhtml_main(args):
    try:
        url = args[1]
    except Exception:
        url = os.path.join(os.pardir, os.pardir, 'data', 'html', 'index.html')
    top = gtk.Window()
    table = gtk.Table()
    table.show()
    top.add(table)
    top.table = table
    viewer = HTMLViewer(top)
    viewer.app = None
    viewer.display(url)
    top.connect('destroy', lambda w: gtk.main_quit())
    gtk.main()
    return 0


if __name__ == '__main__':
    sys.exit(tkhtml_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


# imports
import os
import re

from findcarddialog import connect_game_find_card_dialog, \
        destroy_find_card_dialog

import gtk
from gtk import gdk

from pysollib.gamedb import GI
from pysollib.mygettext import _
from pysollib.settings import TITLE

from selectcardset import SelectCardsetDialogWithPreview

from selectgame import SelectGameDialogWithPreview

from selecttile import SelectTileDialogWithPreview

from soundoptionsdialog import SoundOptionsDialog


def ltk2gtk(s):
    # label tk to gtk
    return _(s).replace('&', '_')


# ************************************************************************
# * - create menubar
# * - update menubar
# * - menu actions
# ************************************************************************

class PysolMenubarTk:
    def __init__(self, app, top, progress=None):
        self.progress = progress
        self._cb_max = gdk.screen_height()/24
        # create menus
        menubar = self.createMenubar()
        self.top.table.attach(menubar,
                              0, 3,                    0, 1,
                              gtk.EXPAND | gtk.FILL,   0,
                              0,                       0)
        menubar.show()

    def connectGame(self, game):
        self.game = game
        if game is None:
            return
        assert self.app is game.app
        #  tkopt, opt = self.tkopt, self.app.opt
        #  tkopt.gameid.set(game.id)
        #  tkopt.gameid_popular.set(game.id)
        #  tkopt.comment.set(bool(game.gsaveinfo.comment))
        if game.canFindCard():
            connect_game_find_card_dialog(game)
        else:
            destroy_find_card_dialog()

    #
    # create menubar
    #

    def m(self, *args):
        # print args
        pass

    def createMenubar(self):

        entries = (

            # toolbar
            ('newgame', gtk.STOCK_NEW,            # action name, stock
             ltk2gtk('&New game'), 'N',           # label, accelerator
             ltk2gtk('New game'),                 # tooltip
             self.mNewGame),                      # callback
            ('open', gtk.STOCK_OPEN,
             ltk2gtk('&Open...'), '<control>O',
             ltk2gtk('Open a\nsaved game'),
             self.mOpen),
            ('restart', gtk.STOCK_REFRESH,
             ltk2gtk('&Restart'), '<control>G',
             ltk2gtk('Restart the\ncurrent game'),
             self.mRestart),
            ('save', gtk.STOCK_SAVE,
             ltk2gtk('&Save'), '<control>S',
             ltk2gtk('Save game'),
             self.mSave),
            ('undo', gtk.STOCK_UNDO,
             ltk2gtk('&Undo'), 'Z',
             ltk2gtk('Undo'),
             self.mUndo),
            ('redo', gtk.STOCK_REDO,
             ltk2gtk('&Redo'), 'R',
             ltk2gtk('Redo'),
             self.mRedo),
            ('shuffle', gtk.STOCK_EXECUTE,
             ltk2gtk('Shuffle tiles'), 'F',
             ltk2gtk('Shuffle tiles'),
             self.mShuffle),
            ('autodrop', gtk.STOCK_JUMP_TO,
             ltk2gtk('&Auto drop'), 'A',
             ltk2gtk('Auto drop'),
             self.mDrop),
            ('stats', gtk.STOCK_INDEX,
             ltk2gtk('&Statistics'), None,
             ltk2gtk('Statistics'),
             lambda w, self=self: self.mPlayerStats(mode=101)),
            ('rules', gtk.STOCK_HELP,
             ltk2gtk('&Rules'), 'F1',
             ltk2gtk('Rules'),
             self.mHelpRules),
            ('quit', gtk.STOCK_QUIT,
             ltk2gtk('&Quit'), '<control>Q',
             ltk2gtk('Quit PySol'),
             self.mQuit),

            # menus
            ('file',           None, ltk2gtk('&File')),
            ('recentgames',    None, ltk2gtk('R&ecent games')),
            ('favoritegames',  None, ltk2gtk('Fa&vorite games')),
            ('select',         None, ltk2gtk('&Select')),
            ('edit',           None, ltk2gtk('&Edit')),
            ('game',           None, ltk2gtk('&Game')),
            ('assist',         None, ltk2gtk('&Assist')),
            ('options',        None, ltk2gtk('&Options')),
            ('assistlevel',    None, ltk2gtk('Assist &level')),
            ('automaticplay',  None, ltk2gtk('&Automatic play')),
            ('animations',     None, ltk2gtk('A&nimations')),
            ('mouse',          None, ltk2gtk('&Mouse')),
            ('cardview',       None, ltk2gtk('Card &view')),
            ('toolbar',        None, ltk2gtk('&Toolbar')),
            ('statusbar',      None, ltk2gtk('Stat&usbar')),
            ('help',           None, ltk2gtk('&Help')),

            # menuitems
            ('playablepreview', None,
             ltk2gtk('Playable pre&view...'), 'V',
             None, self.mSelectGameDialogWithPreview),
            ('selectgamebynumber', None,
             ltk2gtk('Select game by nu&mber...'), None,
             None, self.mSelectGameById),
            ('addtofavorites', None,
             ltk2gtk('A&dd to favorites'), None,
             None, self.mAddFavor),
            ('removefromfavorites', None,
             ltk2gtk('R&emove from favorites'), None,
             None, self.mDelFavor),
            ('saveas', None,
             ltk2gtk('Save &as...'), None,
             None, self.mSaveAs),
            ('holdandquit', None,
             ltk2gtk('&Hold and quit'), None,
             None, self.mHoldAndQuit),
            ('redoall', None,
             ltk2gtk('Redo &all'), None,
             None, self.mRedoAll),
            ('dealcards', None,
             ltk2gtk('&Deal cards'), 'D',
             None, self.mDeal),
            ('status', None,
             ltk2gtk('S&tatus...'),  'T',
             None, self.mStatus),
            ('hint', None,
             ltk2gtk('&Hint'), 'H',
             None, self.mHint),
            ('highlightpiles', None,
             ltk2gtk('Highlight p&iles'), None,
             None, self.mHighlightPiles),
            ('demo', None,
             ltk2gtk('&Demo'), '<control>D',
             None, self.mDemo),
            ('demoallgames', None,
             ltk2gtk('Demo (&all games)'), None,
             None, self.mMixedDemo),
            ('playeroptions', None,
             ltk2gtk('&Player options...'), None,
             None, self.mOptPlayerOptions),
            ('sound', None,
             ltk2gtk('&Sound...'), None,
             None, self.mOptSoundDialog),
            ('cardset', None,
             ltk2gtk('Cards&et...'), '<control>E',
             None, self.mSelectCardsetDialog),
            ('tabletile', None,
             ltk2gtk('Table t&ile...'), None,
             None, self.mOptTableTile),
            ('fonts', None,
             ltk2gtk('&Fonts...'), None,
             None, self.mOptFonts),
            ('colors', None,
             ltk2gtk('&Colors...'), None,
             None, self.mOptColors),
            ('timeouts', None,
             ltk2gtk('Time&outs...'), None,
             None, self.mOptTimeouts),
            ('contents', None,
             ltk2gtk('&Contents'), '<control>F1',
             None, self.mHelp),
            ('aboutpysol', None,
             ltk2gtk('&About ')+TITLE+'...',
             None, None, self.mHelpAbout),
            ('updateall', None,
             'Redraw Game', '<control>L',
             None,
             self.updateAll),
            )

        #
        toggle_entries = [
            ('pause', gtk.STOCK_STOP,            # action, stock
             ltk2gtk('&Pause'), 'P',             # label, accelerator
             ltk2gtk('Pause game'),              # tooltip
             self.mPause,                        # callback
             False,                              # initial value
             ),
            ('negativecardsbottom', None,
             ltk2gtk('&Negative cards bottom'), None, None,
             self.mOptNegativeBottom,
             self.app.opt.negative_bottom,
             ),
            ('showstatusbar', None,
             ltk2gtk('Show &statusbar'), None, None,
             self.mOptStatusbar,
             self.app.opt.statusbar,
             ),
            ]
        for label, action, opt_name, update_game in (
            ('A&uto drop',   'optautodrop', 'autodrop',               False),
            ('Auto &face up',           '', 'autofaceup',             False),
            ('Auto &deal',              '', 'autodeal',               False),
            ('&Quick play',             '', 'quickplay',              False),
            ('Enable &undo',            '', 'undo',                   False),
            ('Enable &bookmarks',       '', 'bookmarks',              False),
            ('Enable &hint',            '', 'hint',                   False),
            ('Enable highlight p&iles', '', 'highlight_piles',        False),
            ('Enable highlight &cards', '', 'highlight_cards',        False),
            ('Enable highlight same &rank', '', 'highlight_samerank', False),
            ('Highlight &no matching',  '', 'highlight_not_matching', False),
            ('Card shado&w',            '', 'shadow',                 False),
            ('Shade &legal moves',      '', 'shade',                  False),
            ('Shrink face-down cards',  '', 'shrink_face_down',       True),
            ('Shade &filled stacks',    '', 'shade_filled_stacks',    True),
            ('Show &number of cards',   '', 'num_cards',              False),
            ('Use mouse for undo/redo', '', 'mouse_undo',             False),
            ('&Demo logo',              '', 'demo_logo',              False),
            ('Startup splash sc&reen',  '', 'splashscreen',           False),
            ('&Show removed tiles (in Mahjongg games)', '',
             'mahjongg_show_removed', True),
            ('Show hint &arrow (in Shisen-Sho games)', '',
             'shisen_show_hint', False),
                ):
            if not action:
                action = re.sub(r'[^0-9a-zA-Z]', '', label).lower()
            toggle_entries.append(
                (action,
                 None, ltk2gtk(label),
                 None, None,
                 lambda w, o=opt_name, u=update_game: self.mOptToggle(w, o, u),
                 getattr(self.app.opt, opt_name)))

        #
        animations_entries = (
          ('animationnone',     None, ltk2gtk('&None'),        None, None, 0),
          ('animationveryfast', None, ltk2gtk('&Very fast'),   None, None, 1),
          ('animationfast',     None, ltk2gtk('&Fast'),        None, None, 2),
          ('animationmedium',   None, ltk2gtk('&Medium'),      None, None, 3),
          ('animationslow',     None, ltk2gtk('&Slow'),        None, None, 4),
          ('animationveryslow', None, ltk2gtk('V&ery slow'),   None, None, 5),
          )
        mouse_entries = (
          ('draganddrop',   None, ltk2gtk('&Drag-and-Drop'),   None, None, 0),
          ('pointandclick', None, ltk2gtk('&Point-and-Click'), None, None, 1),
          ('stickymouse',   None, ltk2gtk('&Sticky mouse'),    None, None, 2),
          )
        toolbar_side_entries = (
            ('toolbarhide',     None, ltk2gtk('Hide'),         None, None, 0),
            ('toolbartop',      None, ltk2gtk('Top'),          None, None, 1),
            ('toolbarbottom',   None, ltk2gtk('Bottom'),       None, None, 2),
            ('toolbarleft',     None, ltk2gtk('Left'),         None, None, 3),
            ('toolbarright',    None, ltk2gtk('Right'),        None, None, 4),
            )

        ui_manager = gtk.UIManager()

        action_group = gtk.ActionGroup('PySolActions')
        action_group.add_actions(entries)
        action_group.add_toggle_actions(toggle_entries)
        action_group.add_radio_actions(animations_entries,
                                       self.app.opt.animations,
                                       self.mOptAnimations)
        t = ['drag-n-drop', 'point-n-click', 'sticky-mouse'].index(
            self.app.opt.mouse_type)
        action_group.add_radio_actions(mouse_entries,
                                       t,
                                       self.mOptMouseType)
        action_group.add_radio_actions(toolbar_side_entries,
                                       self.app.opt.toolbar,
                                       self.mOptToolbar)

        ui_manager.insert_action_group(action_group, 0)
        self.top.add_accel_group(ui_manager.get_accel_group())
        self.top.ui_manager = ui_manager

        # ui_manager.get_widget('/menubar/file/recentgames').show()
        # ui_manager.get_widget('/menubar/file/favoritegames').show()

        games = map(self.app.gdb.get, self.app.gdb.getGamesIdSortedByName())
        menu = ui_manager.get_widget('/menubar/select').get_submenu()
        self._createSelectMenu(games, menu)

        if not self.app.audio.CAN_PLAY_SOUND:
            item = ui_manager.get_widget('/menubar/options/sound')
            item.set_sensitive(False)

        menubar = ui_manager.get_widget('/menubar')
        return menubar

    #
    # Select Game menu creation
    #

    def _getNumGames(self, games, select_data):
        ngames = 0
        for label, select_func in select_data:
            ngames += len(filter(select_func, games))
        return ngames

    def _createSubMenu(self, menu, label):
        menu_item = gtk.MenuItem(label)
        menu.add(menu_item)
        menu_item.show()
        submenu = gtk.Menu()
        menu_item.set_submenu(submenu)
        return submenu

    def _addGamesMenuItem(self, menu, gi, short_name=False):
        if not gi:
            return
        if short_name:
            label = gi.short_name
        else:
            label = gi.name
        menu_item = gtk.MenuItem(label)
        menu_item.set_data('user_data', gi.id)
        menu_item.connect('activate', self.mSelectGame)
        menu.add(menu_item)
        menu_item.show()

    def _addGamesSubMenu(self, games, menu, short_name=False):
        for gi in games:
            self._addGamesMenuItem(menu, gi, short_name=short_name)

    def _addAllGamesMenu(self, games, menu):
        menu = self._createSubMenu(menu, label=ltk2gtk('&All games by name'))
        n, d = 0, self._cb_max
        i = 0
        while True:
            if self.progress:
                self.progress.update(step=1)
            i += 1
            if not games[n:n+d]:
                break
            m = min(n+d-1, len(games)-1)
            n1, n2 = games[n].name, games[m].name
            label = n1[:3]+' - '+n2[:3]
            submenu = self._createSubMenu(menu, label=label)
            self._addGamesSubMenu(games[n:n+d], submenu)
            n += d

    def _addSelectedGamesSubMenu(self, games, menu, select_data):
        for label, select_func in select_data:
            g = filter(select_func, games)
            if not g:
                continue
            submenu = self._createSubMenu(menu, label=label)
            self._addGamesSubMenu(g, submenu)

    def _addPopularGamesMenu(self, games, menu):
        def select_func(gi):
            return gi.si.game_flags & GI.GT_POPULAR
        if len(filter(select_func, games)) == 0:
            return
        data = (ltk2gtk('&Popular games'), select_func)
        self._addSelectedGamesSubMenu(games, menu, (data, ))

    def _addGamesByType(self, games, menu, label, data):
        if self._getNumGames(games, data) == 0:
            return
        submenu = self._createSubMenu(menu, label=label)
        self._addSelectedGamesSubMenu(games, submenu, data)

    def _addMahjonggGamesMenu(self, games, menu):
        def select_func(gi):
            return gi.si.game_type == GI.GT_MAHJONGG
        mahjongg_games = filter(select_func, games)
        if len(mahjongg_games) == 0:
            return
        menu = self._createSubMenu(menu, label=ltk2gtk('&Mahjongg games'))
        #

        def add_menu(games, c0, c1, menu=menu):
            if not games:
                return
            label = c0 + ' - ' + c1
            if c0 == c1:
                label = c0
            submenu = self._createSubMenu(menu, label=label)
            self._addGamesSubMenu(games, submenu, short_name=True)
        #
        games = {}
        for gi in mahjongg_games:
            c = gi.short_name.strip()[0]
            if c in games:
                games[c].append(gi)
            else:
                games[c] = [gi]
        games = games.items()
        games.sort()
        #
        g0 = []
        c0 = c1 = games[0][0]
        for c, g1 in games:
            if len(g0)+len(g1) >= self._cb_max:
                add_menu(g0, c0, c1)
                g0 = g1
                c0 = c1 = c
            else:
                g0 += g1
                c1 = c
        add_menu(g0, c0, c1)

    def _createSelectMenu(self, games, menu):
        assert isinstance(menu, gtk.Menu)
        self._addPopularGamesMenu(games, menu)
        for l, d in (
            (ltk2gtk('&French games'),   GI.SELECT_GAME_BY_TYPE),
            (ltk2gtk('&Oriental games'), GI.SELECT_ORIENTAL_GAME_BY_TYPE),
            (ltk2gtk('&Special games'),  GI.SELECT_SPECIAL_GAME_BY_TYPE),
                ):
            self._addGamesByType(games, menu, l, d)
        self._addMahjonggGamesMenu(games, menu)
        sep = gtk.SeparatorMenuItem()
        menu.add(sep)
        self._addAllGamesMenu(games, menu)

    #
    # menu updates
    #

    #  WARNING: setMenuState: not found: /menubar/assist/findcard
    def setMenuState(self, state, path):
        path_map = {
            'help.rulesforthisgame': '/menubar/help/rules',
            'options.automaticplay.autodrop':
                '/menubar/options/automaticplay/optautodrop'
            }
        if path in path_map:
            path = path_map[path]
        else:
            path = '/menubar/'+path.replace('.', '/')
        menuitem = self.top.ui_manager.get_widget(path)
        if not menuitem:
            # print 'WARNING: setMenuState: not found:', path
            return
        menuitem.set_sensitive(state)

    def setToolbarState(self, state, path):
        path = '/toolbar/'+path
        button = self.top.ui_manager.get_widget(path)
        if not button:
            print('WARNING: setToolbarState: not found:', path)
        else:
            button.set_sensitive(state)

    #
    # menu actions
    #

    def mAddFavor(self, w):
        gameid = self.app.game.id
        if gameid not in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.append(gameid)
            self.updateFavoriteGamesMenu()

    def mDelFavor(self, w):
        gameid = self.app.game.id
        if gameid in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.remove(gameid)
            self.updateFavoriteGamesMenu()

    def updateFavoriteGamesMenu(self):
        games = self.app.opt.favorite_gameid
        self._updateGamesMenu('/menubar/file/favoritegames', games)
        in_favor = self.app.game.id in games
        item = self.top.ui_manager.get_widget('/menubar/file/addtofavorites')
        item.set_sensitive(not in_favor)
        item = self.top.ui_manager.get_widget(
            '/menubar/file/removefromfavorites')
        item.set_sensitive(in_favor)

    def updateRecentGamesMenu(self, games):
        self._updateGamesMenu('/menubar/file/recentgames', games)

    def updateBookmarkMenuState(self):
        # FIXME
        pass

    def _updateGamesMenu(self, path, games):
        item = self.top.ui_manager.get_widget(path)
        item.show()
        menu = item.get_submenu()
        menu.show()
        #
        menu_games = []

        def checkFavor(item):
            gameid = item.get_data('user_data')
            if gameid in games:
                menu_games.append(gameid)
            else:
                menu.remove(item)
        menu.foreach(checkFavor)
        #
        for gameid in games:
            if gameid not in menu_games:
                gi = self.app.getGameInfo(gameid)
                self._addGamesMenuItem(menu, gi)
        if not games:
            item = gtk.MenuItem(_('Empty'))
            item.show()
            item.set_sensitive(False)
            menu.add(item)

    def _createFileChooser(self, title, action, idir, ifile, stock):
        d = gtk.FileChooserDialog(title, self.top, action,
                                  (stock, gtk.RESPONSE_ACCEPT,
                                   gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL))
        d.set_current_folder(idir)
        if ifile:
            d.set_current_name(ifile)

        filter = gtk.FileFilter()
        filter.set_name('PySol files')
        filter.add_pattern('*.pso')
        d.add_filter(filter)

        filter = gtk.FileFilter()
        filter.set_name('All files')
        filter.add_pattern('*')
        d.add_filter(filter)

        resp = d.run()
        if resp == gtk.RESPONSE_ACCEPT:
            filename = d.get_filename()
        else:
            filename = None
        d.destroy()
        return filename

    def mOpen(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        filename = self.game.filename
        if filename:
            idir, = os.path.split(os.path.normpath(filename))
        else:
            idir = ''
        if not idir:
            idir = self.app.dn.savegames
        filename = self._createFileChooser(_('Open Game'),
                                           gtk.FILE_CHOOSER_ACTION_OPEN,
                                           idir, '',
                                           gtk.STOCK_OPEN)
        if filename:
            # filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            if os.path.isfile(filename):
                self.game.loadGame(filename)

    def mSaveAs(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.menustate.save_as:
            return
        filename = self.game.filename
        if not filename:
            filename = self.app.getGameSaveName(self.game.id)
            if os.name == 'posix' or os.path.supports_unicode_filenames:
                filename += '-' + self.game.getGameNumber(format=0)
            else:
                filename += '-01'
            filename += '.pso'
        idir, ifile = os.path.split(os.path.normpath(filename))
        if not idir:
            idir = self.app.dn.savegames
        # print self.game.filename, ifile
        filename = self._createFileChooser(_('Save Game'),
                                           gtk.FILE_CHOOSER_ACTION_SAVE,
                                           idir, ifile,
                                           gtk.STOCK_SAVE)
        if filename:
            # filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            self.game.saveGame(filename)
            self.updateMenus()

    def mSelectGame(self, menu_item):
        game_id = menu_item.get_data('user_data')
        self._mSelectGame(game_id)

    def mSelectGameDialogWithPreview(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        #  self.game.setCursor(cursor=CURSOR_WATCH)
        bookmark = None
        #  if 0:
        #      # use a bookmark for our preview game
        #      if self.game.setBookmark(-2, confirm=0):
        #          bookmark = self.game.gsaveinfo.bookmarks[-2][0]
        #          del self.game.gsaveinfo.bookmarks[-2]
        # ~ after_idle(self.top, self.__restoreCursor)
        d = SelectGameDialogWithPreview(self.top, title=_('Select game'),
                                        app=self.app, gameid=self.game.id,
                                        bookmark=bookmark)
        if d.status == 0 and d.button == 0 and d.gameid != self.game.id:
            #   self.tkopt.gameid.set(d.gameid)
            #   self.tkopt.gameid_popular.set(d.gameid)
            if 0:
                self._mSelectGame(d.gameid, random=d.random)
            else:
                # don't ask areYouSure()
                self._cancelDrag()
                self.game.endGame()
                self.game.quitGame(d.gameid, random=d.random)

    def mPause(self, *args):
        if not self.game.pause:
            if self._cancelDrag():
                return
        self.game.doPause()

    def mOptSoundDialog(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        SoundOptionsDialog(self.top, _('Sound settings'), self.app)

    def mOptTableTile(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        key = self.app.tabletile_index
        if key <= 0:
            key = self.app.opt.colors['table']
        d = SelectTileDialogWithPreview(self.top, app=self.app,
                                        title=_('Select table background'),
                                        manager=self.app.tabletile_manager,
                                        key=key)
        if d.status == 0 and d.button in (0, 1):
            if isinstance(d.key, str):
                tile = self.app.tabletile_manager.get(0)
                tile.color = d.key
                self.app.setTile(0)
            elif d.key > 0 and d.key != self.app.tabletile_index:
                self.app.setTile(d.key)

    def mSelectCardsetDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        key = self.app.nextgame.cardset.index
        d = SelectCardsetDialogWithPreview(
            self.top, title=_('Select cardset'),
            app=self.app, manager=self.app.cardset_manager, key=key)
        cs = self.app.cardset_manager.get(d.key)
        if cs is None or d.key == self.app.cardset.index:
            return
        if d.status == 0 and d.button in (0, 1) and d.key >= 0:
            self.app.nextgame.cardset = cs
            if d.button == 0:
                self._cancelDrag()
                self.game.endGame(bookmark=1)
                self.game.quitGame(bookmark=1)

    def mOptToggle(self, w, opt_name, update_game):
        # print 'mOptToggle:', opt, w.get_active()
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.__dict__[opt_name] = w.get_active()
        if update_game:
            self.game.endGame(bookmark=1)
            self.game.quitGame(bookmark=1)

    def mOptNegativeBottom(self, w):
        if self._cancelDrag():
            return
        self.app.opt.negative_bottom = w.get_active()
        self.app.updateCardset()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptAnimations(self, w1, w2):
        self.app.opt.animations = w1.get_current_value()

    def mOptMouseType(self, w1, w2):
        v = w1.get_current_value()
        t = ('drag-n-drop', 'point-n-click', 'sticky-mouse')[v]
        self.app.opt.mouse_type = t

    def mOptToolbar(self, w1, w2):
        if self._cancelDrag(break_pause=False):
            return
        side = w1.get_current_value()
        self.app.opt.toolbar = side
        if self.app.toolbar.show(side, resize=1):
            self.top.update_idletasks()

    def mOptStatusbar(self, w):
        if self._cancelDrag(break_pause=False):
            return
        if not self.app.statusbar:
            return
        side = w.get_active()
        self.app.opt.statusbar = side
        resize = not self.app.opt.save_games_geometry
        if self.app.statusbar.show(side, resize=resize):
            self.top.update_idletasks()

    def updateAll(self, *event):
        self.app.canvas.updateAll()

    def _setCommentMenu(self, v):
        # FIXME
        pass

    def _setPauseMenu(self, v):
        # FIXME
        pass

    def mStatus(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.mPlayerStats(mode=100)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# imports
#  import os
#  from six.moves import tkinter
#  import traceback

#  # PySol imports

#  # Toolkit imports
#  from tkutil import after, after_cancel
#  from tkutil import bind, unbind_destroy, makeImage
#  from tkcanvas import MfxCanvas, MfxCanvasGroup, MfxCanvasImage, \
#           MfxCanvasRectangle


# ************************************************************************
# *
# ************************************************************************

find_card_dialog = None


def create_find_card_dialog(parent, game, dir):
    pass


def connect_game_find_card_dialog(game):
    pass


def destroy_find_card_dialog():
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import gtk
import gtk.glade

import pango

from pysollib.mygettext import _

from tkutil import create_pango_font_desc


# ************************************************************************
# *
# ************************************************************************

class FontsDialog:

    def __init__(self, parent, title, app, **kw):
        glade_file = app.dataloader.findFile('pysolfc.glade')
        self.widgets_tree = gtk.glade.XML(glade_file)

        keys = (
            'sans',
            'small',
            'fixed',
            'canvas_default',
            'canvas_fixed',
            'canvas_large',
            'canvas_small',
            )

        for n in keys:
            font = app.opt.fonts[n]
            self._setFont(n, font)
            button = self.widgets_tree.get_widget(n+'_button')
            button.connect('clicked', self._changeFont, n)

        self._translateLabels()

        dialog = self.widgets_tree.get_widget('fonts_dialog')
        self.dialog = dialog
        dialog.set_title(title)
        dialog.set_transient_for(parent)

        self.status = -1
        self.button = -1
        self.fonts = {}
        response = dialog.run()
        if response == gtk.RESPONSE_OK:
            self.status = 0
            self.button = 0
            for n in keys:
                label = self.widgets_tree.get_widget(n+'_label')
                font = label.get_data('user_data')
                self.fonts[n] = font

        dialog.destroy()

    def _setFont(self, name, font):
        label = self.widgets_tree.get_widget(name+'_label')
        font_desc = create_pango_font_desc(font)
        label.modify_font(font_desc)
        text = ' '.join([str(i) for i in font if i not in ('roman', 'normal')])
        label.set_text(text)
        label.set_data('user_data', font)

    def _changeFont(self, w, name):
        label = self.widgets_tree.get_widget(name+'_label')
        font = label.get_data('user_data')
        dialog = gtk.FontSelectionDialog(_('Select color'))
        dialog.set_transient_for(self.dialog)
        dialog.set_position(gtk.WIN_POS_CENTER_ON_PARENT)
        font_name = font[0]
        bi = []
        if 'bold' in font:
            bi.append('bold')
        if 'italic' in font:
            bi.append('italic')
        if bi:
            bi = ' '.join(bi)
            font_name += ', '+bi
        font_name += ' '+str(font[1])
        dialog.fontsel.set_font_name(font_name)
        response = dialog.run()
        if response == gtk.RESPONSE_OK:
            font = dialog.fontsel.get_font_name()
            fd = pango.FontDescription(font)
            family = fd.get_family()
            size = fd.get_size()/pango.SCALE
            style = ('roman' if fd.get_style() == pango.STYLE_NORMAL
                     else 'italic')
            weight = ('normal' if fd.get_weight() == pango.WEIGHT_NORMAL
                      else 'bold')
            font = (family, size, style, weight)
            self._setFont(name, font)

        dialog.destroy()

    def _translateLabels(self):
        for n in (
            'label54',
            'label55',
            'label56',
            'label57',
            'label58',
            'label59',
            'label60',
            'label69',
            'label70',
            'label71',
            'label72',
            'label73',
            'label74',
            'label75',
                ):
            w = self.widgets_tree.get_widget(n)
            w.set_text(_(w.get_text()))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------


# imports
import gtk

# PySol imports
from pysollib.acard import AbstractCard

# Toolkit imports
from tkcanvas import MfxCanvasGroup, MfxCanvasImage


# ************************************************************************
# *
# ************************************************************************

class _HideableCard(AbstractCard):
    def hide(self, stack):
        if stack is self.hide_stack:
            return
        self.item.hide()
        self.hide_stack = stack

    def unhide(self):
        if self.hide_stack is None:
            return 0
        self.item.show()
        self.hide_stack = None
        return 1


# ************************************************************************
# *
# ************************************************************************

class _OneImageCard(_HideableCard):
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        images = game.app.images
        self.__face_image = images.getFace(deck, suit, rank)
        self.__back_image = images.getBack()
        self.__image = MfxCanvasImage(game.canvas, self.x, self.y,
                                      image=self.__back_image,
                                      anchor=gtk.ANCHOR_NW)
        if 0:
            # using a group for a single image doesn't gain much
            self.item = MfxCanvasGroup(game.canvas)
            self.__image.addtag(self.item)
        else:
            self.item = self.__image

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__image.config(image=self.__face_image)
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__image.config(image=self.__back_image)
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back_image = image
        if not self.face_up:
            self.__image.config(image=image)


# ************************************************************************
# *
# ************************************************************************

class _TwoImageCard(_HideableCard):
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        images = game.app.images
        self.item = MfxCanvasGroup(game.canvas)
        self.__face = MfxCanvasImage(game.canvas, self.x, self.y,
                                     image=images.getFace(deck, suit, rank),
                                     anchor='nw')
        self.__back = MfxCanvasImage(game.canvas, self.x, self.y,
                                     image=images.getBack(),
                                     anchor='nw')
        self.__face.addtag(self.item)
        self.__back.addtag(self.item)
        self.__face.hide()

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__back.hide()
            self.__face.show()
            # self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__face.hide()
            self.__back.show()
            # self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back.config(image=image)


# choose the implementation
Card = _TwoImageCard
# Card = _OneImageCard # FIXME this implementation lost any cards (bug?)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


import gobject

import gtk
from gtk import gdk

from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _

from pysoltree import PysolTreeView

from tkcanvas import MfxCanvas

from tkutil import setTransient

from tkwidget import MfxDialog


class SelectTileDialogWithPreview(MfxDialog):

    def __init__(self, parent, title, app, manager, key=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, **kw)
        #
        top_box, bottom_box = self.createHBox()
        #
        if key is None:
            key = manager.getSelected()
        self.app = app
        self.manager = manager
        self.key = key
        self.preview_key = -1
        self.all_keys = []
        self.table_color = app.opt.colors['table']
        # paned
        hpaned = gtk.HPaned()
        self.hpaned = hpaned
        hpaned.show()
        top_box.pack_start(hpaned, expand=True, fill=True)
        #
        model = self._createStore(manager, key)
        treeview = PysolTreeView(self, model)
        self.treeview = treeview
        hpaned.pack1(treeview.scrolledwindow, True, True)
        treeview.treeview.expand_all()
        #
        self.preview = MfxCanvas(top_box)  # width=w2
        hpaned.pack2(self.preview, True, True)
        self.preview.show()
        hpaned.set_position(240)

        self.createButtons(bottom_box, kw)

        self.updatePreview(key)

        self.show_all()
        gtk.main()

    def rowActivated(self, w, row, col):
        # FIXME
        print('row-activated-event', row, col)

    def getSelected(self):
        index = self.treeview.getSelected()
        if index < 0:
            return None
        return self.all_keys[index]

    def showSelected(self, w):
        key = self.getSelected()
        self.updatePreview(key)

    def _createStore(self, manager, key):
        self.all_keys = []
        index = 0
        #
        model = gtk.TreeStore(gobject.TYPE_STRING,
                              gobject.TYPE_INT)
        #
        iter = model.append(None)
        model.set(iter, 0, _('Solid color'), 1, -1)
        for color, value in ((_('Blue'),   '#0082df'),
                             (_('Green'),  '#008200'),
                             (_('Navy'),   '#000086'),
                             (_('Olive'),  '#868200'),
                             (_('Orange'), '#f79600'),
                             (_('Teal'),   '#008286'),):
            child_iter = model.append(iter)
            model.set(child_iter, 0, color, 1, index)
            self.all_keys.append(value)
            index += 1
        #
        tiles = manager.getAllSortedByName()
        tiles = [obj for obj in tiles if not obj.error]
        tiles = [tile for tile in tiles if tile.index > 0 and tile.filename]
        #
        iter = model.append(None)
        model.set(iter, 0, _('All Backgrounds'), 1, -1)
        if tiles:
            for tile in tiles:
                child_iter = model.append(iter)
                model.set(child_iter, 0, tile.name, 1, index)
                self.all_keys.append(tile.index)
                index += 1
        else:
            child_iter = model.append(iter)
            model.set(child_iter, 0, _('(no tiles)'), 1, -1)

        return model

    def updatePreview(self, key):
        # print 'updatePreview:', key, type(key)
        if key is None:
            return
        if key == self.preview_key:
            return
        canvas = self.preview
        # canvas.deleteAllItems()
        if isinstance(key, str):
            # solid color
            canvas.setTile(self.app, 0, force=True)
            canvas.config(bg=key)
            # canvas.setTextColor(None)
            self.preview_key = key
            self.table_color = key
        else:
            # image
            if self.preview.setTile(self.app, key):
                self.preview_key = key
            else:
                self.preview_key = -1

    def initKw(self, kw):
        kwdefault(kw,
                  strings=(_('&OK'), _('&Solid color...'), _('&Cancel'),),
                  default=0,
                  resizable=1,
                  padx=10, pady=10,
                  width=600, height=400,
                  )
        return MfxDialog.initKw(self, kw)

    def _colorselOkClicked(self, w, d):
        c = d.colorsel.get_current_color()
        c = '#%02x%02x%02x' % (c.red//256, c.green//256, c.blue//256)
        d.destroy()
        self.updatePreview(c)
        self.treeview.unselectAll()

    def createColorsel(self):
        win = gtk.ColorSelectionDialog(_('Select table color'))
        win.help_button.destroy()
        win.set_position(gtk.WIN_POS_CENTER_ON_PARENT)
        if isinstance(self.preview_key, str):
            color = self.preview_key
        else:
            color = self.app.opt.colors['table']
        win.colorsel.set_current_color(gdk.color_parse(color))
        win.connect('delete_event', lambda w, e: win.destroy())
        win.ok_button.connect('clicked', self._colorselOkClicked, win)
        win.cancel_button.connect('clicked', lambda w: win.destroy())
        setTransient(win, self)
        win.show()

    def done(self, button):
        b = button.get_data('user_data')
        if b == 1:
            self.createColorsel()
            return
        if b == 0:
            self.key = self.getSelected()
            if not self.key:
                self.key = self.preview_key
        self.status = 0
        self.button = b
        # self.hide()
        self.quit()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


# imports
import os
import sys

import gtk
from gtk import gdk

# Toolkit imports
from tkutil import makeToplevel, setTransient


# ************************************************************************
# * a simple progress bar
# ************************************************************************

class PysolProgressBar:
    def __init__(self, app, parent, title=None, images=None,
                 color='blue', bg='#c0c0c0',
                 height=25, show_text=1, norm=1):
        self.parent = parent
        self.percent = 0
        self.steps_sum = 0
        self.norm = norm
        self.top = makeToplevel(parent, title=title)
        self.top.set_position(gtk.WIN_POS_CENTER)
        self.top.set_resizable(False)
        self.top.connect("delete_event", self.wmDeleteWindow)

        # hbox
        hbox = gtk.HBox(spacing=5)
        hbox.set_border_width(10)
        hbox.show()
        self.top.table.attach(hbox,
                              0, 1, 0, 1,
                              0,    0,
                              0,    0)
        # hbox-1: image
        if images and images[0]:
            im = gtk.Image()
            im.set_from_pixbuf(images[0].pixbuf)
            hbox.pack_start(im, expand=False, fill=False)
            im.show()
            im.set_property('xpad', 10)
            im.set_property('ypad', 5)
        # hbox-2:vbox
        vbox = gtk.VBox()
        vbox.show()
        hbox.pack_start(vbox, False, False)
        # hbox-2:vbox:pbar
        self.pbar = gtk.ProgressBar()
        self.pbar.show()
        vbox.pack_start(self.pbar, True, False)
        self.pbar.realize()
        # ~ self.pbar.set_show_text(show_text)
        self.pbar.set_text(str(show_text)+'%')
        w, h = self.pbar.size_request()
        self.pbar.set_size_request(max(w, 300), max(h, height))
        # hbox-3:image
        if images and images[1]:
            im = gtk.Image()
            im.set_from_pixbuf(images[1].pixbuf)
            hbox.pack_end(im, expand=False)
            im.show()
            im.set_property('xpad', 10)
            im.set_property('ypad', 5)

        setTransient(self.top, parent)
        self.top.show()
        self.top.window.set_cursor(gdk.Cursor(gdk.WATCH))
        self.update(percent=0)

    def destroy(self):
        self.top.destroy()

    def pack(self):
        pass

    def update(self, percent=None, step=1):
        # self.steps_sum += step
        # print self.steps_sum, self.norm
        step /= self.norm
        if percent is None:
            self.percent += step
        elif percent > self.percent:
            self.percent = percent
        percent = int(self.percent)
        percent = min(100, max(0, percent))
        self.pbar.set_fraction(percent / 100.0)
        self.pbar.set_text(str(percent)+'%')
        self.update_idletasks()

    def reset(self, percent=0):
        self.percent = percent

    def update_idletasks(self):
        while gtk.events_pending():
            gtk.main_iteration()

    def wmDeleteWindow(self, *args):
        return True


# ************************************************************************
# *
# ************************************************************************

# %ifndef BUNDLE

class TestProgressBar:
    def __init__(self, parent, images=None):
        self.parent = parent
        self.progress = PysolProgressBar(None, parent, title="Progress",
                                         images=images, color='#008200')
        self.progress.pack()
        self.func = [self.update, 0]
        # self.func[1] = timeout_add(30, self.func[0])

    def update(self, *args):
        if self.progress.percent >= 100:
            self.progress.destroy()
            # mainquit()
            return False
        self.progress.update(step=1)
        return True


def progressbar_main(args):
    root = gtk.Window()
    # root.connect("destroy", mainquit)
    # root.connect("delete_event", mainquit)
    images = None
    if 1:
        from tkwrap import loadImage
        im = loadImage(os.path.join(
            os.pardir, os.pardir, 'data', 'images', 'jokers',
            'joker07_40_774.gif'))
        images = (im, im)
    TestProgressBar(root, images=images)
    # main()
    return 0


if __name__ == '__main__':
    sys.exit(progressbar_main(sys.argv))

# %endif
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import gtk

from pysollib.mfxutil import KwStruct, kwdefault, openURL
from pysollib.mygettext import _

from tkutil import setTransient

gdk = gtk.gdk
# ************************************************************************
# *
# ************************************************************************


class _MyDialog(gtk.Dialog):
    def __init__(self):
        gtk.Dialog.__init__(self)
        self.connect("destroy", self.quit)
        self.connect("delete_event", self.quit)

    def __setattr__(self, name, value):
        self.__dict__[name] = value

    def quit(self, *args):
        self.status = 0
        self.hide()
        self.destroy()
        gtk.main_quit()


class MfxDialog(_MyDialog):
    img = {}
    button_img = {}

    def __init__(self, parent, title='',
                 timeout=0,
                 resizable=0,
                 width=-1, height=-1,
                 text='', justify='center',
                 strings=("OK",), default=0,
                 separator=False,
                 padx=20, pady=20,
                 bitmap=None, bitmap_side='left',
                 bitmap_padx=20, bitmap_pady=20,
                 image=None, image_side='left',
                 image_padx=10, image_pady=20,
                 **kw):
        _MyDialog.__init__(self)
        self.status = 1
        self.button = -1
        self.buttons = []

        modal = True
        if modal:
            setTransient(self, parent)

        # settings
        if width > 0 or height > 0:
            self.set_size_request(width, height)
            # self.window.resize(width, height)
        self.set_title(title)
        #
        self.connect('key-press-event', self._keyPressEvent)

    def createBox(self, widget_class=gtk.HBox):
        box = widget_class(spacing=5)
        box.set_border_width(5)
        self.vbox.pack_start(box)
        box.show()
        return box, self.action_area

    createHBox = createBox

    def createVBox(self):
        return self.createBox(widget_class=gtk.VBox)

    def createTable(self):
        # FIXME
        return self.createBox(widget_class=gtk.Table)

    def createBitmaps(self, box, kw):
        if kw['bitmap']:
            stock = {"info":     gtk.STOCK_DIALOG_INFO,
                     "error":    gtk.STOCK_DIALOG_ERROR,
                     "warning":  gtk.STOCK_DIALOG_WARNING,
                     "question": gtk.STOCK_DIALOG_QUESTION}[kw['bitmap']]
            im = gtk.image_new_from_stock(stock, gtk.ICON_SIZE_DIALOG)
            box.pack_start(im)
            im.set_property('xpad', kw['bitmap_padx'])
            im.set_property('ypad', kw['bitmap_pady'])
            im.show()
        elif kw['image']:
            im = gtk.Image()
            im.set_from_pixbuf(kw['image'].pixbuf)
            if kw['image_side'] == 'left':
                box.pack_start(im)
            else:
                box.pack_end(im)
            im.set_property('xpad', kw['image_padx'])
            im.set_property('ypad', kw['image_pady'])
            im.show()

    def createButtons(self, box, kw):
        strings, default = kw['strings'], kw['default']
        for i in range(len(strings)):
            text = strings[i]
            if not text:
                continue
            if isinstance(text, (list, tuple)):
                text, index = text
            else:  # str
                index = i
            text = text.replace('&', '_')
            b = gtk.Button(text)
            b.set_property('can-default', True)
            if index == default:
                b.grab_focus()
                # b.grab_default()
            b.set_data("user_data", index)
            b.connect("clicked", self.done)
            box.pack_start(b)
            b.show()
            self.buttons.append(b)

    def initKw(self, kw):
        kwdefault(kw,
                  timeout=0, resizable=0,
                  text="", justify="center",
                  strings=(_("&OK"),),
                  default=0,
                  width=0,
                  padx=20, pady=20,
                  bitmap=None, bitmap_side="left",
                  bitmap_padx=10, bitmap_pady=20,
                  image=None, image_side="left",
                  image_padx=10, image_pady=20,
                  )
        #  # default to separator if more than one button
        #  sw = len(kw.strings) > 1
        #  kwdefault(kw.__dict__, separator=sw)
        return kw

    def done(self, button):
        self.status = 0
        self.button = button.get_data("user_data")
        self.quit()

    def _keyPressEvent(self, w, e):
        if gdk.keyval_name(e.keyval) == 'Escape':
            self.quit()


class MfxMessageDialog(MfxDialog):
    def __init__(self, parent, title, **kw):
        # print 'MfxMessageDialog', kw
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, **kw)

        top_box, bottom_box = self.createBox()
        self.createBitmaps(top_box, kw)

        label = gtk.Label(kw['text'])
        label.set_justify(gtk.JUSTIFY_CENTER)
        label.set_property('xpad', kw['padx'])
        label.set_property('ypad', kw['pady'])
        top_box.pack_start(label)

        self.createButtons(bottom_box, kw)

        label.show()
        self.set_position(gtk.WIN_POS_CENTER_ON_PARENT)
        # self.set_position(gtk.WIN_POS_CENTER)

        self.show_all()
        gtk.main()

    def initKw(self, kw):
        # if kw.has_key('bitmap'):
        #    kwdefault(kw, width=250, height=150)
        return MfxDialog.initKw(self, kw)


# ************************************************************************
# *
# ************************************************************************

class PysolAboutDialog(MfxDialog):
    def __init__(self, app, parent, title, **kw):
        self._url = kw['url']
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, **kw)

        top_box, bottom_box = self.createBox()
        self.createBitmaps(top_box, kw)

        box = gtk.VBox()
        box.set_property('border-width', 20)
        top_box.pack_start(box)

        label = gtk.Label(kw['text'])
        label.set_justify(gtk.JUSTIFY_CENTER)
        box.pack_start(label)

        url_label = gtk.Label()
        url_label.set_justify(gtk.JUSTIFY_CENTER)
        url_label.set_markup(
            '<span foreground="blue" underline="single">%s</span>' % kw['url'])

        event_box = gtk.EventBox()
        box.pack_start(event_box)
        event_box.connect('button-press-event', self._urlClicked)
        event_box.add(url_label)

        self.createButtons(bottom_box, kw)

        self.set_position(gtk.WIN_POS_CENTER_ON_PARENT)
        # self.set_position(gtk.WIN_POS_CENTER)

        self.show_all()
        event_box.window.set_cursor(gdk.Cursor(gdk.HAND2))
        gtk.main()

    def initKw(self, kw):
        # if kw.has_key('bitmap'):
        #    kwdefault(kw, width=250, height=150)
        return MfxDialog.initKw(self, kw)

    def _urlClicked(self, *args):
        openURL(self._url)


# ************************************************************************
# *
# ************************************************************************

class MfxExceptionDialog(MfxDialog):
    def __init__(self, parent, ex, title="Error", **kw):
        kw = KwStruct(kw, bitmap="error")
        text = str(kw.get("text", ""))
        if text and text[-1] != "\n":
            text = text + "\n"
        text = text + "\n"
        if isinstance(ex, EnvironmentError) and ex.filename is not None:
            t = '[Errno %s] %s:\n%s' % \
                (ex.errno, ex.strerror, repr(ex.filename))
        else:
            t = str(ex)
        kw.text = text + t
        MfxDialog.__init__(self, parent, title, **kw.__dict__)


# ************************************************************************
# *
# ************************************************************************

class MfxSimpleEntry(_MyDialog):
    def __init__(self, parent, title, label, value, resizable=0, **kw):
        _MyDialog.__init__(self)
        self.button = 0
        self.status = 1
        self.value = value
        self.init(parent, label, True)
        self.entry.set_text(str(value))
        self.set_title(title)
        self.show()
        gtk.main()

    def init(self, parent,  message="", modal=True):
        if modal:
            setTransient(self, parent)
        box = gtk.VBox(spacing=10)
        box.set_border_width(10)
        self.vbox.pack_start(box)
        box.show()
        if message:
            label = gtk.Label(message)
            box.pack_start(label)
            label.show()
        self.entry = gtk.Entry()
        box.pack_start(self.entry)
        self.entry.show()
        self.entry.grab_focus()
        button = gtk.Button("OK")
        button.connect("clicked", self.done)
        button.set_flags(gtk.CAN_DEFAULT)
        self.action_area.pack_start(button)
        button.show()
        button.grab_default()
        button = gtk.Button("Cancel")
        button.connect("clicked", self.quit)
        button.set_flags(gtk.CAN_DEFAULT)
        self.action_area.pack_start(button)
        button.show()

    def done(self, button):
        self.status = 0
        self.value = self.entry.get_text()
        self.quit()


class SelectDialogTreeData:
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


#  # imports
#  import os, sys
#  from six.moves import tkinter

#  # PySol imports
#  from pysollib.mfxutil import KwStruct
#  from pysollib.gamedb import GI

# Toolkit imports
from tkwidget import MfxDialog

# ************************************************************************
# *
# ************************************************************************


class GameInfoDialog(MfxDialog):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# imports

# PySol imports

# Toolkit imports
from tkwidget import MfxDialog

# ************************************************************************
# *
# ************************************************************************


class EditTextDialog(MfxDialog):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------


# imports
import time

import gtk
from gtk import gdk

# PySol imports
#  from pysollib.images import Images
from pysollib.settings import TITLE, VERSION

# Toolkit imports
from tkutil import makeToplevel


# ************************************************************************
# *
# ************************************************************************

class TclError:
    pass


def make_help_toplevel(parent, title=None, class_=None):
    return makeToplevel(
        parent, title=title, class_=class_, gtkclass=_MfxToplevel)


# ************************************************************************
# * A toplevel window.
# ************************************************************************

class _MfxToplevel(gtk.Window):
    def __init__(self, *args, **kw):
        gtk.Window.__init__(self, type=gtk.WINDOW_TOPLEVEL)
        # self.vbox = gtk.VBox()
        # self.vbox.show()
        # self.add(self.vbox)
        self.table = gtk.Table(3, 6, False)
        self.add(self.table)
        self.connect('destroy', self.mainquit)
        self.table.show()
        self.realize()

    def cget(self, attr):
        if attr == 'cursor':
            # FIXME
            return gdk.LEFT_PTR
            # return self.get_window().get_cursor(v)
        elif attr in ("background", "bg"):
            c = self.style.bg[gtk.STATE_NORMAL]
            c = '#%02x%02x%02x' % (c.red//256, c.green//256, c.blue//256)
            return c
        print("Toplevel cget:", attr)
        # ~ raise AttributeError, attr
        return None

    def configure(self, **kw):
        height, width = -1, -1
        for k, v in kw.items():
            if k in ("background", "bg"):
                # print "Toplevel configure: bg"
                pass
            elif k == "cursor":
                self.setCursor(v)
            elif k == "height":
                height = v
            elif k == "width":
                width = v
            else:
                print("Toplevel configure:", k, v)
                raise AttributeError(k)
        if height > 0 and width > 0:
            # print 'configure: size:', width, height
            #  FIXME
            # self.set_default_size(width, height)
            # self.set_size_request(width, height)
            # self.set_geometry_hints(base_width=width, base_height=height)
            pass

    config = configure

    def mainloop(self):
        gtk.main()      # the global function

    def mainquit(self, *args):
        gtk.main_quit()      # the global function

    def screenshot(self, filename):
        pass

    def setCursor(self, cursor):
        # self.get_window().set_cursor(cursor_new(v))
        pass

    def tk_setPalette(self, *args):
        # FIXME ?
        pass

    def update(self):
        self.update_idletasks()

    def update_idletasks(self):
        # print '_MfxToplevel.update_idletasks'
        while gtk.events_pending():
            gtk.main_iteration(True)

    def winfo_ismapped(self):
        # FIXME
        return 1

    def winfo_screenwidth(self):
        return gdk.screen_width()

    def winfo_screenheight(self):
        return gdk.screen_height()

    def winfo_screendepth(self):
        # print 'winfo_screendepth', self.window.get_geometry()
        return self.window.get_geometry()[-1]

    def wm_command(self, *args):
        # FIXME
        pass

    def wm_deiconify(self):
        self.present()

    def wm_geometry(self, newGeometry=None):
        # print 'wm_geometry', newGeometry
        if not newGeometry:
            pass
            # self.reshow_with_initial_size()
            # self.resize(1, 1)
        else:
            pass
            # w, h = newGeometry
            # self.resize(w, h)

    def wm_group(self, pathName=None):
        # FIXME
        pass

    def wm_iconbitmap(self, name):
        pass

    def wm_iconname(self, name):
        pass
        # ~ self.set_icon_name(name)

    def wm_minsize(self, width, height):
        pass
        # ~ self.set_geometry_hints(min_width=width, min_height=height)

    def wm_title(self, title):
        self.set_title(title)

    def tkraise(self):
        self.present()

    def option_add(self, *args):
        # print self, 'option_add'
        pass

    def option_get(self, *args):
        if args and args[0] == 'font':
            return self.get_style().font_desc.to_string()
        print('_MfxToplevel: option_get', args)
        return None

    def grid_columnconfigure(self, *args, **kw):
        # print self, 'grid_columnconfigure'
        pass

    def grid_rowconfigure(self, *args, **kw):
        # print self, 'grid_rowconfigure'
        pass

    def interruptSleep(self, *args, **kw):
        # print self, 'interruptSleep'
        pass

    def wm_state(self):
        # print self, 'wm_state'
        pass


# ************************************************************************
# * The root toplevel window of an application.
# ************************************************************************

class MfxRoot(_MfxToplevel):
    def __init__(self, **kw):
        _MfxToplevel.__init__(self, **kw)
        self.app = None
        self.connect("delete_event", self.wmDeleteWindow)

    def connectApp(self, app):
        self.app = app

    def initToolkit(self, app, fg=None, bg=None, font=None, theme=None):
        sw, sh = self.winfo_screenwidth(), self.winfo_screenheight()
        # self.wm_group(self)
        self.wm_title(TITLE + ' ' + VERSION)
        # self.wm_iconname(TITLE + ' ' + VERSION)
        if sw < 640 or sh < 480:
            self.wm_minsize(400, 300)
        else:
            self.wm_minsize(520, 360)
        # self.self.wm_maxsize(9999, 9999) # unlimited

    # sometimes an update() is needed under Windows, whereas
    # under Unix an update_idletask() would be enough...
    def busyUpdate(self):
        game = None
        if self.app:
            game = self.app.game
        if not game:
            self.update()
        elif not game.busy:
            game.busy = 1
            self.update()
            game.busy = 0

    # FIXME - make sleep interruptible
    def sleep(self, seconds):
        gdk.window_process_all_updates()
        time.sleep(seconds)

    def wmDeleteWindow(self, *args):
        if self.app and self.app.menubar:
            self.app.menubar.mQuit()
        else:
            # self.after_idle(self.quit)
            pass
        return True
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os

import gobject

import gtk

from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.resource import CSI

from pysoltree import PysolTreeView

from tkcanvas import MfxCanvas, MfxCanvasImage

from tkutil import loadImage

from tkwidget import MfxDialog


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectCardsetDialogWithPreview(MfxDialog):
    _cardset_store = None

    def __init__(self, parent, title, app, manager, key=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, **kw)
        #
        top_box, bottom_box = self.createHBox()
        #
        if key is None:
            key = manager.getSelected()
        self.app = app
        self.manager = manager
        self.key = key
        self.preview_key = -1
        self.all_keys = []

        if self._cardset_store is None:
            self._createStore()

        # padx, pady = kw.padx, kw.pady
        # left
        # paned
        hpaned = gtk.HPaned()
        self.hpaned = hpaned
        hpaned.show()
        top_box.pack_start(hpaned, expand=True, fill=True)
        # tree
        treeview = PysolTreeView(self, self._cardset_store)
        self.treeview = treeview
        hpaned.pack1(treeview.scrolledwindow, True, True)
        # treeview.treeview.expand_all()
        # right
        sw = gtk.ScrolledWindow()
        sw.show()
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        hpaned.pack2(sw, True, True)
        # self.scrolledwindow = sw
        #
        self.preview = MfxCanvas(self)
        self.preview.show()
        sw.add(self.preview)
        # hpaned.pack2(self.preview, True, True)
        self.preview.setTile(app, app.tabletile_index, force=True)
        #
        hpaned.set_position(240)

        self.createButtons(bottom_box, kw)

        # ~self.updatePreview(key)

        self.show_all()
        gtk.main()

    def _selectCardset(self, all_cardsets, selecter):
        if selecter is None:
            return [(cs.index, cs.name) for cs in all_cardsets]
        return [(cs.index, cs.name) for cs in all_cardsets if selecter(cs)]

    def _addCardsets(self, store, root_iter, root_label, cardsets):
        iter = store.append(root_iter)
        store.set(iter, 0, root_label, 1, -1)
        for index, name in cardsets:
            child_iter = store.append(iter)
            # ~ name = _(name)
            store.set(child_iter, 0, name, 1, index)

    def _addCardsetsByType(self, store, root_label, all_cardsets,
                           cardset_types, selecter_type, registered):
        manager = self.manager
        root_iter = store.append(None)
        store.set(root_iter, 0, root_label, 1, -1)
        items = cardset_types.items()
        items.sort(key=lambda x: x[1])
        added = False
        for key, label in items:
            if key not in getattr(manager, registered):
                continue
            cardsets = []
            for cs in all_cardsets:
                si = getattr(cs.si, selecter_type)
                if isinstance(si, int):  # type
                    if key == si:
                        cardsets.append((cs.index, cs.name))
                else:  # style, nationality, date
                    if key in si:
                        cardsets.append((cs.index, cs.name))
            if cardsets:
                added = True
                self._addCardsets(store, root_iter, label, cardsets)
        if added:
            def selecter(cs, selecter_type=selecter_type):
                return getattr(cs.si, selecter_type)
            cs = self._selectCardset(all_cardsets, selecter)
            if cs:
                self._addCardsets(store, root_iter, _('Uncategorized'), cs)
        else:
            iter = store.append(root_iter)
            store.set(iter, 0, _('(no cardsets)'), 1, -1)

    def _createStore(self):
        store = gtk.TreeStore(gobject.TYPE_STRING,
                              gobject.TYPE_INT)
        manager = self.manager
        all_cardsets = manager.getAllSortedByName()
        all_cardsets = [obj for obj in all_cardsets if not obj.error]

        cs = self._selectCardset(all_cardsets, None)
        self._addCardsets(store, None, 'All cadsets', cs)

        root_iter = store.append(None)
        store.set(root_iter, 0, _('by Size'), 1, -1)
        for label, selecter in (
            (_("Tiny cardsets"), lambda cs: cs.si.size == CSI.SIZE_TINY),
            (_("Small cardsets"), lambda cs: cs.si.size == CSI.SIZE_SMALL),
            (_("Medium cardsets"), lambda cs: cs.si.size == CSI.SIZE_MEDIUM),
            (_("Large cardsets"), lambda cs: cs.si.size == CSI.SIZE_LARGE),
            (_("XLarge cardsets"), lambda cs: cs.si.size == CSI.SIZE_XLARGE),
                ):
            cs = self._selectCardset(all_cardsets, selecter)
            if cs:
                self._addCardsets(store, root_iter, label, cs)

        self._addCardsetsByType(store, _('by Type'), all_cardsets,
                                CSI.TYPE, 'type', 'registered_types')
        self._addCardsetsByType(store, _('by Style'), all_cardsets,
                                CSI.STYLE, 'styles', 'registered_styles')
        self._addCardsetsByType(store, _('by Nationality'), all_cardsets,
                                CSI.NATIONALITY, 'nationalities',
                                'registered_nationalities')
        self._addCardsetsByType(store, _('by Date'), all_cardsets,
                                CSI.DATE, 'dates', 'registered_dates')

        self._cardset_store = store

    def getSelected(self):
        index = self.treeview.getSelected()
        if index < 0:
            return None
        return index

    def showSelected(self, w):
        key = self.getSelected()
        if key is not None:
            self.updatePreview(key)
        pass

    def updatePreview(self, key):
        if key == self.preview_key:
            return
        canvas = self.preview
        canvas.deleteAllItems()
        self.preview_images = []
        cs = self.manager.get(key)
        if not cs:
            self.preview_key = -1
            return
        names, columns = cs.getPreviewCardNames()
        try:
            # ???names, columns = cs.getPreviewCardNames()
            for n in names:
                f = os.path.join(cs.dir, n + cs.ext)
                self.preview_images.append(loadImage(file=f))
        except Exception:
            self.preview_key = -1
            self.preview_images = []
            return
        i, x, y, sx, sy, dx, dy = 0, 10, 10, 0, 0, cs.CARDW + 10, cs.CARDH + 10
        for image in self.preview_images:
            MfxCanvasImage(canvas, x, y, anchor="nw", image=image)
            sx, sy = max(x, sx), max(y, sy)
            i += 1
            if i % columns == 0:
                x, y = 10, y + dy
            else:
                x += dx
        canvas.config(width=sx+dx, height=sy+dy)
        canvas.set_scroll_region(0, 0, sx+dx, sy+dy)
        self.preview_key = key

    def initKw(self, kw):
        kwdefault(kw,
                  strings=(_("&Load"), _("&Cancel"), _("&Info..."),),
                  default=1,
                  resizable=1,
                  padx=10, pady=10,
                  width=600, height=400,
                  )
        return MfxDialog.initKw(self, kw)

    def createInfo(self):
        pass

    def done(self, button):
        b = button.get_data('user_data')
        if b == 2:
            self.createInfo()
            return
        if b == 0:
            self.key = self.getSelected()
            if not self.key:
                self.key = self.preview_key
        self.status = 0
        self.button = b
        self.hide()
        self.quit()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


# imports
# import sys

from gtk import gdk

# ************************************************************************
# * constants
# ************************************************************************

EVENT_HANDLED = 1
EVENT_PROPAGATE = 0

CURSOR_DRAG = gdk.HAND1
CURSOR_WATCH = gdk.WATCH
CURSOR_DOWN_ARROW = gdk.SB_DOWN_ARROW

TOOLBAR_BUTTONS = (
    "new",
    "restart",
    "open",
    "save",
    "undo",
    "redo",
    "autodrop",
    "shuffle",
    "pause",
    "statistics",
    "rules",
    "quit",
    "player",
    )
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import string

import gobject

import gtk
from gtk import gdk

import pango


# ************************************************************************
# * window util
# ************************************************************************

def wm_withdraw(window):
    window.hide()


def wm_deiconify(window):
    window.present()


def wm_map(window, maximized=None):
    window.show()


def makeToplevel(parent, title=None, class_=None, gtkclass=gtk.Window):
    window = gtkclass()
    if not hasattr(window, 'table'):
        window.table = gtk.Table(1, 4, False)
        window.table.show()
        window.add(window.table)
    window.realize()        # needed for set_icon_name()
    if title:
        window.set_title(title)
        # ~ window.set_icon_name(title)
    if class_:
        #  window.set_wmclass(???)      #  FIXME
        pass
    return window


def setTransient(window, parent, relx=0.5, rely=0.3, expose=1):
    window.realize()
    # ~ grab_add(window)
    if parent:
        window.set_transient_for(parent)
    if expose:
        # window.unmap()          # Become visible at the desired location
        pass


# ************************************************************************
# * conversion util
# ************************************************************************

def anchor_tk2gtk(anchor):
    if isinstance(anchor, int):
        assert 0 <= anchor <= 8
        return anchor
    if isinstance(anchor, str):
        a = ['center', 'n', 'nw', 'ne', 's', 'sw', 'se', 'w', 'e']
        return a.index(string.lower(anchor))
    assert 0


def color_tk2gtk(col):
    r = string.atoi(col[1:3], 16) / 255.0
    g = string.atoi(col[3:5], 16) / 255.0
    b = string.atoi(col[5:7], 16) / 255.0
    return (r, g, b, 1.0)


def color_gtk2tk(col):
    r = int(round(col[0] * 255.0))
    g = int(round(col[1] * 255.0))
    b = int(round(col[2] * 255.0))
    return "#%02x%02x%02x" % (r, g, b)


# ************************************************************************
# * image util
# ************************************************************************


class _PysolPixmap:
    def __init__(self, file=None, pixbuf=None, width=0, height=0,
                 fill=None, outline=None):
        if file:
            self.pixbuf = gdk.pixbuf_new_from_file(file)
        elif pixbuf:
            self.pixbuf = pixbuf
        else:
            self.pixbuf = gdk.Pixbuf(gdk.COLORSPACE_RGB,
                                     True, 8, width, height)
            if fill:
                c = gdk.color_parse(fill)
                c = '%02x%02x%02xffL' % (c.red, c.green, c.blue)
                self.pixbuf.fill(int(c, 16))
            else:
                self.pixbuf.fill(0)
            if outline:
                # FIXME
                pass

    def clone(self):
        pixbuf = self.pixbuf.copy()
        im = _PysolPixmap(pixbuf=pixbuf)
        return im

    def width(self):
        return self.pixbuf.get_width()

    def height(self):
        return self.pixbuf.get_height()

    def subsample(self, r):
        w, h = self.pixbuf.get_width(), self.pixbuf.get_height()
        w, h = int(float(w)/r), int(float(h)/r)
        pixbuf = self.pixbuf.scale_simple(w, h, gdk.INTERP_BILINEAR)
        im = _PysolPixmap(pixbuf=pixbuf)
        return im


def loadImage(file):
    return _PysolPixmap(file=file)


def copyImage(image, x, y, width, height):
    # FIXME
    return image.clone()


def createImage(width, height, fill, outline=None):
    # FIXME
    return _PysolPixmap(width=width, height=height, fill=fill, outline=outline)


def shadowImage(image):
    # FIXME
    return None


def markImage(image):
    # FIXME
    return image


# ************************************************************************
# * event wrapper
# * this really sucks, need something better...
# ************************************************************************

def _wrap_b1_press(e):
    return (e.type == gdk.BUTTON_PRESS and e.button == 1 and
            not (e.state & gdk.CONTROL_MASK) and
            not (e.state & gdk.SHIFT_MASK))


def _wrap_b1_double(e):
    return e.type == gdk._2BUTTON_PRESS and e.button == 1


def _wrap_b1_control(e):
    return e.type == gdk.BUTTON_PRESS and e.button == 1 \
        and (e.state & gdk.CONTROL_MASK)


def _wrap_b1_shift(e):
    return e.type == gdk.BUTTON_PRESS and e.button == 1 \
        and (e.state & gdk.SHIFT_MASK)


def _wrap_b2_press(e):
    return e.type == gdk.BUTTON_PRESS and e.button == 2


def _wrap_b3_press(e):
    return (e.type == gdk.BUTTON_PRESS and e.button == 3 and
            not (e.state & gdk.CONTROL_MASK) and
            not (e.state & gdk.SHIFT_MASK))


def _wrap_b3_control(e):
    return e.type == gdk.BUTTON_PRESS and e.button == 3 \
        and (e.state & gdk.CONTROL_MASK)


def _wrap_b1_motion(e):
    return e.type == gdk.MOTION_NOTIFY and (e.state & gdk.BUTTON_PRESS_MASK)


def _wrap_b1_release(e):
    return e.type == gdk.BUTTON_RELEASE and e.button == 1


def _wrap_key_press(e, key):
    return e.type == gdk.KEY_PRESS and e.key == key


def _wrap_enter(e):
    return e.type == gdk.ENTER_NOTIFY


def _wrap_leave(e):
    return e.type == gdk.LEAVE_NOTIFY


_wrap_handlers = {
    '<1>':                  (_wrap_b1_press,   'button-press-event'),
    '<ButtonPress-1>':      (_wrap_b1_press,   'button-press-event'),
    '<Double-1>':           (_wrap_b1_double,  'button-press-event'),
    '<Control-1>':          (_wrap_b1_control, 'button-press-event'),
    '<Shift-1>':            (_wrap_b1_shift,   'button-press-event'),
    '<2>':                  (_wrap_b2_press,   'button-press-event'),
    '<ButtonPress-2>':      (_wrap_b2_press,   'button-press-event'),
    '<3>':                  (_wrap_b3_press,   'button-press-event'),
    '<ButtonPress-3>':      (_wrap_b3_press,   'button-press-event'),
    '<Control-3>':          (_wrap_b3_control, 'button-press-event'),
    '<Motion>':             (_wrap_b1_motion,  'motion-notify-event'),
    '<ButtonRelease-1>':    (_wrap_b1_release, 'button-release-event'),
    '<Enter>':              (_wrap_enter,      'enter-notify-event'),
    '<Leave>':              (_wrap_leave,      'leave-notify-event'),
}
#  for c in " " + string.letters:
#      seq = "<" + c + ">"
#      if not _wrap_handlers.has_key(seq):
#          _wrap_handlers[seq] = lambda e, key=c: _wrap_key_press(e, key)
#  import pprint; pprint.pprint(_wrap_handlers)

#  NOT BOUND: <Unmap>


__bindings = {}


def _wrap_event(widget, event, l):
    for wrap, func in l:
        if wrap(event):
            # print "event:", wrap, func, event
            return func(event)
    return 0


def bind(widget, sequence, func, add=None):
    wrap = _wrap_handlers.get(sequence)
    if not wrap:
        # print "NOT BOUND:", sequence
        return
    wrap, signal = wrap
    #
    k = id(widget)
    if k in __bindings:
        __bindings[k].append((wrap, func))
    else:
        lst = [(wrap, func)]
        widget.connect(signal, _wrap_event, lst)
        __bindings[k] = lst


def unbind_destroy(widget):
    k = id(widget)
    if k in __bindings:
        #  FIXME
        del __bindings[k]


# ************************************************************************
# * timer wrapper
# ************************************************************************

def after(widget, ms, func, *args):
    timer = gobject.timeout_add(ms, func, *args)
    return timer


def after_idle(widget, func, *args):
    gobject.idle_add(func, *args)
    return None


def after_cancel(t):
    if t is not None:
        gobject.source_remove(t)


# ************************************************************************
# * font
# ************************************************************************

def create_pango_font_desc(font):
    font_desc = pango.FontDescription(font[0]+' '+str(font[1]))
    if 'italic' in font:
        font_desc.set_style(pango.STYLE_ITALIC)
    if 'bold' in font:
        font_desc.set_weight(pango.WEIGHT_BOLD)
    return font_desc


def get_text_width(text, font=None, root=None):
    if root:
        # pango_font_desc = create_pango_font_desc(font)
        pangolayout = root.create_pango_layout(text)
        width = pangolayout.get_pixel_extents()[1][2]
        return width
    return 0
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##


#
# This files tries to wrap a limited subset of the tkinter canvas
# into GTK / Gnome.
#

#
# Some background information:
#
#   - Each card is a canvas group consisting of a background and foreground
#     image. Turning a card raises the respective image within that group.
#
#   - Each stack is a canvas group consisting of cards (i.e. a group of groups)
#
#   - Cards change stacks, and are bound to the main canvas when dragging
#     around.
#

import gobject

import gtk

try:
    import gnomecanvas
except ImportError:
    import gnome.canvas as gnomecanvas

# toolkit imports
from tkutil import anchor_tk2gtk, bind, create_pango_font_desc

gdk = gtk.gdk

# ************************************************************************
# * canvas items
# *
# * My first (obvious) approach was to subclass the GnomeCanvas*
# * classes, but this didn't work at all...
# *
# * Now I've resorted to delegation, but what are the Gnome canvas item
# * classes for then ?
# ************************************************************************


class _CanvasItem:

    def __init__(self, canvas):
        self.canvas = canvas
        canvas._all_items.append(self)
        self._is_hidden = False
        self._x, self._y = 0, 0
        self._group = None

    def addtag(self, group):
        # print self, 'addtag'
        # ~ assert isinstance(group._item, CanvasGroup)
        self._item.reparent(group._item)
        if self._group == group:
            print('addtag: new_group == old_group')
        self._group = group

    def dtag(self, group):
        # print self, 'dtag'
        # ~ assert isinstance(group._item, CanvasGroup)
        # self._item.reparent(self.canvas.root())
        pass

    def bind(self, sequence, func, add=None):
        bind(self._item, sequence, func, add)

    def bbox(self):
        #  FIXME
        return (0, 0, 0, 0)

    def delete(self):
        if self._item is not None:
            self._item.destroy()
            self._item = None

    def lower(self, positions=None):
        print('lower', self, positions)
        return  # don't need?
        #  if positions is None:
        #      pass
        #      ##self._item.lower_to_bottom()
        #      ##self._item.get_property('parent').lower_to_bottom()
        #  else:
        #      print self, positions
        #      self._item.lower(positions)

    def tkraise(self, positions=None):
        # print 'tkraise', positions
        if positions is None:
            self._item.raise_to_top()
            self._item.get_property('parent').raise_to_top()
        else:
            # print self, 'tkraise', positions
            # self._item.raise_to_top()
            self._item.raise_to_top()  # positions)

    def move(self, x, y):
        self._item.move(x, y)
        self._x, self._y = self._x+x, self._y+y

    def moveTo(self, x, y):
        self._item.move(x-self._x, y-self._y)
        self._x, self._y = x, y

    def show(self):
        if self._item:
            self._item.show()
        self._is_hidden = False

    def hide(self):
        if self._item:
            self._item.hide()
        self._is_hidden = True

    def connect(self, signal, func, args):
        # print '_CanvasItem.connect:', self, signal
        self._item.connect('event', func, args)


class MfxCanvasGroup(_CanvasItem):
    def __init__(self, canvas):
        _CanvasItem.__init__(self, canvas)
        self._item = canvas.root().add(gnomecanvas.CanvasGroup, x=0, y=0)


class MfxCanvasImage(_CanvasItem):
    def __init__(self, canvas, x, y, image, anchor=gtk.ANCHOR_NW, group=None):
        _CanvasItem.__init__(self, canvas)
        self._x, self._y = x, y
        if isinstance(anchor, str):
            anchor = anchor_tk2gtk(anchor)
        if group:
            self._group = group
            group = group._item
        else:
            group = canvas.root()
        self._item = group.add(gnomecanvas.CanvasPixbuf,
                               x=x, y=y,
                               pixbuf=image.pixbuf,
                               width=image.width(),
                               height=image.height(),
                               anchor=anchor)
        self._item.show()

    def config(self, image):
        # ~ assert isinstance(image.im, GdkImlib.Image)
        self._item.set(pixbuf=image.pixbuf)


class MfxCanvasLine(_CanvasItem):
    def __init__(self, canvas, *points, **kw):
        _CanvasItem.__init__(self, canvas)
        kwargs = {}
        if 'arrow' in kw:
            if kw['arrow'] == 'first':
                kwargs['first_arrowhead'] = True
            elif kw['arrow'] == 'last':
                kwargs['last_arrowhead'] = True
            elif kw['arrow'] == 'both':
                kwargs['first_arrowhead'] = True
                kwargs['last_arrowhead'] = True
        if 'fill' in kw:
            kwargs['fill_color'] = kw['fill']
        if 'width' in kw:
            kwargs['width_units'] = float(kw['width'])
        if 'arrowshape' in kw:
            kwargs['arrow_shape_a'] = kw['arrowshape'][0]
            kwargs['arrow_shape_b'] = kw['arrowshape'][1]
            kwargs['arrow_shape_c'] = kw['arrowshape'][2]
        if 'group' in kw:
            self._group = kw['group']
            group = kw['group']._item
        else:
            group = canvas.root()
        self._item = group.add(gnomecanvas.CanvasLine,
                               points=points, **kwargs)
        self._item.show()


class MfxCanvasRectangle(_CanvasItem):
    def __init__(self, canvas, x1, y1, x2, y2,
                 width=0, fill=None, outline=None, group=None):
        _CanvasItem.__init__(self, canvas)
        self._x, self._y = x1, y1
        kw = {'x1': x1, 'x2': x2, 'y1': y1, 'y2': y2}
        if width:
            kw['width_pixels'] = width
        if fill:
            kw['fill_color'] = fill
        if outline:
            kw['outline_color'] = outline
        if group:
            self._group = group
            group = group._item
        else:
            group = canvas.root()
        self._item = group.add(gnomecanvas.CanvasRect, **kw)
        self._item.show()


class MfxCanvasText(_CanvasItem):
    def __init__(self, canvas, x, y, anchor=gtk.ANCHOR_NW, preview=-1, **kw):
        _CanvasItem.__init__(self, canvas)
        self._x, self._y = x, y
        if preview < 0:
            preview = canvas.preview
        if preview > 1:
            self._item = None
            return
        anchor = anchor_tk2gtk(anchor)
        if 'group' in kw:
            self._group = kw['group']
            group = kw['group']._item
            del kw['group']
        else:
            group = canvas.root()
        self._item = group.add(gnomecanvas.CanvasText,
                               x=x, y=y, anchor=anchor)
        if 'fill' not in kw:
            kw['fill'] = canvas._text_color
        for k, v in kw.items():
            self[k] = v
        # ~ self.text_format = None
        canvas._text_items.append(self)
        self._item.show()

    def __setitem__(self, key, value):
        if key == 'fill':
            self._item.set(fill_color=value)
        elif key == 'font':
            # print 'set font:', value
            font_desc = create_pango_font_desc(value)
            self._item.set(font_desc=font_desc)
        elif key == 'text':
            self._item.set(text=value)
        else:
            raise AttributeError(key)

    def config(self, **kw):
        for k, v in kw.items():
            self[k] = v

    def __getitem__(self, key):
        if key == 'text':
            return self._item.get_property('text')
        else:
            raise AttributeError(key)
    cget = __getitem__


# ************************************************************************
# * canvas
# ************************************************************************

class MfxCanvas(gnomecanvas.Canvas):
    def __init__(self, top, bg=None, highlightthickness=0):
        self.preview = 0
        # tkinter compat
        self.items = {}
        self._all_items = []
        self._text_items = []
        self._hidden_items = []
        self._width, self._height = -1, -1
        self._tile = None
        # private
        self.__tileimage = None
        self.__tiles = []
        self.__topimage = None
        # friend MfxCanvasText
        self._text_color = '#000000'
        #
        gnomecanvas.Canvas.__init__(self)
        c = top.style.bg[gtk.STATE_NORMAL]
        c = '#%02x%02x%02x' % (c.red//256, c.green//256, c.blue//256)
        self.top_bg = c
        if bg is not None:
            self.modify_bg(gtk.STATE_NORMAL, gdk.color_parse(bg))

        #
        self.top = top
        self.xmargin, self.ymargin = 0, 0

        self.connect('size-allocate', self._sizeAllocate)
        # self.connect('destroy', self.destroyEvent)

    def __setattr__(self, name, value):
        self.__dict__[name] = value

    def _sizeAllocate(self, w, rect):
        # print '_sizeAllocate', rect.x, rect.y, rect.width, rect.height
        if self._width > 0:
            w = self._width
            h = min(self._height, rect.height)
            self.set_scroll_region(0, 0, w, h)
        if self._tile and self._tile.filename:
            self._setTile()

    def bind(self, sequence=None, func=None, add=None):
        assert add is None
        # FIXME
        print('TkCanvas bind:', sequence)
        return

    def cget(self, attr):
        if attr == 'cursor':
            # FIXME
            return gdk.LEFT_PTR
            # return self.get_window().get_cursor(v)
        elif attr == 'width':
            return self.get_size()[0]
        elif attr == 'height':
            return self.get_size()[1]
        print('TkCanvas cget:', attr)
        raise AttributeError(attr)

    def xview(self):
        w, h = self.get_size()
        dx, dy = self.world_to_window(0, 0)
        return -float(dx)/w, 1.0

    def yview(self):
        w, h = self.get_size()
        dx, dy = self.world_to_window(0, 0)
        return -float(dy)/h, 1.0

    def winfo_width(self):
        return self.get_size()[0]

    def winfo_height(self):
        return self.get_size()[1]

    def configure(self, **kw):
        height, width = -1, -1
        for k, v in kw.items():
            if k in ('background', 'bg'):
                self.modify_bg(gtk.STATE_NORMAL, gdk.color_parse(v))
            elif k == 'cursor':
                if not self.window:
                    self.realize()
                if v == '':
                    v = gdk.LEFT_PTR
                self.window.set_cursor(gdk.Cursor(v))
            elif k == 'height':
                height = v
            elif k == 'width':
                width = v
            else:
                print('TkCanvas', k, v)
                raise AttributeError(k)
        if height > 0 and width > 0:
            self.set_size_request(width, height)

    config = configure

    # PySol extension
    # delete all CanvasItems, but keep the background and top tiles
    def deleteAllItems(self):
        for i in self._all_items:
            if i._item:
                i._item.destroy()
            # i._item = None
        self._all_items = []

    def hideAllItems(self):
        self._hidden_items = []
        for i in self._all_items:
            if not i._is_hidden:
                i.hide()
                self._hidden_items.append(i)

    def showAllItems(self):
        for i in self._hidden_items:
            i.show()
        self._hidden_items = []

    # PySol extension
    def findCard(self, stack, event):
        # FIXME
        # w = self.get_item_at(event.x, event.y)
        # print w
        return stack._findCardXY(event.x, event.y)

    def pack(self, **kw):
        self.show()

    # PySol extension
    def setTextColor(self, color):
        if self._text_color != color:
            self._text_color = color
            for item in self._text_items:
                item._item.set(fill_color=self._text_color)

    # PySol extension - set a tiled background image
    def setTile(self, app, i, force=False):
        # print 'setTile:', i
        tile = app.tabletile_manager.get(i)
        if tile is None or tile.error:
            return False
        if i == 0:
            assert tile.color
            assert tile.filename is None
        else:
            assert tile.color is None
            assert tile.filename
            assert tile.basename
        if not force:
            if (i == app.tabletile_index and
                    tile.color == app.opt.colors['table']):
                return False
            if self._tile is tile:
                return False
        #
        self._tile = tile
        if i == 0:
            self.setBackgroundImage(None)
            self.configure(bg=tile.color)
            # app.top.config(bg=tile.color)
        else:
            self._setTile()
            self.configure(bg=self.top_bg)

        self.setTextColor(app.opt.colors['text'])

        return True

    # FIXME: should use style.bg_pixmap ????
    def _setTile(self):
        if not self._tile:
            return
        # print '_setTile:', self.get_size(), self._tile.filename
        #
        filename = self._tile.filename
        stretch = self._tile.stretch

        if not filename:
            return False
        if not self.window:
            # not realized yet
            self.realize()
            # return False

        gobject.idle_add(self.setBackgroundImage, filename, stretch)

    def setBackgroundImage(self, filename, stretch=False):
        # print 'setBackgroundImage', filename
        if filename is None:
            if self.__tileimage:
                self.__tileimage.destroy()
                self.__tileimage = None
            return

        width, height = self.get_size()
        pixbuf = gtk.gdk.pixbuf_new_from_file(filename)
        w, h = pixbuf.get_width(), pixbuf.get_height()
        dx, dy = self.world_to_window(0, 0)
        dx, dy = int(dx), int(dy)

        if self.__tileimage:
            self.__tileimage.destroy()
            self.__tileimage = None

        if stretch:
            bg_pixbuf = pixbuf.scale_simple(width, height, gdk.INTERP_BILINEAR)
        else:
            bg_pixbuf = gdk.Pixbuf(pixbuf.get_colorspace(),
                                   pixbuf.get_has_alpha(),
                                   pixbuf.get_bits_per_sample(),
                                   width, height)
            y = 0
            while y < height:
                x = 0
                while x < width:
                    ww = min(w, width-x)
                    hh = min(h, height-y)
                    pixbuf.copy_area(0, 0, ww, hh, bg_pixbuf, x, y)
                    x += w
                y += h

        w = self.root().add(gnomecanvas.CanvasPixbuf,
                            pixbuf=bg_pixbuf, x=0-dx, y=0-dy)
        w.lower_to_bottom()
        self.__tileimage = w

    def setTopImage(self, image, cw=0, ch=0):
        if self.__topimage:
            self.__topimage.destroy()
            self.__topimage = None
        if not image:
            return
        if isinstance(image, str):
            pixbuf = gtk.gdk.pixbuf_new_from_file(image)
        else:
            pixbuf = image.pixbuf
        w, h = self.get_size()
        iw, ih = pixbuf.get_width(), pixbuf.get_height()
        x, y = (w-iw)//2, (h-ih)//2
        dx, dy = self.world_to_window(0, 0)
        dx, dy = int(dx), int(dy)
        self.__topimage = self.root().add(gnomecanvas.CanvasPixbuf,
                                          pixbuf=pixbuf, x=x-dx, y=y-dy)

    def update_idletasks(self):
        # print 'MfxCanvas.update_idletasks'
        # gdk.window_process_all_updates()
        # self.show_now()
        # FIXME
        # if self.__topimage:
        #     self.__topimage.raise_to_top()
        self.update_now()
        pass

    def updateAll(self):
        print('Canvas - updateAll')
        for i in self._all_items:
            i._item.hide()
        self.update_now()
        n = 0
        for i in self._all_items:
            i._item.show()
            print(n, i)
            n += 1
        self.update_now()
        # self.window.invalidate_rect((0, 0, 400, 400), True)

    def grid(self, *args, **kw):
        self.top.table.attach(
            self,
            1, 2,                   2, 3,
            gtk.EXPAND | gtk.FILL,  gtk.EXPAND | gtk.FILL | gtk.SHRINK,
            0,                      0)
        self.show()

    def setInitialSize(self, width, height):
        # print 'setInitialSize:', width, height
        self._width, self._height = width, height
        self.set_size_request(width, height)
        # self.set_size(width, height)
        # self.queue_resize()

    def destroyEvent(self, w):
        # print 'MfxCanvas.destroyEvent'
        self.hide()
        #  self.deleteAllItems()
        #  if self.__topimage:
        #      self.__topimage.destroy()
        #      self.__topimage = None


class MfxScrolledCanvas(MfxCanvas):
    def __init__(self, parent, hbar=2, vbar=2, **kw):
        MfxCanvas.__init__(self, parent)
        self.canvas = self
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# imports
import os

import gobject

import gtk

from pysollib.gamedb import GI
from pysollib.help import help_html
from pysollib.mfxutil import Struct, destruct
from pysollib.mfxutil import format_time
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.resource import CSI

from pysoltree import PysolTreeView

from tkcanvas import MfxCanvas

from tkutil import unbind_destroy

from tkwidget import MfxDialog


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectGameDialogWithPreview(MfxDialog):
    # Tree_Class = SelectGameTreeWithPreview
    game_store = None
    #
    _paned_position = 300
    _expanded_rows = []
    _geometry = None
    _selected_row = None
    _vadjustment_position = None

    def __init__(self, parent, title, app, gameid, bookmark=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, **kw)
        #
        self.app = app
        self.gameid = gameid
        self.bookmark = bookmark
        self.random = None
        #
        if self.game_store is None:
            self.createGameStore()
        #
        top_box, bottom_box = self.createHBox()
        # paned
        hpaned = gtk.HPaned()
        self.hpaned = hpaned
        hpaned.show()
        top_box.pack_start(hpaned, expand=True, fill=True)
        # left
        self.treeview = PysolTreeView(self, self.game_store)
        hpaned.pack1(self.treeview.scrolledwindow, True, True)
        # right
        table = gtk.Table(2, 2, False)
        table.show()
        hpaned.pack2(table, True, True)
        # frames
        frame = gtk.Frame(label=_('About game'))
        frame.show()
        table.attach(frame,
                     0, 1,      0, 1,
                     gtk.FILL,  gtk.FILL,
                     0,         0)
        frame.set_border_width(4)
        info_frame = gtk.Table(2, 7, False)
        info_frame.show()
        frame.add(info_frame)
        info_frame.set_border_width(4)
        #
        frame = gtk.Frame(label=_('Statistics'))
        frame.show()
        table.attach(frame,
                     1, 2,      0, 1,
                     gtk.FILL,  gtk.FILL,
                     0,         0)
        frame.set_border_width(4)
        stats_frame = gtk.Table(2, 6, False)
        stats_frame.show()
        frame.add(stats_frame)
        stats_frame.set_border_width(4)
        # info
        self.info_labels = {}
        for n, t, f, row in (
            ('name',        _('Name:'),             info_frame,   0),
            ('altnames',    _('Alternate names:'),  info_frame,   1),
            ('category',    _('Category:'),         info_frame,   2),
            ('type',        _('Type:'),             info_frame,   3),
            ('skill_level', _('Skill level:'),      info_frame,   4),
            ('decks',       _('Decks:'),            info_frame,   5),
            ('redeals',     _('Redeals:'),          info_frame,   6),
            #
            ('played',      _('Played:'),           stats_frame,  0),
            ('won',         _('Won:'),              stats_frame,  1),
            ('lost',        _('Lost:'),             stats_frame,  2),
            ('time',        _('Playing time:'),     stats_frame,  3),
            ('moves',       _('Moves:'),            stats_frame,  4),
            ('percent',     _('% won:'),            stats_frame,  5),
                ):
            title_label = gtk.Label()
            title_label.show()
            title_label.set_text(t)
            title_label.set_alignment(0., 0.)
            title_label.set_property('xpad', 2)
            title_label.set_property('ypad', 2)
            f.attach(title_label,
                     0, 1,      row, row+1,
                     gtk.FILL,  0,
                     0,         0)
            text_label = gtk.Label()
            text_label.show()
            text_label.set_alignment(0., 0.)
            text_label.set_property('xpad', 2)
            text_label.set_property('ypad', 2)
            f.attach(text_label,
                     1, 2,      row, row+1,
                     gtk.FILL,  0,
                     0,         0)
            self.info_labels[n] = (title_label, text_label)
        # canvas
        self.preview = MfxCanvas(self)
        self.preview.show()
        table.attach(
            self.preview,
            0, 2,                            1, 2,
            gtk.EXPAND | gtk.FILL | gtk.SHRINK,
            gtk.EXPAND | gtk.FILL | gtk.SHRINK,
            0,                               0)
        self.preview.set_border_width(4)
        self.preview.setTile(app, app.tabletile_index, force=True)

        # set the scale factor
        self.preview.preview = 2
        # create a preview of the current game
        self.preview_key = -1
        self.preview_game = None
        self.preview_app = None
        # ~ self.updatePreview(gameid, animations=0)
        # ~ SelectGameTreeWithPreview.html_viewer = None

        self.connect('unrealize', self._unrealizeEvent)

        self.createButtons(bottom_box, kw)
        self._restoreSettings()
        self.show_all()
        gtk.main()

    def _addGamesFromData(self, data, store, root_iter, root_label, all_games):
        gl = []
        for label, selecter in data:
            games = self._selectGames(all_games, selecter)
            if games:
                gl.append((label, games))
        if not gl:
            return
        iter = store.append(root_iter)
        store.set(iter, 0, root_label, 1, -1)
        for label, games in gl:
            self._addGames(store, iter, label, games)

    def _addGames(self, store, root_iter, root_label, games):
        if not games:
            return
        iter = store.append(root_iter)
        store.set(iter, 0, root_label, 1, -1)
        for id, name in games:
            child_iter = store.append(iter)
            store.set(child_iter, 0, name, 1, id)

    def _selectGames(self, all_games, selecter):
        # return list of tuples (gameid, gamename)
        if selecter is None:
            return [(gi.id, gi.name) for gi in all_games]
        elif selecter == 'alt':
            return all_games
        return [(gi.id, gi.name) for gi in all_games if selecter(gi)]

    def createGameStore(self):
        store = gtk.TreeStore(gobject.TYPE_STRING, gobject.TYPE_INT)
        app = self.app
        gdb = app.gdb

        all_games = map(gdb.get, gdb.getGamesIdSortedByName())
        #
        alter_games = gdb.getGamesTuplesSortedByAlternateName()
        for label, games, selecter in (
            (_('All Games'),       all_games,   None),
            (_('Alternate Names'), alter_games, 'alt'),
            (_('Popular Games'),   all_games,
                lambda gi: gi.si.game_flags & GI.GT_POPULAR),
                ):
            games = self._selectGames(games, selecter)
            self._addGames(store, None, label, games)

        # by type
        games = self._selectGames(all_games,
                                  lambda gi: gi.si.game_type == GI.GT_MAHJONGG)
        self._addGames(store, None, _("Mahjongg Games"), games)
        self._addGamesFromData(GI.SELECT_ORIENTAL_GAME_BY_TYPE, store,
                               None, _("Oriental Games"), all_games)
        self._addGamesFromData(GI.SELECT_SPECIAL_GAME_BY_TYPE, store,
                               None, _("Special Games"), all_games)
        self._addGamesFromData(GI.SELECT_GAME_BY_TYPE, store,
                               None, _("French games"), all_games)
        # by skill level
        data = (
          (_('Luck only'), lambda gi: gi.skill_level == GI.SL_LUCK),
          (_('Mostly luck'), lambda gi: gi.skill_level == GI.SL_MOSTLY_LUCK),
          (_('Balanced'), lambda gi: gi.skill_level == GI.SL_BALANCED),
          (_('Mostly skill'), lambda gi: gi.skill_level == GI.SL_MOSTLY_SKILL),
          (_('Skill only'), lambda gi: gi.skill_level == GI.SL_SKILL),
          )
        self._addGamesFromData(data, store, None,
                               _("by Skill Level"), all_games)

        # by game feature
        root_iter = store.append(None)
        store.set(root_iter, 0, _('by Game Feature'), 1, -1)
        data = (
            (_("32 cards"), lambda gi: gi.si.ncards == 32),
            (_("48 cards"), lambda gi: gi.si.ncards == 48),
            (_("52 cards"), lambda gi: gi.si.ncards == 52),
            (_("64 cards"), lambda gi: gi.si.ncards == 64),
            (_("78 cards"), lambda gi: gi.si.ncards == 78),
            (_("104 cards"), lambda gi: gi.si.ncards == 104),
            (_("144 cards"), lambda gi: gi.si.ncards == 144),
            (_("Other number"),
                lambda gi: gi.si.ncards not in (32, 48, 52, 64, 78, 104, 144))
            )
        self._addGamesFromData(
            data, store, root_iter, _("by Number of Cards"), all_games)
        data = (
            (_("1 deck games"), lambda gi: gi.si.decks == 1),
            (_("2 deck games"), lambda gi: gi.si.decks == 2),
            (_("3 deck games"), lambda gi: gi.si.decks == 3),
            (_("4 deck games"), lambda gi: gi.si.decks == 4),)
        self._addGamesFromData(
            data, store, root_iter, _("by Number of Decks"), all_games)
        data = (
            (_("No redeal"), lambda gi: gi.si.redeals == 0),
            (_("1 redeal"), lambda gi: gi.si.redeals == 1),
            (_("2 redeals"), lambda gi: gi.si.redeals == 2),
            (_("3 redeals"), lambda gi: gi.si.redeals == 3),
            (_("Unlimited redeals"), lambda gi: gi.si.redeals == -1),
            # (_("Variable redeals"), lambda gi: gi.si.redeals == -2),
            (_("Other number of redeals"),
                lambda gi: gi.si.redeals not in (-1, 0, 1, 2, 3)),)
        self._addGamesFromData(data, store, root_iter,
                               _("by Number of Redeals"), all_games)

        data = []
        for label, vg in GI.GAMES_BY_COMPATIBILITY:
            def selecter(gi, vg=vg):
                return gi.id in vg
            data.append((label, selecter))
        self._addGamesFromData(data, store, root_iter,
                               _("by Compatibility"), all_games)

        # by PySol version
        data = []
        for version, vg in GI.GAMES_BY_PYSOL_VERSION:
            def selecter(gi, vg=vg):
                return gi.id in vg
            label = _("New games in v. %(version)s") % {'version': version}
            data.append((label, selecter))
        self._addGamesFromData(data, store, None,
                               _("by PySol version"), all_games)

        #
        data = (
            (_("Games for Children (very easy)"),
                lambda gi: gi.si.game_flags & GI.GT_CHILDREN),
            (_("Games with Scoring"),
                lambda gi: gi.si.game_flags & GI.GT_SCORE),
            (_("Games with Separate Decks"),
                lambda gi: gi.si.game_flags & GI.GT_SEPARATE_DECKS),
            (_("Open Games (all cards visible)"),
                lambda gi: gi.si.game_flags & GI.GT_OPEN),
            (_("Relaxed Variants"),
                lambda gi: gi.si.game_flags & GI.GT_RELAXED),)
        self._addGamesFromData(data, store, None,
                               _("Other Categories"), all_games)

        #
        self._addGamesFromData(GI.SELECT_ORIGINAL_GAME_BY_TYPE, store,
                               None, _("Original Games"), all_games)
        # self._addGamesFromData(GI.SELECT_CONTRIB_GAME_BY_TYPE, store,
        #               None, _("Contrib Game"), all_games)

        SelectGameDialogWithPreview.game_store = store
        return

    def initKw(self, kw):
        kwdefault(kw,
                  strings=(_("&Select"), _("&Rules"), _("&Cancel"),),
                  default=0,
                  width=600, height=400,
                  )
        return MfxDialog.initKw(self, kw)

    def _unrealizeEvent(self, w):
        self.deletePreview(destroy=1)
        # self.preview.unbind_all()
        self._saveSettings()

    def _saveSettings(self):
        SelectGameDialogWithPreview._geometry = self.get_size()
        SelectGameDialogWithPreview._paned_position = \
            self.hpaned.get_position()

    def _restoreSettings(self):
        if self._geometry:
            self.resize(self._geometry[0], self._geometry[1])
        self.hpaned.set_position(self._paned_position)

    def getSelected(self):
        index = self.treeview.getSelected()
        if index < 0:
            return None
        return index

    def showSelected(self, w):
        id = self.getSelected()
        if id:
            self.updatePreview(id)

    def deletePreview(self, destroy=0):
        self.preview_key = -1
        # clean up the canvas
        if self.preview:
            unbind_destroy(self.preview)
            self.preview.deleteAllItems()
            # ~ if destroy:
            # ~     self.preview.delete("all")
        #
        # for l in self.info_labels.values():
        #    l.config(text='')
        # destruct the game
        if self.preview_game:
            self.preview_game.endGame()
            self.preview_game.destruct()
            destruct(self.preview_game)
        self.preview_game = None
        # destruct the app
        if destroy:
            if self.preview_app:
                destruct(self.preview_app)
            self.preview_app = None

    def updatePreview(self, gameid, animations=10):
        if gameid == self.preview_key:
            return
        self.deletePreview()
        canvas = self.preview
        #
        gi = self.app.gdb.get(gameid)
        if not gi:
            self.preview_key = -1
            return
        #
        if self.preview_app is None:
            self.preview_app = Struct(
                # variables
                audio=self.app.audio,
                canvas=canvas,
                cardset=self.app.cardset.copy(),
                gamerandom=self.app.gamerandom,
                gdb=self.app.gdb,
                gimages=self.app.gimages,
                images=self.app.subsampled_images,
                menubar=None,
                miscrandom=self.app.miscrandom,
                opt=self.app.opt.copy(),
                startup_opt=self.app.startup_opt,
                stats=self.app.stats.new(),
                top=None,
                top_cursor=self.app.top_cursor,
                toolbar=None,
                # methods
                constructGame=self.app.constructGame,
                getFont=self.app.getFont,
            )
            self.preview_app.opt.shadow = 0
            self.preview_app.opt.shade = 0
        #
        self.preview_app.audio = None    # turn off audio for initial dealing
        if animations >= 0:
            self.preview_app.opt.animations = animations
        #
        if self.preview_game:
            self.preview_game.endGame()
            self.preview_game.destruct()
        # self.top.wm_title(
        #   "Select Game - " + self.app.getGameTitleName(gameid))
        title = self.app.getGameTitleName(gameid)
        self.set_title(_("Playable Preview - %(game)s") % {'game': title})
        #
        self.preview_game = gi.gameclass(gi)
        self.preview_game.createPreview(self.preview_app)
        # tx, ty = 0, 0
        # gw, gh = self.preview_game.width, self.preview_game.height
        # ~ canvas.config(scrollregion=(-tx, -ty, -tx, -ty))
        # ~ canvas.xview_moveto(0)
        # ~ canvas.yview_moveto(0)
        #
        random = None
        if gameid == self.gameid:
            random = self.app.game.random.copy()
        if gameid == self.gameid and self.bookmark:
            self.preview_game.restoreGameFromBookmark(self.bookmark)
        else:
            self.preview_game.newGame(random=random, autoplay=1)
        # ~ canvas.config(scrollregion=(-tx, -ty, gw, gh))
        #
        self.preview_app.audio = self.app.audio
        if self.app.opt.animations:
            self.preview_app.opt.animations = 10
        else:
            self.preview_app.opt.animations = 0
        # save seed
        self.random = self.preview_game.random.copy()
        self.random.origin = self.random.ORIGIN_PREVIEW
        self.preview_key = gameid
        #
        self.updateInfo(gameid)
        #
        rules_button = self.buttons[1]
        if self.app.getGameRulesFilename(gameid):
            rules_button.set_sensitive(True)
        else:
            rules_button.set_sensitive(False)

    def updateInfo(self, gameid):
        gi = self.app.gdb.get(gameid)
        # info
        name = gi.name
        altnames = '\n'.join(gi.altnames)
        category = _(CSI.TYPE[gi.category])
        type = ''
        if gi.si.game_type in GI.TYPE_NAMES:
            type = _(GI.TYPE_NAMES[gi.si.game_type])
        sl = {
            GI.SL_LUCK:         _('Luck only'),
            GI.SL_MOSTLY_LUCK:  _('Mostly luck'),
            GI.SL_BALANCED:     _('Balanced'),
            GI.SL_MOSTLY_SKILL: _('Mostly skill'),
            GI.SL_SKILL:        _('Skill only'),
            }
        skill_level = sl.get(gi.skill_level)
        if gi.redeals == -2:
            redeals = _('variable')
        elif gi.redeals == -1:
            redeals = _('unlimited')
        else:
            redeals = str(gi.redeals)
        # stats
        won, lost, time, moves = self.app.stats.getFullStats(
            self.app.opt.player, gameid)
        if won+lost > 0:
            percent = "%.1f" % (100.0*won/(won+lost))
        else:
            percent = "0.0"
        time = format_time(time)
        moves = str(round(moves, 1))
        for n, t in (
            ('name',        name),
            ('altnames',    altnames),
            ('category',    category),
            ('type',        type),
            ('skill_level', skill_level),
            ('decks',       gi.decks),
            ('redeals',     redeals),
            ('played',      won+lost),
            ('won',         won),
            ('lost',        lost),
            ('time',        time),
            ('moves',       moves),
            ('percent',     percent),
                ):
            title_label, text_label = self.info_labels[n]
            if t in ('', None):
                title_label.hide()
                text_label.hide()
            else:
                title_label.show()
                text_label.show()
            text_label.set_text(str(t))

    def done(self, button):
        button = button.get_data("user_data")
        print('done', button)
        if button == 0:                    # Ok or double click
            id = self.getSelected()
            if id:
                self.gameid = id
            # ~ self.tree.n_expansions = 1  # save xyview in any case
        if button == 1:                    # Rules
            id = self.getSelected()
            if id:
                doc = self.app.getGameRulesFilename(id)
                if not doc:
                    return
            dir = os.path.join("html", "rules")
            help_html(self.app, doc, dir, self)
            return

        self.status = 0
        self.button = button
        self.quit()
# !/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------


import math
import time
import traceback
from pickle import Pickler, Unpickler, UnpicklingError

import attr

from pysol_cards.cards import ms_rearrange
from pysol_cards.random import random__int2str

from pysollib.game.dump import pysolDumpGame
from pysollib.gamedb import GI
from pysollib.help import help_about
from pysollib.hint import DefaultHint
from pysollib.mfxutil import Image, ImageTk, USE_PIL
from pysollib.mfxutil import Struct, SubclassResponsibility, destruct
from pysollib.mfxutil import format_time, print_err
from pysollib.mfxutil import uclock, usleep
from pysollib.move import AFlipAllMove
from pysollib.move import AFlipAndMoveMove
from pysollib.move import AFlipMove
from pysollib.move import AMoveMove
from pysollib.move import ANextRoundMove
from pysollib.move import ASaveSeedMove
from pysollib.move import ASaveStateMove
from pysollib.move import AShuffleStackMove
from pysollib.move import ASingleCardMove
from pysollib.move import ASingleFlipMove
from pysollib.move import ATurnStackMove
from pysollib.move import AUpdateStackMove
from pysollib.mygettext import _
from pysollib.mygettext import ungettext
from pysollib.pysolrandom import LCRandom31, PysolRandom, constructRandom
from pysollib.pysoltk import CURSOR_WATCH
from pysollib.pysoltk import Card
from pysollib.pysoltk import EVENT_HANDLED, EVENT_PROPAGATE
from pysollib.pysoltk import MfxCanvasLine, MfxCanvasRectangle, MfxCanvasText
from pysollib.pysoltk import MfxExceptionDialog, MfxMessageDialog
from pysollib.pysoltk import after, after_cancel, after_idle
from pysollib.pysoltk import bind, wm_map
from pysollib.settings import DEBUG
from pysollib.settings import PACKAGE, TITLE, TOOLKIT, TOP_SIZE
from pysollib.settings import VERSION, VERSION_TUPLE
from pysollib.struct_new import NewStruct

import random2

import six
from six import BytesIO
from six.moves import range

if TOOLKIT == 'tk':
    from pysollib.ui.tktile.solverdialog import reset_solver_dialog
else:
    from pysollib.pysoltk import reset_solver_dialog

# See: https://github.com/shlomif/PySolFC/issues/159 .
# 'factory=' is absent from older versions.
assert getattr(attr, '__version_info__', (0, 0, 0)) >= (18, 2, 0), (
        "Newer version of https://pypi.org/project/attrs/ is required.")


PLAY_TIME_TIMEOUT = 200
S_PLAY = 0x40

# ************************************************************************
# * Base class for all solitaire games
# *
# * Handles:
# *   load/save
# *   undo/redo (using a move history)
# *   hints/demo
# ************************************************************************


def _updateStatus_process_key_val(tb, sb, k, v):
    if k == "gamenumber":
        if v is None:
            if sb:
                sb.updateText(gamenumber="")
            # self.top.wm_title("%s - %s"
            # % (TITLE, self.getTitleName()))
            return
        if isinstance(v, six.string_types):
            if sb:
                sb.updateText(gamenumber=v)
            # self.top.wm_title("%s - %s %s" % (TITLE,
            # self.getTitleName(), v))
            return
    if k == "info":
        # print 'updateStatus info:', v
        if v is None:
            if sb:
                sb.updateText(info="")
            return
        if isinstance(v, str):
            if sb:
                sb.updateText(info=v)
            return
    if k == "moves":
        if v is None:
            # if tb: tb.updateText(moves="Moves\n")
            if sb:
                sb.updateText(moves="")
            return
        if isinstance(v, tuple):
            # if tb: tb.updateText(moves="Moves\n%d/%d" % v)
            if sb:
                sb.updateText(moves="%d/%d" % v)
            return
        if isinstance(v, int):
            # if tb: tb.updateText(moves="Moves\n%d" % v)
            if sb:
                sb.updateText(moves="%d" % v)
            return
        if isinstance(v, str):
            # if tb: tb.updateText(moves=v)
            if sb:
                sb.updateText(moves=v)
            return
    if k == "player":
        if v is None:
            if tb:
                tb.updateText(player=_("Player\n"))
            return
        if isinstance(v, six.string_types):
            if tb:
                # if self.app.opt.toolbar_size:
                if tb.getSize():
                    tb.updateText(player=_("Player\n") + v)
                else:
                    tb.updateText(player=v)
            return
    if k == "stats":
        if v is None:
            if sb:
                sb.updateText(stats="")
            return
        if isinstance(v, tuple):
            t = "%d: %d/%d" % (v[0]+v[1], v[0], v[1])
            if sb:
                sb.updateText(stats=t)
            return
    if k == "time":
        if v is None:
            if sb:
                sb.updateText(time='')
        if isinstance(v, six.string_types):
            if sb:
                sb.updateText(time=v)
        return
    if k == 'stuck':
        if sb:
            sb.updateText(stuck=v)
        return
    raise AttributeError(k)


def _stats__is_perfect(stats):
    """docstring for _stats__is_perfect"""
    return (stats.undo_moves == 0 and
            stats.goto_bookmark_moves == 0 and
            # stats.quickplay_moves == 0 and
            stats.highlight_piles == 0 and
            stats.highlight_cards == 0 and
            stats.shuffle_moves == 0)


def _highlightCards__calc_item(canvas, delta, cw, ch, s, c1, c2, color):
    assert c1 in s.cards and c2 in s.cards
    tkraise = False
    if c1 is c2:
        # highlight single card
        sx0, sy0 = s.getOffsetFor(c1)
        x1, y1 = s.getPositionFor(c1)
        x2, y2 = x1, y1
        if c1 is s.cards[-1]:
            # last card in the stack (for Pyramid-like games)
            tkraise = True
    else:
        # highlight pile
        if len(s.CARD_XOFFSET) > 1:
            sx0 = 0
        else:
            sx0 = s.CARD_XOFFSET[0]
        if len(s.CARD_YOFFSET) > 1:
            sy0 = 0
        else:
            sy0 = s.CARD_YOFFSET[0]
        x1, y1 = s.getPositionFor(c1)
        x2, y2 = s.getPositionFor(c2)
    if sx0 != 0 and sy0 == 0:
        # horizontal stack
        y2 += ch
        if c2 is s.cards[-1]:  # top card
            x2 += cw
        else:
            if sx0 > 0:
                # left to right
                x2 += sx0
            else:
                # right to left
                x1 += cw
                x2 += cw + sx0
    elif sx0 == 0 and sy0 != 0:
        # vertical stack
        x2 += cw
        if c2 is s.cards[-1]:  # top card
            y2 += ch
        else:
            if sy0 > 0:
                # up to down
                y2 = y2 + sy0
            else:
                # down to up
                y1 += ch
                y2 += ch + sy0
    else:
        x2 += cw
        y2 += ch
        tkraise = True
    # print c1, c2, x1, y1, x2, y2
    x1, x2 = x1-delta[0], x2+delta[1]
    y1, y2 = y1-delta[2], y2+delta[3]
    if TOOLKIT == 'tk':
        r = MfxCanvasRectangle(canvas, x1, y1, x2, y2,
                               width=4, fill=None, outline=color)
        if tkraise:
            r.tkraise(c2.item)
    elif TOOLKIT == 'kivy':
        r = MfxCanvasRectangle(canvas, x1, y1, x2, y2,
                               width=4, fill=None, outline=color)
        if tkraise:
            r.tkraise(c2.item)
    elif TOOLKIT == 'gtk':
        r = MfxCanvasRectangle(canvas, x1, y1, x2, y2,
                               width=4, fill=None, outline=color,
                               group=s.group)
        if tkraise:
            i = s.cards.index(c2)
            for c in s.cards[i+1:]:
                c.tkraise(1)
    return r


@attr.s
class StackGroups(NewStruct):
    dropstacks = attr.ib(factory=list)
    hp_stacks = attr.ib(factory=list)  # for getHightlightPilesStacks()
    openstacks = attr.ib(factory=list)
    reservestacks = attr.ib(factory=list)
    talonstacks = attr.ib(factory=list)

    def to_tuples(self):
        """docstring for to_tuples"""
        self.openstacks = [s for s in self.openstacks
                           if s.cap.max_accept >= s.cap.min_accept]
        self.hp_stacks = [s for s in self.dropstacks
                          if s.cap.max_move >= 2]
        self.openstacks = tuple(self.openstacks)
        self.talonstacks = tuple(self.talonstacks)
        self.dropstacks = tuple(self.dropstacks)
        self.reservestacks = tuple(self.reservestacks)
        self.hp_stacks = tuple(self.hp_stacks)


@attr.s
class StackRegions(NewStruct):
    # list of tuples(stacks, rect)
    info = attr.ib(factory=list)
    # list of stacks in no region
    remaining = attr.ib(factory=list)
    data = attr.ib(factory=list)
    # init info (at the start)
    init_info = attr.ib(factory=list)

    def calc_info(self, xf, yf):
        """docstring for calc_info"""
        info = []
        for stacks, rect in self.init_info:
            newrect = (int(round(rect[0]*xf)), int(round(rect[1]*yf)),
                       int(round(rect[2]*xf)), int(round(rect[3]*yf)))
            info.append((stacks, newrect))
        self.info = tuple(info)

    def optimize(self, remaining):
        """docstring for optimize"""
        # sort data by priority
        self.data.sort()
        self.data.reverse()
        # copy (stacks, rect) to info
        self.info = []
        for d in self.data:
            self.info.append((d[2], d[3]))
        self.info = tuple(self.info)
        # determine remaining stacks
        for stacks, rect in self.info:
            for stack in stacks:
                while stack in remaining:
                    remaining.remove(stack)
        self.remaining = tuple(remaining)
        self.init_info = self.info


@attr.s
class GameStacks(NewStruct):
    talon = attr.ib(default=None)
    waste = attr.ib(default=None)
    foundations = attr.ib(factory=list)
    rows = attr.ib(factory=list)  # for getHightlightPilesStacks()
    reserves = attr.ib(factory=list)
    internals = attr.ib(factory=list)

    def to_tuples(self):
        self.foundations = tuple(self.foundations)
        self.rows = tuple(self.rows)
        self.reserves = tuple(self.reserves)
        self.internals = tuple(self.internals)


@attr.s
class GameDrag(NewStruct):
    event = attr.ib(default=None)
    timer = attr.ib(default=None)
    start_x = attr.ib(default=0)
    start_y = attr.ib(default=0)
    index = attr.ib(default=-1)
    stack = attr.ib(default=None)
    shade_stack = attr.ib(default=None)
    shade_img = attr.ib(default=None)
    cards = attr.ib(factory=list)
    canshade_stacks = attr.ib(factory=list)
    noshade_stacks = attr.ib(factory=list)
    shadows = attr.ib(factory=list)


@attr.s
class GameTexts(NewStruct):
    info = attr.ib(default=None)
    help = attr.ib(default=None)
    misc = attr.ib(default=None)
    score = attr.ib(default=None)
    base_rank = attr.ib(default=None)
    list = attr.ib(factory=list)


@attr.s
class GameHints(NewStruct):
    list = attr.ib(default=None)
    index = attr.ib(default=-1)
    level = attr.ib(default=-1)


@attr.s
class GameStatsStruct(NewStruct):
    hints = attr.ib(default=0)                  # number of hints consumed
    # number of highlight piles consumed
    highlight_piles = attr.ib(default=0)
    # number of highlight matching cards consumed
    highlight_cards = attr.ib(default=0)
    # number of highlight same rank consumed
    highlight_samerank = attr.ib(default=0)
    undo_moves = attr.ib(default=0)             # number of undos
    redo_moves = attr.ib(default=0)             # number of redos
    # number of total moves in this game
    total_moves = attr.ib(default=0)
    player_moves = attr.ib(default=0)           # number of moves
    # number of moves while in demo mode
    demo_moves = attr.ib(default=0)
    autoplay_moves = attr.ib(default=0)         # number of moves
    quickplay_moves = attr.ib(default=0)        # number of quickplay moves
    goto_bookmark_moves = attr.ib(default=0)    # number of goto bookmark
    shuffle_moves = attr.ib(default=0)          # number of shuffles (Mahjongg)
    # did this game already update the demo stats ?
    demo_updated = attr.ib(default=0)
    update_time = attr.ib()
    @update_time.default
    def _foofoo(self):
        return time.time()  # for updateTime()
    elapsed_time = attr.ib(default=0.0)
    pause_start_time = attr.ib(default=0.0)

    def _reset_statistics(self):
        """docstring for _reset_stats"""
        self.undo_moves = 0
        self.redo_moves = 0
        self.player_moves = 0
        self.demo_moves = 0
        self.total_moves = 0
        self.quickplay_moves = 0
        self.goto_bookmark_moves = 0


_GLOBAL_U_PLAY = 0


@attr.s
class GameGlobalStatsStruct(NewStruct):
    holded = attr.ib(default=0)                 # is this a holded game
    # number of times this game was loaded
    loaded = attr.ib(default=0)
    # number of times this game was saved
    saved = attr.ib(default=0)
    # number of times this game was restarted
    restarted = attr.ib(default=0)
    goto_bookmark_moves = attr.ib(default=0)    # number of goto bookmark
    # did this game already update the player stats ?
    updated = attr.ib(default=_GLOBAL_U_PLAY)
    start_time = attr.ib()
    @start_time.default
    def _foofoo(self):
        return time.time()  # for updateTime()
    total_elapsed_time = attr.ib(default=0.0)
    start_player = attr.ib(default=None)


@attr.s
class GameWinAnimation(NewStruct):
    timer = attr.ib(default=None)
    images = attr.ib(factory=list)
    tk_images = attr.ib(factory=list)             # saved tk images
    saved_images = attr.ib(factory=dict)          # saved resampled images
    canvas_images = attr.ib(factory=list)         # ids of canvas images
    frame_num = attr.ib(default=0)              # number of the current frame
    width = attr.ib(default=0)
    height = attr.ib(default=0)


@attr.s
class GameMoves(NewStruct):
    current = attr.ib(factory=list)
    history = attr.ib(factory=list)
    index = attr.ib(default=0)
    state = attr.ib(default=S_PLAY)

# used when loading a game
@attr.s
class GameLoadInfo(NewStruct):
    ncards = attr.ib(default=0)
    stacks = attr.ib(factory=list)
    talon_round = attr.ib(default=1)


# global saveinfo survives a game restart
@attr.s
class GameGlobalSaveInfo(NewStruct):
    bookmarks = attr.ib(factory=dict)
    comment = attr.ib(default="")


# Needed for saving a game
@attr.s
class GameSaveInfo(NewStruct):
    stack_caps = attr.ib(factory=list)


_Game_LOAD_CLASSES = [GameGlobalSaveInfo, GameGlobalStatsStruct, GameMoves,
                      GameSaveInfo, GameStatsStruct, ]


class Game(object):
    # for self.gstats.updated
    U_PLAY = _GLOBAL_U_PLAY
    U_WON = -2
    U_LOST = -3
    U_PERFECT = -4

    # for self.moves.state
    S_INIT = 0x00
    S_DEAL = 0x10
    S_FILL = 0x20
    S_RESTORE = 0x30
    S_UNDO = 0x50
    S_PLAY = S_PLAY
    S_REDO = 0x60

    # for loading and saving - subclasses should override if
    # the format for a saved game changed (see also canLoadGame())
    GAME_VERSION = 1

    # only basic initialization here
    def __init__(self, gameinfo):
        self.preview = 0
        self.random = None
        self.gameinfo = gameinfo
        self.id = gameinfo.id
        assert self.id > 0
        self.busy = 0
        self.pause = False
        self.finished = False
        self.version = VERSION
        self.version_tuple = VERSION_TUPLE
        self.cards = []
        self.stackmap = {}              # dict with (x,y) tuples as key
        self.allstacks = []
        self.sn_groups = []  # snapshot groups; list of list of similar stacks
        self.snapshots = []
        self.failed_snapshots = []
        self.stackdesc_list = []
        self.demo_logo = None
        self.pause_logo = None
        self.s = GameStacks()
        self.sg = StackGroups()
        self.regions = StackRegions()
        self.init_size = (0, 0)
        self.event_handled = False      # if click event handled by Stack (???)
        self.reset()

    # main constructor
    def create(self, app):
        # print 'Game.create'
        old_busy = self.busy
        self.__createCommon(app)
        self.setCursor(cursor=CURSOR_WATCH)
        # print 'gameid:', self.id
        self.top.wm_title(TITLE + " - " + self.getTitleName())
        self.top.wm_iconname(TITLE + " - " + self.getTitleName())
        # create the game
        if self.app.intro.progress:
            self.app.intro.progress.update(step=1)
        self.createGame()
        # set some defaults
        self.createSnGroups()
        # convert stackgroups to tuples (speed)
        self.allstacks = tuple(self.allstacks)
        self.sg.to_tuples()
        self.s.to_tuples()
        # init the stack view
        for stack in self.allstacks:
            stack.prepareStack()
            stack.assertStack()
        if self.s.talon:
            assert hasattr(self.s.talon, "round")
            assert hasattr(self.s.talon, "max_rounds")
        if DEBUG:
            self._checkGame()
        self.optimizeRegions()
        # create cards
        if not self.cards:
            self.cards = self.createCards(progress=self.app.intro.progress)
        self.initBindings()
        # self.top.bind('<ButtonPress>', self.top._sleepEvent)
        # self.top.bind('<3>', self.top._sleepEvent)
        # update display properties
        self.canvas.busy = True
        # geometry
        mycond = (self.app.opt.save_games_geometry and
                  self.id in self.app.opt.games_geometry)
        if mycond:
            # restore game geometry
            w, h = self.app.opt.games_geometry[self.id]
            self.canvas.config(width=w, height=h)
        if True and USE_PIL:
            if self.app.opt.auto_scale:
                w, h = self.app.opt.game_geometry
                self.canvas.setInitialSize(w, h, margins=False,
                                           scrollregion=False)
                # self.canvas.config(width=w, height=h)
                # dx, dy = self.canvas.xmargin, self.canvas.ymargin
                # self.canvas.config(scrollregion=(-dx, -dy, dx, dy))
            else:
                if not mycond:
                    w = int(round(self.width * self.app.opt.scale_x))
                    h = int(round(self.height * self.app.opt.scale_y))
                    self.canvas.setInitialSize(w, h)
                self.top.wm_geometry("")    # cancel user-specified geometry
            # preserve texts positions
            for t in ('info', 'help', 'misc', 'score', 'base_rank'):
                item = getattr(self.texts, t)
                if item:
                    coords = self.canvas.coords(item)
                    setattr(self.init_texts, t, coords)
            #
            for item in self.texts.list:
                coords = self.canvas.coords(item)
                self.init_texts.list.append(coords)
            # resize
            self.resizeGame()
            # fix coords of cards (see self.createCards)
            x, y = self.s.talon.x, self.s.talon.y
            for c in self.cards:
                c.moveTo(x, y)
        else:
            # no PIL
            self.canvas.setInitialSize(self.width, self.height)
            self.top.wm_geometry("")    # cancel user-specified geometry
        # done; update view
        self.top.update_idletasks()
        self.canvas.busy = False
        if DEBUG >= 4:
            MfxCanvasRectangle(self.canvas, 0, 0, self.width, self.height,
                               width=2, fill=None, outline='green')
        #
        self.stats.update_time = time.time()
        self.showHelp()                 # just in case
        hint_class = self.getHintClass()
        if hint_class is not None:
            self.Stuck_Class = hint_class(self, 0)
        self.busy = old_busy

    def _checkGame(self):
        class_name = self.__class__.__name__
        if self.s.foundations:
            ncards = 0
            for stack in self.s.foundations:
                ncards += stack.cap.max_cards
            if ncards != self.gameinfo.ncards:
                print_err('invalid sum of foundations.max_cards: '
                          '%s: %s %s' %
                          (class_name, ncards, self.gameinfo.ncards),
                          2)
        if self.s.rows:
            from pysollib.stack import AC_RowStack, UD_AC_RowStack, \
                 SS_RowStack, UD_SS_RowStack, \
                 RK_RowStack, UD_RK_RowStack, \
                 Spider_AC_RowStack, Spider_SS_RowStack
            r = self.s.rows[0]
            for c, f in (
                ((Spider_AC_RowStack, Spider_SS_RowStack),
                 (self._shallHighlightMatch_RK,
                  self._shallHighlightMatch_RKW)),
                ((AC_RowStack, UD_AC_RowStack),
                 (self._shallHighlightMatch_AC,
                  self._shallHighlightMatch_ACW)),
                ((SS_RowStack, UD_SS_RowStack),
                 (self._shallHighlightMatch_SS,
                  self._shallHighlightMatch_SSW)),
                ((RK_RowStack, UD_RK_RowStack),
                 (self._shallHighlightMatch_RK,
                  self._shallHighlightMatch_RKW)),):
                if isinstance(r, c):
                    if self.shallHighlightMatch not in f:
                        print_err('shallHighlightMatch is not valid: '
                                  ' %s, %s' % (class_name, r.__class__), 2)
                    if r.cap.mod == 13 and self.shallHighlightMatch != f[1]:
                        print_err('shallHighlightMatch is not valid (wrap): '
                                  ' %s, %s' % (class_name, r.__class__), 2)
                    break
        if self.s.talon.max_rounds > 1 and self.s.talon.texts.rounds is None:
            print_err('max_rounds > 1, but talon.texts.rounds is None: '
                      '%s' % class_name, 2)
        elif (self.s.talon.max_rounds <= 1 and
              self.s.talon.texts.rounds is not None):
            print_err('max_rounds <= 1, but talon.texts.rounds is not None: '
                      '%s' % class_name, 2)

    def initBindings(self):
        # note: a Game is only allowed to bind self.canvas and not to self.top
        # bind(self.canvas, "<Double-1>", self.undoHandler)
        bind(self.canvas, "<1>", self.undoHandler)
        bind(self.canvas, "<2>", self.dropHandler)
        bind(self.canvas, "<3>", self.redoHandler)
        bind(self.canvas, '<Unmap>', self._unmapHandler)
        bind(self.canvas, '<Configure>', self._configureHandler, add=True)

    def __createCommon(self, app):
        self.busy = 1
        self.app = app
        self.top = app.top
        self.canvas = app.canvas
        self.filename = ""
        self.drag = GameDrag()
        if self.gstats.start_player is None:
            self.gstats.start_player = self.app.opt.player
        # optional MfxCanvasText items
        self.texts = GameTexts()
        # initial position of the texts
        self.init_texts = GameTexts()

    def createPreview(self, app):
        old_busy = self.busy
        self.__createCommon(app)
        self.preview = max(1, self.canvas.preview)
        # create game
        self.createGame()
        # set some defaults
        self.sg.openstacks = [s for s in self.sg.openstacks
                              if s.cap.max_accept >= s.cap.min_accept]
        self.sg.hp_stacks = [s for s in self.sg.dropstacks
                             if s.cap.max_move >= 2]
        # init the stack view
        for stack in self.allstacks:
            stack.prepareStack()
            stack.assertStack()
        self.optimizeRegions()
        # create cards
        self.cards = self.createCards()
        #
        self.canvas.setInitialSize(self.width, self.height)
        self.busy = old_busy

    def destruct(self):
        # help breaking circular references
        for obj in self.cards:
            destruct(obj)
        for obj in self.allstacks:
            obj.destruct()
            destruct(obj)

    # Do not destroy game structure (like stacks and cards) here !
    def reset(self, restart=0):
        self.filename = ""
        self.demo = None
        self.solver = None
        self.hints = GameHints()
        self.saveinfo = GameSaveInfo()
        self.loadinfo = GameLoadInfo()
        self.snapshots = []
        self.failed_snapshots = []
        # local statistics are reset on each game restart
        self.stats = GameStatsStruct()
        self.startMoves()
        if restart:
            return
        # global statistics survive a game restart
        self.gstats = GameGlobalStatsStruct()
        self.gsaveinfo = GameGlobalSaveInfo()
        # some vars for win animation
        self.win_animation = GameWinAnimation()

    def getTitleName(self):
        return self.app.getGameTitleName(self.id)

    def getGameNumber(self, format):
        s = self.random.getSeedAsStr()
        if format:
            return "# " + s
        return s

    # this is called from within createGame()
    def setSize(self, w, h):
        self.width, self.height = int(round(w)), int(round(h))
        dx, dy = self.canvas.xmargin, self.canvas.ymargin
        self.init_size = self.width+2*dx, self.height+2*dy

    def setCursor(self, cursor):
        if self.canvas:
            self.canvas.config(cursor=cursor)
            # self.canvas.update_idletasks()
        # if self.app and self.app.toolbar:
        # self.app.toolbar.setCursor(cursor=cursor)

    def newGame(self, random=None, restart=0, autoplay=1, shuffle=True,
                dealer=None):
        self.finished = False
        old_busy, self.busy = self.busy, 1
        self.setCursor(cursor=CURSOR_WATCH)
        self.stopWinAnimation()
        self.disableMenus()
        if shuffle:
            self.redealAnimation()
        self.reset(restart=restart)
        self.resetGame()
        self.createRandom(random)
        if shuffle:
            self.shuffle()
            assert len(self.s.talon.cards) == self.gameinfo.ncards
        for stack in self.allstacks:
            stack.updateText()
        self.updateText()
        self.updateStatus(
            player=self.app.opt.player,
            gamenumber=self.getGameNumber(format=1),
            moves=(0, 0),
            stats=self.app.stats.getStats(
                self.app.opt.player,
                self.id),
            stuck='')
        reset_solver_dialog()
        # unhide toplevel when we use a progress bar
        if not self.preview:
            wm_map(self.top, maximized=self.app.opt.wm_maximized)
            self.top.busyUpdate()
        if TOOLKIT == 'gtk':
            # FIXME
            if self.top:
                self.top.update_idletasks()
                self.top.show_now()
        self.stopSamples()
        self.moves.state = self.S_INIT
        if dealer:
            dealer()
        else:
            self.startGame()
        self.startMoves()
        for stack in self.allstacks:
            stack.updateText()
        self.updateSnapshots()
        self.updateText()
        self.updateStatus(moves=(0, 0))
        self.updateMenus()
        self.stopSamples()
        if autoplay:
            self.autoPlay()
            self.stats.player_moves = 0
        self.setCursor(cursor=self.app.top_cursor)
        self.stats.update_time = time.time()
        if not self.preview:
            self.startPlayTimer()
        self.busy = old_busy

    def restoreGame(self, game, reset=1):
        old_busy, self.busy = self.busy, 1
        if reset:
            self.reset()
        self.resetGame()
        # 1) copy loaded variables
        self.filename = game.filename
        self.version = game.version
        self.version_tuple = game.version_tuple
        self.random = game.random
        self.moves = game.moves
        self.stats = game.stats
        self.gstats = game.gstats
        # 2) copy extra save-/loadinfo
        self.saveinfo = game.saveinfo
        self.gsaveinfo = game.gsaveinfo
        self.s.talon.round = game.loadinfo.talon_round
        self.finished = game.finished
        self.snapshots = game.snapshots
        # 3) move cards to stacks
        assert len(self.allstacks) == len(game.loadinfo.stacks)
        old_state = game.moves.state
        game.moves.state = self.S_RESTORE
        for i in range(len(self.allstacks)):
            for t in game.loadinfo.stacks[i]:
                card_id, face_up = t
                card = self.cards[card_id]
                if face_up:
                    card.showFace()
                else:
                    card.showBack()
                self.allstacks[i].addCard(card)
        game.moves.state = old_state
        # 4) update settings
        for stack_id, cap in self.saveinfo.stack_caps:
            # print stack_id, cap
            self.allstacks[stack_id].cap.update(cap.__dict__)
        # 5) subclass settings
        self._restoreGameHook(game)
        # 6) update view
        for stack in self.allstacks:
            stack.updateText()
        self.updateText()
        self.updateStatus(
            player=self.app.opt.player,
            gamenumber=self.getGameNumber(format=1),
            moves=(self.moves.index, self.stats.total_moves),
            stats=self.app.stats.getStats(self.app.opt.player, self.id))
        if not self.preview:
            self.updateMenus()
            wm_map(self.top, maximized=self.app.opt.wm_maximized)
        self.setCursor(cursor=self.app.top_cursor)
        self.stats.update_time = time.time()
        self.busy = old_busy
        # wait for canvas is mapped
        after(self.top, 200, self._configureHandler)
        if TOOLKIT == 'gtk':
            # FIXME
            if self.top:
                self.top.update_idletasks()
                self.top.show_now()
        self.startPlayTimer()

    def restoreGameFromBookmark(self, bookmark):
        old_busy, self.busy = self.busy, 1
        file = BytesIO(bookmark)
        p = Unpickler(file)
        game = self._undumpGame(p, self.app)
        assert game.id == self.id
        self.restoreGame(game, reset=0)
        destruct(game)
        self.busy = old_busy

    def resetGame(self):
        self.hints.list = None
        self.s.talon.removeAllCards()
        for stack in self.allstacks:
            stack.resetGame()
            if TOOLKIT == 'gtk':
                # FIXME (pyramid like games)
                stack.group.tkraise()
        if self.preview <= 1:
            for t in (self.texts.score, self.texts.base_rank,):
                if t:
                    t.config(text="")

    def nextGameFlags(self, id, random=None):
        f = 0
        if id != self.id:
            f |= 1
        if self.app.nextgame.cardset is not self.app.cardset:
            f |= 2
        if random is not None:
            if ((random.__class__ is not self.random.__class__) or
                    random.initial_seed != self.random.initial_seed):
                f |= 16
        return f

    # quit to outer mainloop in class App, possibly restarting
    # with another game from there
    def quitGame(self, id=0, random=None, loadedgame=None,
                 startdemo=0, bookmark=0, holdgame=0):
        self.updateTime()
        if bookmark:
            id, random = self.id, self.random
            f = BytesIO()
            self._dumpGame(Pickler(f, 1), bookmark=1)
            self.app.nextgame.bookmark = f.getvalue()
        if id > 0:
            self.setCursor(cursor=CURSOR_WATCH)
        self.app.nextgame.id = id
        self.app.nextgame.random = random
        self.app.nextgame.loadedgame = loadedgame
        self.app.nextgame.startdemo = startdemo
        self.app.nextgame.holdgame = holdgame
        self.updateStatus(time=None, moves=None, gamenumber=None, stats=None)
        self.top.mainquit()

    # This should be called directly before newGame(),
    # restoreGame(), restoreGameFromBookmark() and quitGame().
    def endGame(self, restart=0, bookmark=0, holdgame=0):
        if self.preview:
            return
        self.app.wm_save_state()
        if self.pause:
            self.doPause()
        if holdgame:
            return
        if bookmark:
            return
        if restart:
            if self.moves.index > 0 and self.getPlayerMoves() > 0:
                self.gstats.restarted += 1
            return
        self.updateStats()
        stats = self.app.stats
        if self.shallUpdateBalance():
            b = self.getGameBalance()
            if b:
                stats.total_balance[self.id] = \
                    stats.total_balance.get(self.id, 0) + b
                stats.session_balance[self.id] = \
                    stats.session_balance.get(self.id, 0) + b
                stats.gameid_balance = stats.gameid_balance + b

    def restartGame(self):
        self.endGame(restart=1)
        self.newGame(restart=1, random=self.random)

    def resizeImages(self):
        # resizing images and cards
        if self.app.opt.auto_scale:
            if self.canvas.winfo_ismapped():
                # apparent size of canvas
                vw = self.canvas.winfo_width()
                vh = self.canvas.winfo_height()
            else:
                # we have no a real size of canvas
                # (winfo_width / winfo_reqwidth)
                # so we use a saved size
                vw, vh = self.app.opt.game_geometry
                if not vw:
                    # first run of the game
                    return 1, 1
            # requested size of canvas (createGame -> setSize)
            iw, ih = self.init_size
            # calculate factor of resizing
            xf = float(vw)/iw
            yf = float(vh)/ih
            if self.app.opt.preserve_aspect_ratio:
                xf = yf = min(xf, yf)
        else:
            xf, yf = self.app.opt.scale_x, self.app.opt.scale_y
        # images
        self.app.images.resize(xf, yf)
        # cards
        for card in self.cards:
            card.update(card.id, card.deck, card.suit, card.rank, self)
        return xf, yf

    def resizeGame(self):
        # if self.busy:
        # return
        if not USE_PIL:
            return
        self.deleteStackDesc()
        xf, yf = self.resizeImages()
        for stack in self.allstacks:
            x0, y0 = stack.init_coord
            x, y = int(round(x0*xf)), int(round(y0*yf))
            stack.resize(xf, yf)
            stack.updatePositions()
        self.regions.calc_info(xf, yf)
        # texts
        for t in ('info', 'help', 'misc', 'score', 'base_rank'):
            init_coord = getattr(self.init_texts, t)
            if init_coord:
                item = getattr(self.texts, t)
                x, y = int(round(init_coord[0]*xf)), \
                    int(round(init_coord[1]*yf))
                self.canvas.coords(item, x, y)
        for i in range(len(self.texts.list)):
            init_coord = self.init_texts.list[i]
            item = self.texts.list[i]
            x, y = int(round(init_coord[0]*xf)), int(round(init_coord[1]*yf))
            self.canvas.coords(item, x, y)

    def createRandom(self, random):
        if random is None:
            if isinstance(self.random, PysolRandom):
                state = self.random.getstate()
                self.app.gamerandom.setstate(state)
            # we want at least 17 digits
            seed = self.app.gamerandom.randrange(
                int('10000000000000000'),
                PysolRandom.MAX_SEED
            )
            self.random = PysolRandom(seed)
            self.random.origin = self.random.ORIGIN_RANDOM
        else:
            self.random = random
            self.random.reset()

    def enterState(self, state):
        old_state = self.moves.state
        if state < old_state:
            self.moves.state = state
        return old_state

    def leaveState(self, old_state):
        self.moves.state = old_state

    def getSnapshot(self):
        # generate hash (unique string) of current move
        sn = []
        for stack in self.allstacks:
            s = []
            for card in stack.cards:
                s.append('%d%03d%d' % (card.suit, card.rank, card.face_up))
            sn.append(''.join(s))
        sn = '-'.join(sn)
        # optimisation
        sn = hash(sn)
        return sn

    def createSnGroups(self):
        # group stacks by class and cap
        sg = {}
        for s in self.allstacks:
            for k in sg:
                if s.__class__ is k.__class__ and \
                       s.cap.__dict__ == k.cap.__dict__:
                    g = sg[k]
                    g.append(s.id)
                    break
            else:
                # new group
                sg[s] = [s.id]
        sg = list(sg.values())
        self.sn_groups = sg

    def updateSnapshots(self):
        sn = self.getSnapshot()
        if sn in self.snapshots:
            # self.updateStatus(snapshot=True)
            pass
        else:
            self.snapshots.append(sn)
            # self.updateStatus(snapshot=False)

    # Create all cards for the game.
    def createCards(self, progress=None):
        gi = self.gameinfo
        pstep = 0
        if progress:
            pstep = (100.0 - progress.percent) / gi.ncards
        cards = []
        id = [0]
        x, y = self.s.talon.x, self.s.talon.y
        for deck in range(gi.decks):
            def _iter_ranks(ranks, suit):
                for rank in ranks:
                    card = self._createCard(id[0], deck, suit, rank, x=x, y=y)
                    if card is None:
                        continue
                    cards.append(card)
                    id[0] += 1
                    if progress:
                        progress.update(step=pstep)
            for suit in gi.suits:
                _iter_ranks(gi.ranks, suit)
            _iter_ranks(gi.trumps, len(gi.suits))
        if progress:
            progress.update(percent=100)
        assert len(cards) == gi.ncards
        return cards

    def _createCard(self, id, deck, suit, rank, x, y):
        return Card(id, deck, suit, rank, game=self, x=x, y=y)

    # shuffle cards
    def shuffle(self):
        # get a fresh copy of the original game-cards
        cards = list(self.cards)
        # init random generator
        if isinstance(self.random, LCRandom31):
            cards = ms_rearrange(cards)
        self.random.reset()         # reset to initial seed
        # shuffle
        self.random.shuffle(cards)
        # subclass hook
        cards = self._shuffleHook(cards)
        # finally add the shuffled cards to the Talon
        for card in cards:
            self.s.talon.addCard(card, update=0)
            card.showBack(unhide=0)

    # shuffle cards, but keep decks together
    def shuffleSeparateDecks(self):
        cards = []
        self.random.reset()
        n = self.gameinfo.ncards // self.gameinfo.decks
        for deck in range(self.gameinfo.decks):
            i = deck * n
            deck_cards = list(self.cards)[i:i+n]
            self.random.shuffle(deck_cards)
            cards.extend(deck_cards)
        cards = self._shuffleHook(cards)
        for card in cards:
            self.s.talon.addCard(card, update=0)
            card.showBack(unhide=0)

    # subclass overrideable (must use self.random)
    def _shuffleHook(self, cards):
        return cards

    # utility for use by subclasses
    def _shuffleHookMoveToTop(self, cards, func, ncards=999999):
        # move cards to top of the Talon (i.e. first cards to be dealt)
        cards, scards = self._shuffleHookMoveSorter(cards, func, ncards)
        return cards + scards

    def _shuffleHookMoveToBottom(self, cards, func, ncards=999999):
        # move cards to bottom of the Talon (i.e. last cards to be dealt)
        cards, scards = self._shuffleHookMoveSorter(cards, func, ncards)
        return scards + cards

    def _shuffleHookMoveSorter(self, cards, cb, ncards):
        extracted, i, new = [], len(cards), []
        for c in cards:
            select, ord_ = cb(c)
            if select:
                extracted.append((ord_, i, c))
                if len(extracted) >= ncards:
                    new += cards[(len(cards)-i+1):]
                    break
            else:
                new.append(c)
            i -= 1
        return new, [x[2] for x in reversed(sorted(extracted))]

    def _finishDrag(self):
        if self.demo:
            self.stopDemo()
        if self.busy:
            return 1
        if self.drag.stack:
            self.drag.stack.finishDrag()
        return 0

    def _cancelDrag(self, break_pause=True):
        self.stopWinAnimation()
        if self.demo:
            self.stopDemo()
        if break_pause and self.pause:
            self.doPause()
        self.interruptSleep()
        self.deleteStackDesc()
        if self.busy:
            return 1
        if self.drag.stack:
            self.drag.stack.cancelDrag()
        return 0

    def updateMenus(self):
        if not self.preview:
            self.app.menubar.updateMenus()

    def disableMenus(self):
        if not self.preview:
            self.app.menubar.disableMenus()

    def _defaultHandler(self, event):
        if not self.app:
            return True                 # FIXME (GTK)
        if not self.app.opt.mouse_undo:
            return True
        if self.pause:
            self.app.menubar.mPause()
            return True
        if not self.event_handled and self.stopWinAnimation():
            return True
        self.interruptSleep()
        if self.deleteStackDesc():
            # delete piles descriptions
            return True
        if self.demo:
            self.stopDemo()
            return True
        if not self.event_handled and self.drag.stack:
            self.drag.stack.cancelDrag(event)
            return True
        return False                    # continue this event

    def dropHandler(self, event):
        if not self._defaultHandler(event) and not self.event_handled:
            self.app.menubar.mDrop()
        self.event_handled = False
        return EVENT_PROPAGATE

    def undoHandler(self, event):
        if not self._defaultHandler(event) and not self.event_handled:
            self.app.menubar.mUndo()
        self.event_handled = False
        return EVENT_PROPAGATE

    def redoHandler(self, event):
        if not self._defaultHandler(event) and not self.event_handled:
            self.app.menubar.mRedo()
        self.event_handled = False
        return EVENT_PROPAGATE

    def updateStatus(self, **kw):
        if self.preview:
            return
        tb, sb = self.app.toolbar, self.app.statusbar
        for k, v in six.iteritems(kw):
            _updateStatus_process_key_val(tb, sb, k, v)

    def _unmapHandler(self, event):
        # pause game if root window has been iconified
        if self.app and not self.pause:
            self.app.menubar.mPause()

    _resizeHandlerID = None

    def _resizeHandler(self):
        self._resizeHandlerID = None
        self.resizeGame()

    def _configureHandler(self, event=None):
        if False:  # if not USE_PIL:
            return
        if not self.app:
            return
        if not self.canvas:
            return
        if not self.app.opt.auto_scale:
            return
        if self.preview:
            return
        if self._resizeHandlerID:
            self.canvas.after_cancel(self._resizeHandlerID)
        self._resizeHandlerID = self.canvas.after(250, self._resizeHandler)

    def playSample(self, name, priority=0, loop=0):
        if name in self.app.opt.sound_samples and \
               not self.app.opt.sound_samples[name]:
            return 0
        if self.app.audio:
            return self.app.audio.playSample(
                name,
                priority=priority,
                loop=loop)
        return 0

    def stopSamples(self):
        if self.app.audio:
            self.app.audio.stopSamples()

    def stopSamplesLoop(self):
        if self.app.audio:
            self.app.audio.stopSamplesLoop()

    def startDealSample(self, loop=999999):
        a = self.app.opt.animations
        if a and not self.preview:
            self.canvas.update_idletasks()
        if self.app.audio and self.app.opt.sound \
                and self.app.opt.sound_samples['deal']:
            if a in (1, 2, 3, 10):
                self.playSample("deal01", priority=100, loop=loop)
            elif a == 4:
                self.playSample("deal04", priority=100, loop=loop)
            elif a == 5:
                self.playSample("deal08", priority=100, loop=loop)

    def areYouSure(self, title=None, text=None, confirm=-1, default=0):
        if TOOLKIT == 'kivy':
            return True
        if self.preview:
            return True
        if confirm < 0:
            confirm = self.app.opt.confirm
        if confirm:
            if not title:
                title = TITLE
            if not text:
                text = _("Discard current game?")
            self.playSample("areyousure")
            d = MfxMessageDialog(self.top, title=title, text=text,
                                 bitmap="question",
                                 strings=(_("&OK"), _("&Cancel")))
            if d.status != 0 or d.button != 0:
                return False
        return True

    def notYetImplemented(self):
        MfxMessageDialog(self.top, title="Not yet implemented",
                         text="This function is\nnot yet implemented.",
                         bitmap="error")

    # main animation method
    def animatedMoveTo(self, from_stack, to_stack, cards, x, y,
                       tkraise=1, frames=-1, shadow=-1):
        # available values of app.opt.animations:
        # 0 - without animations
        # 1 - very fast (without timer)
        # 2 - fast (default)
        # 3 - medium (2/3 of fast speed)
        # 4 - slow (1/4 of fast speed)
        # 5 - very slow (1/8 of fast speed)
        # 10 - used internally in game preview
        if self.app.opt.animations == 0 or frames == 0:
            return
        # init timer - need a high resolution for this to work
        clock, delay, skip = None, 1, 1
        if self.app.opt.animations >= 2:
            clock = uclock
        SPF = 0.15 / 8          # animation speed - seconds per frame
        if frames < 0:
            frames = 8
        assert frames >= 2
        if self.app.opt.animations == 3:        # medium
            frames *= 3
            SPF /= 2
        elif self.app.opt.animations == 4:      # slow
            frames *= 8
            SPF /= 2
        elif self.app.opt.animations == 5:      # very slow
            frames *= 16
            SPF /= 2
        elif self.app.opt.animations == 10:
            # this is used internally in game preview to speed up
            # the initial dealing
            if self.moves.state == self.S_INIT and frames > 4:
                frames //= 2
        if shadow < 0:
            shadow = self.app.opt.shadow
        shadows = ()
        # start animation
        if TOOLKIT == 'kivy':
            c0 = cards[0]
            dx, dy = (x - c0.x), (y - c0.y)
            for card in cards:
                base = float(self.app.opt.animations)
                duration = base*0.1
                card.animatedMove(dx, dy, duration)
            return

        if tkraise:
            for card in cards:
                card.tkraise()
        c0 = cards[0]
        dx, dy = (x - c0.x) / float(frames), (y - c0.y) / float(frames)
        tx, ty = 0, 0
        i = 1
        if clock:
            starttime = clock()
        while i < frames:
            mx, my = int(round(dx * i)) - tx, int(round(dy * i)) - ty
            tx, ty = tx + mx, ty + my
            if i == 1 and shadow and from_stack:
                # create shadows in the first frame
                sx, sy = self.app.images.SHADOW_XOFFSET, \
                    self.app.images.SHADOW_YOFFSET
                shadows = from_stack.createShadows(cards, sx, sy)
            for s in shadows:
                s.move(mx, my)
            for card in cards:
                card.moveBy(mx, my)
            self.canvas.update_idletasks()
            step = 1
            if clock:
                endtime = starttime + i*SPF
                sleep = endtime - clock()
                if delay and sleep >= 0.005:
                    # we're fast - delay
                    # print "Delay frame", i, sleep
                    usleep(sleep)
                elif skip and sleep <= -0.75*SPF:
                    # we're slow - skip 1 or 2 frames
                    # print "Skip frame", i, sleep
                    step += 1
                    if frames > 4 and sleep < -1.5*SPF:
                        step += 1
                # print i, step, mx, my; time.sleep(0.5)
            i += step
        # last frame: delete shadows, move card to final position
        for s in shadows:
            s.delete()
        dx, dy = x - c0.x, y - c0.y
        for card in cards:
            card.moveBy(dx, dy)
        self.canvas.update_idletasks()

    def doAnimatedFlipAndMove(self, from_stack, to_stack=None, frames=-1):
        if self.app.opt.animations == 0 or frames == 0:
            return False
        if not from_stack.cards:
            return False
        if TOOLKIT == 'gtk':
            return False
        if not Image:
            return False

        canvas = self.canvas
        card = from_stack.cards[-1]
        im1 = card._active_image._pil_image
        if card.face_up:
            im2 = card._back_image._pil_image
        else:
            im2 = card._face_image._pil_image
        w, h = im1.size
        id = card.item.id

        SPF = 0.1/8                     # animation speed - seconds per frame
        frames = 4.0                    # num frames for each step
        if self.app.opt.animations == 3:  # medium
            SPF = 0.1/8
            frames = 7.0
        elif self.app.opt.animations == 4:  # slow
            SPF = 0.1/8
            frames = 12.0
        elif self.app.opt.animations == 5:  # very slow
            SPF = 0.1/8
            frames = 24.0

        if to_stack is None:
            x0, y0 = from_stack.getPositionFor(card)
            x1, y1 = x0, y0
            dest_x, dest_y = 0, 0
        else:
            x0, y0 = from_stack.getPositionFor(card)
            x1, y1 = to_stack.getPositionForNextCard()
            dest_x, dest_y = x1-x0, y1-y0

        if dest_x == 0 and dest_y == 0:
            # flip
            # ascent_dx, ascent_dy = 0, self.app.images.SHADOW_YOFFSET/frames
            ascent_dx, ascent_dy = 0, h/10.0/frames
            min_size = w/10
            shrink_dx = (w-min_size) / (frames-1)
            shrink_dy = 0
        elif dest_y == 0:
            # move to left/right waste
            # ascent_dx, ascent_dy = 0, self.app.images.SHADOW_YOFFSET/frames
            ascent_dx, ascent_dy = 0, h/10.0/frames
            min_size = w/10
            shrink_dx = (w-min_size) / (frames-1)
            shrink_dy = 0
        elif dest_x == 0:
            # move to top/bottom waste
            if 0:
                ascent_dx, ascent_dy = 0, h/10.0/frames
                min_size = w/10
                shrink_dx = (w-min_size) / (frames-1)
                shrink_dy = 0
            elif 0:
                ascent_dx, ascent_dy = 0, 0
                min_size = h/10
                shrink_dx = 0
                shrink_dy = (h-min_size) / (frames-1)
            else:
                return False
        else:
            # dest_x != 0 and dest_y != 0
            return False

        move_dx = dest_x / frames / 2
        move_dy = dest_y / frames / 2
        xpos, ypos = float(x0), float(y0)

        card.tkraise()

        # step 1
        d_x = shrink_dx/2+move_dx-ascent_dx
        d_y = shrink_dy/2+move_dy-ascent_dy
        nframe = 0
        while nframe < frames:
            starttime = uclock()
            # resize img
            ww = w - nframe*shrink_dx
            hh = h - nframe*shrink_dy
            tmp = im1.resize((int(ww), int(hh)))
            tk_tmp = ImageTk.PhotoImage(image=tmp)
            canvas.itemconfig(id, image=tk_tmp)
            # move img
            xpos += d_x
            ypos += d_y
            card.moveTo(int(round(xpos)), int(round(ypos)))
            canvas.update_idletasks()

            nframe += 1
            t = (SPF-(uclock()-starttime))*1000   # milliseconds
            if t > 0:
                usleep(t/1000)
                # else:
                # nframe += 1
                # xpos += d_x
                # ypos += d_y

        # step 2
        d_x = -shrink_dx/2+move_dx+ascent_dx
        d_y = -shrink_dy/2+move_dy+ascent_dy
        nframe = 0
        while nframe < frames:
            starttime = uclock()
            # resize img
            ww = w - (frames-nframe-1)*shrink_dx
            hh = h - (frames-nframe-1)*shrink_dy
            tmp = im2.resize((int(ww), int(hh)))
            tk_tmp = ImageTk.PhotoImage(image=tmp)
            canvas.itemconfig(id, image=tk_tmp)
            # move img
            xpos += d_x
            ypos += d_y
            card.moveTo(int(round(xpos)), int(round(ypos)))
            canvas.update_idletasks()

            nframe += 1
            t = (SPF-(uclock()-starttime))*1000  # milliseconds
            if t > 0:
                usleep(t/1000)
                # else:
                # nframe += 1
                # xpos += d_x
                # ypos += d_y

        card.moveTo(x1, y1)
        # canvas.update_idletasks()
        return True

    def animatedFlip(self, stack):
        if not self.app.opt.flip_animation:
            return False
        return self.doAnimatedFlipAndMove(stack)

    def animatedFlipAndMove(self, from_stack, to_stack, frames=-1):
        if not self.app.opt.flip_animation:
            return False
        return self.doAnimatedFlipAndMove(from_stack, to_stack, frames)

    def winAnimationEvent(self):
        # based on code from pygtk-demo
        FRAME_DELAY = 80
        CYCLE_LEN = 60
        starttime = uclock()
        images = self.win_animation.images
        saved_images = self.win_animation.saved_images  # cached images
        canvas = self.canvas
        canvas.delete(*self.win_animation.canvas_images)
        self.win_animation.canvas_images = []

        x0 = int(int(canvas.cget('width'))*(canvas.xview()[0]))
        y0 = int(int(canvas.cget('height'))*(canvas.yview()[0]))
        width, height = self.win_animation.width, self.win_animation.height
        cw = self.canvas.winfo_width()
        ch = self.canvas.winfo_height()
        x0 -= (width-cw)/2
        y0 -= (height-ch)/2

        tmp_tk_images = []
        raised_images = []
        n_images = len(images)
        xmid = width / 2.0
        ymid = height / 2.0
        radius = min(xmid, ymid) / 2.0

        f = float(self.win_animation.frame_num % CYCLE_LEN) / float(CYCLE_LEN)
        r = radius + (radius / 3.0) * math.sin(f * 2.0 * math.pi)
        img_index = 0

        for im in images:

            iw, ih = im.size

            ang = 2.0 * math.pi * img_index / n_images - f * 2.0 * math.pi
            xpos = x0 + int(xmid + r * math.cos(ang) - iw / 2.0)
            ypos = y0 + int(ymid + r * math.sin(ang) - ih / 2.0)

            k = (math.sin if img_index & 1 else math.cos)(f * 2.0 * math.pi)
            k = max(0.4, k ** 2)
            round_k = int(round(k*100))
            if img_index not in saved_images:
                saved_images[img_index] = {}
            if round_k in saved_images[img_index]:
                tk_tmp = saved_images[img_index][round_k]
            else:
                new_size = (int(iw*k), int(ih*k))
                if round_k == 100:
                    tmp = im
                else:
                    tmp = im.resize(new_size, resample=Image.BILINEAR)
                tk_tmp = ImageTk.PhotoImage(image=tmp)
                saved_images[img_index][round_k] = tk_tmp

            id = canvas.create_image(xpos, ypos, image=tk_tmp, anchor='nw')
            self.win_animation.canvas_images.append(id)
            if k > 0.6:
                raised_images.append(id)
            tmp_tk_images.append(tk_tmp)

            img_index += 1

        for id in raised_images:
            canvas.tag_raise(id)
        self.win_animation.frame_num = \
            (self.win_animation.frame_num+1) % CYCLE_LEN
        self.win_animation.tk_images = tmp_tk_images
        canvas.update_idletasks()
        # loop
        t = FRAME_DELAY-int((uclock()-starttime)*1000)
        if t > 0:
            self.win_animation.timer = after(canvas, t, self.winAnimationEvent)
        else:
            self.win_animation.timer = after_idle(
                canvas,
                self.winAnimationEvent)

    def stopWinAnimation(self):
        if self.win_animation.timer:
            after_cancel(self.win_animation.timer)  # stop loop
            self.win_animation.timer = None
            self.canvas.delete(*self.win_animation.canvas_images)
            self.win_animation.canvas_images = []
            self.win_animation.tk_images = []  # delete all images
            self.saved_images = {}
            self.canvas.showAllItems()
            return True
        return False

    def winAnimation(self, perfect=0):
        if self.preview:
            return
        if not self.app.opt.win_animation:
            return
        if TOOLKIT == 'gtk':
            return
        if not Image:
            return
        self.canvas.hideAllItems()
        # select some random cards
        cards = self.cards[:]
        scards = []
        ncards = min(10, len(cards))
        for i in range(ncards):
            c = self.app.miscrandom.choice(cards)
            scards.append(c)
            cards.remove(c)
        for c in scards:
            self.win_animation.images.append(c._face_image._pil_image)
        # compute visible geometry
        self.win_animation.width = self.canvas.winfo_width()
        self.win_animation.height = self.canvas.winfo_height()
        # run win animation in background
        # after_idle(self.canvas, self.winAnimationEvent)
        after(self.canvas, 200, self.winAnimationEvent)
        return

    def redealAnimation(self):
        if self.preview:
            return
        if not self.app.opt.animations or not self.app.opt.redeal_animation:
            return
        cards = []
        for s in self.allstacks:
            if s is not self.s.talon:
                for c in s.cards:
                    cards.append((c, s))
        if not cards:
            return
        self.setCursor(cursor=CURSOR_WATCH)
        self.top.busyUpdate()
        self.canvas.update_idletasks()
        old_a = self.app.opt.animations
        if old_a == 0:
            self.app.opt.animations = 1     # very fast
        elif old_a == 3:                    # medium
            self.app.opt.animations = 2     # fast
        elif old_a == 4:                    # very slow
            self.app.opt.animations = 3     # slow
        # select some random cards
        acards = []
        scards = cards[:]
        for i in range(8):
            c, s = self.app.miscrandom.choice(scards)
            if c not in acards:
                acards.append(c)
                scards.remove((c, s))
                if not scards:
                    break
        # animate
        sx, sy = self.s.talon.x, self.s.talon.y
        w, h = self.width, self.height
        while cards:
            # get and un-tuple a random card
            t = self.app.miscrandom.choice(cards)
            c, s = t
            s.removeCard(c, update=0)
            # animation
            if c in acards or len(cards) <= 2:
                self.animatedMoveTo(
                    s, None, [c], w//2, h//2, tkraise=0, shadow=0)
                self.animatedMoveTo(s, None, [c], sx, sy, tkraise=0, shadow=0)
            else:
                c.moveTo(sx, sy)
            cards.remove(t)
        self.app.opt.animations = old_a

    def sleep(self, seconds):
        # if 0 and self.canvas:
        # self.canvas.update_idletasks()
        if seconds > 0:
            if self.top:
                self.top.interruptSleep()
                self.top.sleep(seconds)
            else:
                time.sleep(seconds)

    def interruptSleep(self):
        if self.top:
            self.top.interruptSleep()

    def getCardFaceImage(self, deck, suit, rank):
        return self.app.images.getFace(deck, suit, rank)

    def getCardBackImage(self, deck, suit, rank):
        return self.app.images.getBack()

    def getCardShadeImage(self):
        return self.app.images.getShade()

    def _getClosestStack(self, cx, cy, stacks, dragstack):
        closest, cdist = None, 999999999
        # Since we only compare distances,
        # we don't bother to take the square root.
        for stack in stacks:
            dist = (stack.x - cx)**2 + (stack.y - cy)**2
            if dist < cdist:
                closest, cdist = stack, dist
        return closest

    def getClosestStack(self, card, dragstack):
        cx, cy = card.x, card.y
        for stacks, rect in self.regions.info:
            if cx >= rect[0] and cx < rect[2] \
                    and cy >= rect[1] and cy < rect[3]:
                return self._getClosestStack(cx, cy, stacks, dragstack)
        return self._getClosestStack(cx, cy, self.regions.remaining, dragstack)

    # define a region for use in getClosestStack()
    def setRegion(self, stacks, rect, priority=0):
        assert len(stacks) > 0
        assert len(rect) == 4 and rect[0] < rect[2] and rect[1] < rect[3]
        if DEBUG >= 2:
            xf, yf = self.app.images._xfactor, self.app.images._yfactor
            MfxCanvasRectangle(self.canvas,
                               xf*rect[0], yf*rect[1], xf*rect[2], yf*rect[3],
                               width=2, fill=None, outline='red')
        for s in stacks:
            assert s and s in self.allstacks
            # verify that the stack lies within the rectangle
            r = rect
            if USE_PIL:
                x, y = s.init_coord
            else:
                x, y = s.x, s.y
            assert r[0] <= x <= r[2] and r[1] <= y <= r[3]
            # verify that the stack is not already in another region
            # with the same priority
            for d in self.regions.data:
                if priority == d[0]:
                    assert s not in d[2]
        # add to regions
        self.regions.data.append(
            (priority, -len(self.regions.data), tuple(stacks), tuple(rect)))

    # as getClosestStack() is called within the mouse motion handler
    # event it is worth optimizing a little bit
    def optimizeRegions(self):
        return self.regions.optimize(list(self.sg.openstacks))

    def getInvisibleCoords(self):
        # for InvisibleStack, etc
        # x, y = -500, -500 - len(game.allstacks)
        cardw, cardh = self.app.images.CARDW, self.app.images.CARDH
        x, y = cardw + self.canvas.xmargin, cardh + self.canvas.ymargin
        return -x-10, -y-10

    #
    # Game - subclass overridable actions - IMPORTANT FOR GAME LOGIC
    #

    # create the game (create stacks, texts, etc.)
    def createGame(self):
        raise SubclassResponsibility

    # start the game (i.e. deal initial cards)
    def startGame(self):
        raise SubclassResponsibility

    # can we deal cards ?
    def canDealCards(self):
        # default: ask the Talon
        return self.s.talon and self.s.talon.canDealCards()

    # deal cards - return number of cards dealt
    def dealCards(self, sound=True):
        # default: set state to deal and pass dealing to Talon
        if self.s.talon and self.canDealCards():
            self.finishMove()
            old_state = self.enterState(self.S_DEAL)
            n = self.s.talon.dealCards(sound=sound)
            self.leaveState(old_state)
            self.finishMove()
            if not self.checkForWin():
                self.autoPlay()
            return n
        return 0

    # fill a stack if rules require it (e.g. Picture Gallery)
    def fillStack(self, stack):
        pass

    # redeal cards (used in RedealTalonStack; all cards already in talon)
    def redealCards(self):
        pass

    # the actual hint class (or None)
    Hint_Class = DefaultHint
    Solver_Class = None
    Stuck_Class = None

    def getHintClass(self):
        return self.Hint_Class

    def getStrictness(self):
        return 0

    def canSaveGame(self):
        return True

    def canLoadGame(self, version_tuple, game_version):
        return self.GAME_VERSION == game_version

    def canSetBookmark(self):
        return self.canSaveGame()

    def canUndo(self):
        return True

    def canRedo(self):
        return self.canUndo()

    # Mahjongg
    def canShuffle(self):
        return False

    # game changed - i.e. should we ask the player to discard the game
    def changed(self, restart=False):
        if self.gstats.updated < 0:
            return 0                    # already won or lost
        if self.gstats.loaded > 0:
            return 0                    # loaded games account for no stats
        if not restart:
            if self.gstats.restarted > 0:
                return 1                # game was restarted - always ask
            if self.gstats.goto_bookmark_moves > 0:
                return 1
        if self.moves.index == 0 or self.getPlayerMoves() == 0:
            return 0
        return 2

    def getWinStatus(self):
        won = self.isGameWon() != 0
        if not won or self.stats.hints > 0 or self.stats.demo_moves > 0:
            # sorry, you lose
            return won, 0, self.U_LOST
        if _stats__is_perfect(self.stats):
            return won, 2, self.U_PERFECT
        return won, 1, self.U_WON

    # update statistics when a game was won/ended/canceled/...
    def updateStats(self, demo=0):
        if self.preview:
            return ''
        if not demo:
            self.stopPlayTimer()
        won, status, updated = self.getWinStatus()
        if demo and self.getPlayerMoves() == 0:
            if not self.stats.demo_updated:
                # a pure demo game - update demo stats
                self.stats.demo_updated = updated
                self.app.stats.updateStats(None, self, won)
            return ''
        elif self.changed():
            # must update player stats
            self.gstats.updated = updated
            if self.app.opt.update_player_stats:
                ret = self.app.stats.updateStats(
                    self.app.opt.player, self, status)
                self.updateStatus(
                    stats=self.app.stats.getStats(
                        self.app.opt.player, self.id))
                top_msg = ''
                if ret:
                    if ret[0] and ret[1]:
                        top_msg = _(
                            '\nYou have reached\n# %(timerank)d in the top ' +
                            '%(tops)d of playing time\nand # %(movesrank)d ' +
                            'in the top %(tops)d of moves.') % {
                                'timerank': ret[0],
                                'movesrank': ret[1],
                                'tops': TOP_SIZE}
                    elif ret[0]:        # playing time
                        top_msg = _(
                            '\nYou have reached\n# %(timerank)d in the top ' +
                            '%(tops)d of playing time.') % {
                                'timerank': ret[0],
                                'tops': TOP_SIZE}
                    elif ret[1]:        # moves
                        top_msg = _(
                            '\nYou have reached\n# %(movesrank)d in the top ' +
                            '%(tops)s of moves.') % {
                                'movesrank': ret[1],
                                'tops': TOP_SIZE}
                return top_msg
        elif not demo:
            # only update the session log
            if self.app.opt.update_player_stats:
                if self.gstats.loaded:
                    self.app.stats.updateStats(self.app.opt.player, self, -2)
                elif self.gstats.updated == 0 and self.stats.demo_updated == 0:
                    self.app.stats.updateStats(self.app.opt.player, self, -1)
        return ''

    def checkForWin(self):
        won, status, updated = self.getWinStatus()
        if not won:
            return False
        self.finishMove()       # just in case
        if self.preview:
            return True
        if self.finished:
            return True
        if self.demo:
            return status
        if TOOLKIT == 'kivy':
            if not self.app.opt.display_win_message:
                return True
            self.top.waitAnimation()
        if status == 2:
            top_msg = self.updateStats()
            time = self.getTime()
            self.finished = True
            self.playSample("gameperfect", priority=1000)
            self.winAnimation(perfect=1)
            text = ungettext('Your playing time is %(time)s\nfor %(n)d move.',
                             'Your playing time is %(time)s\nfor %(n)d moves.',
                             self.moves.index)
            text = text % {'time': time, 'n': self.moves.index}
            congrats = _('Congratulations, this\nwas a truly perfect game!')
            d = MfxMessageDialog(
                self.top, title=_("Game won"),
                text='\n' + congrats + '\n\n' + text + '\n' + top_msg + '\n',
                strings=(_("&New game"), None, _("&Cancel")),
                image=self.app.gimages.logos[5])
        elif status == 1:
            top_msg = self.updateStats()
            time = self.getTime()
            self.finished = True
            self.playSample("gamewon", priority=1000)
            self.winAnimation()
            text = ungettext('Your playing time is %(time)s\nfor %(n)d move.',
                             'Your playing time is %(time)s\nfor %(n)d moves.',
                             self.moves.index)
            text = text % {'time': time, 'n': self.moves.index}
            congrats = _('Congratulations, you did it!')
            d = MfxMessageDialog(
                self.top, title=_("Game won"),
                text='\n' + congrats + '\n\n' + text + '\n' + top_msg + '\n',
                strings=(_("&New game"), None, _("&Cancel")),
                image=self.app.gimages.logos[4])
        elif self.gstats.updated < 0:
            self.finished = True
            self.playSample("gamefinished", priority=1000)
            d = MfxMessageDialog(
                self.top, title=_("Game finished"), bitmap="info",
                text=_("\nGame finished\n"),
                strings=(_("&New game"), None, _("&Cancel")))
        else:
            self.finished = True
            self.playSample("gamelost", priority=1000)
            d = MfxMessageDialog(
                self.top, title=_("Game finished"), bitmap="info",
                text=_("\nGame finished, but not without my help...\n"),
                strings=(_("&New game"), _("&Restart"), _("&Cancel")))
        self.updateMenus()
        if TOOLKIT == 'kivy':
            return True
        if d.status == 0 and d.button == 0:
            # new game
            self.endGame()
            self.newGame()
        elif d.status == 0 and d.button == 1:
            # restart game
            self.restartGame()
        return True

    #
    # Game - subclass overridable methods (but usually not)
    #

    def isGameWon(self):
        # default: all Foundations must be filled
        return sum([len(s.cards) for s in self.s.foundations]) == \
            len(self.cards)

    def getFoundationDir(self):
        for s in self.s.foundations:
            if len(s.cards) >= 2:
                return s.getRankDir()
        return 0

    # determine the real number of player_moves
    def getPlayerMoves(self):
        return self.stats.player_moves

    def updateTime(self):
        if self.finished or self.pause:
            return
        t = time.time()
        d = t - self.stats.update_time
        if d > 0:
            self.stats.elapsed_time += d
            self.gstats.total_elapsed_time += d
        self.stats.update_time = t

    def getTime(self):
        self.updateTime()
        t = int(self.stats.elapsed_time)
        return format_time(t)

    #
    # Game - subclass overridable intelligence
    #

    def getAutoStacks(self, event=None):
        # returns (flipstacks, dropstacks, quickplaystacks)
        # default: sg.dropstacks
        return (self.sg.dropstacks, self.sg.dropstacks, self.sg.dropstacks)

    # handles autofaceup, autodrop and autodeal
    def autoPlay(self, autofaceup=-1, autodrop=-1, autodeal=-1, sound=True):
        if self.demo:
            return 0
        old_busy, self.busy = self.busy, 1
        if autofaceup < 0:
            autofaceup = self.app.opt.autofaceup
        if autodrop < 0:
            autodrop = self.app.opt.autodrop
        if autodeal < 0:
            autodeal = self.app.opt.autodeal
        moves = self.stats.total_moves
        n = self._autoPlay(autofaceup, autodrop, autodeal, sound=sound)
        self.finishMove()
        self.stats.autoplay_moves += (self.stats.total_moves - moves)
        self.busy = old_busy
        return n

    def _autoPlay(self, autofaceup, autodrop, autodeal, sound):
        flipstacks, dropstacks, quickstacks = self.getAutoStacks()
        done_something = 1
        while done_something:
            done_something = 0
            # a) flip top cards face-up
            if autofaceup and flipstacks:
                for s in flipstacks:
                    if s.canFlipCard():
                        if sound:
                            self.playSample("autoflip", priority=5)
                        # ~s.flipMove()
                        s.flipMove(animation=True)
                        done_something = 1
                        # each single flip is undo-able unless opt.autofaceup
                        self.finishMove()
                        if self.checkForWin():
                            return 1
            # b) drop cards
            if autodrop and dropstacks:
                for s in dropstacks:
                    to_stack, ncards = s.canDropCards(self.s.foundations)
                    if to_stack:
                        # each single drop is undo-able (note that this call
                        # is before the actual move)
                        self.finishMove()
                        if sound:
                            self.playSample("autodrop", priority=30)
                        s.moveMove(ncards, to_stack)
                        done_something = 1
                        if self.checkForWin():
                            return 1
            # c) deal
            if autodeal:
                if self._autoDeal(sound=sound):
                    done_something = 1
                    self.finishMove()
                    if self.checkForWin():
                        return 1
        return 0

    def _autoDeal(self, sound=True):
        # default: deal a card to the waste if the waste is empty
        w = self.s.waste
        if w and len(w.cards) == 0 and self.canDealCards():
            return self.dealCards(sound=sound)
        return 0

    def autoDrop(self, autofaceup=-1):
        old_a = self.app.opt.animations
        if old_a == 3:                   # medium
            self.app.opt.animations = 2  # fast
        self.autoPlay(autofaceup=autofaceup, autodrop=1)
        self.app.opt.animations = old_a

    # for find_card_dialog
    def highlightCard(self, suit, rank):
        if not self.app:
            return None
        col = self.app.opt.colors['samerank_1']
        info = []
        for s in self.allstacks:
            for c in s.cards:
                if c.suit == suit and c.rank == rank:
                    if s.basicShallHighlightSameRank(c):
                        info.append((s, c, c, col))
        return self._highlightCards(info, 0)

    # highlight all moveable piles
    def getHighlightPilesStacks(self):
        # default: dropstacks with min pile length = 2
        if self.sg.hp_stacks:
            return ((self.sg.hp_stacks, 2),)
        return ()

    def _highlightCards(self, info, sleep=1.5, delta=(1, 1, 1, 1)):
        if not info:
            return 0
        if self.pause:
            return 0
        self.stopWinAnimation()
        cw, ch = self.app.images.getSize()
        items = []
        for s, c1, c2, color in info:
            items.append(
                _highlightCards__calc_item(
                    self.canvas, delta, cw, ch, s, c1, c2, color))
        if not items:
            return 0
        self.canvas.update_idletasks()
        if sleep:
            self.sleep(sleep)
            items.reverse()
            for r in items:
                r.delete()
            self.canvas.update_idletasks()
            return EVENT_HANDLED
        else:
            # remove items later (find_card_dialog)
            return items

    def highlightNotMatching(self):
        if self.demo:
            return
        if not self.app.opt.highlight_not_matching:
            return
        # compute visible geometry
        x = int(int(self.canvas.cget('width'))*(self.canvas.xview()[0]))
        y = int(int(self.canvas.cget('height'))*(self.canvas.yview()[0]))
        w, h = self.canvas.winfo_width(), self.canvas.winfo_height()

        color = self.app.opt.colors['not_matching']
        width = 6
        xmargin, ymargin = self.canvas.xmargin, self.canvas.ymargin
        if self.preview:
            width = 4
            xmargin, ymargin = 0, 0
        x0, y0 = x+width//2-xmargin, y+width//2-ymargin
        x1, y1 = x+w-width//2-xmargin, y+h-width//2-ymargin
        r = MfxCanvasRectangle(self.canvas, x0, y0, x1, y1,
                               width=width, fill=None, outline=color)

        if TOOLKIT == "kivy":
            r.canvas.canvas.ask_update()
            r.delete_deferred(self.app.opt.timeouts['highlight_cards'])
            return

        self.canvas.update_idletasks()
        self.sleep(self.app.opt.timeouts['highlight_cards'])
        r.delete()
        self.canvas.update_idletasks()

    def highlightPiles(self, sleep=1.5):
        stackinfo = self.getHighlightPilesStacks()
        if not stackinfo:
            self.highlightNotMatching()
            return 0
        col = self.app.opt.colors['piles']
        hi = []
        for si in stackinfo:
            for s in si[0]:
                pile = s.getPile()
                if pile and len(pile) >= si[1]:
                    hi.append((s, pile[0], pile[-1], col))
        if not hi:
            self.highlightNotMatching()
            return 0
        return self._highlightCards(hi, sleep)

    #
    # highlight matching cards
    #

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return False

    def _shallHighlightMatch_AC(self, stack1, card1, stack2, card2):
        # by alternate color
        return card1.color != card2.color and abs(card1.rank-card2.rank) == 1

    def _shallHighlightMatch_ACW(self, stack1, card1, stack2, card2):
        # by alternate color with wrapping (only for french games)
        return (card1.color != card2.color and
                ((card1.rank + 1) % 13 == card2.rank or
                 (card2.rank + 1) % 13 == card1.rank))

    def _shallHighlightMatch_SS(self, stack1, card1, stack2, card2):
        # by same suit
        return card1.suit == card2.suit and abs(card1.rank-card2.rank) == 1

    def _shallHighlightMatch_SSW(self, stack1, card1, stack2, card2):
        # by same suit with wrapping (only for french games)
        return (card1.suit == card2.suit and
                ((card1.rank + 1) % 13 == card2.rank or
                 (card2.rank + 1) % 13 == card1.rank))

    def _shallHighlightMatch_RK(self, stack1, card1, stack2, card2):
        # by rank
        return abs(card1.rank-card2.rank) == 1

    def _shallHighlightMatch_RKW(self, stack1, card1, stack2, card2):
        # by rank with wrapping (only for french games)
        return ((card1.rank + 1) % 13 == card2.rank or
                (card2.rank + 1) % 13 == card1.rank)

    def _shallHighlightMatch_BO(self, stack1, card1, stack2, card2):
        # by any suit but own
        return card1.suit != card2.suit and abs(card1.rank-card2.rank) == 1

    def _shallHighlightMatch_BOW(self, stack1, card1, stack2, card2):
        # by any suit but own with wrapping (only for french games)
        return (card1.suit != card2.suit and
                ((card1.rank + 1) % 13 == card2.rank or
                 (card2.rank + 1) % 13 == card1.rank))

    def _shallHighlightMatch_SC(self, stack1, card1, stack2, card2):
        # by same color
        return card1.color == card2.color and abs(card1.rank-card2.rank) == 1

    def _shallHighlightMatch_SCW(self, stack1, card1, stack2, card2):
        # by same color with wrapping (only for french games)
        return (card1.color == card2.color and
                ((card1.rank + 1) % 13 == card2.rank or
                 (card2.rank + 1) % 13 == card1.rank))

    def getQuickPlayScore(self, ncards, from_stack, to_stack):
        if to_stack in self.s.reserves:
            # if to_stack in reserves prefer empty stack
            # return 1000 - len(to_stack.cards)
            return 1000 - int(len(to_stack.cards) != 0)
        # prefer non-empty piles in to_stack
        return 1001 + int(len(to_stack.cards) != 0)

    def _getSpiderQuickPlayScore(self, ncards, from_stack, to_stack):
        if to_stack in self.s.reserves:
            # if to_stack in reserves prefer empty stack
            return 1000-len(to_stack.cards)
        # for spider-type stacks
        if to_stack.cards:
            # check suit
            same_suit = (from_stack.cards[-ncards].suit ==
                         to_stack.cards[-1].suit)
            return int(same_suit)+1002
        return 1001

    #
    # Score (I really don't like scores in Patience games...)
    #

    # update game-related canvas texts (i.e. self.texts)
    def updateText(self):
        pass

    def getGameScore(self):
        return None

    # casino type scoring
    def getGameScoreCasino(self):
        v = -len(self.cards)
        for s in self.s.foundations:
            v = v + 5 * len(s.cards)
        return v

    def shallUpdateBalance(self):
        # Update the balance unless this is a loaded game or
        # a manually selected game number.
        if self.gstats.loaded:
            return False
        if self.random.origin == self.random.ORIGIN_SELECTED:
            return False
        return True

    def getGameBalance(self):
        return 0

    # compute all hints for the current position
    # this is the only method that actually uses class Hint
    def getHints(self, level, taken_hint=None):
        if level == 3:
            # if self.solver is None:
            # return None
            return self.solver.getHints(taken_hint)
        hint_class = self.getHintClass()
        if hint_class is None:
            return None
        hint = hint_class(self, level)      # call constructor
        return hint.getHints(taken_hint)    # and return all hints

    # give a hint
    def showHint(self, level=0, sleep=1.5, taken_hint=None):
        if self.getHintClass() is None:
            self.highlightNotMatching()
            return None
        # reset list if level has changed
        if level != self.hints.level:
            self.hints.level = level
            self.hints.list = None
        # compute all hints
        if self.hints.list is None:
            self.hints.list = self.getHints(level, taken_hint)
            # print self.hints.list
            self.hints.index = 0
        # get next hint from list
        if not self.hints.list:
            self.highlightNotMatching()
            return None
        h = self.hints.list[self.hints.index]
        self.hints.index = self.hints.index + 1
        if self.hints.index >= len(self.hints.list):
            self.hints.index = 0
        # paranoia - verify hint
        score, pos, ncards, from_stack, to_stack, text_color, forced_move = h
        assert from_stack and len(from_stack.cards) >= ncards
        if ncards == 0:
            # a deal move, should not happen with level=0/1
            assert level >= 2
            assert from_stack is self.s.talon
            return h
        elif from_stack == to_stack:
            # a flip move, should not happen with level=0/1
            assert level >= 2
            assert ncards == 1 and len(from_stack.cards) >= ncards
            return h
        else:
            # a move move
            assert to_stack
            assert 1 <= ncards <= len(from_stack.cards)
            if DEBUG:
                if not to_stack.acceptsCards(
                        from_stack, from_stack.cards[-ncards:]):
                    print('*fail accepts cards*', from_stack, to_stack, ncards)
                if not from_stack.canMoveCards(from_stack.cards[-ncards:]):
                    print('*fail move cards*', from_stack, ncards)
            # assert from_stack.canMoveCards(from_stack.cards[-ncards:])
            # FIXME: Pyramid
            assert to_stack.acceptsCards(
                from_stack, from_stack.cards[-ncards:])
        if sleep <= 0.0:
            return h
        info = (level == 1) or (level > 1 and DEBUG)
        if info and self.app.statusbar and self.app.opt.statusbar:
            self.app.statusbar.configLabel(
                "info", text=_("Score %6d") % (score), fg=text_color)
        else:
            info = 0
        self.drawHintArrow(from_stack, to_stack, ncards, sleep)
        if info:
            self.app.statusbar.configLabel("info", text="", fg="#000000")
        return h

    def drawHintArrow(self, from_stack, to_stack, ncards, sleep):
        # compute position for arrow
        images = self.app.images
        x1, y1 = from_stack.getPositionFor(from_stack.cards[-ncards])
        x2, y2 = to_stack.getPositionFor(to_stack.getCard())
        cw, ch = images.getSize()
        dx, dy = images.getDelta()
        x1, y1 = x1 + dx, y1 + dy
        x2, y2 = x2 + dx, y2 + dy
        if ncards == 1:
            x1 += cw // 2
            y1 += ch // 2
        elif from_stack.CARD_XOFFSET[0]:
            x1 += from_stack.CARD_XOFFSET[0] // 2
            y1 += ch // 2
        else:
            x1 += cw // 2
            y1 += from_stack.CARD_YOFFSET[0] // 2
        x2 += cw // 2
        y2 += ch // 2
        # draw the hint
        arrow = MfxCanvasLine(self.canvas, x1, y1, x2, y2, width=7,
                              fill=self.app.opt.colors['hintarrow'],
                              arrow="last", arrowshape=(30, 30, 10))
        self.canvas.update_idletasks()
        # wait
        if TOOLKIT == "kivy":
            arrow.delete_deferred(sleep)
            return
        # wait
        self.sleep(sleep)
        # delete the hint
        if arrow is not None:
            arrow.delete()
        self.canvas.update_idletasks()

    #
    # Demo - uses showHint()
    #

    def startDemo(self, mixed=1, level=2):
        assert level >= 2               # needed for flip/deal hints
        if not self.top:
            return
        self.demo = Struct(
            level=level,
            mixed=mixed,
            sleep=self.app.opt.timeouts['demo'],
            last_deal=[],
            snapshots=[],
            hint=None,
            keypress=None,
            start_demo_moves=self.stats.demo_moves,
            info_text=None,
        )
        self.hints.list = None
        self.createDemoInfoText()
        self.createDemoLogo()
        after_idle(self.top, self.demoEvent)  # schedule first move

    def stopDemo(self, event=None):
        if not self.demo:
            return
        self.canvas.setTopImage(None)
        self.demo_logo = None
        self.demo = None
        self.updateMenus()

    # demo event - play one demo move and check for win/loss
    def demoEvent(self):
        # note: other events are allowed to stop self.demo at any time
        if not self.demo or self.demo.keypress:
            self.stopDemo()
            # self.updateMenus()
            return
        finished = self.playOneDemoMove(self.demo)
        self.finishMove()
        self.top.update_idletasks()
        self.hints.list = None
        player_moves = self.getPlayerMoves()
        d, status = None, 0
        bitmap = "info"
        timeout = 10000
        if 1 and player_moves == 0:
            timeout = 5000
        if self.demo and self.demo.level == 3:
            timeout = 0
        if self.isGameWon():
            self.updateTime()
            finished = 1
            self.finished = True
            self.stopPlayTimer()
            if not self.top.winfo_ismapped():
                status = 2
            elif player_moves == 0:
                self.playSample("autopilotwon", priority=1000)
                s = self.app.miscrandom.choice((_("&Great"), _("&Cool"),
                                                _("&Yeah"),  _("&Wow")))
                text = ungettext('\nGame solved in %d move.\n',
                                 '\nGame solved in %d moves.\n',
                                 self.moves.index)
                text = text % self.moves.index
                d = MfxMessageDialog(self.top,
                                     title=_("%s Autopilot") % TITLE,
                                     text=text,
                                     image=self.app.gimages.logos[4],
                                     strings=(s,),
                                     separator=True,
                                     timeout=timeout)
                status = d.status
            else:
                # s = self.app.miscrandom.choice((_("&OK"), _("&OK")))
                s = _("&OK")
                text = _("\nGame finished\n")
                if DEBUG:
                    text += "\nplayer_moves: %d\ndemo_moves: %d\n" % \
                        (self.stats.player_moves, self.stats.demo_moves)
                d = MfxMessageDialog(self.top,
                                     title=_("%s Autopilot") % TITLE,
                                     text=text, bitmap=bitmap, strings=(s,),
                                     padx=30, timeout=timeout)
                status = d.status
        elif finished:
            # self.stopPlayTimer()
            if not self.top.winfo_ismapped():
                status = 2
            else:
                if player_moves == 0:
                    self.playSample("autopilotlost", priority=1000)
                s = self.app.miscrandom.choice(
                        (_("&Oh well"), _("&That's life"), _("&Hmm")))
                # ??? accelerators
                d = MfxMessageDialog(self.top,
                                     title=_("%s Autopilot") % TITLE,
                                     text=_("\nThis won't come out...\n"),
                                     bitmap=bitmap, strings=(s,),
                                     padx=30, timeout=timeout)
                status = d.status
        if finished:
            self.updateStats(demo=1)
            if not DEBUG and self.demo and status == 2:
                # timeout in dialog
                if self.stats.demo_moves > self.demo.start_demo_moves:
                    # we only increase the splash-screen counter if the last
                    # demo actually made a move
                    self.app.demo_counter += 1
                    if self.app.demo_counter % 3 == 0:
                        if self.top.winfo_ismapped():
                            status = help_about(self.app, timeout=10000)
            if self.demo and status == 2:
                # timeout in dialog - start another demo
                demo = self.demo
                id = self.id
                if 1 and demo.mixed and DEBUG:
                    # debug - advance game id to make sure we hit all games
                    gl = self.app.gdb.getGamesIdSortedById()
                    # gl = self.app.gdb.getGamesIdSortedByName()
                    gl = list(gl)
                    index = (gl.index(self.id) + 1) % len(gl)
                    id = gl[index]
                elif demo.mixed:
                    # choose a random game
                    gl = self.app.gdb.getGamesIdSortedById()
                    while len(gl) > 1:
                        id = self.app.getRandomGameId()
                        if 0 or id != self.id:      # force change of game
                            break
                if self.nextGameFlags(id) == 0:
                    self.endGame()
                    self.newGame(autoplay=0)
                    self.startDemo(mixed=demo.mixed)
                else:
                    self.endGame()
                    self.stopDemo()
                    self.quitGame(id, startdemo=1)
            else:
                self.stopDemo()
                if DEBUG >= 10:
                    # debug - only for testing winAnimation()
                    self.endGame()
                    self.winAnimation()
                    self.newGame()
        else:
            # game not finished yet
            self.top.busyUpdate()
            if self.demo:
                after_idle(self.top, self.demoEvent)  # schedule next move

    # play one demo move while in the demo event
    def playOneDemoMove(self, demo):
        if self.moves.index > 2000:
            # we're probably looping because of some bug in the hint code
            return 1
        sleep = demo.sleep
        # first try to deal cards to the Waste (unless there was a forced move)
        if not demo.hint or not demo.hint[6]:
            if self._autoDeal(sound=False):
                return 0
        # display a hint
        h = self.showHint(demo.level, sleep, taken_hint=demo.hint)
        demo.hint = h
        if not h:
            return 1
        # now actually play the hint
        score, pos, ncards, from_stack, to_stack, text_color, forced_move = h
        if ncards == 0:
            # a deal-move
            # do not let games like Klondike and Canfield deal forever
            if self.dealCards() == 0:
                return 1
            if 0:                       # old version, based on dealing card
                c = self.s.talon.getCard()
                if c in demo.last_deal:
                    # We went through the whole Talon. Give up.
                    return 1
                # Note that `None' is a valid entry in last_deal[]
                # (this means that all cards are on the Waste).
                demo.last_deal.append(c)
            else:                       # new version, based on snapshots
                # check snapshot
                sn = self.getSnapshot()
                if sn in demo.snapshots:
                    # not unique
                    return 1
                demo.snapshots.append(sn)
        elif from_stack == to_stack:
            # a flip-move
            from_stack.flipMove(animation=True)
            demo.last_deal = []
        else:
            # a move-move
            from_stack.moveMove(ncards, to_stack, frames=-1)
            demo.last_deal = []
        return 0

    def createDemoInfoText(self):
        # TODO - the text placement is not fully ok
        if DEBUG:
            self.showHelp('help', self.getDemoInfoText())
        return
        if not self.demo or self.demo.info_text or self.preview:
            return
        tinfo = [
            ("sw", 8, self.height - 8),
            ("se", self.width - 8, self.height - 8),
            ("nw", 8, 8),
            ("ne", self.width - 8, 8),
        ]
        ta = self.getDemoInfoTextAttr(tinfo)
        if ta:
            # font = self.app.getFont("canvas_large")
            font = self.app.getFont("default")
            self.demo.info_text = MfxCanvasText(self.canvas, ta[1], ta[2],
                                                anchor=ta[0], font=font,
                                                text=self.getDemoInfoText())

    def getDemoInfoText(self):
        h = self.Hint_Class is None and 'None' or self.Hint_Class.__name__
        return '%s (%s)' % (self.gameinfo.short_name, h)

    def getDemoInfoTextAttr(self, tinfo):
        items1, items2 = [], []
        for s in self.allstacks:
            if s.is_visible:
                items1.append(s)
                items1.extend(list(s.cards))
                if not s.cards and s.cap.max_accept > 0:
                    items2.append(s)
                else:
                    items2.extend(list(s.cards))
        ti = self.__checkFreeSpaceForDemoInfoText(items1)
        if ti < 0:
            ti = self.__checkFreeSpaceForDemoInfoText(items2)
        if ti < 0:
            return None
        return tinfo[ti]

    def __checkFreeSpaceForDemoInfoText(self, items):
        CW, CH = self.app.images.CARDW, self.app.images.CARDH
        # note: these are translated by (-CW/2, -CH/2)
        x1, x2 = 3*CW//2, self.width - 5*CW//2
        y1, y2 = CH//2, self.height - 3*CH//2
        #
        m = [1, 1, 1, 1]
        for c in items:
            cx, cy = c.x, c.y
            if cy >= y2:
                if cx <= x1:
                    m[0] = 0
                elif cx >= x2:
                    m[1] = 0
            elif cy <= y1:
                if cx <= x1:
                    m[2] = 0
                elif cx >= x2:
                    m[3] = 0
        for mm in m:
            if mm:
                return mm
        return -1

    def createDemoLogo(self):
        if not self.app.gimages.demo:
            return
        if self.demo_logo or not self.app.opt.demo_logo:
            return
        if self.width <= 100 or self.height <= 100:
            return
        # self.demo_logo = self.app.miscrandom.choice(self.app.gimages.demo)
        n = self.random.initial_seed % len(self.app.gimages.demo)
        self.demo_logo = self.app.gimages.demo[int(n)]
        self.canvas.setTopImage(self.demo_logo)

    def getStuck(self):
        h = self.Stuck_Class.getHints(None)
        if h:
            self.failed_snapshots = []
            return True
        if not self.canDealCards():
            return False
        # can deal cards: do we have any hints in previous deals ?
        sn = self.getSnapshot()
        if sn in self.failed_snapshots:
            return False
        self.failed_snapshots.append(sn)
        return True

    def updateStuck(self):
        # stuck
        if self.finished:
            return
        if self.Stuck_Class is None:
            return
        if self.getStuck():
            text = ''
        else:
            text = 'x'
            # self.playSample("autopilotlost", priority=1000)
        self.updateStatus(stuck=text)

    #
    # Handle moves (with move history for undo/redo)
    # Actual move is handled in a subclass of AtomicMove.
    #
    # Note:
    # All playing moves (user actions, demo games) must get routed
    # to Stack.moveMove() because the stack may add important
    # triggers to a move (most notably fillStack and updateModel).
    #
    # Only low-level game (Game.startGame, Game.dealCards, Game.fillStack)
    # or stack methods (Stack.moveMove) should call the functions below
    # directly.
    #

    def startMoves(self):
        self.moves = GameMoves()
        self.stats._reset_statistics()

    def __storeMove(self, am):
        if self.S_DEAL <= self.moves.state <= self.S_PLAY:
            self.moves.current.append(am)

    # move type 1
    def moveMove(self, ncards, from_stack, to_stack, frames=-1, shadow=-1):
        assert from_stack and to_stack and from_stack is not to_stack
        assert 0 < ncards <= len(from_stack.cards)
        am = AMoveMove(ncards, from_stack, to_stack, frames, shadow)
        self.__storeMove(am)
        am.do(self)
        self.hints.list = None

    # move type 2
    def flipMove(self, stack):
        assert stack
        am = AFlipMove(stack)
        self.__storeMove(am)
        am.do(self)
        self.hints.list = None

    def singleFlipMove(self, stack):
        # flip with animation (without "moveMove" in this move)
        assert stack
        am = ASingleFlipMove(stack)
        self.__storeMove(am)
        am.do(self)
        self.hints.list = None

    def flipAndMoveMove(self, from_stack, to_stack, frames=-1):
        assert from_stack and to_stack and (from_stack is not to_stack)
        am = AFlipAndMoveMove(from_stack, to_stack, frames)
        self.__storeMove(am)
        am.do(self)
        self.hints.list = None

    # move type 3
    def turnStackMove(self, from_stack, to_stack):
        assert from_stack and to_stack and (from_stack is not to_stack)
        assert len(to_stack.cards) == 0
        am = ATurnStackMove(from_stack, to_stack)
        self.__storeMove(am)
        am.do(self)
        self.hints.list = None

    # move type 4
    def nextRoundMove(self, stack):
        assert stack
        am = ANextRoundMove(stack)
        self.__storeMove(am)
        am.do(self)
        self.hints.list = None

    # move type 5
    def saveSeedMove(self):
        am = ASaveSeedMove(self)
        self.__storeMove(am)
        am.do(self)
        # self.hints.list = None

    # move type 6
    def shuffleStackMove(self, stack):
        assert stack
        am = AShuffleStackMove(stack, self)
        self.__storeMove(am)
        am.do(self)
        self.hints.list = None

    # move type 7
    def updateStackMove(self, stack, flags):
        assert stack
        am = AUpdateStackMove(stack, flags)
        self.__storeMove(am)
        am.do(self)
        # #self.hints.list = None

    # move type 8
    def flipAllMove(self, stack):
        assert stack
        am = AFlipAllMove(stack)
        self.__storeMove(am)
        am.do(self)
        self.hints.list = None

    # move type 9
    def saveStateMove(self, flags):
        am = ASaveStateMove(self, flags)
        self.__storeMove(am)
        am.do(self)
        # self.hints.list = None

    # for ArbitraryStack
    def singleCardMove(self, from_stack, to_stack, position,
                       frames=-1, shadow=-1):
        am = ASingleCardMove(from_stack, to_stack, position, frames, shadow)
        self.__storeMove(am)
        am.do(self)
        self.hints.list = None

    # Finish the current move.
    def finishMove(self):
        current, moves, stats = self.moves.current, self.moves, self.stats
        if not current:
            return 0
        # invalidate hints
        self.hints.list = None
        # update stats
        if self.demo:
            stats.demo_moves += 1
            if moves.index == 0:
                stats.player_moves = 0  # clear all player moves
        else:
            stats.player_moves += 1
            if moves.index == 0:
                stats.demo_moves = 0    # clear all demo moves
        stats.total_moves += 1

        # try to detect a redo move in order to keep our history
        redo = 0
        if moves.index + 1 < len(moves.history):
            mylen, m = len(current), moves.history[moves.index]
            if mylen == len(m):
                for i in range(mylen):
                    a1 = current[i]
                    a2 = m[i]
                    if a1.__class__ is not a2.__class__ or \
                            a1.cmpForRedo(a2) != 0:
                        break
                else:
                    redo = 1
        # add current move to history (which is a list of lists)
        if redo:
            # print "detected redo:", current
            # overwrite existing entry because minor things like
            # shadow/frames may have changed
            moves.history[moves.index] = current
            moves.index += 1
        else:
            # resize (i.e. possibly shorten list from previous undos)
            moves.history[moves.index:] = [current]
            moves.index += 1
            assert moves.index == len(moves.history)

        moves.current = []
        self.updateSnapshots()
        # update view
        self.updateText()
        self.updateStatus(moves=(moves.index, self.stats.total_moves))
        self.updateMenus()
        self.updatePlayTime(do_after=0)
        self.updateStuck()
        reset_solver_dialog()

        return 1

    def undo(self):
        assert self.canUndo()
        assert self.moves.state == self.S_PLAY and len(self.moves.current) == 0
        assert 0 <= self.moves.index <= len(self.moves.history)
        if self.moves.index == 0:
            return
        self.moves.index -= 1
        self.moves.state = self.S_UNDO
        for atomic_move in reversed(self.moves.history[self.moves.index]):
            atomic_move.undo(self)
        self.moves.state = self.S_PLAY
        self.stats.undo_moves += 1
        self.stats.total_moves += 1
        self.hints.list = None
        self.updateSnapshots()
        self.updateText()
        self.updateStatus(moves=(self.moves.index, self.stats.total_moves))
        self.updateMenus()
        self.updateStatus(stuck='')
        self.failed_snapshots = []
        reset_solver_dialog()

    def redo(self):
        assert self.canRedo()
        assert self.moves.state == self.S_PLAY and len(self.moves.current) == 0
        assert 0 <= self.moves.index <= len(self.moves.history)
        if self.moves.index == len(self.moves.history):
            return
        m = self.moves.history[self.moves.index]
        self.moves.index += 1
        self.moves.state = self.S_REDO
        for atomic_move in m:
            atomic_move.redo(self)
        self.moves.state = self.S_PLAY
        self.stats.redo_moves += 1
        self.stats.total_moves += 1
        self.hints.list = None
        self.updateSnapshots()
        self.updateText()
        self.updateStatus(moves=(self.moves.index, self.stats.total_moves))
        self.updateMenus()
        self.updateStuck()
        reset_solver_dialog()

    #
    # subclass hooks
    #

    def setState(self, state):
        # restore saved vars (from undo/redo)
        pass

    def getState(self):
        # save vars (for undo/redo)
        return []

    #
    # bookmarks
    #

    def setBookmark(self, n, confirm=1):
        self.finishMove()       # just in case
        if not self.canSetBookmark():
            return 0
        if confirm < 0:
            confirm = self.app.opt.confirm
        if confirm and self.gsaveinfo.bookmarks.get(n):
            if not self.areYouSure(
                    _("Set bookmark"),
                    _("Replace existing bookmark %d?") % (n+1)):
                return 0
        f = BytesIO()
        try:
            self._dumpGame(Pickler(f, 1), bookmark=2)
            bm = (f.getvalue(), self.moves.index)
        except Exception:
            pass
        else:
            self.gsaveinfo.bookmarks[n] = bm
            return 1
        return 0

    def gotoBookmark(self, n, confirm=-1, update_stats=1):
        self.finishMove()       # just in case
        bm = self.gsaveinfo.bookmarks.get(n)
        if not bm:
            return
        if confirm < 0:
            confirm = self.app.opt.confirm
        if confirm:
            if not self.areYouSure(_("Goto bookmark"),
                                   _("Goto bookmark %d?") % (n+1)):
                return
        try:
            s, moves_index = bm
            self.setCursor(cursor=CURSOR_WATCH)
            file = BytesIO(s)
            p = Unpickler(file)
            game = self._undumpGame(p, self.app)
            assert game.id == self.id
            # save state for undoGotoBookmark
            self.setBookmark(-1, confirm=0)
        except Exception:
            del self.gsaveinfo.bookmarks[n]
            self.setCursor(cursor=self.app.top_cursor)
        else:
            if update_stats:
                self.stats.goto_bookmark_moves += 1
                self.gstats.goto_bookmark_moves += 1
            self.restoreGame(game, reset=0)
            destruct(game)

    def undoGotoBookmark(self):
        self.gotoBookmark(-1, update_stats=0)

    def loadGame(self, filename):
        if self.changed():
            if not self.areYouSure(_("Open game")):
                return
        self.finishMove()       # just in case
        game = None
        self.setCursor(cursor=CURSOR_WATCH)
        self.disableMenus()
        try:
            game = self._loadGame(filename, self.app)
            game.gstats.holded = 0
        except AssertionError:
            self.updateMenus()
            self.setCursor(cursor=self.app.top_cursor)
            MfxMessageDialog(
                self.top, title=_("Load game error"), bitmap="error",
                text=_(
                    "Error while loading game.\n\n" +
                    "Probably the game file is damaged,\n" +
                    "but this could also be a bug you might want to report."))
            traceback.print_exc()
        except UnpicklingError as ex:
            self.updateMenus()
            self.setCursor(cursor=self.app.top_cursor)
            MfxExceptionDialog(self.top, ex, title=_("Load game error"),
                               text=_("Error while loading game"))
        except Exception:
            self.updateMenus()
            self.setCursor(cursor=self.app.top_cursor)
            MfxMessageDialog(
                self.top, title=_("Load game error"),
                bitmap="error", text=_(
                    """Internal error while loading game.\n\n""" +
                    "Please report this bug."))
            traceback.print_exc()
        else:
            if self.pause:
                # unselect pause-button
                self.app.menubar.mPause()
            self.filename = filename
            game.filename = filename
            # now start the new game
            # print game.__dict__
            if self.nextGameFlags(game.id) == 0:
                self.endGame()
                self.restoreGame(game)
                destruct(game)
            else:
                self.endGame()
                self.quitGame(game.id, loadedgame=game)

    def saveGame(self, filename, protocol=-1):
        self.finishMove()       # just in case
        self.setCursor(cursor=CURSOR_WATCH)
        try:
            self._saveGame(filename, protocol)
        except Exception as ex:
            self.setCursor(cursor=self.app.top_cursor)
            MfxExceptionDialog(self.top, ex, title=_("Save game error"),
                               text=_("Error while saving game"))
        else:
            self.filename = filename
            self.setCursor(cursor=self.app.top_cursor)

    #
    # low level load/save
    #

    def _loadGame(self, filename, app):
        game = None
        with open(filename, "rb") as f:
            game = self._undumpGame(Unpickler(f), app)
            game.gstats.loaded += 1
        return game

    def _undumpGame(self, p, app):
        self.updateTime()
        #
        err_txt = _("Invalid or damaged %s save file") % PACKAGE
        #

        def pload(t=None, p=p):
            obj = p.load()
            if isinstance(t, type):
                if not isinstance(obj, t):
                    # accept old storage format in case:
                    if t in _Game_LOAD_CLASSES:
                        assert isinstance(obj, Struct), err_txt
                    else:
                        assert False, err_txt
            return obj

        def validate(v, txt):
            if not v:
                raise UnpicklingError(txt)
        #
        package = pload(str)
        validate(package == PACKAGE, err_txt)
        version = pload(str)
        # validate(isinstance(version, str) and len(version) <= 20, err_txt)
        version_tuple = pload(tuple)
        validate(
            version_tuple >= (1, 0),
            _('Cannot load games saved with\n%(app)s version %(ver)s') % {
                'app': PACKAGE,
                'ver': version})
        game_version = 1
        bookmark = pload(int)
        validate(0 <= bookmark <= 2, err_txt)
        game_version = pload(int)
        validate(game_version > 0, err_txt)
        #
        id = pload(int)
        validate(id > 0, err_txt)
        if id not in GI.PROTECTED_GAMES:
            game = app.constructGame(id)
            if game:
                if not game.canLoadGame(version_tuple, game_version):
                    destruct(game)
                    game = None
        validate(
            game is not None,
            _('Cannot load this game from version %s\n' +
              'as the game rules have changed\n' +
              'in the current implementation.') % version)
        game.version = version
        game.version_tuple = version_tuple
        #
        initial_seed = random__int2str(pload(int))
        game.random = constructRandom(initial_seed)
        state = pload()
        if not (isinstance(game.random, random2.Random) and
                isinstance(state, int)):
            game.random.setstate(state)
        # if not hasattr(game.random, "origin"):
        # game.random.origin = game.random.ORIGIN_UNKNOWN
        game.loadinfo.stacks = []
        game.loadinfo.ncards = 0
        nstacks = pload(int)
        validate(1 <= nstacks, err_txt)
        for i in range(nstacks):
            stack = []
            ncards = pload(int)
            validate(0 <= ncards <= 1024, err_txt)
            for j in range(ncards):
                card_id = pload(int)
                face_up = pload(int)
                stack.append((card_id, face_up))
            game.loadinfo.stacks.append(stack)
            game.loadinfo.ncards = game.loadinfo.ncards + ncards
        validate(game.loadinfo.ncards == game.gameinfo.ncards, err_txt)
        game.loadinfo.talon_round = pload()
        game.finished = pload()
        if 0 <= bookmark <= 1:
            saveinfo = pload(GameSaveInfo)
            game.saveinfo.__dict__.update(saveinfo.__dict__)
            gsaveinfo = pload(GameGlobalSaveInfo)
            game.gsaveinfo.__dict__.update(gsaveinfo.__dict__)
        moves = pload(GameMoves)
        game.moves.__dict__.update(moves.__dict__)
        snapshots = pload(list)
        game.snapshots = snapshots
        if 0 <= bookmark <= 1:
            gstats = pload(GameGlobalStatsStruct)
            game.gstats.__dict__.update(gstats.__dict__)
            stats = pload(GameStatsStruct)
            game.stats.__dict__.update(stats.__dict__)
        game._loadGameHook(p)
        dummy = pload(str)
        validate(dummy == "EOF", err_txt)
        if bookmark == 2:
            # copy back all variables that are not saved
            game.stats = self.stats
            game.gstats = self.gstats
            game.saveinfo = self.saveinfo
            game.gsaveinfo = self.gsaveinfo
        return game

    def _saveGame(self, filename, protocol=-1):
        if self.canSaveGame():
            with open(filename, "wb") as f:
                self._dumpGame(Pickler(f, protocol))

    def _dumpGame(self, p, bookmark=0):
        return pysolDumpGame(self, p, bookmark)

    def startPlayTimer(self):
        self.updateStatus(time=None)
        self.stopPlayTimer()
        self.play_timer = after(
            self.top, PLAY_TIME_TIMEOUT, self.updatePlayTime)

    def stopPlayTimer(self):
        if hasattr(self, 'play_timer') and self.play_timer:
            after_cancel(self.play_timer)
            self.play_timer = None
            self.updatePlayTime(do_after=0)

    def updatePlayTime(self, do_after=1):
        if not self.top:
            return
        if self.pause or self.finished:
            return
        if do_after:
            self.play_timer = after(
                self.top, PLAY_TIME_TIMEOUT, self.updatePlayTime)
        d = time.time() - self.stats.update_time + self.stats.elapsed_time
        self.updateStatus(time=format_time(d))

    def doPause(self):
        if self.finished:
            return
        if self.demo:
            self.stopDemo()
        if not self.pause:
            self.updateTime()
        self.pause = not self.pause
        if self.pause:
            # self.updateTime()
            self.canvas.hideAllItems()
            n = self.random.initial_seed % len(self.app.gimages.pause)
            self.pause_logo = self.app.gimages.pause[int(n)]
            self.canvas.setTopImage(self.pause_logo)
        else:
            self.stats.update_time = time.time()
            self.updatePlayTime()
            self.canvas.setTopImage(None)
            self.pause_logo = None
            self.canvas.showAllItems()

    def showHelp(self, *args):
        if self.preview:
            return
        kw = dict([(args[i], args[i+1]) for i in range(0, len(args), 2)])
        if not kw:
            kw = {'info': '', 'help': ''}
        if 'info' in kw and self.app.opt.statusbar and self.app.opt.num_cards:
            self.app.statusbar.updateText(info=kw['info'])
        if 'help' in kw and self.app.opt.helpbar:
            self.app.helpbar.updateText(info=kw['help'])

    #
    # Piles descriptions
    #

    def showStackDesc(self):
        from pysollib.pysoltk import StackDesc
        from pysollib.stack import InitialDealTalonStack
        sd_list = []
        for s in self.allstacks:
            sd = (s.__class__.__name__, s.cap.base_rank, s.cap.dir)
            if sd in sd_list:
                # one of each uniq pile
                continue
            if isinstance(s, InitialDealTalonStack):
                continue
            self.stackdesc_list.append(StackDesc(self, s))
            sd_list.append(sd)

    def deleteStackDesc(self):
        if self.stackdesc_list:
            for sd in self.stackdesc_list:
                sd.delete()
            self.stackdesc_list = []
            return True
        return False

    # for find_card_dialog
    def canFindCard(self):
        return self.gameinfo.category == GI.GC_FRENCH

    #
    # subclass hooks
    #

    def _restoreGameHook(self, game):
        pass

    def _loadGameHook(self, p):
        pass

    def _saveGameHook(self, p):
        pass

    def _dealNumRows(self, n):
        for i in range(n):
            self.s.talon.dealRow(frames=0)

    def _startDealNumRows(self, n):
        self._dealNumRows(n)
        self.startDealSample()

    def _startDealNumRowsAndDealSingleRow(self, n):
        self._startDealNumRows(n)
        self.s.talon.dealRow()

    def _startAndDealRow(self):
        self._startDealNumRowsAndDealSingleRow(0)

    def _startDealNumRowsAndDealRowAndCards(self, n):
        self._startDealNumRowsAndDealSingleRow(n)
        self.s.talon.dealCards()

    def _startAndDealRowAndCards(self):
        self._startAndDealRow()
        self.s.talon.dealCards()


class StartDealRowAndCards(object):
    def startGame(self):
        self._startAndDealRowAndCards()
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
from pysol_cards.random import random__str2int
from pysollib.settings import PACKAGE
from pysollib.settings import VERSION, VERSION_TUPLE


def pysolDumpGame(game_, p, bookmark=0):
    game_.updateTime()
    assert 0 <= bookmark <= 2
    p.dump(PACKAGE)
    p.dump(VERSION)
    p.dump(VERSION_TUPLE)
    p.dump(bookmark)
    p.dump(game_.GAME_VERSION)
    p.dump(game_.id)
    #
    p.dump(random__str2int(game_.random.getSeedStr()))
    p.dump(game_.random.getstate())
    #
    p.dump(len(game_.allstacks))
    for stack in game_.allstacks:
        p.dump(len(stack.cards))
        for card in stack.cards:
            p.dump(card.id)
            p.dump(card.face_up)
    p.dump(game_.s.talon.round)
    p.dump(game_.finished)
    if 0 <= bookmark <= 1:
        p.dump(game_.saveinfo)
        p.dump(game_.gsaveinfo)
    p.dump(game_.moves)
    p.dump(game_.snapshots)
    if 0 <= bookmark <= 1:
        if bookmark == 0:
            game_.gstats.saved += 1
        p.dump(game_.gstats)
        p.dump(game_.stats)
    game_._saveGameHook(p)
    p.dump("EOF")
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.hint import FreeCellSolverWrapper
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AC_FoundationStack, \
        AC_RowStack, \
        DealRowRedealTalonStack, \
        DealRow_StackMethods, \
        FullStackWrapper, \
        InitialDealTalonStack, \
        InvisibleStack, \
        KingAC_RowStack, \
        KingSS_RowStack, \
        RK_RowStack, \
        RedealTalonStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        Stack, \
        StackWrapper, \
        SuperMoveSS_RowStack, \
        TalonStack, \
        UD_RK_RowStack, \
        UD_SS_RowStack
from pysollib.util import ACE, KING, NO_RANK, UNLIMITED_CARDS


class Fan_Hint(CautiousDefaultHint):
    # FIXME: demo is not too clever in this game
    pass


# ************************************************************************
# * Fan
# ************************************************************************

class Fan(Game):
    Talon_Class = InitialDealTalonStack
    Foundation_Classes = [SS_FoundationStack]
    ReserveStack_Class = ReserveStack
    RowStack_Class = KingSS_RowStack
    Hint_Class = Fan_Hint

    #
    # game layout
    #

    def createGame(self, rows=(5, 5, 5, 3), playcards=9, reserves=0,
                   texts=False):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (set size so that at least 9 cards are fully playable)
        w = max(2*l.XS, l.XS+(playcards-1)*l.XOFFSET)
        w = min(3*l.XS, w)
        w = (w + 1) & ~1
        # print 2*l.XS, w
        self.setSize(l.XM + max(rows)*w, l.YM + (1+len(rows))*l.YS)

        # create stacks
        decks = self.gameinfo.decks
        if reserves:
            x, y = l.XM, l.YM
            for r in range(reserves):
                s.reserves.append(self.ReserveStack_Class(x, y, self))
                x += l.XS
            x = (self.width - decks*4*l.XS)  # - 2*l.XS) // 2
            dx = l.XS
        else:
            dx = (self.width - decks*4*l.XS)//(decks*4+1)
            x, y = l.XM + dx, l.YM
            dx += l.XS
        for fnd_cls in self.Foundation_Classes:
            for i in range(4):
                s.foundations.append(fnd_cls(x, y, self, suit=i))
                x += dx
        for i in range(len(rows)):
            x, y = l.XM, y + l.YS
            for j in range(rows[i]):
                stack = self.RowStack_Class(
                    x, y, self, max_move=1, max_accept=1)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
                s.rows.append(stack)
                x += w
        x, y = self.width - l.XS, self.height - l.YS
        s.talon = self.Talon_Class(x, y, self)
        if texts:
            l.createRoundText(s.talon, 'nn')

        # define stack-groups
        l.defaultStackGroups()
        return l

    #
    # game overrides
    #

    def startGame(self):
        for i in range(2):
            self.s.talon.dealRow(rows=self.s.rows[:17], frames=0)
        self._startAndDealRow()

    shallHighlightMatch = Game._shallHighlightMatch_SS

    def getHighlightPilesStacks(self):
        return ()


class FanGame(Fan):
    Solver_Class = FreeCellSolverWrapper(preset='fan')


# ************************************************************************
# * Scotch Patience
# ************************************************************************

class ScotchPatience(Fan):
    Foundation_Classes = [AC_FoundationStack]
    RowStack_Class = StackWrapper(RK_RowStack, base_rank=NO_RANK)

    def createGame(self):
        Fan.createGame(self, playcards=8)
    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Shamrocks
# * Shamrocks II
# ************************************************************************

class Shamrocks(Fan):
    RowStack_Class = StackWrapper(
        UD_RK_RowStack, base_rank=NO_RANK, max_cards=3)

    def createGame(self):
        Fan.createGame(self, playcards=4)
    shallHighlightMatch = Game._shallHighlightMatch_RK


class ShamrocksII(Shamrocks):
    def _shuffleHook(self, cards):
        # move Kings to bottom of each stack
        i, n = 0, 17
        kings = []
        for c in cards:
            if c.rank == KING:
                kings.append(i)
            i += 1
        for i in kings:
            if i == 51:
                continue
            j = i % n
            while j < i:
                if cards[j].rank != KING:
                    cards[i], cards[j] = cards[j], cards[i]
                    break
                j += n
        cards.reverse()
        return cards


# ************************************************************************
# * La Belle Lucie (Midnight Oil)
# ************************************************************************

class LaBelleLucie_Talon(TalonStack):
    def canDealCards(self):
        return self.round != self.max_rounds and not self.game.isGameWon()

    def dealCards(self, sound=False):
        n = self.redealCards1()
        if n == 0:
            return 0
        self.redealCards2()
        if sound:
            self.game.startDealSample()
        self.redealCards3()
        if sound:
            self.game.stopSamples()
        return n

    # redeal step 1) - collect all cards, move them to the Talon
    def redealCards1(self):
        assert len(self.cards) == 0
        num_cards = 0
        for r in self.game.s.rows:
            if r.cards:
                num_cards = num_cards + len(r.cards)
                self.game.moveMove(len(r.cards), r, self, frames=0)
        assert len(self.cards) == num_cards
        return num_cards

    # redeal step 2) - shuffle
    def redealCards2(self):
        assert self.round != self.max_rounds
        assert self.cards
        self.game.shuffleStackMove(self)
        self.game.nextRoundMove(self)

    # redeal step 3) - redeal cards to stacks
    def redealCards3(self, face_up=1):
        # deal 3 cards to each row, and 1-3 cards to last row
        to_stacks = self.game.s.rows
        n = min(len(self.cards), 3*len(to_stacks))
        for i in range(3):
            j = (n//3, (n+1)//3, (n+2)//3)[i]
            frames = (0, 0, 4)[i]
            for r in to_stacks[:j]:
                if self.cards[-1].face_up != face_up:
                    self.game.flipMove(self)
                self.game.moveMove(1, self, r, frames=frames)


class LaBelleLucie(Fan):
    Talon_Class = StackWrapper(LaBelleLucie_Talon, max_rounds=3)
    RowStack_Class = StackWrapper(SS_RowStack, base_rank=NO_RANK)

    def createGame(self):
        return Fan.createGame(self, texts=True)


# ************************************************************************
# * Super Flower Garden
# ************************************************************************

class SuperFlowerGarden(LaBelleLucie):
    RowStack_Class = StackWrapper(RK_RowStack, base_rank=NO_RANK)
    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Three Shuffles and a Draw
# ************************************************************************

class ThreeShufflesAndADraw_RowStack(SS_RowStack):
    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        game, r = self.game, self.game.s.reserves[0]
        if to_stack is not r:
            SS_RowStack.moveMove(
                self, ncards, to_stack, frames=frames, shadow=shadow)
            return
        f = self._canDrawCard()
        assert f and game.draw_done == 0 and ncards == 1
        # 1) top card from self to reserve
        game.updateStackMove(r, 2 | 16)       # update view for undo
        game.moveMove(1, self, r, frames=frames, shadow=shadow)
        game.updateStackMove(r, 3 | 64)       # update model
        game.updateStackMove(r, 1 | 16)       # update view for redo
        # 2) second card from self to foundation/row
        if 1 or not game.demo:
            game.playSample("drop", priority=200)
        if frames == 0:
            frames = -1
        game.moveMove(1, self, f, frames=frames, shadow=shadow)
        # 3) from reserve back to self
        #    (need S_FILL because the move is normally not valid)
        old_state = game.enterState(game.S_FILL)
        game.moveMove(1, r, self, frames=frames, shadow=shadow)
        game.leaveState(old_state)

    def _canDrawCard(self):
        if len(self.cards) >= 2:
            pile = self.cards[-2:-1]
            for s in self.game.s.foundations + self.game.s.rows:
                if s is not self and s.acceptsCards(self, pile):
                    return s
        return None


class ThreeShufflesAndADraw_ReserveStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack not in self.game.s.rows:
            return False
        if self.game.draw_done or not from_stack._canDrawCard():
            return False
        return True

    def updateModel(self, undo, flags):
        assert undo == self.game.draw_done
        self.game.draw_done = not self.game.draw_done

    def updateText(self):
        if self.game.preview > 1 or self.texts.misc is None:
            return
        t = (_("X"), _("Draw"))[self.game.draw_done == 0]
        self.texts.misc.config(text=t)

    def prepareView(self):
        ReserveStack.prepareView(self)
        if not self.is_visible or self.game.preview > 1:
            return
        images = self.game.app.images
        x, y = self.x + images.CARDW//2, self.y + images.CARDH//2
        self.texts.misc = MfxCanvasText(
            self.game.canvas, x, y,
            anchor="center",
            font=self.game.app.getFont("canvas_default"))


class ThreeShufflesAndADraw(LaBelleLucie):
    RowStack_Class = StackWrapper(
        ThreeShufflesAndADraw_RowStack, base_rank=NO_RANK)

    def createGame(self):
        lay = LaBelleLucie.createGame(self)
        s = self.s
        # add a reserve stack
        x, y = s.rows[3].x, s.rows[-1].y
        s.reserves.append(ThreeShufflesAndADraw_ReserveStack(x, y, self))
        # redefine the stack-groups
        lay.defaultStackGroups()
        # extra settings
        self.draw_done = 0

    def startGame(self):
        self.draw_done = 0
        self.s.reserves[0].updateText()
        LaBelleLucie.startGame(self)

    def _restoreGameHook(self, game):
        self.draw_done = game.loadinfo.draw_done

    def _loadGameHook(self, p):
        self.loadinfo.addattr(draw_done=p.load())

    def _saveGameHook(self, p):
        p.dump(self.draw_done)


# ************************************************************************
# * Trefoil
# ************************************************************************

class Trefoil(LaBelleLucie):
    GAME_VERSION = 2
    Foundation_Classes = [StackWrapper(SS_FoundationStack, min_cards=1)]

    def createGame(self):
        return Fan.createGame(self, rows=(5, 5, 5, 1), texts=True)

    def _shuffleHook(self, cards):
        # move Aces to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        self._startDealNumRows(2)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.foundations)


# ************************************************************************
# * Intelligence
# ************************************************************************

class Intelligence_Talon(LaBelleLucie_Talon):
    # all Aces go to Foundations
    dealToStacks = TalonStack.dealToStacksOrFoundations

    # redeal step 1) - collect all cards, move them to the Talon (face down)
    def redealCards1(self):
        assert len(self.cards) == 0
        r = self.game.s.reserves[0]
        num_cards = len(r.cards)
        if num_cards > 0:
            self.game.moveMove(len(r.cards), r, self, frames=0)
        for r in self.game.s.rows:
            num_cards = num_cards + len(r.cards)
            while r.cards:
                self.game.moveMove(1, r, self, frames=0)
                self.game.flipMove(self)
        assert len(self.cards) == num_cards
        return num_cards

    # redeal step 3) - redeal cards to stacks
    def redealCards3(self, face_up=1):
        for r in self.game.s.rows:
            while len(r.cards) < 3:
                self.dealToStacks([r], frames=4)
                if not self.cards:
                    return
        # move all remaining cards to the reserve
        self.game.moveMove(
            len(self.cards), self, self.game.s.reserves[0], frames=0)


# up or down in suit
class Intelligence_RowStack(UD_SS_RowStack):
    def fillStack(self):
        if not self.cards:
            r = self.game.s.reserves[0]
            if r.cards:
                r.dealRow((self, self, self), sound=True)


class Intelligence_ReserveStack(ReserveStack, DealRow_StackMethods):
    # all Aces go to Foundations (used in r.dealRow() above)
    dealToStacks = DealRow_StackMethods.dealToStacksOrFoundations

    def canFlipCard(self):
        return False


class Intelligence(Fan):

    Foundation_Classes = [SS_FoundationStack, SS_FoundationStack]
    Talon_Class = StackWrapper(Intelligence_Talon, max_rounds=3)
    RowStack_Class = StackWrapper(Intelligence_RowStack, base_rank=NO_RANK)

    def createGame(self, rows=(5, 5, 5, 3)):
        lay = Fan.createGame(self, rows)
        s = self.s
        # add a reserve stack
        x, y = s.talon.x - lay.XS, s.talon.y
        s.reserves.append(
            Intelligence_ReserveStack(
                x, y, self, max_move=0, max_accept=0,
                max_cards=UNLIMITED_CARDS))
        lay.createText(s.reserves[0], "sw")
        lay.createRoundText(s.talon, 'nn')
        # redefine the stack-groups
        lay.defaultStackGroups()

    def startGame(self):
        talon = self.s.talon
        self._startDealNumRows(2)
        talon.dealRow()
        # move all remaining cards to the reserve
        self.moveMove(len(talon.cards), talon, self.s.reserves[0], frames=0)


class IntelligencePlus(Intelligence):
    def createGame(self):
        Intelligence.createGame(self,  rows=(5, 5, 5, 4))


# ************************************************************************
# * House in the Wood
# * House on the Hill
# *   (2 decks variants of Fan)
# ************************************************************************

class HouseInTheWood(Fan):
    Foundation_Classes = [SS_FoundationStack, SS_FoundationStack]
    RowStack_Class = StackWrapper(UD_SS_RowStack, base_rank=NO_RANK)

    def createGame(self):
        Fan.createGame(self,  rows=(6, 6, 6, 6, 6, 5))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.rows[:34], frames=0)
        self.s.talon.dealRow(rows=self.s.rows[:35], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:35])


class HouseOnTheHill(HouseInTheWood):
    Foundation_Classes = [SS_FoundationStack,
                          StackWrapper(
                              SS_FoundationStack, base_rank=KING, dir=-1)]


# ************************************************************************
# * Clover Leaf
# ************************************************************************

class CloverLeaf_RowStack(UD_SS_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not UD_SS_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return cards[0].rank in (ACE, KING)
        return True

    def _getBaseCard(self):
        return _('Base card - Ace or King.')


class CloverLeaf(Game):

    Hint_Class = Fan_Hint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        playcards = 7
        w, h = l.XM+l.XS+4*(l.XS+(playcards-1)*l.XOFFSET), l.YM+4*l.YS
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(2):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            y += l.YS
        for i in range(2):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i+2,
                                                    base_rank=KING, dir=-1))
            y += l.YS

        x = l.XM+l.XS
        for i in range(4):
            y = l.YM
            for j in range(4):
                stack = CloverLeaf_RowStack(x, y, self,
                                            max_move=1, max_accept=1)
                s.rows.append(stack)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
                y += l.YS
            x += l.XS+(playcards-1)*l.XOFFSET

        s.talon = InitialDealTalonStack(w-l.XS, h-l.YS, self)

        # default
        l.defaultAll()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(2)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.foundations)

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToBottom(
            cards,
            lambda c: ((c.rank == ACE and c.suit in (0, 1)) or
                       (c.rank == KING and c.suit in (2, 3)),
                       c.suit))

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Free Fan
# ************************************************************************

class FreeFan(Fan):
    RowStack_Class = FullStackWrapper(SuperMoveSS_RowStack, base_rank=KING)
    Solver_Class = FreeCellSolverWrapper(esf='kings', sbb='suit')

    def createGame(self):
        Fan.createGame(self, reserves=2, playcards=8)


# ************************************************************************
# * Box Fan
# ************************************************************************

class BoxFan(Fan):

    RowStack_Class = KingAC_RowStack
    Solver_Class = FreeCellSolverWrapper(esf='kings')

    def createGame(self):
        Fan.createGame(self, rows=(4, 4, 4, 4))

    def startGame(self):
        self._startDealNumRows(2)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.foundations)

    def _shuffleHook(self, cards):
        # move Aces to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == 0, c.suit))

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Troika
# ************************************************************************

class Troika(Fan):

    RowStack_Class = StackWrapper(RK_RowStack, dir=0,
                                  base_rank=NO_RANK, max_cards=3)

    def createGame(self):
        Fan.createGame(self, rows=(6, 6, 6), playcards=4)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank == card2.rank

    def startGame(self, ncards=3):
        self.startDealSample()
        for r in self.s.rows:
            for i in range(ncards):
                if not self.s.talon.cards:
                    break
                c = self.s.talon.cards[-1]
                t = r
                if c.rank == ACE:
                    t = self.s.foundations[c.suit]
                self.s.talon.dealRow(rows=[t], frames=4)


class Quads_RowStack(RK_RowStack):
    getBottomImage = Stack._getReserveBottomImage


class Quads(Troika):
    RowStack_Class = FullStackWrapper(
        Quads_RowStack, dir=0,
        # base_rank=NO_RANK,
        max_cards=4)

    def createGame(self):
        Fan.createGame(self, rows=(5, 5, 3), playcards=5)

    def startGame(self):
        Troika.startGame(self, ncards=4)


class QuadsPlus(Quads):
    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(cards,
                                          lambda c: (c.rank == ACE, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        for i in range(3):
            self.s.talon.dealRow(rows=self.s.rows[:-1], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:-1])


# ************************************************************************
# * Fascination Fan
# ************************************************************************

class FascinationFan_Talon(RedealTalonStack):
    def dealCards(self, sound=False):
        RedealTalonStack.redealCards(self, shuffle=True, sound=sound)


class FascinationFan(Fan):
    Talon_Class = StackWrapper(FascinationFan_Talon, max_rounds=7)
    # Talon_Class = StackWrapper(LaBelleLucie_Talon, max_rounds=7)
    RowStack_Class = StackWrapper(AC_RowStack, base_rank=NO_RANK)

    def createGame(self):
        Fan.createGame(self, texts=True)

    def startGame(self):
        for i in range(2):
            self.s.talon.dealRow(rows=self.s.rows[:17], flip=0, frames=0)
        self._startAndDealRow()

    def redealCards(self):
        r0 = r1 = len(self.s.talon.cards)//3
        m = len(self.s.talon.cards) % 3
        if m >= 1:
            r1 += 1
        self.s.talon.dealRow(rows=self.s.rows[:r0], flip=0, frames=4)
        self.s.talon.dealRow(rows=self.s.rows[:r1], flip=0, frames=4)
        self.s.talon.dealRowAvail(frames=4)

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Crescent
# ************************************************************************

class Crescent_Talon(RedealTalonStack):

    def dealCards(self, sound=False):
        old_state = self.game.enterState(self.game.S_DEAL)
        ncards = 0
        intern1, intern2 = self.game.s.internals
        if sound and self.game.app.opt.animations:
            self.game.startDealSample()
        for r in self.game.s.rows:
            if len(r.cards) <= 1:
                continue
            ncards += len(r.cards)
            # move cards to internal stacks
            while len(r.cards) != 1:
                self.game.moveMove(1, r, intern1, frames=4)
            self.game.moveMove(1, r, intern2, frames=4)
            # move back
            while intern1.cards:
                self.game.moveMove(1, intern1, r, frames=4)
            self.game.moveMove(1, intern2, r, frames=4)
        self.game.nextRoundMove(self)
        if sound:
            self.game.stopSamples()
        self.game.leaveState(old_state)
        return ncards


class Crescent(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):
        l, s = Layout(self), self.s
        playcards = 10
        w0 = l.XS+(playcards-1)*l.XOFFSET
        w, h = l.XM+max(4*w0, 9*l.XS), l.YM+5*l.YS
        self.setSize(w, h)
        x, y = l.XM, l.YM
        s.talon = Crescent_Talon(x, y, self, max_rounds=4)
        l.createRoundText(s.talon, 'ne')
        x, y = w-8*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                    base_rank=KING, dir=-1))
            x += l.XS
        y = l.YM+l.YS
        for i in range(4):
            x = l.XM
            for j in range(4):
                stack = UD_SS_RowStack(x, y, self, base_rank=NO_RANK, mod=13)
                s.rows.append(stack)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
                x += w0
            y += l.YS
        self.s.internals.append(InvisibleStack(self))
        self.s.internals.append(InvisibleStack(self))

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (ACE, KING) and c.deck == 0,
                       (c.rank, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startDealNumRowsAndDealSingleRow(5)

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * School
# ************************************************************************

class School(Fan):

    Talon_Class = StackWrapper(LaBelleLucie_Talon, max_rounds=3)
    RowStack_Class = StackWrapper(RK_RowStack, dir=0, base_rank=NO_RANK)

    def createGame(self):
        Fan.createGame(self, rows=(4, 4, 4, 4), playcards=10, texts=True)

    def startGame(self):
        self._startDealNumRows(2)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.foundations)

    def _shuffleHook(self, cards):
        # move Aces to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(cards,
                                             lambda c: (c.rank == ACE, c.suit))

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank == card2.rank


# ************************************************************************
# * Forest Glade
# ************************************************************************

class ForestGlade_Talon(DealRowRedealTalonStack):

    def _redeal(self, rows=None, frames=0):
        # move all cards to the talon
        num_cards = 0
        if rows is None:
            rows = self.game.s.rows
        for r in rows:
            for i in range(len(r.cards)):
                num_cards += 1
                self.game.moveMove(1, r, self, frames=frames, shadow=0)
                if self.cards[-1].face_up:
                    self.game.flipMove(self)
        return num_cards

    def canDealCards(self):
        if self.round == self.max_rounds:
            if not self.cards:
                return False
            for r in self.game.s.rows:
                if not r.cards:
                    return True
            return False
        return True

    def dealCards(self, sound=False):
        rows = [r for r in self.game.s.rows if not r.cards]
        if not rows or not self.cards:
            if sound and self.game.app.opt.animations:
                self.game.startDealSample()
            # move all cards to the talon
            ncards = self._redeal(frames=4)
            # shuffle
            self.game.shuffleStackMove(self)
            # deal
            if self.cards:
                for r in self.game.s.rows:
                    for i in range(3):
                        if not self.cards:
                            break
                        ncards += self.dealRowAvail(rows=[r], frames=4)
            #
            self.game.nextRoundMove(self)
            if sound:
                self.game.stopSamples()
            return ncards
        #
        if sound and self.game.app.opt.animations:
            self.game.startDealSample()
        ncards = 0
        for r in rows:
            for i in range(3):
                if not self.cards:
                    break
                ncards += self.dealRowAvail(rows=[r], sound=False)
        if sound:
            self.game.stopSamples()
        return ncards


class ForestGlade(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):

        l, s = Layout(self), self.s
        playcards = 7
        w0 = l.XS+(playcards-1)*l.XOFFSET
        w, h = l.XM + 3*w0 + 4*l.XS, l.YM+6*l.YS
        self.setSize(w, h)

        x1, x2 = l.XM, self.width - 2*l.XS
        for i in range(2):
            y = l.YM
            for j in range(4):
                s.foundations.append(SS_FoundationStack(x1, y, self,
                                     suit=j, dir=2, max_cards=7))
                s.foundations.append(SS_FoundationStack(x2, y, self,
                                     base_rank=1, suit=j, dir=2, max_cards=6))
                y += l.YS
            x1 += l.XS
            x2 += l.XS

        x, y = l.XM + 3*l.XS, l.YM
        for i in (0, 1):
            stack = SS_RowStack(x, y, self, max_move=1, base_rank=KING)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
            s.rows.append(stack)
            x += w0
        y = l.YM+l.YS
        for i in range(4):
            x = l.XM + 2*l.XS
            for j in range(3):
                stack = SS_RowStack(x, y, self, max_move=1, base_rank=KING)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
                s.rows.append(stack)
                x += w0
            y += l.YS
        x, y = l.XM + 3*l.XS, l.YM + 5*l.YS
        for i in (0, 1):
            stack = SS_RowStack(x, y, self, max_move=1, base_rank=KING)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
            s.rows.append(stack)
            x += w0

        x, y = l.XM, self.height - l.YS
        s.talon = ForestGlade_Talon(x, y, self, max_rounds=3)
        l.createText(s.talon, 'ne')
        l.createRoundText(s.talon, 'se')

        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(2)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# register the game
registerGame(GameInfo(56, FanGame, "Fan",
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(87, ScotchPatience, "Scotch Patience",
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(57, Shamrocks, "Shamrocks",
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(901, LaBelleLucie, "La Belle Lucie",      # was: 32, 82
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 1, 2, GI.SL_MOSTLY_SKILL,
                      altnames=("Fair Lucy", "Midnight Oil")))
registerGame(GameInfo(132, SuperFlowerGarden, "Super Flower Garden",
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 1, 2, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(128, ThreeShufflesAndADraw, "Three Shuffles and a Draw",
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 1, 2, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(88, Trefoil, "Trefoil",
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 1, 2, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(227, Intelligence, "Intelligence",
                      GI.GT_FAN_TYPE, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(340, IntelligencePlus, "Intelligence +",
                      GI.GT_FAN_TYPE, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(268, HouseInTheWood, "House in the Wood",
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(317, HouseOnTheHill, "House on the Hill",
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 2, 0, GI.SL_MOSTLY_SKILL,
                      rules_filename='houseinthewood.html'))
registerGame(GameInfo(320, CloverLeaf, "Clover Leaf",
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(347, FreeFan, "Free Fan",
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(385, BoxFan, "Box Fan",
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(516, Troika, "Troika",
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(517, Quads, "Quads",
                      GI.GT_FAN_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(625, FascinationFan, "Fascination Fan",
                      GI.GT_FAN_TYPE, 1, 6, GI.SL_BALANCED,
                      altnames=('Demon Fan',)))
registerGame(GameInfo(647, Crescent, "Crescent",
                      GI.GT_FAN_TYPE, 2, 3, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(714, ShamrocksII, "Shamrocks II",
                      GI.GT_FAN_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(719, School, "School",
                      GI.GT_FAN_TYPE, 1, 2, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(739, ForestGlade, "Forest Glade",
                      GI.GT_FAN_TYPE, 2, 2, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(767, QuadsPlus, "Quads +",
                      GI.GT_FAN_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.stack import \
        AC_RowStack, \
        AbstractFoundationStack, \
        BasicRowStack, \
        InitialDealTalonStack, \
        OpenStack, \
        Stack, \
        StackWrapper, \
        UD_RK_RowStack, \
        isAlternateColorSequence
from pysollib.util import ANY_RANK, ANY_SUIT, JACK, KING, QUEEN

# ************************************************************************
# * Take Away
# ************************************************************************


class TakeAway_Foundation(AbstractFoundationStack):

    def acceptsCards(self, from_stack, cards):
        if not self.cards:
            return True
        c1, c2, mod = self.cards[-1], cards[0], self.cap.mod
        return (c1.rank == (c2.rank + 1) % mod or
                c2.rank == (c1.rank + 1) % mod)

    def closeStack(self):
        pass

    def getHelp(self):
        return _('Foundation. Build up or down regardless of suit.')


class TakeAway(Game):

    RowStack_Class = BasicRowStack
    Foundation_Class = StackWrapper(TakeAway_Foundation, max_move=0, mod=13)

    #
    # game layout
    #

    def createGame(self, reserves=6):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = 2*l.XM+10*l.XS, l.YM+l.YS+16*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(4):
            s.rows.append(self.RowStack_Class(x, y, self,
                                              max_move=1, max_accept=0))
            x += l.XS
        x += l.XM
        for i in range(6):
            stack = self.Foundation_Class(x, y, self, suit=ANY_SUIT,
                                          base_rank=ANY_RANK)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, l.YOFFSET
            s.foundations.append(stack)
            x += l.XS
        s.talon = InitialDealTalonStack(w-l.XS, h-l.YS, self)

        # default
        l.defaultAll()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(10)
        for i in range(3):
            self.s.talon.dealRow()


# ************************************************************************
# * Four Stacks
# ************************************************************************

class FourStacks_RowStack(AC_RowStack):
    getBottomImage = Stack._getReserveBottomImage


class FourStacks(Game):
    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+10*l.XS, l.YM+l.YS+16*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(10):
            s.rows.append(FourStacks_RowStack(x, y, self))
            x += l.XS
        s.talon = InitialDealTalonStack(w-l.XS, h-l.YS, self)

        # default
        l.defaultAll()

    def startGame(self):
        rows = self.s.rows[:4]
        for i in range(10):
            self.s.talon.dealRow(rows=rows, frames=0)
        self.startDealSample()
        for i in range(3):
            self.s.talon.dealRow(rows=rows)

    def isGameWon(self):
        for s in self.s.rows:
            if s.cards:
                if len(s.cards) != 13 or not isAlternateColorSequence(s.cards):
                    return False
        return True

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Striptease
# ************************************************************************

class Striptease_RowStack(UD_RK_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return False
        if not self.cards:
            return True
        r1, r2 = self.cards[-1].rank, cards[0].rank
        if ((r1 == JACK and r2 == KING) or
                (r2 == JACK and r1 == KING)):
            return True
        return ((r1+1) % 13 == r2 or (r2+1) % 13 == r1)

    getBottomImage = Stack._getReserveBottomImage


class Striptease_Reserve(OpenStack):
    def canFlipCard(self):
        if not OpenStack.canFlipCard(self):
            return False
        for r in self.game.s.reserves:
            if len(r.cards) > 2:
                return False
        return True


class Striptease(TakeAway):

    def createGame(self):
        l, s = Layout(self), self.s
        w, h = l.XM+9*l.XS, l.YM+l.YS+16*l.YOFFSET
        self.setSize(w, h)

        x, y = l.XM, l.YM
        for i in range(4):
            stack = Striptease_Reserve(x, y, self, max_move=1,
                                       min_cards=1, max_accept=0)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, l.YOFFSET
            s.reserves.append(stack)
            x += l.XS
        x += l.XS
        for i in range(4):
            stack = Striptease_RowStack(x, y, self, max_move=0, mod=13)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, l.YOFFSET
            s.rows.append(stack)
            x += l.XS
        s.talon = InitialDealTalonStack(w-l.XS, h-l.YS, self)

        l.defaultAll()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(cards,
                                          lambda c: (c.rank == QUEEN, None))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.s.talon.dealRow(rows=self.s.reserves, flip=0, frames=0)
        for i in range(8):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        for i in range(3):
            self.s.talon.dealRow(rows=self.s.reserves)

    def isGameWon(self):
        for r in self.s.reserves:
            if len(r.cards) != 1:
                return False
        return True

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        r1, r2 = card1.rank, card2.rank
        if r1 == QUEEN or r2 == QUEEN:
            return False
        if ((r1 == JACK and r2 == KING) or
                (r2 == JACK and r1 == KING)):
            return True
        return ((r1+1) % 13 == r2 or (r2+1) % 13 == r1)


# register the game
registerGame(GameInfo(334, TakeAway, "Take Away",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(335, FourStacks, "Four Stacks",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(654, Striptease, "Striptease",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        AbstractFoundationStack, \
        ReserveStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ANY_SUIT, KING

# ************************************************************************
# * Doublets
# ************************************************************************


class Doublets_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if self.cards:
            # check the rank
            if (2 * self.cards[-1].rank + 1) % self.cap.mod != cards[0].rank:
                return False
        return True


class Doublets(Game):
    Hint_Class = CautiousDefaultHint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 5.5*l.XS, l.YM + 4*l.YS)

        # create stacks
        for dx, dy in ((0, 0), (1, 0), (2, 0), (0, 1), (2, 1), (0, 2), (2, 2)):
            x, y = l.XM + (2*dx+5)*l.XS//2, l.YM + (2*dy+1)*l.YS//2
            s.rows.append(ReserveStack(x, y, self))
        dx, dy = 1, 2
        x, y = l.XM + (2*dx+5)*l.XS//2, l.YM + (2*dy+1)*l.YS//2
        s.foundations.append(Doublets_Foundation(x, y, self, ANY_SUIT,
                                                 dir=0, mod=13,
                                                 max_move=0, max_cards=48))
        l.createText(s.foundations[0], "s")
#         help = "A, 2, 4, 8, 3, 6, Q, J, 9, 5, 10, 7, A, ..."
#         self.texts.help = MfxCanvasText(
#             self.canvas, x + l.CW//2, y + l.YS + l.YM, anchor="n", text=help)
        x, y = l.XM, l.YM + 3*l.YS//2
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "s")
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")
        l.createRoundText(s.talon, 'nn')

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        # move all Kings in the first 8 cards to the bottom
        kings, topcards = [], []
        for c in cards[:]:
            cards.remove(c)
            if c.rank == KING:
                kings.append(c)
            else:
                topcards.append(c)
                if len(topcards) == 8:
                    break
        return kings + cards + topcards

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealCards()          # deal first card to WasteStack

    def isGameWon(self):
        if self.s.talon.cards or self.s.waste.cards:
            return False
        return len(self.s.foundations[0].cards) == 48

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if self.s.waste.cards:
                self.s.waste.moveMove(1, stack)
            elif self.s.talon.canDealCards():
                self.s.talon.dealCards()
                self.s.waste.moveMove(1, stack)
            self.leaveState(old_state)

    def getAutoStacks(self, event=None):
        return ((), (), self.sg.dropstacks)


# register the game
registerGame(GameInfo(111, Doublets, "Doublets",
                      GI.GT_1DECK_TYPE, 1, 2, GI.SL_MOSTLY_LUCK,
                      altnames=('Double or Quits',)))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import DefaultHint
from pysollib.layout import Layout
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AbstractFoundationStack, \
        BasicRowStack, \
        DealReserveRedealTalonStack, \
        DealRowTalonStack, \
        FaceUpWasteTalonStack, \
        InitialDealTalonStack, \
        OpenStack, \
        ReserveStack, \
        Stack, \
        StackWrapper, \
        TalonStack, \
        WasteStack, \
        WasteTalonStack, \
        getNumberOfFreeStacks
from pysollib.util import ANY_RANK, ANY_SUIT, JACK, KING, NO_RANK, QUEEN, \
        UNLIMITED_CARDS, UNLIMITED_REDEALS


# ************************************************************************
# *
# ************************************************************************

class Pyramid_Hint(DefaultHint):
    # consider moving card to the Talon as well
    def step010(self, dropstacks, rows):
        rows = rows + (self.game.s.talon,)
        return DefaultHint.step010(self, dropstacks, rows)


# ************************************************************************
# * basic logic for Talon, Waste and Rows
# ************************************************************************

class Pyramid_StackMethods:
    def acceptsCards(self, from_stack, cards):
        if self.basicIsBlocked():
            return False
        if from_stack is self or not self.cards or len(cards) != 1:
            return False
        c = self.cards[-1]
        return c.face_up and cards[0].face_up and cards[0].rank + c.rank == 11

    def _dropKingClickHandler(self, event):
        if not self.cards:
            return 0
        c = self.cards[-1]
        if c.face_up and c.rank == KING and not self.basicIsBlocked():
            self.game.playSample("autodrop", priority=20)
            self.playMoveMove(1, self.game.s.foundations[0], sound=False)
            return 1
        return 0

    def _dropPairMove(self, n, other_stack, frames=-1, shadow=-1):
        if not self.game.demo:
            self.game.playSample("droppair", priority=200)
        if not (n == 1
                and other_stack.cards
                and self.acceptsCards(other_stack, [other_stack.cards[-1]])):
            return
        old_state = self.game.enterState(self.game.S_FILL)
        f = self.game.s.foundations[0]
        self.game.moveMove(n, self, f, frames=frames, shadow=shadow)
        self.game.moveMove(n, other_stack, f, frames=frames, shadow=shadow)
        self.game.leaveState(old_state)
        self.fillStack()
        other_stack.fillStack()

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        if to_stack in self.game.s.foundations:
            self.game.moveMove(
                ncards, self, to_stack, frames=frames, shadow=shadow)
            self.fillStack()
        else:
            self._dropPairMove(ncards, to_stack, frames=-1, shadow=shadow)


# ************************************************************************
# *
# ************************************************************************

class Pyramid_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # We accept any King. Pairs will get delivered by _dropPairMove.
        return cards[0].rank == KING


# note that this Talon can accept and drop cards
class Pyramid_Talon(Pyramid_StackMethods, FaceUpWasteTalonStack):
    def clickHandler(self, event):
        if self._dropKingClickHandler(event):
            return 1
        return FaceUpWasteTalonStack.clickHandler(self, event)

    def releaseHandler(self, event, drag, sound=True):
        if self.game.app.opt.mouse_type == 'point-n-click':
            drag.stack.dragMove(drag, self, sound=sound)
            return
        FaceUpWasteTalonStack.releaseHandler(self, event, drag, sound)

    def canDealCards(self):
        if not FaceUpWasteTalonStack.canDealCards(self):
            return False
        return not self.game.isGameWon()

    def canDropCards(self, stacks):
        if self.cards:
            cards = self.cards[-1:]
            for s in stacks:
                if s is not self and s.acceptsCards(self, cards):
                    return (s, 1)
        return (None, 0)


class Pyramid_Waste(Pyramid_StackMethods, WasteStack):
    def clickHandler(self, event):
        if self._dropKingClickHandler(event):
            return 1
        return WasteStack.clickHandler(self, event)


class Pyramid_RowStack(Pyramid_StackMethods, OpenStack):
    def __init__(self, x, y, game):
        OpenStack.__init__(self, x, y, game, max_accept=1, max_cards=2)
        self.CARD_YOFFSET = 1
        self.blockmap = []

    def basicIsBlocked(self):
        for r in self.blockmap:
            if r.cards:
                return True
        return False

    def clickHandler(self, event):
        if self._dropKingClickHandler(event):
            return 1
        return OpenStack.clickHandler(self, event)

    getBottomImage = Stack._getNoneBottomImage

    def copyModel(self, clone):
        OpenStack.copyModel(self, clone)
        clone.blockmap = self.blockmap


# ************************************************************************
# * Pyramid
# ************************************************************************

class Pyramid(Game):
    Hint_Class = Pyramid_Hint
    Foundation_Class = Pyramid_Foundation
    Talon_Class = StackWrapper(Pyramid_Talon, max_rounds=3, max_accept=1)
    RowStack_Class = Pyramid_RowStack
    WasteStack_Class = Pyramid_Waste

    PYRAMID_Y_FACTOR = 2

    #
    # game layout
    #

    def _createPyramid(self, l, x0, y0, size):
        rows = []
        # create stacks
        for i in range(size):
            x = x0 + (size-1-i) * l.XS // 2
            y = y0 + i * l.YS // self.PYRAMID_Y_FACTOR
            for j in range(i+1):
                stack = self.RowStack_Class(x, y, self)
                rows.append(stack)
                x = x + l.XS
        # compute blocking
        n = 0
        for i in range(size-1):
            for j in range(i+1):
                k = n+i+1
                rows[n].blockmap = [rows[k], rows[k+1]]
                n += 1
        return rows

    def _createInvertedPyramid(self, l, x0, y0, size):
        rows = []
        # create stacks
        for i in range(size):
            x = x0 + i * l.XS // 2
            y = y0 + i * l.YS // self.PYRAMID_Y_FACTOR
            for j in range(size-i):
                stack = self.RowStack_Class(x, y, self)
                rows.append(stack)
                x = x + l.XS
        # compute blocking
        n = 0
        for i in range(size-1):
            for j in range(size-i):
                k = n+(size-i)
                if j == 0:              # left
                    rows[n].blockmap = [rows[k]]
                elif j == size-i-1:     # right
                    rows[n].blockmap = [rows[k-1]]
                else:
                    rows[n].blockmap = [rows[k-1], rows[k]]
                n += 1
        return rows

    def createGame(self, pyramid_len=7, reserves=0, waste=True, texts=True):
        # create layout
        l, s = Layout(self), self.s

        # set window
        max_rows = max(pyramid_len+2, reserves)
        w = l.XM + max_rows*l.XS
        h = l.YM + l.YS + (pyramid_len-1)*l.YS//self.PYRAMID_Y_FACTOR
        if reserves:
            h += l.YS+2*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        decks = self.gameinfo.decks

        x, y = l.XM+l.XS, l.YM
        s.rows = self._createPyramid(l, x, y, pyramid_len)

        x, y = l.XM, l.YM
        s.talon = self.Talon_Class(x, y, self)
        if texts:
            l.createText(s.talon, "se")
            if s.talon.max_rounds > 1:
                l.createRoundText(s.talon, 'ne')
        if waste:
            y = y + l.YS
            s.waste = self.WasteStack_Class(x, y, self, max_accept=1)
            l.createText(s.waste, "se")
        x, y = self.width - l.XS, l.YM
        s.foundations.append(self.Foundation_Class(x, y, self,
                             suit=ANY_SUIT, dir=0, base_rank=ANY_RANK,
                             max_move=0, max_cards=52*decks))
        l.createText(s.foundations[0], 's')
        if reserves:
            x, y = l.XM+(max_rows-reserves)*l.XS//2, l.YM+4*l.YS
            for i in range(reserves):
                stack = self.Reserve_Class(x, y, self)
                s.reserves.append(stack)
                stack.CARD_YOFFSET = l.YOFFSET
                x += l.XS

        # define stack-groups
        l.defaultStackGroups()
        self.sg.openstacks.append(s.talon)
        self.sg.dropstacks.append(s.talon)
        if s.waste:
            self.sg.openstacks.append(s.waste)

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(frames=4)
        self.s.talon.dealCards()          # deal first card to WasteStack

    def getAutoStacks(self, event=None):
        return (self.sg.dropstacks, self.sg.dropstacks, ())

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank + card2.rank == 11


# ************************************************************************
# * Relaxed Pyramid
# ************************************************************************

class RelaxedPyramid(Pyramid):
    # the pyramid must be empty
    def isGameWon(self):
        return getNumberOfFreeStacks(self.s.rows) == len(self.s.rows)


# ************************************************************************
# * Giza
# ************************************************************************

class Giza_Reserve(Pyramid_StackMethods, OpenStack):
    def clickHandler(self, event):
        if self._dropKingClickHandler(event):
            return 1
        return OpenStack.clickHandler(self, event)


class Giza(Pyramid):
    Talon_Class = InitialDealTalonStack
    Reserve_Class = StackWrapper(Giza_Reserve, max_accept=1)

    def createGame(self):
        Pyramid.createGame(self, reserves=8, waste=False, texts=False)

    def startGame(self):
        for i in range(3):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(frames=4)


# ************************************************************************
# * Thirteen
# * FIXME: UNFINISHED
# * (this doesn't work yet as 2 cards of the Waste should be playable)
# ************************************************************************

class Thirteen(Pyramid):

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(7*l.XS+l.XM, 5*l.YS+l.YM)

        # create stacks
        for i in range(7):
            x = l.XM + (6-i) * l.XS // 2
            y = l.YM + l.YS + i * l.YS // 2
            for j in range(i+1):
                s.rows.append(Pyramid_RowStack(x, y, self))
                x = x + l.XS
        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "s")
        x = x + l.XS
        s.waste = Pyramid_Waste(x, y, self, max_accept=1)
        l.createText(s.waste, "s")
        s.waste.CARD_XOFFSET = 14
        x, y = self.width - l.XS, l.YM
        s.foundations.append(Pyramid_Foundation(x, y, self,
                             suit=ANY_SUIT, dir=0, base_rank=ANY_RANK,
                             max_move=0, max_cards=52))

        # define stack-groups
        self.sg.talonstacks = [s.talon] + [s.waste]
        self.sg.openstacks = s.rows + self.sg.talonstacks
        self.sg.dropstacks = s.rows + self.sg.talonstacks

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:21], flip=0)
        self.s.talon.dealRow(rows=self.s.rows[21:])
        self.s.talon.dealCards()          # deal first card to WasteStack


# ************************************************************************
# * Thirteens
# ************************************************************************

class Thirteens(Pyramid):

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+5*l.XS, l.YM+4*l.YS)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(2):
            x = l.XM
            for j in range(5):
                s.rows.append(Giza_Reserve(x, y, self, max_accept=1))
                x += l.XS
            y += l.YS
        x, y = l.XM, self.height-l.YS
        s.talon = TalonStack(x, y, self)
        l.createText(s.talon, 'n')
        x, y = self.width-l.XS, self.height-l.YS
        s.foundations.append(Pyramid_Foundation(x, y, self,
                             suit=ANY_SUIT, dir=0, base_rank=ANY_RANK,
                             max_move=0, max_cards=52))
        l.createText(s.foundations[0], 'n')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startAndDealRow()

    def fillStack(self, stack):
        if stack in self.s.rows:
            if not stack.cards and self.s.talon.cards:
                old_state = self.enterState(self.S_FILL)
                self.s.talon.flipMove()
                self.s.talon.moveMove(1, stack)
                self.leaveState(old_state)

# ************************************************************************
# * Elevens
# * Suit Elevens
# ************************************************************************


class Elevens_RowStack(Giza_Reserve):
    ACCEPTED_SUM = 9

    def acceptsCards(self, from_stack, cards):
        # if self.basicIsBlocked():
        #    return False
        if from_stack is self or not self.cards or len(cards) != 1:
            return False
        c = self.cards[-1]
        return (c.face_up and cards[0].face_up and
                cards[0].rank + c.rank == self.ACCEPTED_SUM)

    def clickHandler(self, event):
        return OpenStack.clickHandler(self, event)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        if to_stack in self.game.s.rows:
            self._dropPairMove(ncards, to_stack, frames=-1, shadow=shadow)
        else:
            self.game.moveMove(ncards, self, to_stack,
                               frames=frames, shadow=shadow)
            self.fillStack()


class Elevens_Reserve(ReserveStack):
    ACCEPTED_CARDS = (JACK, QUEEN, KING)

    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        c = cards[0]
        if c.rank not in self.ACCEPTED_CARDS:
            return False
        for s in self.game.s.reserves:
            if s.cards and s.cards[0].rank == c.rank:
                return False
        return True


class Elevens(Pyramid):

    RowStack_Class = Elevens_RowStack
    Reserve_Class = Elevens_Reserve

    def createGame(self, rows=3, cols=3, reserves=3, texts=False):

        l, s = Layout(self), self.s

        self.setSize(l.XM+(cols+2)*l.XS, l.YM+(rows+1.5)*l.YS)

        x, y = self.width-l.XS, l.YM
        s.talon = TalonStack(x, y, self)
        l.createText(s.talon, 's')
        x, y = self.width-l.XS, self.height-l.YS
        s.foundations.append(AbstractFoundationStack(x, y, self,
                             suit=ANY_SUIT, max_accept=0,
                             max_move=0, max_cards=52))
        l.createText(s.foundations[0], 'n')
        y = l.YM
        for i in range(rows):
            x = l.XM
            for j in range(cols):
                s.rows.append(self.RowStack_Class(x, y, self, max_accept=1))
                x += l.XS
            y += l.YS
        x, y = l.XM, self.height-l.YS
        for i in range(reserves):
            stack = self.Reserve_Class(x, y, self)
            s.reserves.append(stack)
            stack.CARD_XOFFSET = l.XOFFSET  # for fifteens
            x += l.XS

        if texts:
            stack = s.reserves[0]
            tx, ty, ta, tf = l.getTextAttr(stack, "n")
            font = self.app.getFont("canvas_default")
            stack.texts.misc = MfxCanvasText(self.canvas, tx, ty,
                                             anchor=ta, font=font)

        l.defaultStackGroups()

    def startGame(self):
        self._startAndDealRow()

    def fillStack(self, stack):
        old_state = self.enterState(self.S_FILL)
        if stack in self.s.rows:
            if not stack.cards and self.s.talon.cards:
                self.s.talon.flipMove()
                self.s.talon.moveMove(1, stack)
        reserves_ncards = 0
        for s in self.s.reserves:
            if s.cards:
                reserves_ncards += 1
        if reserves_ncards == len(self.s.reserves):
            if not self.demo:
                self.playSample("droppair", priority=200)
            for s in self.s.reserves:
                s.moveMove(1, self.s.foundations[0], frames=4)
        self.leaveState(old_state)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        # FIXME
        return False


class ElevensToo(Elevens):

    def fillStack(self, stack):
        old_state = self.enterState(self.S_FILL)
        reserves_ncards = 0
        for s in self.s.reserves:
            if s.cards:
                reserves_ncards += 1
        if reserves_ncards == 0:
            for r in self.s.rows:
                if not r.cards and self.s.talon.cards:
                    self.s.talon.flipMove()
                    self.s.talon.moveMove(1, r)
        elif reserves_ncards == len(self.s.reserves):
            if not self.demo:
                self.playSample("droppair", priority=200)
            for s in self.s.reserves:
                s.moveMove(1, self.s.foundations[0], frames=4)
            self.fillStack(stack)
        self.leaveState(old_state)


class SuitElevens_RowStack(Elevens_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not Elevens_RowStack.acceptsCards(self, from_stack, cards):
            return False
        return cards[0].suit == self.cards[0].suit


class SuitElevens_Reserve(Elevens_Reserve):
    def acceptsCards(self, from_stack, cards):
        if not Elevens_Reserve.acceptsCards(self, from_stack, cards):
            return False
        for r in self.game.s.reserves:
            if r.cards and r.cards[0].suit != cards[0].suit:
                return False
        return True


class SuitElevens(Elevens):
    RowStack_Class = SuitElevens_RowStack
    Reserve_Class = SuitElevens_Reserve

    def createGame(self):
        Elevens.createGame(self, rows=3, cols=5)


# ************************************************************************
# * Fifteens
# ************************************************************************

class Fifteens_RowStack(Elevens_RowStack):
    ACCEPTED_SUM = 13

    def acceptsCards(self, from_stack, cards):
        if not Elevens_RowStack.acceptsCards(self, from_stack, cards):
            return False
        return cards[0].rank < 9 and self.cards[0].rank < 9


class Fifteens_Reserve(ReserveStack):
    def updateText(self):
        if self.game.preview > 1 or self.texts.misc is None:
            return
        t = ''
        if self.cards:
            ranks = [c.rank for c in self.cards]
            for r in (9, JACK, QUEEN, KING):
                if r in ranks:
                    break
            else:
                n = sum([i+1 for i in ranks])
                t = str(n)
        self.texts.misc.config(text=t)


class Fifteens(Elevens):
    Hint_Class = None

    RowStack_Class = Fifteens_RowStack
    Reserve_Class = StackWrapper(Fifteens_Reserve, max_cards=UNLIMITED_CARDS)

    def createGame(self):
        Elevens.createGame(self, rows=4, cols=4, reserves=1, texts=True)

    def _dropReserve(self):
        reserve = self.s.reserves[0]
        if not self.demo:
            self.playSample("droppair", priority=200)
        while reserve.cards:
            reserve.moveMove(1, self.s.foundations[0], frames=4)
        self.fillStack()

    def fillStack(self, stack=None):
        old_state = self.enterState(self.S_FILL)
        reserve = self.s.reserves[0]
        if len(reserve.cards) == 0:
            for r in self.s.rows:
                if not r.cards and self.s.talon.cards:
                    self.s.talon.flipMove()
                    self.s.talon.moveMove(1, r)
        else:
            reserve_ranks = [c.rank for c in reserve.cards]
            reserve_ranks.sort()
            if (9 in reserve_ranks or JACK in reserve_ranks or
                    QUEEN in reserve_ranks or KING in reserve_ranks):
                if reserve_ranks == [9, JACK, QUEEN, KING]:
                    self._dropReserve()
            else:
                reserve_sum = sum([c.rank+1 for c in reserve.cards])
                if reserve_sum == 15:
                    self._dropReserve()
        self.leaveState(old_state)


# ************************************************************************
# * Triple Alliance
# ************************************************************************

class TripleAlliance_Reserve(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        r_ranks = []
        for r in self.game.s.reserves:
            if r.cards:
                r_ranks.append(r.cards[0].rank)
        if not r_ranks:
            return True
        r_ranks.append(cards[0].rank)
        r_ranks.sort()
        if len(r_ranks) == 2:
            return r_ranks[1]-r_ranks[0] in (1, 12)
        for i in range(3):
            j, k = (i+1) % 3, (i+2) % 3
            if ((r_ranks[i]+1) % 13 == r_ranks[j] and
                    (r_ranks[j]+1) % 13 == r_ranks[k]):
                return True
        return False


class TripleAlliance(Game):

    def createGame(self):

        l, s = Layout(self), self.s
        w0 = l.XS+5*l.XOFFSET
        self.setSize(l.XM+5*w0, l.YM+5*l.YS)

        x, y = l.XM, l.YM
        for i in range(3):
            s.reserves.append(TripleAlliance_Reserve(x, y, self))
            x += l.XS
        x, y = self.width-l.XS, l.YM
        s.foundations.append(AbstractFoundationStack(x, y, self, suit=ANY_SUIT,
                             max_move=0, max_accept=0, max_cards=52))
        l.createText(s.foundations[0], 'nw')
        y = l.YM+l.YS
        nstacks = 0
        for i in range(4):
            x = l.XM
            for j in range(5):
                stack = BasicRowStack(x, y, self, max_accept=0)
                s.rows.append(stack)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
                x += w0
                nstacks += 1
                if nstacks >= 18:
                    break
            y += l.YS

        x, y = self.width-l.XS, self.height-l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRows(2)
        self.s.talon.dealRowAvail()

    def fillStack(self, stack):
        for r in self.s.reserves:
            if not r.cards:
                return
        if not self.demo:
            self.playSample("droppair", priority=200)
        old_state = self.enterState(self.S_FILL)
        for r in self.s.reserves:
            r.moveMove(1, self.s.foundations[0])
        self.leaveState(old_state)

    def isGameWon(self):
        return len(self.s.foundations[0].cards) == 51


# ************************************************************************
# * Pharaohs
# ************************************************************************

class Pharaohs(Pyramid):

    Talon_Class = InitialDealTalonStack
    RowStack_Class = Pyramid_RowStack

    PYRAMID_Y_FACTOR = 3

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w = l.XM + 9*l.XS
        h = l.YM + 5.67*l.YS
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        s.rows += self._createPyramid(l, x, y, 2)
        x, y = l.XM+2*l.XS, l.YM
        s.rows += self._createPyramid(l, x, y, 7)
        x, y = l.XM+2.5*l.XS, l.YM+3*l.YS
        s.rows += self._createPyramid(l, x, y, 6)

        x, y = l.XM, self.height-l.YS
        s.talon = self.Talon_Class(x, y, self)
        x, y = self.width - l.XS, l.YM
        s.foundations.append(Pyramid_Foundation(x, y, self,
                             suit=ANY_SUIT, dir=0, base_rank=ANY_RANK,
                             max_move=0, max_cards=52))
        l.createText(s.foundations[0], 's')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(frames=4)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.rank + card2.rank == 11 or
                card1.rank == card2.rank)


# ************************************************************************
# * Baroness
# ************************************************************************

class Baroness_Talon(DealRowTalonStack):
    def dealCards(self, sound=False):
        rows = self.game.s.rows
        if len(self.cards) == 7:
            rows += self.game.s.reserves
        return self.dealRowAvail(rows=rows, sound=sound)


class Baroness_RowStack(Giza_Reserve):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return False
        if not self.cards:
            return True
        return cards[0].rank + self.cards[-1].rank == 11

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        if to_stack in self.game.s.rows and not to_stack.cards:
            return OpenStack.moveMove(self, ncards, to_stack, frames, shadow)
        return Giza_Reserve.moveMove(self, ncards, to_stack, frames, shadow)


class Baroness(Pyramid):

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+9*l.XS, l.YM+max(3.5*l.YS, l.YS+12*l.YOFFSET))

        # create stacks
        x, y = l.XM, l.YM
        s.talon = Baroness_Talon(x, y, self)
        l.createText(s.talon, 's')

        x += 2*l.XS
        for i in range(5):
            stack = Baroness_RowStack(x, y, self, max_accept=1)
            s.rows.append(stack)
            stack.CARD_YOFFSET = l.YOFFSET
            x += l.XS
        x += l.XS
        s.foundations.append(Pyramid_Foundation(x, y, self,
                             suit=ANY_SUIT, dir=0, base_rank=ANY_RANK,
                             max_move=0, max_cards=52))
        l.createText(s.foundations[0], 's')
        x, y = l.XM, self.height-l.YS
        s.reserves.append(Giza_Reserve(x, y, self, max_accept=1))
        y -= l.YS
        s.reserves.append(Giza_Reserve(x, y, self, max_accept=1))

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startAndDealRow()


# ************************************************************************
# * Apophis
# ************************************************************************

class Apophis_Hint(Pyramid_Hint):
    def computeHints(self):
        DefaultHint.computeHints(self)
        if self.hints:
            return
        reserves = self.game.s.reserves
        for i in range(3):
            for j in range(i+1, 3):
                r1 = reserves[i]
                r2 = reserves[j]
                if r1.cards and r2.acceptsCards(r1, r1.cards[-1:]):
                    self.addHint(50000+len(r1.cards)+len(r2.cards), 1, r1, r2)


class Apophis_RowStack(Pyramid_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return False
        if not self.cards:
            return False
        r0, r1 = cards[0].rank, self.cards[-1].rank
        return r0+r1 == 11


class Apophis(Pharaohs):
    Hint_Class = Apophis_Hint
    RowStack_Class = Apophis_RowStack

    PYRAMID_Y_FACTOR = 2

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w = l.XM + 9*l.XS
        h = l.YM + 4*l.YS
        self.setSize(w, h)

        # create stacks
        x, y = l.XM+1.5*l.XS, l.YM
        s.rows = self._createPyramid(l, x, y, 7)

        x, y = l.XM, l.YM
        s.talon = DealReserveRedealTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, 'se')
        l.createRoundText(s.talon, 'ne')

        y += l.YS
        for i in range(3):
            stack = Pyramid_Waste(x, y, self, max_accept=1)
            s.reserves.append(stack)
            l.createText(stack, 'se')
            y += l.YS
        x, y = self.width - l.XS, l.YM
        s.foundations.append(Pyramid_Foundation(x, y, self,
                             suit=ANY_SUIT, dir=0, base_rank=ANY_RANK,
                             max_move=0, max_cards=52))
        l.createText(s.foundations[0], 'nw')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(frames=4)
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank + card2.rank == 11

# ************************************************************************
# * Cheops
# ************************************************************************


class Cheops_StackMethods(Pyramid_StackMethods):
    def acceptsCards(self, from_stack, cards):
        if self.basicIsBlocked():
            return False
        if from_stack is self or not self.cards or len(cards) != 1:
            return False
        c = self.cards[-1]
        return (c.face_up and cards[0].face_up and
                abs(cards[0].rank-c.rank) in (0, 1))


class Cheops_Talon(Cheops_StackMethods, Pyramid_Talon):
    def clickHandler(self, event):
        return FaceUpWasteTalonStack.clickHandler(self, event)


class Cheops_Waste(Cheops_StackMethods, Pyramid_Waste):
    def clickHandler(self, event):
        return WasteStack.clickHandler(self, event)


class Cheops_RowStack(Cheops_StackMethods, Pyramid_RowStack):
    def clickHandler(self, event):
        return OpenStack.clickHandler(self, event)


class Cheops(Pyramid):

    Foundation_Class = StackWrapper(AbstractFoundationStack, max_accept=0)
    Talon_Class = StackWrapper(Cheops_Talon, max_rounds=1, max_accept=1)
    RowStack_Class = Cheops_RowStack
    WasteStack_Class = Cheops_Waste

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return abs(card1.rank-card2.rank) in (0, 1)


# ************************************************************************
# * Exit
# ************************************************************************

class Exit_RowStack(Elevens_RowStack):
    def acceptsCards(self, from_stack, cards):
        # if self.basicIsBlocked():
        #    return False
        if from_stack is self or not self.cards or len(cards) != 1:
            return False
        c1 = self.cards[-1]
        c2 = cards[0]
        # if not c1.face_up or not c2.face_up:
        #    return False
        return self.game._checkPair(c1, c2)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        self._dropPairMove(ncards, to_stack, frames=-1, shadow=shadow)


class Exit(Game):
    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        h1 = l.YS+5*l.YOFFSET
        self.setSize(l.XM+7*l.XS, l.YM+2*h1+l.YS)

        # create stacks
        y = l.YM
        for i in (0, 1):
            x = l.XM
            for j in range(5):
                stack = Exit_RowStack(x, y, self, base_rank=NO_RANK,
                                      max_move=1, max_accept=1, dir=0)
                s.rows.append(stack)
                stack.CARD_YOFFSET = l.YOFFSET
                x += l.XS
            y += h1
        x, y = self.width-l.XS, l.YM
        stack = Exit_RowStack(x, y, self, base_rank=NO_RANK,
                              max_move=1, max_accept=1, dir=0)
        s.reserves.append(stack)
        stack.CARD_YOFFSET = l.YOFFSET
        x, y = self.width-l.XS, self.height-l.YS
        s.foundations.append(AbstractFoundationStack(x, y, self, suit=ANY_SUIT,
                             max_accept=0, max_move=0, max_cards=52))
        l.createText(s.foundations[0], "n")
        x, y = l.XM, self.height-l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()

    def _checkPair(self, c1, c2):
        if c1.rank + c2.rank == 9:      # A-10, 2-9, 3-8, 4-7, 5-6
            return True
        if c1.rank == JACK and c2.rank == JACK:
            return True
        if c1.rank + c2.rank == 23:     # Q-K
            return True
        return False

    def _shuffleHook(self, cards):
        swap_index = None
        for i in range(10):
            jack_indexes = []
            for j in range(5):
                k = i*5+j
                c = cards[k]
                if c.rank == JACK:
                    jack_indexes.append(k)
            if len(jack_indexes) == 3:
                swap_index = jack_indexes[1]
            if len(jack_indexes) >= 2:
                break
        if swap_index is not None:
            i = -1
            if cards[-1].rank == JACK:  # paranoia
                i = -2
            cards[swap_index], cards[i] = cards[i], cards[swap_index]
        cards.reverse()
        return cards

    def startGame(self):
        self.startDealSample()
        for i in range(10):
            for j in range(5):
                self.s.talon.dealRow(rows=[self.s.rows[i]], frames=4)
        self.s.talon.dealRow(rows=self.s.reserves, frames=4)
        self.s.talon.dealRow(rows=self.s.reserves, frames=4)

        #     def getAutoStacks(self, event=None):
        #         return ((), (), self.sg.dropstacks)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return self._checkPair(card1, card2)


# ************************************************************************
# * Two Pyramids
# ************************************************************************

class TwoPyramids(Pyramid):

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w = l.XM + 14*l.XS
        h = l.YM + 5*l.YS
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM+l.YS
        s.rows = self._createPyramid(l, x, y, 7)
        x += 7*l.XS
        s.rows += self._createPyramid(l, x, y, 7)

        x, y = l.XM, l.YM
        s.talon = self.Talon_Class(x, y, self)
        l.createText(s.talon, "se")
        l.createRoundText(s.talon, 'ne')

        y += l.YS
        s.waste = self.WasteStack_Class(x, y, self, max_accept=1)
        l.createText(s.waste, "se")
        x, y = self.width-l.XS, l.YM
        s.foundations.append(self.Foundation_Class(x, y, self,
                             suit=ANY_SUIT, dir=0, base_rank=ANY_RANK,
                             max_move=0, max_cards=104))
        l.createText(s.foundations[0], 'nw')
        # define stack-groups
        l.defaultStackGroups()
        self.sg.openstacks.append(s.talon)
        self.sg.dropstacks.append(s.talon)
        self.sg.openstacks.append(s.waste)


# ************************************************************************
# * King Tut
# ************************************************************************

class KingTut(RelaxedPyramid):

    def createGame(self):
        l, s = Layout(self), self.s

        w = l.XM + max(7*l.XS, 2*l.XS+23*l.XOFFSET)
        h = l.YM + 5.5*l.YS
        self.setSize(w, h)

        x, y = l.XM+(w-7*l.XS)//2, l.YM
        s.rows = self._createPyramid(l, x, y, 7)

        x, y = l.XM, self.height-l.YS
        s.talon = WasteTalonStack(
            x, y, self, max_rounds=UNLIMITED_REDEALS, num_deal=3)
        l.createText(s.talon, "n")
        x += l.XS
        s.waste = Pyramid_Waste(x, y, self, max_accept=1)
        s.waste.CARD_XOFFSET = l.XOFFSET
        l.createText(s.waste, "n")

        x, y = self.width - l.XS, l.YM
        s.foundations.append(self.Foundation_Class(x, y, self,
                             suit=ANY_SUIT, dir=0, base_rank=ANY_RANK,
                             max_move=0, max_cards=52))
        l.createText(s.foundations[0], 'nw')

        l.defaultStackGroups()
        self.sg.openstacks.append(s.waste)


# ************************************************************************
# * Double Pyramid
# ************************************************************************

class DoublePyramid(Pyramid):
    def createGame(self):
        Pyramid.createGame(self, pyramid_len=9)


# ************************************************************************
# * Triangle
# ************************************************************************

class Triangle(Pyramid):

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w = l.XM + 10.5*l.XS
        h = l.YM + 4*l.YS
        self.setSize(w, h)

        # create stacks
        x, y = l.XM+2*l.XS, l.YM
        s.rows = self._createInvertedPyramid(l, x, y, 7)

        x, y = l.XM, l.YM
        s.talon = self.Talon_Class(x, y, self)
        l.createText(s.talon, "se")
        l.createRoundText(s.talon, 'ne')

        y += l.YS
        s.waste = self.WasteStack_Class(x, y, self, max_accept=1)
        l.createText(s.waste, "se")
        x, y = self.width - l.XS, l.YM
        s.foundations.append(self.Foundation_Class(x, y, self,
                             suit=ANY_SUIT, dir=0, base_rank=ANY_RANK,
                             max_move=0, max_cards=52))

        # define stack-groups
        l.defaultStackGroups()
        self.sg.openstacks.append(s.talon)
        self.sg.dropstacks.append(s.talon)
        self.sg.openstacks.append(s.waste)


# ************************************************************************
# * Up and Down
# ************************************************************************

class UpAndDown(Pyramid):

    def createGame(self, pyramid_len=7, reserves=0, waste=True, texts=True):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w = l.XM + 13*l.XS
        h = l.YM + 4*l.YS
        self.setSize(w, h)

        # create stacks
        x, y = l.XM+l.XS//2, l.YM
        s.rows = self._createPyramid(l, x, y, 7)
        x += 5.5*l.XS
        s.rows += self._createInvertedPyramid(l, x, y, 7)

        x, y = l.XM, l.YM
        s.talon = self.Talon_Class(x, y, self)
        l.createText(s.talon, "se")
        l.createRoundText(s.talon, 'ne')

        y += l.YS
        s.waste = self.WasteStack_Class(x, y, self, max_accept=1)
        l.createText(s.waste, "se")
        x, y = self.width - l.XS, self.height-l.YS
        s.foundations.append(self.Foundation_Class(x, y, self,
                             suit=ANY_SUIT, dir=0, base_rank=ANY_RANK,
                             max_move=0, max_cards=104))
        l.createText(s.foundations[0], 'sw')

        # define stack-groups
        l.defaultStackGroups()
        self.sg.openstacks.append(s.talon)
        self.sg.dropstacks.append(s.talon)
        self.sg.openstacks.append(s.waste)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(frames=4)
        self.s.talon.dealCards()          # deal first card to WasteStack


# ************************************************************************
# * Hurricane
# ************************************************************************

class Hurricane_Hint(DefaultHint):
    def step010(self, dropstacks, rows):
        rows = rows + self.game.s.reserves
        return DefaultHint.step010(self, dropstacks, rows)


class Hurricane_StackMethods(Pyramid_StackMethods):

    def acceptsCards(self, from_stack, cards):
        if from_stack is self:
            return False
        if len(cards) != 1:
            return False
        if not self.cards:
            return False
        c1 = self.cards[-1]
        c2 = cards[0]
        return c1.face_up and c2.face_up and c1.rank + c2.rank == 12

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        if to_stack in self.game.s.rows or \
               to_stack in self.game.s.reserves:
            self._dropPairMove(ncards, to_stack, frames=-1, shadow=shadow)
        else:
            self.game.moveMove(ncards, self, to_stack,
                               frames=frames, shadow=shadow)
            self.fillStack()


class Hurricane_RowStack(Hurricane_StackMethods, BasicRowStack):
    pass


class Hurricane_Reserve(Hurricane_StackMethods, OpenStack):
    pass


class Hurricane(Pyramid):
    Hint_Class = Hurricane_Hint

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        ww = l.XS + max(2*l.XOFFSET, l.XS//2)
        w = l.XM + 1.5*l.XS + 4*ww
        h = l.YM + 3*l.YS
        self.setSize(w, h)

        # create stacks
        for xx,  yy in ((0, 0), (1, 0), (2, 0), (3, 0),
                        (0, 1),             (3, 1),
                        (0, 2), (1, 2), (2, 2), (3, 2),
                        ):
            x, y = l.XM + 1.5*l.XS + ww*xx, l.YM + l.YS*yy
            stack = Hurricane_Reserve(x, y, self, max_accept=1)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
            s.reserves.append(stack)

        d = 3*ww - 4*l.XS - 2*l.XOFFSET
        x = l.XM + 1.5*l.XS + l.XS+2*l.XOFFSET + d//2
        y = l.YM+l.YS
        for i in range(3):
            stack = Hurricane_RowStack(x, y, self, max_accept=1)
            s.rows.append(stack)
            x += l.XS

        x, y = l.XM, l.YM
        s.talon = TalonStack(x, y, self)
        l.createText(s.talon, 'ne')
        y += 2*l.YS
        s.foundations.append(AbstractFoundationStack(x, y, self,
                             suit=ANY_SUIT, dir=0, base_rank=ANY_RANK,
                             max_accept=0, max_move=0, max_cards=52))
        l.createText(s.foundations[0], 'ne')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        for i in range(2):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRow()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards and self.s.talon.cards:
            old_state = self.enterState(self.S_FILL)
            self.s.talon.flipMove()
            self.s.talon.moveMove(1, stack)
            self.leaveState(old_state)


# register the game
registerGame(GameInfo(38, Pyramid, "Pyramid",
                      GI.GT_PAIRING_TYPE, 1, 2, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(193, RelaxedPyramid, "Relaxed Pyramid",
                      GI.GT_PAIRING_TYPE | GI.GT_RELAXED, 1, 2,
                      GI.SL_MOSTLY_LUCK,
                      altnames=(" Pyramid's Stones",)))
# registerGame(GameInfo(44, Thirteen, "Thirteen",
#                       GI.GT_PAIRING_TYPE, 1, 0))
registerGame(GameInfo(592, Giza, "Giza",
                      GI.GT_PAIRING_TYPE | GI.GT_OPEN, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(593, Thirteens, "Thirteens",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_LUCK))
registerGame(GameInfo(594, Elevens, "Elevens",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_LUCK))
registerGame(GameInfo(595, ElevensToo, "Elevens Too",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_LUCK))
registerGame(GameInfo(596, SuitElevens, "Suit Elevens",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_LUCK))
registerGame(GameInfo(597, Fifteens, "Fifteens",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(619, TripleAlliance, "Triple Alliance",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(655, Pharaohs, "Pharaohs",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(657, Baroness, "Baroness",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_BALANCED,
                      altnames=('Five Piles',)))
registerGame(GameInfo(658, Apophis, "Apophis",
                      GI.GT_PAIRING_TYPE, 1, 2, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(659, Cheops, "Cheops",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(674, Exit, "Exit",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(677, TwoPyramids, "Two Pyramids",
                      GI.GT_PAIRING_TYPE | GI.GT_ORIGINAL, 2, 2,
                      GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(681, KingTut, "King Tut",
                      GI.GT_PAIRING_TYPE, 1, -1, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(699, DoublePyramid, "Double Pyramid",
                      GI.GT_PAIRING_TYPE, 2, 2, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(700, Triangle, "Triangle",
                      GI.GT_PAIRING_TYPE, 1, 2, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(701, UpAndDown, "Up and Down",
                      GI.GT_PAIRING_TYPE | GI.GT_ORIGINAL, 2, 2,
                      GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(735, Hurricane, "Hurricane",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        AC_RowStack, \
        InitialDealTalonStack, \
        OpenStack, \
        SS_FoundationStack, \
        SS_RowStack
from pysollib.util import KING

# ************************************************************************
# * Heads and Tails
# ************************************************************************


class HeadsAndTails_Reserve(OpenStack):
    def canFlipCard(self):
        return False


class HeadsAndTails(Game):
    Hint_Class = CautiousDefaultHint

    #
    # game layout
    #

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        h = l.YS + 7*l.YOFFSET
        self.setSize(l.XM+10*l.XS, l.YM+l.YS+2*h)

        # create stacks
        x, y = self.width - l.XS, self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        x, y = l.XM+l.XS, l.YM
        for i in range(8):
            s.rows.append(SS_RowStack(x, y, self,
                          dir=1, max_move=1, max_accept=1))
            x += l.XS
        x, y = l.XM+l.XS, l.YM+l.YS+h
        for i in range(8):
            s.rows.append(SS_RowStack(x, y, self,
                          dir=-1, max_move=1, max_accept=1))
            x += l.XS

        x, y = l.XM+l.XS, l.YM+h
        for i in range(8):
            stack = HeadsAndTails_Reserve(x, y, self)
            s.reserves.append(stack)
            l.createText(stack, "n")
            x += l.XS

        x, y = l.XM, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            y += l.YS
        x, y = l.XM+9*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self,
                                 suit=i, base_rank=KING, dir=-1))
            y += l.YS

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        for i in range(11):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0, flip=0)
        self._startAndDealRow()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            reserves = self.s.reserves
            si = list(self.s.rows).index(stack) % 8
            from_stack = None
            if reserves[si].cards:
                from_stack = reserves[si]
            else:
                for i in range(1, 8):
                    n = si+i
                    if n < 8 and reserves[n].cards:
                        from_stack = reserves[n]
                        break
                    n = si-i
                    if n >= 0 and reserves[n].cards:
                        from_stack = reserves[n]
                        break
            if not from_stack:
                return
            old_state = self.enterState(self.S_FILL)
            from_stack.flipMove()
            from_stack.moveMove(1, stack)
            self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Barrier
# ************************************************************************


class Barrier_ReserveStack(OpenStack):
    def canFlipCard(self):
        return False


class Barrier(Game):

    def createGame(self):
        reserves = 8
        rows = 10
        max_rows = max(8, rows, reserves)

        l, s = Layout(self), self.s
        self.setSize(l.XM+max_rows*l.XS, l.YM+4*l.YS+12*l.YOFFSET)

        s.addattr(reserves2=[])         # register extra stack variables

        x, y = l.XM+(max_rows-reserves)*l.XS//2+l.XS//2, l.YM
        for i in range(reserves//2):
            stack = Barrier_ReserveStack(x, y, self)
            s.reserves2.append(stack)
            l.createText(stack, "ne")
            x += 2*l.XS
        x, y = l.XM+(max_rows-reserves)*l.XS//2, l.YM+l.YS
        for i in range(reserves):
            s.reserves.append(OpenStack(x, y, self))
            x += l.XS
        x, y = l.XM+(max_rows-rows)*l.XS//2, l.YM+2*l.YS
        for i in range(rows):
            s.rows.append(AC_RowStack(x, y, self))
            x += l.XS
        x, y = l.XM+(max_rows-8)*l.XS//2, self.height-l.YS
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2))
            x += l.XS
        x, y = l.XM, self.height-l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        l.defaultStackGroups()

    def startGame(self):
        rows = len(self.s.rows)
        reserves = len(self.s.reserves)
        n = (104-reserves-2*rows)//(reserves//2)
        for i in range(n):
            self.s.talon.dealRow(rows=self.s.reserves2, frames=0, flip=0)
        self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRow()

    def fillStack(self, stack):
        if stack in self.s.reserves and not stack.cards:
            si = list(self.s.reserves).index(stack)
            from_stack = self.s.reserves2[si//2]
            if not from_stack.cards:
                return
            old_state = self.enterState(self.S_FILL)
            from_stack.flipMove()
            from_stack.moveMove(1, stack)
            self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_AC


# register the game

registerGame(GameInfo(307, HeadsAndTails, "Heads and Tails",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(708, Barrier, "Barrier",
                      GI.GT_2DECK_TYPE | GI.GT_ORIGINAL, 2, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        AC_FoundationStack, \
        AbstractFoundationStack, \
        BasicRowStack, \
        DealRowRedealTalonStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        KingAC_RowStack, \
        OpenStack, \
        RK_FoundationStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        Stack, \
        StackWrapper, \
        TalonStack, \
        UD_AC_RowStack, \
        UD_SS_RowStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, ANY_SUIT, JACK, KING, NO_RANK, QUEEN, \
        UNLIMITED_REDEALS


# ************************************************************************
# * Sultan
# ************************************************************************

class Sultan(Game):

    #
    # game layout
    #

    def createGame(self, reserves=6):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = 3*l.XM+5*l.XS, l.YM+4*l.YS+l.TEXT_HEIGHT+l.TEXT_MARGIN
        self.setSize(w, h)

        # create stacks
        lay = ((0, 0, 0, 1, 13),
               (2, 0, 0, 1, 13),
               (0, 1, 1, 1, 13),
               (2, 1, 1, 1, 13),
               (1, 1, 2, 0, 1),
               (1, 2, 2, 1, 13),
               (0, 2, 3, 1, 13),
               (2, 2, 3, 1, 13),
               (1, 0, 2, 1, 12),
               )
        for i, j, suit, max_accept, max_cards in lay:
            x, y = 2*l.XM+l.XS+i*l.XS, l.YM+j*l.YS
            stack = SS_FoundationStack(
                x, y, self, suit=suit,
                max_move=0, max_accept=max_accept, max_cards=max_cards, mod=13)
            s.foundations.append(stack)

        x, y = l.XM, l.YM
        for i in range(reserves//2):
            s.rows.append(ReserveStack(x, y, self))
            y += l.YS

        x, y = 3*l.XM+4*l.XS, l.YM
        for i in range(reserves//2):
            s.rows.append(ReserveStack(x, y, self))
            y += l.YS

        x, y = 2*l.XM+1.5*l.XS, l.YM+3*l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "s")
        l.createRoundText(self.s.talon, 'sss')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        cards = self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank == ACE and c.suit == 2 and c.deck == 0, c.suit))
        cards = self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank == KING, c.suit))
        return cards

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRowAndCards()

    def getAutoStacks(self, event=None):
        return (self.sg.dropstacks, (), self.sg.dropstacks)


class SultanPlus(Sultan):
    def createGame(self):
        Sultan.createGame(self, reserves=8)


# ************************************************************************
# * Boudoir
# ************************************************************************

class Boudoir(Game):

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+5.5*l.XS, l.YM+4*l.YS)

        x, y = l.XM, l.YM+l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, 'ne')
        l.createRoundText(s.talon, 'nn')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'ne')

        x, y = l.XM+1.5*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                    max_cards=13))
            x += l.XS

        x = l.XM+1.5*l.XS
        y += l.YS
        for i in range(4):
            s.rows.append(AbstractFoundationStack(x, y, self, suit=i,
                          max_cards=1, max_move=0, base_rank=QUEEN))
            x += l.XS

        x = l.XM+1.5*l.XS
        y += l.YS
        for i in range(4):
            s.rows.append(AbstractFoundationStack(x, y, self, suit=i,
                          max_cards=1, max_move=0, base_rank=JACK))
            x += l.XS

        x = l.XM+1.5*l.XS
        y += l.YS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                 mod=13, max_cards=11, base_rank=9, dir=-1))
            x += l.XS

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        # move 4 Queens to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank == QUEEN and c.deck == 0, c.suit))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:4])
        self.s.talon.dealCards()          # deal first card to WasteStack

    def isGameWon(self):
        return (len(self.s.talon.cards) + len(self.s.waste.cards)) == 0


# ************************************************************************
# * Captive Queens
# ************************************************************************

class CaptiveQueens(Game):

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+5.5*l.XS, l.YM+3*l.YS)

        x, y = l.XM, l.YM+l.YS//2
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "se")
        l.createRoundText(s.talon, 'nn')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "se")

        x, y = l.XM+1.5*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                 mod=13, max_cards=6, base_rank=4, dir=-1))
            x += l.XS

        x, y = l.XM+1.5*l.XS, l.YM+l.YS
        for i in range(4):
            s.foundations.append(AbstractFoundationStack(x, y, self, suit=i,
                                 max_cards=1, max_move=0, base_rank=QUEEN))
            x += l.XS

        x, y = l.XM+1.5*l.XS, l.YM+2*l.YS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                 mod=13, max_cards=6, base_rank=5))
            x += l.XS

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealCards()

    def isGameWon(self):
        return (len(self.s.talon.cards) + len(self.s.waste.cards)) == 0


# ************************************************************************
# * Contradance
# ************************************************************************

class Contradance(Game):

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+4*l.YS)

        x, y = l.XM, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2,
                                 base_rank=4, dir=-1, mod=13, max_cards=6))
            x += l.XS
        x, y = l.XM, l.YM+l.YS
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2,
                                 base_rank=5, max_cards=7))
            x += l.XS

        x, y = l.XM+3*l.XS, l.YM+3*l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=2)
        l.createText(s.talon, 'n')
        l.createRoundText(self.s.talon, 'nnn')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'n')

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        # move 5's and 6's to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (4, 5), (c.rank, c.suit)))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealCards()          # deal first card to WasteStack


# ************************************************************************
# * Idle Aces
# ************************************************************************

class IdleAces_AceFoundation(AbstractFoundationStack):

    def getBottomImage(self):
        return self.game.app.images.getLetter(ACE)


class IdleAces(Game):

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+7*l.XS, l.YM+4*l.YS)

        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, 's')
        l.createRoundText(s.talon, 'ne', dx=l.XS)
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 's')
        x0, y0 = l.XM+2*l.XS, l.YM
        k = 0
        for i, j in((2, 0), (0, 1.5), (4, 1.5), (2, 3)):
            x, y = x0+i*l.XS, y0+j*l.YS
            s.foundations.append(
                RK_FoundationStack(
                    x, y, self,
                    # suit=ANY_SUIT,
                    base_rank=KING, dir=-1, max_move=0))
            k += 1
        k = 0
        for i, j in((2, 1), (1, 1.5), (3, 1.5), (2, 2)):
            x, y = x0+i*l.XS, y0+j*l.YS
            s.foundations.append(
                RK_FoundationStack(
                    x, y, self,
                    # suit=ANY_SUIT,
                    base_rank=1, max_move=0, max_cards=12))
            k += 1
        k = 0
        for i, j in((1, 0.2), (3, 0.2), (1, 2.8), (3, 2.8)):
            x, y = x0+i*l.XS, y0+j*l.YS
            s.foundations.append(IdleAces_AceFoundation(x, y, self,
                                 suit=k, max_cards=1, max_move=0))
            k += 1

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (1, KING) and c.deck == 0, (-c.rank, c.suit)))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations[:8])
        self.s.talon.dealCards()


# ************************************************************************
# * Lady of the Manor
# * Archway
# ************************************************************************

class LadyOfTheManor_RowStack(BasicRowStack):
    clickHandler = BasicRowStack.doubleclickHandler


class LadyOfTheManor_Reserve(OpenStack):
    clickHandler = OpenStack.doubleclickHandler


class LadyOfTheManor(Game):
    Foundation_Class_1 = RK_FoundationStack
    Foundation_Class_2 = RK_FoundationStack

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+max(4*l.YS, 3*l.YS+14*l.YOFFSET))

        x, y = l.XM, self.height-l.YS
        for i in range(4):
            suit = i
            if self.Foundation_Class_1 is RK_FoundationStack:
                suit = ANY_SUIT
            s.foundations.append(
                self.Foundation_Class_1(x, y, self, suit=suit))
            x += l.XS
        for i in range(4):
            suit = i
            if self.Foundation_Class_1 is RK_FoundationStack:
                suit = ANY_SUIT
            s.foundations.append(
                self.Foundation_Class_2(x, y, self, suit=suit))
            x += l.XS
        x, y = l.XM+2*l.XS, l.YM+l.YS
        for i in range(4):
            s.rows.append(LadyOfTheManor_RowStack(x, y, self, max_accept=0))
            x += l.XS
        for i, j in ((0, 2), (0, 1), (0, 0),
                     (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0),
                     (7, 0), (7, 1), (7, 2), ):
            x, y = l.XM+i*l.XS, l.YM+j*l.YS
            s.reserves.append(LadyOfTheManor_Reserve(x, y, self, max_accept=0))

        s.talon = InitialDealTalonStack(
            self.width-l.XS, self.height-2*l.YS, self)

        l.defaultAll()

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank == ACE, c.suit))

    def startGame(self, flip=False):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        for i in range(11):
            self.s.talon.dealRow(frames=0, flip=flip)
        self.s.talon.dealRow(frames=0)
        self.startDealSample()
        while self.s.talon.cards:
            self.flipMove(self.s.talon)
            c = self.s.talon.cards[-1]
            r = self.s.reserves[c.rank-1]
            self.moveMove(1, self.s.talon, r, frames=4)


# ************************************************************************
# * Matrimony
# ************************************************************************

class Matrimony_Talon(DealRowTalonStack):

    def canDealCards(self):
        if self.round == self.max_rounds and not self.cards:
            return False
        return not self.game.isGameWon()

    def _redeal(self):
        num_cards = 0
        assert len(self.cards) == 0
        r = self.game.s.rows[-self.round]
        for i in range(len(r.cards)):
            num_cards += 1
            self.game.moveMove(1, r, self, frames=4)
            self.game.flipMove(self)
        assert len(self.cards) == num_cards
        self.game.nextRoundMove(self)
        return num_cards

    def dealCards(self, sound=False):
        if sound:
            self.game.startDealSample()
        num_cards = 0
        if len(self.cards) == 0:
            num_cards += self._redeal()
        if self.round == 1:
            num_cards += self.dealRowAvail(sound=False)
        else:
            rows = self.game.s.rows[-self.round+1:]
            num_cards += self.dealRowAvail(rows=rows, sound=False)
            while self.cards:
                num_cards += self.dealRowAvail(
                    rows=self.game.s.rows, sound=False)
        if sound:
            self.game.stopSamples()
        return num_cards


class Matrimony(Game):

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+4*l.YS)

        s.talon = Matrimony_Talon(l.XM, l.YM, self, max_rounds=17)
        l.createText(s.talon, 'se')
        l.createRoundText(s.talon, 'ne')

        x, y = l.XM+2*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                 base_rank=JACK, dir=-1, mod=13))
            x += l.XS
        x, y = l.XM+2*l.XS, l.YM+l.YS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                 base_rank=QUEEN, dir=1, mod=13))
            x += l.XS
        y = l.YM+2*l.YS
        for i in range(2):
            x = l.XM
            for j in range(8):
                stack = LadyOfTheManor_RowStack(x, y, self, max_accept=0)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
                s.rows.append(stack)
                x += l.XS
            y += l.YS

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (JACK, QUEEN) and c.deck == 0 and c.suit == 3,
                       (c.rank, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=[self.s.foundations[3],
                                   self.s.foundations[7]], frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Picture Patience
# * Patriarchs
# ************************************************************************

class PicturePatience(Game):

    def createGame(self, max_rounds=1):

        l, s = Layout(self), self.s
        w, h = 3*l.XM+5*l.XS, l.YM+4*l.YS
        if max_rounds > 1:
            h += l.TEXT_HEIGHT+l.TEXT_MARGIN
        self.setSize(w, h)

        x, y = l.XM, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            y += l.YS
        x, y = 3*l.XM+4*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                    base_rank=KING, dir=-1))
            y += l.YS
        y = l.YM
        for i in range(3):
            x = 2*l.XM+l.XS
            for j in range(3):
                s.rows.append(BasicRowStack(x, y, self,
                                            max_cards=1, max_accept=1))
                x += l.XS
            y += l.YS
        x, y = 2*l.XM+l.XS+l.XS//2, l.YM+3*l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=max_rounds)
        x += l.XS
        s.waste = WasteStack(x, y, self)
        if max_rounds > 1:
            l.createText(s.talon, 's')
            l.createRoundText(s.talon, 'sss')
            l.createText(s.waste, 's')
        else:
            l.createText(s.talon, 'sw')
            l.createText(s.waste, 'se')

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            if not self.s.waste.cards:
                self.s.talon.dealCards()
            if self.s.waste.cards:
                self.s.waste.moveMove(1, stack)


class Patriarchs(PicturePatience):
    def createGame(self):
        PicturePatience.createGame(self, max_rounds=2)

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (ACE, KING) and c.deck == 0,
                       (c.rank, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()


# ************************************************************************
# * Sixes and Sevens
# * Two Rings
# ************************************************************************

class SixesAndSevens(Game):

    def createGame(self, max_rounds=2):

        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+4*l.YS)

        y = l.YM
        for i in range(2):
            x = l.XM
            for j in range(4):
                s.foundations.append(SS_FoundationStack(x, y, self,
                                     suit=j, base_rank=6, max_cards=7))
                x += l.XS
            y += l.YS
        for i in range(2):
            x = l.XM
            for j in range(4):
                s.foundations.append(SS_FoundationStack(x, y, self, suit=j,
                                     base_rank=5, dir=-1, max_cards=6))
                x += l.XS
            y += l.YS
        y = l.YM
        for i in range(3):
            x = l.XM+5*l.XS
            for j in range(3):
                s.rows.append(ReserveStack(x, y, self))
                x += l.XS
            y += l.YS
        x, y = l.XM+5*l.XS, l.YM+3*l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'sw')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'se')

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (5, 6), (-c.rank, c.deck, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()


class TwoRings(Game):

    def createGame(self, max_rounds=2):

        l, s = Layout(self), self.s
        self.setSize(l.XM+10*l.XS, l.YM+5*l.YS)

        lay = (
            (1.5, 0),
            (2.5, 0.3),
            (3,   1.3),
            (2.5, 2.3),
            (1.5, 2.6),
            (0.5, 2.3),
            (0,   1.3),
            (0.5, 0.3),
            )

        suit = 0
        x0, y0 = l.XM+l.XS, l.YM
        for xx, yy in lay:
            x, y = x0+xx*l.XS, y0+yy*l.YS
            s.foundations.append(SS_FoundationStack(x, y, self, suit=suit//2,
                                 base_rank=6, max_cards=7))
            suit += 1
        suit = 0
        x0, y0 = l.XM+5*l.XS, l.YM
        for xx, yy in lay:
            x, y = x0+xx*l.XS, y0+yy*l.YS
            s.foundations.append(SS_FoundationStack(x, y, self, suit=suit//2,
                                 base_rank=5, dir=-1, max_cards=6))
            suit += 1

        x, y = l.XM, l.YM+4*l.YS
        for i in range(8):
            stack = BasicRowStack(x, y, self)
            stack.CARD_YOFFSET = 0
            s.rows.append(stack)
            x += l.XS

        x += l.XS
        s.talon = DealRowRedealTalonStack(x, y, self, max_rounds=2)
        l.createText(s.talon, 'nw')
        l.createRoundText(s.talon, 'sw')

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (5, 6), (-c.rank, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Corner Suite
# ************************************************************************

class CornerSuite_RowStack(RK_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return from_stack is self.game.s.waste
        return True
    getBottomImage = Stack._getReserveBottomImage


class CornerSuite(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+5*l.XS, l.YM+5*l.YS)

        suit = 0
        for x, y in ((0, 0), (4, 0), (0, 4), (4, 4)):
            x, y = l.XM+x*l.XS, l.YM+y*l.YS
            s.foundations.append(SS_FoundationStack(x, y, self, suit=suit))
            suit += 1

        x, y = l.XM+3*l.XS//2, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'nw')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'ne')

        y = l.YM+l.YS
        for i in range(3):
            x = l.XM+l.XS
            for j in range(3):
                stack = CornerSuite_RowStack(x, y, self, max_move=1)
                s.rows.append(stack)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
                x += l.XS
            y += l.YS

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Marshal
# ************************************************************************

class Marshal_Hint(CautiousDefaultHint):
    def _getDropCardScore(self, score, color, r, t, ncards):
        return 93000, color


class Marshal(Game):

    Hint_Class = Marshal_Hint

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+9*l.XS, l.YM+5*l.YS)

        x, y = l.XM, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            y += l.YS
        x, y = self.width-l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self,
                                 suit=i, base_rank=KING, dir=-1))
            y += l.YS
        x, y = (self.width-l.XS)//2, self.height-l.YS
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, 'se')
        y = l.YM
        for i in range(4):
            x = l.XM+l.XS*3//2
            for j in range(6):
                stack = UD_SS_RowStack(x, y, self, base_rank=NO_RANK)
                s.rows.append(stack)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
                x += l.XS
            y += l.YS

        l.defaultStackGroups()

    def startGame(self):
        self._startAndDealRow()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            if self.s.talon.cards:
                old_state = self.enterState(self.S_FILL)
                self.flipMove(self.s.talon)
                self.moveMove(1, self.s.talon, stack)
                self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Royal Aids
# ************************************************************************

class RoyalAids(Game):

    Hint_Class = CautiousDefaultHint

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+4*l.YS+l.TEXT_HEIGHT)

        x0 = l.XM+1.5*l.XS
        for k in (0, 1):
            suit = 0
            for i, j in ((1, 0), (0, 0.5), (2, 0.5), (1, 1)):
                x, y = x0+i*l.XS, l.YM+j*l.YS
                s.foundations.append(AC_FoundationStack(x, y, self, suit=suit))
                suit += 1
            x0 += 3.5*l.XS

        x, y = l.XM, l.YM+l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=UNLIMITED_REDEALS)
        l.createText(s.talon, 'se')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'se')

        x, y = l.XM+3.75*l.XS, l.YM+2*l.YS
        for i in (0, 1):
            stack = KingAC_RowStack(x, y, self, max_move=1)
            stack.getBottomImage = stack._getReserveBottomImage
            s.rows.append(stack)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
            x += l.XS
        x, y = l.XM+2.75*l.XS, l.YM+3*l.YS
        for i in range(4):
            stack = BasicRowStack(x, y, self)
            s.reserves.append(stack)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
            l.createText(stack, 's')
            x += l.XS

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank == ACE, (c.deck, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        for i in range(6):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        for i in range(4):
            self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Circle Eight
# ************************************************************************

class CircleEight(Game):

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+5*l.XS, l.YM+4*l.YS)

        for i, j in ((1, 0),
                     (2, 0),
                     (3, 0),
                     (4, 1.5),
                     (3, 3),
                     (2, 3),
                     (1, 3),
                     (0, 1.5),
                     ):
            x, y = l.XM+i*l.XS, l.YM+j*l.YS
            stack = RK_RowStack(x, y, self, dir=1, mod=13, max_move=0)
            s.rows.append(stack)
            stack.CARD_YOFFSET = 0

        x, y = l.XM+1.5*l.XS, l.YM+1.5*l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=2)
        l.createText(s.talon, 'nw')
        l.createRoundText(self.s.talon, 'nn')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'ne')

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def isGameWon(self):
        return len(self.s.talon.cards) == 0 and len(self.s.waste.cards) == 0

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# ************************************************************************
# * Adela
# ************************************************************************

class Adela_Foundation(SS_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        index = list(self.game.s.foundations).index(self)
        index %= 8
        return len(self.game.s.foundations[index].cards) > 0


class Adela(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+9.5*l.XS, l.YM+4*l.YS)

        x, y = l.XM+l.XS, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i % 4,
                                 base_rank=JACK, dir=-1, max_cards=11))
            x += l.XS
        x, y = l.XM+l.XS, l.YM+l.YS
        for i in range(8):
            s.foundations.append(Adela_Foundation(x, y, self, suit=i % 4,
                                 base_rank=QUEEN, max_cards=1))
            x += l.XS
        x, y = l.XM+l.XS, l.YM+2*l.YS
        for i in range(8):
            s.foundations.append(Adela_Foundation(x, y, self, suit=i % 4,
                                 base_rank=KING, max_cards=1))
            x += l.XS
        x, y = l.XM, l.YM+l.YS
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, 'n')
        x, y = l.XM+l.XS//2, l.YM+3*l.YS
        for i in range(9):
            stack = SS_RowStack(x, y, self, max_move=1, dir=1)
            s.rows.append(stack)
            stack.CARD_YOFFSET = 0
            x += l.XS

        l.defaultStackGroups()

    def startGame(self):
        self._startAndDealRow()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            if self.s.talon.cards:
                old_state = self.enterState(self.S_FILL)
                self.flipMove(self.s.talon)
                self.moveMove(1, self.s.talon, stack)
                self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Toni
# ************************************************************************

class Toni(Game):

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+8.5*l.XS, l.YM+4*l.YS)

        y = l.YM
        suit = 0
        for i in (0, 1, 3, 4):
            x = l.XM+(2+i)*l.XS
            s.foundations.append(SS_FoundationStack(x, y, self, suit=suit))
            suit += 1

        x, y = l.XM+4*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                    base_rank=KING, dir=-1))
            y += l.YS

        for i, j in ((0, 0), (1, 0), (2, 0), (5, 0), (6, 0), (7, 0),
                     (0, 1), (1, 1), (2, 1), (5, 1), (6, 1), (7, 1),
                     ):
            x, y = l.XM+(0.5+i)*l.XS, l.YM+(1.5+j)*l.YS
            stack = BasicRowStack(x, y, self, max_accept=0)
            s.rows.append(stack)
            stack.CARD_YOFFSET = 0

        x, y = l.XM, l.YM
        s.talon = DealRowRedealTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, 'se')
        l.createRoundText(s.talon, 'ne')

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (ACE, KING) and c.deck == 0,
                       (c.rank, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Khedive
# ************************************************************************

class Khedive(Game):

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+10*l.XS, l.YM+5*l.YS)

        x, y = l.XM, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            s.foundations.append(SS_FoundationStack(x+6*l.XS, y, self, suit=i))
            x += l.XS

        x, y = l.XM+4*l.XS, l.YM
        r = list(range(11))
        for i in range(5, 0, -1):
            for j in r[i:-i]:
                x, y = l.XM+(j-0.5)*l.XS, l.YM+(5-i)*l.YS
                s.rows.append(BasicRowStack(x, y, self, max_accept=0))

        x, y = l.XM, l.YM+1.5*l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'ne')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'ne')

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(frames=4)
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if not self.s.waste.cards:
                self.s.talon.dealCards()
            if self.s.waste.cards:
                self.s.waste.moveMove(1, stack)
            self.leaveState(old_state)


# ************************************************************************
# * Phalanx
# ************************************************************************

class Phalanx(Game):

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+5*l.YS)

        y = l.YM
        for i in range(5):
            x = l.XM+(8-i)*l.XS//2
            for j in range(i+1):
                s.rows.append(ReserveStack(x, y, self))
                x += l.XS
            y += l.YS

        suit = 0
        for xx, yy in ((1.5, 1.5),
                       (1,   2.5),
                       (6.5, 1.5),
                       (7,   2.5)):
            x, y = l.XM+xx*l.XS, l.YM+yy*l.YS
            s.foundations.append(SS_FoundationStack(x, y, self, suit))
            suit += 1

        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 's')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 's')

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(frames=4)
        self.s.talon.dealCards()


# ************************************************************************
# * Grandee
# * Turncoats
# * Voracious
# ************************************************************************

class Grandee(Game):
    Hint_Class = CautiousDefaultHint
    Talon_Class = DealRowTalonStack
    RowStack_Class = SS_RowStack

    def createGame(self, waste=False, rows=14):

        # create layout
        l, s = Layout(self), self.s

        # set window
        decks = self.gameinfo.decks
        w = max(decks*4, rows//2)
        self.setSize(l.XM+w*l.XS, l.YM+5*l.YS)

        # create stacks
        x, y = l.XM + (w-decks*4)*l.XS//2, l.YM
        for i in range(4):
            for j in range(decks):
                s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
                x += l.XS

        y = l.YM+1.5*l.YS
        for i in range(2):
            x = l.XM + (w-rows//2)*l.XS//2
            for j in range(rows//2):
                stack = self.RowStack_Class(x, y, self, max_move=1)
                stack.CARD_YOFFSET = 0
                s.rows.append(stack)
                x += l.XS
            y += l.YS

        x, y = self.width-l.XS, self.height-l.YS
        s.talon = self.Talon_Class(x, y, self)
        if waste:
            l.createText(s.talon, 'n')
            x -= l.XS
            s.waste = WasteStack(x, y, self)
            l.createText(s.waste, 'n')
        else:
            l.createText(s.talon, 'sw')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startAndDealRow()

    shallHighlightMatch = Game._shallHighlightMatch_SS


class Turncoats(Grandee):
    Talon_Class = TalonStack
    RowStack_Class = StackWrapper(UD_AC_RowStack, base_rank=NO_RANK)

    def createGame(self):
        Grandee.createGame(self, rows=12)

    def fillStack(self, stack):
        if not stack.cards:
            if stack in self.s.rows and self.s.talon.cards:
                old_state = self.enterState(self.S_FILL)
                self.s.talon.flipMove()
                self.s.talon.moveMove(1, stack)
                self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_AC


class Voracious(Grandee):
    Talon_Class = StackWrapper(WasteTalonStack, max_rounds=1)
    RowStack_Class = StackWrapper(SS_RowStack, base_rank=NO_RANK)

    def createGame(self):
        Grandee.createGame(self, waste=True, rows=12)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if not stack.cards:
            if stack in self.s.rows:
                old_state = self.enterState(self.S_FILL)
                if not self.s.waste.cards:
                    self.s.talon.dealCards()
                if self.s.waste.cards:
                    self.s.waste.moveMove(1, stack)
                self.leaveState(old_state)


# ************************************************************************
# * Desert Island
# ************************************************************************

class DesertIsland(Game):

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+8*l.XS, l.YM+5*l.YS)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self,
                                                    suit=i//2, max_cards=10))
            x += l.XS

        y = l.YM+l.YS
        for i in range(3):
            x = l.XM
            for j in range(8):
                # stack = SS_RowStack(x, y, self, max_move=1)
                stack = ReserveStack(x, y, self)
                stack.CARD_YOFFSET = 0
                s.rows.append(stack)
                x += l.XS
            y += l.YS

        x, y = self.width-l.XS, self.height-l.YS
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, 'sw')

        # define stack-groups
        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank == ACE, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRow()

    def isGameWon(self):
        for s in self.s.foundations:
            if len(s.cards) != 10:
                return False
        return True


# ************************************************************************
# * Catherine the Great
# ************************************************************************

class CatherineTheGreat(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self, reserves=6):

        l, s = Layout(self), self.s
        w, h = 3*l.XM+5*l.XS, l.YM+5*l.YS
        self.setSize(w, h)

        lay = ((0, 2, 0, QUEEN, -1),
               (0, 1, 0, QUEEN, -1),
               (0, 0, 1, QUEEN, -1),
               (2, 0, 1, QUEEN, -1),
               (1, 0, 2, QUEEN, -1),
               (2, 1, 3, QUEEN, -1),
               (2, 2, 3, QUEEN, -1),
               (1, 1, 2, KING, 1),
               )
        for xx, yy, suit, base_rank, dir in lay:
            x, y = 2*l.XM+l.XS+xx*l.XS, l.YM+yy*l.YS
            stack = SS_FoundationStack(x, y, self, suit=suit,
                                       max_move=0, base_rank=base_rank,
                                       dir=dir, mod=13)
            s.foundations.append(stack)

        for x, y in ((l.XM,          l.YM),
                     (3*l.XM+4*l.XS, l.YM)):
            for i in range(5):
                stack = RK_RowStack(x, y, self, dir=1,
                                    base_rank=NO_RANK,
                                    max_move=1, mod=13)
                stack.CARD_YOFFSET = 0
                s.rows.append(stack)
                y += l.YS

        x, y = 2*l.XM+1.5*l.XS, l.YM+4*l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'n')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'n')

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        def select_func(card):
            if card.rank == KING and card.suit == 2 and card.deck == 0:
                return (True, 999)
            if card.rank == QUEEN:
                if card.suit == 2 and card.deck == 0:
                    return (False, 0)
                return (True, card.suit)
            return (False, 0)
        cards = self._shuffleHookMoveToTop(
            cards, select_func)
        return cards

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRowAndCards()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if not self.s.waste.cards:
                self.s.talon.dealCards()
            if self.s.waste.cards:
                self.s.waste.moveMove(1, stack)
            self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# register the game
registerGame(GameInfo(330, Sultan, "Sultan",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_MOSTLY_LUCK,
                      altnames=("Sultan of Turkey",)))
registerGame(GameInfo(331, SultanPlus, "Sultan +",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(354, Boudoir, "Boudoir",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(410, CaptiveQueens, "Captive Queens",
                      GI.GT_1DECK_TYPE, 1, 2, GI.SL_MOSTLY_LUCK,
                      altnames=("Quadrille",)))
registerGame(GameInfo(418, Contradance, "Contradance",
                      GI.GT_2DECK_TYPE, 2, 1, GI.SL_LUCK,
                      altnames=("Cotillion",)))
registerGame(GameInfo(419, IdleAces, "Idle Aces",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(423, LadyOfTheManor, "Lady of the Manor",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_LUCK,
                      altnames=("Vassal", "La Chatelaine")))
registerGame(GameInfo(424, Matrimony, "Matrimony",
                      GI.GT_2DECK_TYPE, 2, 16, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(429, Patriarchs, "Patriarchs",
                      GI.GT_2DECK_TYPE, 2, 1, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(438, SixesAndSevens, "Sixes and Sevens",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(477, CornerSuite, "Corner Suite",
                      GI.GT_2DECK_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(559, Marshal, "Marshal",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(565, RoyalAids, "Royal Aids",
                      GI.GT_2DECK_TYPE, 2, UNLIMITED_REDEALS, GI.SL_BALANCED))
registerGame(GameInfo(598, PicturePatience, "Picture Patience",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_LUCK,
                      rules_filename="patriarchs.html"))
registerGame(GameInfo(635, CircleEight, "Circle Eight",
                      GI.GT_1DECK_TYPE, 1, 1, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(646, Adela, "Adela",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(660, Toni, "Toni",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(691, Khedive, "Khedive",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(729, TwoRings, "Two Rings",
                      GI.GT_2DECK_TYPE, 2, 1, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(730, Phalanx, "Phalanx",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(742, Grandee, "Grandee",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(743, Turncoats, "Turncoats",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(744, Voracious, "Voracious",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(745, DesertIsland, "Desert Island",
                      GI.GT_2DECK_TYPE | GI.GT_ORIGINAL, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(761, CatherineTheGreat, "Catherine the Great",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        RedealTalonStack, \
        SS_FoundationStack, \
        StackWrapper, \
        TalonStack, \
        UD_RK_RowStack, \
        UD_SS_RowStack
from pysollib.util import ACE, JACK, KING, NO_RANK


class StHelena_Talon(TalonStack):

    def canDealCards(self):
        if self.round == self.max_rounds:
            return False
        return not self.game.isGameWon()

    def dealCards(self, sound=False):
        # move all cards to the Talon and redeal
        lr = len(self.game.s.rows)
        num_cards = 0
        assert len(self.cards) == 0
        for r in self.game.s.rows[::-1]:
            for i in range(len(r.cards)):
                num_cards = num_cards + 1
                self.game.moveMove(1, r, self, frames=0)
        assert len(self.cards) == num_cards
        if num_cards == 0:          # game already finished
            return 0
        # redeal
        self.cards.reverse()
        self.game.nextRoundMove(self)
        self.game.startDealSample()
        for i in range(lr):
            k = min(lr, len(self.cards))
            for j in range(k):
                self.game.moveMove(1, self, self.game.s.rows[j], frames=4)
        # done
        self.game.stopSamples()
        assert len(self.cards) == 0
        return num_cards


class StHelena_FoundationStack(SS_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if self.game.s.talon.round == 1:
            if (self.cap.base_rank == KING and
                    from_stack in self.game.s.rows[6:10:]):
                return False
            if (self.cap.base_rank == ACE and
                    from_stack in self.game.s.rows[:4]):
                return False
        return True


class StHelena(Game):

    Hint_Class = CautiousDefaultHint
    Talon_Class = StackWrapper(StHelena_Talon, max_rounds=3)
    Foundation_Class = StHelena_FoundationStack
    RowStack_Class = StackWrapper(UD_RK_RowStack, base_rank=NO_RANK)

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = 3*l.XM+6*l.XS, 3*l.YM+4*l.YS
        self.setSize(w, h)

        # create stacks
        lay = (
            (2, 1, 1, 0),
            (2, 2, 1, 0),
            (2, 3, 1, 0),
            (2, 4, 1, 0),
            (3, 5, 2, 1),
            (3, 5, 2, 2),
            (2, 4, 3, 3),
            (2, 3, 3, 3),
            (2, 2, 3, 3),
            (2, 1, 3, 3),
            (1, 0, 2, 2),
            (1, 0, 2, 1),
            )
        for xm, xs, ym, ys in lay:
            x, y = xm*l.XM+xs*l.XS, ym*l.YM+ys*l.YS
            stack = self.RowStack_Class(x, y, self, max_move=1, max_accept=1)
            stack.CARD_XOFFSET = stack.CARD_YOFFSET = 0
            s.rows.append(stack)
        x, y = 2*l.XM+l.XS, 2*l.YM+l.YS
        for i in range(4):
            s.foundations.append(self.Foundation_Class(x, y, self, suit=i,
                                                       base_rank=KING, dir=-1))
            x = x + l.XS
        x, y = 2*l.XM+l.XS, 2*l.YM+2*l.YS
        for i in range(4):
            s.foundations.append(self.Foundation_Class(x, y, self, suit=i))
            x = x + l.XS

        s.talon = self.Talon_Class(l.XM, l.YM, self)

        # default
        l.defaultAll()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.deck == 0 and c.rank in (0, 12),
                              (-c.rank, c.suit)), 8)

    def startGame(self):
        self._startDealNumRows(7)
        self.s.talon.dealRow()
        self.s.talon.dealRow(self.s.foundations)

    shallHighlightMatch = Game._shallHighlightMatch_RK

# ************************************************************************
# * Box Kite
# ************************************************************************


class BoxKite(StHelena):
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = StackWrapper(UD_RK_RowStack, base_rank=NO_RANK, mod=13)

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# ************************************************************************
# * Les Quatre Coins
# ************************************************************************

class LesQuatreCoins_RowStack(UD_RK_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not UD_RK_RowStack.acceptsCards(self, from_stack, cards):
            return False
        return len(self.game.s.talon.cards) == 0


class LesQuatreCoins_Talon(RedealTalonStack):

    def canDealCards(self):
        if self.round == self.max_rounds:
            return len(self.cards) != 0
        return not self.game.isGameWon()

    def dealCards(self, sound=False):
        if not self.cards:
            RedealTalonStack.redealCards(self, sound=False)
        if sound and not self.game.demo:
            self.game.startDealSample()
        rows = self.game.s.rows
        rows = rows[:1]+rows[4:8]+rows[2:3]+rows[1:2]+rows[8:]+rows[3:4]
        num_cards = self.dealRowAvail(rows=rows)
        if sound and not self.game.demo:
            self.game.stopSamples()
        return num_cards


class LesQuatreCoins_Foundation(SS_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return True
        if self.game.s.talon.cards:
            if from_stack in self.game.s.rows[4:]:
                i = list(self.game.s.foundations).index(self)
                j = list(self.game.s.rows).index(from_stack)
                return i == j-4
        return True


class LesQuatreCoins(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+7*l.XS, l.YM+5*l.YS)

        for i, j in ((0, 0), (5, 0), (0, 4), (5, 4)):
            x, y = l.XM+l.XS+i*l.XS, l.YM+j*l.YS
            stack = LesQuatreCoins_RowStack(x, y, self,
                                            max_move=1, base_rank=NO_RANK)
            s.rows.append(stack)
            stack.CARD_YOFFSET = 0
        for x in (l.XM+2*l.XS, l.XM+5*l.XS):
            y = l.YM+l.YS/2
            for j in range(4):
                stack = LesQuatreCoins_RowStack(x, y, self,
                                                max_move=1, base_rank=NO_RANK)
                s.rows.append(stack)
                stack.CARD_YOFFSET = 0
                y += l.YS
        x, y = l.XM+3*l.XS, l.YM+l.YS/2
        for i in range(4):
            s.foundations.append(LesQuatreCoins_Foundation(x, y, self, suit=i))
            y += l.YS
        x, y = l.XM+4*l.XS, l.YM+l.YS/2
        for i in range(4):
            s.foundations.append(LesQuatreCoins_Foundation(x, y, self, suit=i,
                                 base_rank=KING, dir=-1))
            y += l.YS

        x, y = l.XM, l.YM+2*l.YS
        s.talon = LesQuatreCoins_Talon(x, y, self, max_rounds=3)
        l.createText(s.talon, 's')
        l.createRoundText(s.talon, 'nn')

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Regal Family
# ************************************************************************

class RegalFamily_RowStack(UD_SS_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not UD_SS_RowStack.acceptsCards(self, from_stack, cards):
            return False
        return len(self.game.s.talon.cards) == 0


class RegalFamily(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+5*l.YS)

        for i, j in ((0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0),
                     (6, 1), (6, 2), (6, 3),
                     (6, 4), (5, 4), (4, 4), (3, 4), (2, 4), (1, 4), (0, 4),
                     (0, 3), (0, 2), (0, 1)
                     ):
            x, y = l.XM+l.XS+i*l.XS, l.YM+j*l.YS
            stack = RegalFamily_RowStack(x, y, self,
                                         max_move=1, base_rank=NO_RANK)
            s.rows.append(stack)
            stack.CARD_YOFFSET = 0

        x, y = l.XM+3*l.XS, l.YM+l.YS
        for i in range(3):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                 base_rank=9, mod=13, dir=-1))
            s.foundations.append(SS_FoundationStack(x, y+2*l.YS, self, suit=i,
                                 base_rank=9, mod=13, dir=-1))
            x += l.XS
        x, y = l.XM+3*l.XS, l.YM+2*l.YS
        s.foundations.append(SS_FoundationStack(x, y, self, suit=3,
                             base_rank=ACE, mod=13))
        x += 2*l.XS
        s.foundations.append(SS_FoundationStack(x, y, self, suit=3,
                             base_rank=JACK, mod=13, dir=-1))

        x, y = l.XM, l.YM+2*l.YS
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, 's')

        l.defaultStackGroups()

    def startGame(self):
        self._startAndDealRow()

    shallHighlightMatch = Game._shallHighlightMatch_SS


# register the game
registerGame(GameInfo(302, StHelena, "St. Helena",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_BALANCED,
                      altnames=("Napoleon's Favorite",
                                "Washington's Favorite")
                      ))
registerGame(GameInfo(408, BoxKite, "Box Kite",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(620, LesQuatreCoins, "Les Quatre Coins",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(621, RegalFamily, "Regal Family",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint, DefaultHint
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AC_RowStack, \
        AbstractFoundationStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        RK_RowStack, \
        ReserveStack, \
        Stack, \
        UD_AC_RowStack, \
        UD_RK_RowStack, \
        WasteStack, \
        WasteTalonStack, \
        cardsFaceDown, \
        isRankSequence
from pysollib.util import ACE, ANY_RANK, ANY_SUIT, RANKS

# ************************************************************************
# * PileOn
# ************************************************************************


class PileOn_RowStack(RK_RowStack):
    getBottomImage = Stack._getReserveBottomImage

    def closeStack(self):
        if len(self.cards) == 4 and isRankSequence(self.cards, dir=0):
            if not self.game.moves.state == self.game.S_REDO:
                self.game.flipAllMove(self)

    def canFlipCard(self):
        return False


class PileOn(Game):
    Hint_Class = DefaultHint
    # Hint_Class = CautiousDefaultHint
    TWIDTH = 4
    NSTACKS = 15
    PLAYCARDS = 4

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (set size so that at least 4 cards are fully playable)
        # w = max(2*l.XS, l.XS+(self.PLAYCARDS-1)*l.XOFFSET+2*l.XM)
        w = l.XS+(self.PLAYCARDS-1)*l.XOFFSET+3*l.XOFFSET
        twidth, theight = self.TWIDTH, int((self.NSTACKS-1)/self.TWIDTH+1)
        self.setSize(l.XM+twidth*w, l.YM+theight*l.YS)

        # create stacks
        y = l.YM
        for i in range(theight):
            x = l.XM
            for j in range(twidth):
                if i*twidth+j >= self.NSTACKS:
                    break
                stack = PileOn_RowStack(
                    x, y, self, dir=0, max_cards=self.PLAYCARDS)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
                s.rows.append(stack)
                x = x + w
            y = y + l.YS
        x, y = self.width - l.XS, self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        self.sg.openstacks = s.rows
        self.sg.talonstacks = [s.talon]
        self.sg.dropstacks = s.rows

    #
    # game overrides
    #

    def startGame(self):
        r = self.s.rows[:-2]
        for i in range(self.PLAYCARDS-1):
            self.s.talon.dealRow(rows=r, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=r)

    def isGameWon(self):
        for r in self.s.rows:
            if r.cards and not cardsFaceDown(r.cards):
                return False
        return True

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank == card2.rank


class SmallPileOn(PileOn):
    TWIDTH = 3
    NSTACKS = 11
    PLAYCARDS = 4


#  class PileOn2Decks(PileOn):
#      TWIDTH = 4
#      NSTACKS = 15
#      PLAYCARDS = 8
#  registerGame(GameInfo(341, PileOn2Decks, "PileOn (2 decks)",
#                        GI.GT_2DECK_TYPE | GI.GT_OPEN,, 2, 0))


# ************************************************************************
# * Foursome
# * Quartets
# ************************************************************************

class Foursome(Game):
    Hint_Class = CautiousDefaultHint
    Talon_Class = DealRowTalonStack

    def createGame(self, rows=6, texts=True):
        l, s = Layout(self), self.s
        max_rows = max(8, rows)
        self.setSize(l.XM+max_rows*l.XS, l.YM+2*l.YS+13*l.YOFFSET)
        x, y = l.XM+l.XS*(max_rows-4)//2, l.YM
        for i in range(4):
            s.reserves.append(ReserveStack(x, y, self))
            x += l.XS
        x = l.XM+(max_rows-1)*l.XS
        s.foundations.append(AbstractFoundationStack(x, y, self,
                             suit=ANY_SUIT, max_cards=52, max_accept=0))
        l.createText(s.foundations[0], 'nw')
        x, y = l.XM+l.XS*(max_rows-rows)//2, l.YM+l.YS
        for i in range(rows):
            s.rows.append(UD_AC_RowStack(x, y, self, mod=13))
            x += l.XS
        s.talon = self.Talon_Class(l.XM, l.YM, self)
        if texts:
            l.createText(s.talon, 'ne')
        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRow()

    def fillStack(self, stack):
        if not self.s.reserves[0].cards:
            return
        rank = self.s.reserves[0].cards[0].rank
        for r in self.s.reserves[1:]:
            if not r.cards or r.cards[0].rank != rank:
                return
        old_state = self.enterState(self.S_FILL)
        self.playSample("droppair", priority=200)
        for r in self.s.reserves:
            self.moveMove(1, r, self.s.foundations[0], frames=4)
            self.flipMove(self.s.foundations[0])
        self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_ACW


class Quartets(Foursome):
    Talon_Class = InitialDealTalonStack

    def createGame(self):
        Foursome.createGame(self, rows=8, texts=False)

    def startGame(self):
        self._startDealNumRows(5)
        self.s.talon.dealRow()
        self.s.talon.dealRowAvail()


# ************************************************************************
# * Four by Four
# ************************************************************************

class FourByFour_Hint(DefaultHint):

    def _getMovePileScore(self, score, color, r, t, pile, rpile):
        self.bonus_color = color
        if len(t.cards) == 0:
            return 0, color
        return score + 1000 - len(r.cards), color

    def _getDropCardScore(self, score, color, r, t, ncards):
        # drop immediately
        return 93000, color


class FourByFour_Foundation(AbstractFoundationStack):

    def _getNumSameCards(self):
        decks = self.game.gameinfo.decks
        rank = self.cards[-1].rank
        n = 1
        for i in range(2, 4*decks+1):
            if len(self.cards) < i:
                break
            if self.cards[-i].rank != rank:
                break
            n += 1
        return n

    def _getDir(self):
        decks = self.game.gameinfo.decks
        if len(self.cards) < 4*decks:
            return 0
        if isRankSequence(self.cards[-4*decks:], dir=0):
            return 1
        return 0

    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return True
        dir = self._getDir()
        return (self.cards[-1].rank+dir) % self.cap.mod == cards[0].rank

    def getHelp(self):
        return _('Foundation. Build up regardless of suit.')


class FourByFour(Game):
    Hint_Class = FourByFour_Hint

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+7*l.XS, l.YM+2*l.YS+20*l.YOFFSET)

        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 's')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 's')

        x += 3.5*l.XS
        s.foundations.append(FourByFour_Foundation(x, y, self,
                             suit=ANY_SUIT, base_rank=ANY_RANK, max_cards=52,
                             max_accept=1, max_move=0, mod=13))
        stack = s.foundations[0]
        tx, ty, ta, tf = l.getTextAttr(stack, 'ne')
        font = self.app.getFont('canvas_default')
        stack.texts.misc = MfxCanvasText(self.canvas, tx, ty,
                                         anchor=ta, font=font)

        x, y = l.XM+3*l.XS, l.YM+l.YS
        for i in range(4):
            stack = UD_RK_RowStack(x, y, self, mod=13)
            stack.getBottomImage = stack._getReserveBottomImage
            s.rows.append(stack)
            x += l.XS

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealCards()

    def updateText(self):
        decks = self.gameinfo.decks
        if self.preview > 1:
            return
        f = self.s.foundations[0]
        if not f.cards:
            if f.cap.base_rank == ANY_RANK:
                t = ''
            else:
                r = RANKS[f.cap.base_rank]
                n = 4*decks
                t = '%s (%d)' % (r, n)
        elif len(f.cards) == 52*decks:
            t = ''
        else:
            n = f._getNumSameCards()
            n = 4*decks - n
            r = f.cards[-1].rank
            if n == 0:
                n = 4*decks
                r = (r+1) % f.cap.mod
            r = r % 13
            r = RANKS[r]
            t = '%s (%d)' % (r, n)
        f.texts.misc.config(text=t)

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# ************************************************************************
# * Footling
# ************************************************************************

class Footling(FourByFour):
    Hint_Class = DefaultHint

    def createGame(self, rows=8, reserves=4, playcards=15):

        decks = self.gameinfo.decks

        l, s = Layout(self), self.s
        self.setSize(l.XM+rows*l.XS, l.YM+2*l.YS+playcards*l.YOFFSET)

        x, y = l.XM, l.YM
        for i in range(reserves):
            s.reserves.append(ReserveStack(x, y, self))
            x += l.XS

        x = self.width - 2*l.XS
        s.foundations.append(FourByFour_Foundation(x, y, self,
                             suit=ANY_SUIT, base_rank=ACE, max_cards=52*decks,
                             max_accept=1, max_move=0))
        stack = s.foundations[0]
        tx, ty, ta, tf = l.getTextAttr(stack, 'ne')
        font = self.app.getFont('canvas_default')
        stack.texts.misc = MfxCanvasText(self.canvas, tx, ty,
                                         anchor=ta, font=font)

        x, y = l.XM, l.YM+l.YS
        for i in range(rows):
            s.rows.append(AC_RowStack(x, y, self))
            x += l.XS

        x, y = l.XM, self.height-l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRows(5)
        self.s.talon.dealRow()
        self.s.talon.dealRowAvail()

    shallHighlightMatch = Game._shallHighlightMatch_AC


class DoubleFootling(Footling):
    def createGame(self):
        Footling.createGame(self, rows=10, reserves=5, playcards=18)

    def startGame(self):
        self._startDealNumRows(9)
        self.s.talon.dealRow()
        self.s.talon.dealRowAvail()


# register the game
registerGame(GameInfo(41, PileOn, "PileOn",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL,
                      altnames=("Fifteen Puzzle",)))
registerGame(GameInfo(289, SmallPileOn, "Small PileOn",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL,
                      ranks=(0, 5, 6, 7, 8, 9, 10, 11, 12),
                      rules_filename="pileon.html"))
registerGame(GameInfo(554, Foursome, "Foursome",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(555, Quartets, "Quartets",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(703, FourByFour, "Four by Four",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(740, Footling, "Footling",
                      GI.GT_FREECELL | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(741, DoubleFootling, "Double Footling",
                      GI.GT_FREECELL | GI.GT_OPEN | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        RK_RowStack, \
        SS_FoundationStack, \
        WasteStack, \
        WasteTalonStack

# ************************************************************************
# * Royal East
# ************************************************************************


class RoyalEast(Game):
    Hint_Class = CautiousDefaultHint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 5.5*l.XS, l.YM + 4*l.YS)

        # extra settings
        self.base_card = None

        # create stacks
        for i in range(4):
            dx, dy = ((0, 0), (2, 0), (0, 2), (2, 2))[i]
            x, y = l.XM + (2*dx+5)*l.XS//2, l.YM + (2*dy+1)*l.YS//2
            stack = SS_FoundationStack(x, y, self, i, mod=13, max_move=0)
            stack.CARD_YOFFSET = 0
            s.foundations.append(stack)
        for i in range(5):
            dx, dy = ((1, 0), (0, 1), (1, 1), (2, 1), (1, 2))[i]
            x, y = l.XM + (2*dx+5)*l.XS//2, l.YM + (2*dy+1)*l.YS//2
            stack = RK_RowStack(x, y, self, mod=13, max_move=1)
            stack.CARD_YOFFSET = 0
            s.rows.append(stack)
        x, y = l.XM, l.YM + 3*l.YS//2
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "s")
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.base_card = self.s.talon.cards[-1]
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        # deal base card to Foundations
        c = self.s.talon.getCard()
        to_stack = self.s.foundations[c.suit * self.gameinfo.decks]
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, to_stack, frames=0)
        # deal rows
        self._startAndDealRowAndCards()

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# register the game
registerGame(GameInfo(93, RoyalEast, "Royal East",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        DealRowTalonStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        StackWrapper, \
        UD_SS_RowStack
from pysollib.util import ACE, KING

# ************************************************************************
# * Carthage
# ************************************************************************


class Carthage_Talon(DealRowTalonStack):
    def dealCards(self, sound=False):
        if sound:
            self.game.startDealSample()
        if len(self.cards) == len(self.game.s.rows):
            n = self.dealRowAvail(rows=self.game.s.rows, sound=False)
        else:
            n = self.dealRowAvail(rows=self.game.s.reserves, sound=False)
            n += self.dealRowAvail(rows=self.game.s.reserves, sound=False)
        if sound:
            self.game.stopSamples()
        return n


class Carthage(Game):

    Hint_Class = CautiousDefaultHint
    Talon_Class = Carthage_Talon
    Foundation_Classes = (SS_FoundationStack,
                          SS_FoundationStack)
    RowStack_Class = StackWrapper(SS_RowStack, max_move=1)

    #
    # game layout
    #

    def createGame(self, rows=8, reserves=6, playcards=12):
        # create layout
        l, s = Layout(self), self.s

        # set window
        decks = self.gameinfo.decks
        foundations = decks*4
        max_rows = max(foundations, rows)
        w, h = l.XM+(max_rows+1)*l.XS, l.YM+3*l.YS+playcards*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y = l.XM+l.XS+(max_rows-foundations)*l.XS//2, l.YM
        for fclass in self.Foundation_Classes:
            for i in range(4):
                s.foundations.append(fclass(x, y, self, suit=i))
                x += l.XS

        x, y = l.XM+l.XS+(max_rows-rows)*l.XS//2, l.YM+l.YS
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self,
                                              max_move=1, max_accept=1))
            x += l.XS
        self.setRegion(s.rows, (-999, y-l.CH//2, 999999, h-l.YS-l.CH//2))

        d = (w-reserves*l.XS)//reserves
        x, y = l.XM, h-l.YS
        for i in range(reserves):
            stack = ReserveStack(x, y, self)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 2, 0
            s.reserves.append(stack)
            x += l.XS+d

        s.talon = self.Talon_Class(l.XM, l.YM, self)
        l.createText(s.talon, "s")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.rows, frames=0)
        for i in range(5):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * Algerian Patience
# ************************************************************************

class AlgerianPatience(Carthage):

    Foundation_Classes = (SS_FoundationStack,
                          StackWrapper(SS_FoundationStack, base_rank=KING,
                                       dir=-1))
    RowStack_Class = StackWrapper(UD_SS_RowStack, mod=13)

    def _shuffleHook(self, cards):
        # move 4 Kings to top of the Talon
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == KING and c.deck == 0, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations[4:], frames=0)
        Carthage.startGame(self)


class AlgerianPatience3(Carthage):
    Foundation_Classes = (SS_FoundationStack,
                          SS_FoundationStack,
                          SS_FoundationStack)
    RowStack_Class = StackWrapper(UD_SS_RowStack, mod=13)

    def createGame(self):
        Carthage.createGame(self, rows=8, reserves=8, playcards=20)

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == ACE, (c.deck, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        Carthage.startGame(self)


# register the game
registerGame(GameInfo(321, Carthage, "Carthage",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(322, AlgerianPatience, "Algerian Patience",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(457, AlgerianPatience3, "Algerian Patience (3 decks)",
                      GI.GT_3DECK_TYPE | GI.GT_ORIGINAL, 3, 0,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.layout import Layout
from pysollib.stack import \
        ArbitraryStack, \
        BasicRowStack, \
        RedealTalonStack, \
        SS_FoundationStack
from pysollib.util import ACE, KING

# ************************************************************************
# * Grand Duchess
# ************************************************************************


class GrandDuchess_Talon(RedealTalonStack):

    def canDealCards(self):
        if self.round == self.max_rounds:
            return len(self.cards) != 0
        return not self.game.isGameWon()

    def dealCards(self, sound=False):
        rows = self.game.s.rows
        reserves = self.game.s.reserves
        if not self.cards:
            RedealTalonStack.redealCards(self, rows=rows+reserves, sound=False)
        if sound and not self.game.demo:
            self.game.startDealSample()
        num_cards = 0
        if self.round != 4:
            num_cards += self.dealRowAvail(rows=[reserves[0]], flip=0)
        num_cards += self.dealRowAvail()
        if self.round != 4:
            num_cards += self.dealRowAvail(rows=[reserves[1]], flip=0)
        if not self.cards:
            for s in reserves:
                self.game.flipAllMove(s)
        if sound and not self.game.demo:
            self.game.stopSamples()
        return num_cards


class GrandDuchess_Reserve(ArbitraryStack):
    def canFlipCard(self):
        return False


class GrandDuchess(Game):

    #
    # game layout
    #

    def createGame(self, rows=4):
        # create layout
        max_rows = max(10, 4+rows)
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+max_rows*l.XS, l.YM+2*l.YS+18*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        s.talon = GrandDuchess_Talon(x, y, self, max_rounds=4)
        l.createText(s.talon, 'se')
        l.createRoundText(s.talon, 'ne')

        x += 2*l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self,
                                 suit=i, base_rank=KING, dir=-1))
            x += l.XS
        x, y = l.XM+(max_rows-rows)*l.XS//2, l.YM+l.YS
        for i in range(rows):
            stack = BasicRowStack(x, y, self, max_move=1, max_accept=0)
            stack.CARD_YOFFSET = l.YOFFSET
            s.rows.append(stack)
            x += l.XS
        dx = (max_rows-rows)*l.XS//4-l.XS//2
        x, y = l.XM+dx, l.YM+l.YS
        s.reserves.append(GrandDuchess_Reserve(x, y, self))
        x, y = self.width-dx-l.XS, l.YM+l.YS
        s.reserves.append(GrandDuchess_Reserve(x, y, self))

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=[self.s.reserves[0]], flip=0)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=[self.s.reserves[1]], flip=0)

    def redealCards(self):
        pass

    def getAutoStacks(self, event=None):
        return ((), (), self.sg.dropstacks)


# ************************************************************************
# * Parisienne
# ************************************************************************

class Parisienne(GrandDuchess):
    def _shuffleHook(self, cards):
        # move one Ace and one King of each suit to top of the Talon
        # (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (ACE, KING) and c.deck == 0,
                       (c.rank, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        GrandDuchess.startGame(self)


class GrandDuchessPlus(GrandDuchess):
    def createGame(self):
        GrandDuchess.createGame(self, rows=6)


registerGame(GameInfo(557, GrandDuchess, "Grand Duchess",
                      GI.GT_2DECK_TYPE, 2, 3))
registerGame(GameInfo(617, Parisienne, "Parisienne",
                      GI.GT_2DECK_TYPE, 2, 3,
                      rules_filename='grandduchess.html',
                      altnames=('La Parisienne', 'Parisian')))
registerGame(GameInfo(618, GrandDuchessPlus, "Grand Duchess +",
                      GI.GT_2DECK_TYPE, 2, 3))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import pysollib.game
from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.layout import Layout
from pysollib.stack import \
        AbstractFoundationStack, \
        SequenceRowStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ANY_RANK, ANY_SUIT

# ************************************************************************
# * Simplex
# ************************************************************************


def isSameRankSequence(cards):
    c0 = cards[0]
    for c in cards[1:]:
        if c0.rank != c.rank:
            return False
    return True


class Simplex_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if len(cards) != 4:
            return False
        return isSameRankSequence(cards)


class Simplex_RowStack(SequenceRowStack):
    def canDropCards(self, stacks):
        if len(self.cards) != 4:
            return (None, 0)
        for s in stacks:
            if s is not self and s.acceptsCards(self, self.cards):
                return (s, 4)
        return (None, 0)

    def _isSequence(self, cards):
        return isSameRankSequence(cards)


class Simplex(pysollib.game.StartDealRowAndCards, Game):

    def createGame(self, reserves=6):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+10*l.XS, l.YM+2*l.YS+4*l.YOFFSET+l.TEXT_HEIGHT
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 's')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 's')
        x += l.XS
        stack = Simplex_Foundation(
            x, y, self,
            suit=ANY_SUIT, base_rank=ANY_RANK, max_cards=52)
        xoffset = (self.width-3*l.XS)//51
        stack.CARD_XOFFSET, stack.CARD_YOFFSET = xoffset, 0
        s.foundations.append(stack)
        x, y = l.XM, l.YM+l.YS+l.TEXT_HEIGHT
        for i in range(9):
            s.rows.append(Simplex_RowStack(x, y, self))
            x += l.XS

        # define stack-groups
        l.defaultStackGroups()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank == card2.rank


# register the game
registerGame(GameInfo(436, Simplex, "Simplex",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.golf import Golf_Hint, Golf_Waste
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import OpenStack, StackWrapper, WasteTalonStack
from pysollib.util import ANY_RANK

# ************************************************************************
# * Three Peaks Row Stack
# ************************************************************************


class ThreePeaks_TalonStack(WasteTalonStack):

    def dealCards(self, sound=False):
        game = self.game
        game.sequence = 0
        old_state = game.enterState(game.S_DEAL)
        num_cards = 0
        waste = self.waste
        if self.cards:
            if sound and not self.game.demo:
                self.game.playSample("dealwaste")
            num_cards = min(len(self.cards), self.num_deal)
            assert len(waste.cards) + num_cards <= waste.cap.max_cards
            for i in range(num_cards):
                if not self.cards[-1].face_up:
                    game.flipMove(self)
                game.moveMove(1, self, waste, frames=4, shadow=0)
                self.fillStack()
        elif waste.cards and self.round != self.max_rounds:
            if sound:
                self.game.playSample("turnwaste", priority=20)
            num_cards = len(waste.cards)
            game.turnStackMove(waste, self)
            game.nextRoundMove(self)
        game.leaveState(old_state)
        return num_cards


class ThreePeaks_RowStack(OpenStack):

    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=1, max_accept=0, max_cards=1,
                  base_rank=ANY_RANK)
        OpenStack.__init__(self, x, y, game, **cap)

    def basicIsBlocked(self):
        r = self.game.s.rows
        step = (3, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9)
        i = self.id
        while i < 18:
            i = i + step[i]
            for j in range(2):
                if r[i + j].cards:
                    return True
        return False

    def clickHandler(self, event):
        result = OpenStack.doubleclickHandler(self, event)
        if result == 1 and not self.game.score_counted:
            self.game.sequence += 1
            self.game.computeHandScore()
            self.game.updateText()
        elif self.game.score_counted:
            self.game.score_counted = False
        return result


# ************************************************************************
# * Three Peaks Game
# ************************************************************************

class ThreePeaks(Game):

    Waste_Class = StackWrapper(Golf_Waste, mod=13)
    Hint_Class = Golf_Hint

    SCORING = 1

    #
    # Game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # compute best XOFFSET
        xoffset = int(l.XS * 8 / self.gameinfo.ncards)
        if xoffset < l.XOFFSET:
            l.XOFFSET = xoffset

        # Set window size
        w, h = l.XM + l.XS * 10, l.YM + l.YS * 4
        self.setSize(w, h)

        # Extra settings
        self.game_score = 0
        self.hand_score = self.sequence = 0
        self.score_counted = False
        self.peaks = [0] * 3

        # Create rows
        x, y = l.XM + l.XS * 1.5, l.YM
        for i in range(3):
            s.rows.append(ThreePeaks_RowStack(x, y, self))
            x = x + l.XS * 3
        x, y = l.XM + l.XS, y + l.YS * .5
        for i in range(3):
            s.rows.append(ThreePeaks_RowStack(x, y, self))
            x = x + l.XS
            s.rows.append(ThreePeaks_RowStack(x, y, self))
            x = x + l.XS * 2
        x, y = l.XM + l.XS * .5, y + l.YS * .5
        for i in range(9):
            s.rows.append(ThreePeaks_RowStack(x, y, self))
            x = x + l.XS
        x, y = l.XM, y + l.YS * .5
        for i in range(10):
            s.rows.append(ThreePeaks_RowStack(x, y, self))
            x = x + l.XS

        # Create talon
        x, y = l.XM, y + l.YM + l.YS
        s.talon = ThreePeaks_TalonStack(x, y, self, num_deal=1, max_rounds=1)
        l.createText(s.talon, "s")
        x = x + l.XS
        s.waste = self.Waste_Class(x, y, self)
        s.waste.CARD_XOFFSET = l.XOFFSET
        s.foundations.append(s.waste)
        l.createText(s.waste, "s")

        # Create text for scores
        if self.preview <= 1:
            self.texts.info = MfxCanvasText(
                self.canvas,
                l.XM + l.XS * 3, h - l.YM,
                anchor="sw",
                font=self.app.getFont("canvas_default"))

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == self.gameinfo.ncards
        self.game_score = self.game_score + self.hand_score
        self.hand_score = -52
        self.peaks = [0] * 3
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:18], flip=0, frames=4)
        self.s.talon.dealRow(rows=self.s.rows[18:], flip=1, frames=4)
        self.s.talon.dealCards()

    def isGameWon(self):
        for r in self.s.rows:
            if r.cards:
                return False
        if self.sequence:
            self.hand_score = self.hand_score + len(self.s.talon.cards) * 10
        self.computeHandScore()
        self.score_counted = True
        self.updateText()
        self.sequence = 0
        return True

    def updateText(self):
        if self.preview > 1 or not self.texts.info or not self.SCORING:
            return
        t = _('Score:\011This hand:  ') + str(self.hand_score)
        t = t + _('\011This game:  ') + str(self.game_score)
        self.texts.info.config(text=t)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        if stack1 == self.s.waste or stack2 == self.s.waste:
            return ((card1.rank + 1) % 13 == card2.rank or
                    (card1.rank - 1) % 13 == card2.rank)
        return False

    def computeHandScore(self):
        score, i = self.hand_score, 1
        # First count the empty peaks
        for r in self.s.rows[:3]:
            if not r.cards:
                i = i * 2
        # Now give credit for newly emptied peaks
        for r in self.s.rows[:3]:
            if not r.cards and not self.peaks[r.id]:
                score, self.peaks[r.id] = score + 5 * i, 1
        # Now give credit for the sequence length
        if self.sequence and len(self.s.waste.cards) - 1:
            score = score + i * 2 ** int((self.sequence - 1) / 4)
        self.hand_score = score
        # print 'getHandScore: score:', score

    def canUndo(self):
        return False

    def _restoreGameHook(self, game):
        self.game_score = game.loadinfo.game_score
        self.hand_score = game.loadinfo.hand_score
        self.sequence = game.loadinfo.sequence
        self.peaks = game.loadinfo.peaks

    def _loadGameHook(self, p):
        self.loadinfo.addattr(game_score=0)
        self.loadinfo.game_score = p.load()
        self.loadinfo.addattr(hand_score=0)
        self.loadinfo.hand_score = p.load()
        self.loadinfo.addattr(sequence=0)
        self.loadinfo.sequence = p.load()
        self.loadinfo.addattr(peaks=[0]*3)
        self.loadinfo.peaks = p.load()

    def _saveGameHook(self, p):
        p.dump(self.game_score)
        p.dump(self.hand_score)
        p.dump(self.sequence)
        p.dump(self.peaks)


# ************************************************************************
# * Three Peaks Game Non-scoring
# ************************************************************************

class ThreePeaksNoScore(ThreePeaks):
    SCORING = 0

    def canUndo(self):
        return True


registerGame(GameInfo(22216, ThreePeaks, "Three Peaks",
                      GI.GT_PAIRING_TYPE | GI.GT_SCORE, 1, 0, GI.SL_BALANCED,
                      altnames=("Tri Peaks",)
                      ))
registerGame(GameInfo(22231, ThreePeaksNoScore, "Three Peaks Non-scoring",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import pysollib.game
from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.stack import \
        AbstractFoundationStack, \
        OpenStack, \
        Stack, \
        StackWrapper, \
        UD_SS_RowStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, ANY_RANK, NO_RANK


# ************************************************************************
# *
# ************************************************************************


class UnionSquare_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # check the rank
        if len(self.cards) > 12:
            return cards[0].rank == 25 - len(self.cards)
        else:
            return cards[0].rank == len(self.cards)


class UnionSquare_RowStack(OpenStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, mod=8192, dir=0, base_rank=ANY_RANK,
                  max_accept=1, max_move=1)
        OpenStack.__init__(self, x, y, game, **cap)
        # self.CARD_YOFFSET = 1

    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return True
        if cards[0].suit != self.cards[0].suit:
            return False
        if len(self.cards) == 1:
            card_dir = cards[0].rank - self.cards[-1].rank
            return card_dir == 1 or card_dir == -1
        else:
            stack_dir = (self.cards[1].rank - self.cards[0].rank) % \
                self.cap.mod
            return (self.cards[-1].rank + stack_dir) % \
                self.cap.mod == cards[0].rank

    getBottomImage = Stack._getReserveBottomImage


# ************************************************************************
# *
# ************************************************************************

class UnionSquare(pysollib.game.StartDealRowAndCards, Game):
    Hint_Class = CautiousDefaultHint
    Foundation_Class = StackWrapper(UnionSquare_Foundation, max_cards=26)
    RowStack_Class = UnionSquare_RowStack

    #
    # game layout
    #

    def createGame(self, rows=16):
        # create layout
        l, s = Layout(self, card_y_space=20), self.s

        # set window
        self.setSize(l.XM + (5+rows//4)*l.XS, l.YM + 4*l.YS)

        # create stacks
        x, y, = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "s")
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")
        for i in range(4):
            x = 3*l.XS
            for j in range(rows//4):
                stack = self.RowStack_Class(x, y, self)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 1
                s.rows.append(stack)
                x = x + l.XS
            y = y + l.YS
        x, y = self.width-l.XS, l.YM
        for i in range(4):
            stack = self.Foundation_Class(x, y, self, suit=i,
                                          max_move=0, dir=0)
            l.createText(stack, "sw")
            s.foundations.append(stack)
            y = y + l.YS

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    shallHighlightMatch = Game._shallHighlightMatch_SS

    def getHighlightPilesStacks(self):
        return ()


# ************************************************************************
# * Solid Square
# ************************************************************************

class SolidSquare(UnionSquare):
    RowStack_Class = StackWrapper(UD_SS_RowStack, base_rank=NO_RANK,
                                  max_accept=1,  max_move=1, mod=13)

    def createGame(self):
        UnionSquare.createGame(self, rows=20)

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank == ACE and c.deck == 0, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        UnionSquare.startGame(self)

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if not self.s.waste.cards:
                self.s.talon.dealCards()
            if self.s.waste.cards:
                self.s.waste.moveMove(1, stack)
            self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * Boomerang
# ************************************************************************

class Boomerang_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # check the rank
        # 7, 8, 9, 10, J, Q, K, A, K, Q, J, 10, 9, 8, 7, A
        if len(self.cards) < 7:
            return cards[0].rank - 6 == len(self.cards)
        elif len(self.cards) == 7:
            return cards[0].rank == ACE
        elif len(self.cards) < 15:
            return cards[0].rank == 20 - len(self.cards)
        else:  # len(self.cards) == 15
            return cards[0].rank == ACE


class Boomerang(UnionSquare):
    Foundation_Class = StackWrapper(Boomerang_Foundation,
                                    base_rank=6, max_cards=16)
    RowStack_Class = StackWrapper(UnionSquare_RowStack, base_rank=NO_RANK)

    def createGame(self):
        UnionSquare.createGame(self, rows=12)

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if not self.s.waste.cards:
                self.s.talon.dealCards()
            if self.s.waste.cards:
                self.s.waste.moveMove(1, stack)
            self.leaveState(old_state)


# register the game
registerGame(GameInfo(35, UnionSquare, "Union Square",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL,
                      altnames=('British Square',),
                      ))
registerGame(GameInfo(439, SolidSquare, "Solid Square",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(738, Boomerang, "Boomerang",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED,
                      ranks=(0, 6, 7, 8, 9, 10, 11, 12),
                      ))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.stack import \
        OpenStack, \
        SS_FoundationStack, \
        Stack, \
        WasteTalonStack


class LarasGame_Hint(CautiousDefaultHint):
    pass


# ************************************************************************
# *
# ************************************************************************

class LarasGame_Talon(WasteTalonStack):
    # Deal a card to each of the RowStacks.  Then deal
    # cards to the talon.  Return number of cards dealt.
    def dealRow(self, rows=None, flip=1, reverse=0, frames=-1, sound=False):
        game = self.game
        if rows is None:
            rows = game.s.rows
        old_state = game.enterState(game.S_DEAL)
        cards = self.dealToStacks(rows[:game.MAX_ROW], flip, reverse, frames)
        if sound and frames and self.game.app.opt.animations:
            self.game.startDealSample()
        for i in range(game.DEAL_TO_TALON):
            if self.cards:
                game.moveMove(1, self, game.s.rows[-1], frames=frames)
                cards = cards + 1
        game.leaveState(old_state)
        if sound:
            self.game.stopSamples()
        return cards

    def dealToStacks(self, stacks, flip=1, reverse=0, frames=-1):
        game = self.game
        i, move = 0, game.moveMove
        for r in stacks:
            if not self.cards:
                return 0
            assert not self.getCard().face_up
            assert r is not self
            if flip:
                game.flipMove(self)
            move(1, self, r, frames=frames)
            # Dealing has extra rules in this game type:
            # If card rank == card location then add one card to talon
            # If card rank == ACE then add two cards to talon
            # If card rank == JACK, or higher then add one card to talon
            # After all the rows have been dealt, deal cards to talon
            #     in self.dealRow
            rank = r.getCard().rank
            if rank == i:       # Is the rank == position?
                if not self.cards:
                    return 0
                move(1, self, game.s.rows[-1], frames=frames)
            i = i + 1
            if rank == 0:       # Is this an Ace?
                for j in range(2):
                    if not self.cards:
                        return 0
                    move(1, self, game.s.rows[-1], frames=frames)
            if rank >= 10:      # Is it a Jack or better?
                if not self.cards:
                    return 0
                move(1, self, game.s.rows[-1], frames=frames)
        return len(stacks)

    def dealCards(self, sound=False):
        game = self.game
        if sound and self.game.app.opt.animations:
            self.game.startDealSample()
        for r in game.s.reserves[:20]:
            while r.cards:
                game.moveMove(
                    1, r, game.s.rows[game.active_row], frames=3, shadow=0)
        if self.cards:
            game.active_row = self.getActiveRow()
            game.flipMove(self)
            game.moveMove(1, self, game.s.reserves[0], frames=4, shadow=0)
            ncards = len(game.s.rows[game.active_row].cards)
            if ncards >= 20:
                # We have encountered an extreme situation.
                # In some game type variations it's possible
                # to have up to 28 cards on a row stack.
                # We'll have to double up on some of the reserves.
                for i in range(ncards - 19):
                    game.moveMove(
                        1, game.s.rows[game.active_row],
                        game.s.reserves[19 - i], frames=4, shadow=0)
                    ncards = len(game.s.rows[game.active_row].cards)
                assert ncards <= 19
            for i in range(ncards):
                game.moveMove(
                    1, game.s.rows[game.active_row],
                    game.s.reserves[ncards - i], frames=4, shadow=0)
            num_cards = len(self.cards) or self.canDealCards()
        else:  # not self.cards
            if self.round < self.max_rounds:
                ncards = 0
                rows = list(game.s.rows)[:game.MAX_ROW]
                rows.reverse()
                for r in rows:
                    while r.cards:
                        ncards += 1
                        if r.cards[-1].face_up:
                            game.flipMove(r)
                        game.moveMove(1, r, self, frames=0)
                assert len(self.cards) == ncards
                if ncards != 0:
                    game.nextRoundMove(self)
                    game.dealToRows()
            num_cards = len(self.cards)
        if sound:
            game.stopSamples()
        return num_cards

    def canDealCards(self):
        if self.game.demo and self.game.moves.index >= 400:
            return False
        return (self.cards or
                (self.round < self.max_rounds and not self.game.isGameWon()))

    def updateText(self):
        if self.game.preview > 1:
            return
        WasteTalonStack.updateText(self, update_rounds=0)
        if not self.max_rounds - 1:
            return
        t = _("Round %d") % self.round
        self.texts.rounds.config(text=t)

    def getActiveRow(self):
        return self.getCard().rank


class LarasGame_RowStack(OpenStack):
    def __init__(self, x, y, game, yoffset=1, **cap):
        OpenStack.__init__(self, x, y, game, **cap)
        self.CARD_YOFFSET = yoffset


class LarasGame_ReserveStack(OpenStack):
    pass


class LarasGame_Reserve(OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return False
        return from_stack in self.game.s.rows

    getBottomImage = Stack._getReserveBottomImage


# ************************************************************************
# * Lara's Game
# ************************************************************************

class LarasGame(Game):
    Hint_Class = LarasGame_Hint
    Talon_Class = LarasGame_Talon
    Reserve_Class = None
    DEAL_TO_TALON = 2
    MAX_ROUNDS = 1
    ROW_LENGTH = 4
    MAX_ROW = 13
    DIR = (-1, 1)

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        ROW_LENGTH = self.ROW_LENGTH

        # set window
        w, h = l.XM + l.XS * (ROW_LENGTH + 5), \
            l.YM + l.YS * (ROW_LENGTH + (ROW_LENGTH != 6))
        self.setSize(w, h)

        # extra settings
        self.active_row = None

        # Create foundations
        x, y = l.XM, l.YM
        for j in range(2):
            for i in range(ROW_LENGTH):
                s.foundations.append(
                    SS_FoundationStack(
                        x, y, self, self.Base_Suit(i, j),
                        max_cards=self.Max_Cards(i), mod=self.Mod(i),
                        dir=self.DIR[j], base_rank=self.Base_Rank(i, j)))
                y = y + l.YS * (not j)
                x = x + l.XS * j
            x, y = x + l.XS * 2, l.YM

        # Create rows
        x, y = l.XM + l.XS, y + l.YS
        for i in range(self.MAX_ROW):
            s.rows.append(LarasGame_RowStack(x, y, self))
            x = x + l.XS
            if i == ROW_LENGTH or i == ROW_LENGTH * 2 + 1 \
                    or i == ROW_LENGTH * 3 + 2:
                x, y = l.XM + l.XS, y + l.YS

        # Create reserves
        x, y = l.XM + l.XS * (ROW_LENGTH == 6), \
            l.YM + l.YS * (ROW_LENGTH - (ROW_LENGTH == 6))
        for i in range(20):
            s.reserves.append(LarasGame_ReserveStack(x, y, self, max_cards=2))
            x += l.XS * (i < (ROW_LENGTH + 4)) - l.XS * (i == (ROW_LENGTH + 9))
            y = y - l.YS * (i > (ROW_LENGTH + 3) and i < (ROW_LENGTH + 9)) \
                + l.YS * (i > (ROW_LENGTH + 9))

        # Create talon
        x, y = l.XM + l.XS * (ROW_LENGTH + 2), h - l.YM - l.YS * 3
        s.talon = self.Talon_Class(x, y, self, max_rounds=self.MAX_ROUNDS)
        l.createText(s.talon, "s")
        if self.MAX_ROUNDS > 1:
            l.createRoundText(s.talon, 'nn')
        y = h - l.YS * 2
        s.rows.append(LarasGame_RowStack(x, y, self, yoffset=0))

        # Define stack-groups (not default)
        self.sg.openstacks = s.foundations + s.rows[:self.MAX_ROW]
        self.sg.talonstacks = [s.talon] + s.rows[-1:]
        self.sg.dropstacks = s.rows[:self.MAX_ROW] + s.reserves

        # Create relaxed reserve
        if self.Reserve_Class is not None:
            x, y = l.XM + l.XS * (ROW_LENGTH + 2), l.YM + l.YS * .5
            s.reserves.append(
                self.Reserve_Class(
                    x, y, self,
                    max_accept=1, max_cards=self.Reserve_Cards))
        self.sg.openstacks = self.sg.openstacks + s.reserves[19:]
        self.sg.dropstacks = self.sg.dropstacks + s.reserves[19:]
        self.setRegion(s.reserves[19:], (x - l.XM // 2, 0, 99999, 99999))

    #
    # Game extras
    #

    def Max_Cards(self, i):
        return 13

    def Mod(self, i):
        return 13

    def Base_Rank(self, i, j):
        return 12 * (not j)

    def Deal_Rows(self, i):
        return 13

    def Base_Suit(self, i, j):
        return i

    #
    # game overrides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == self.gameinfo.ncards
        self.dealToRows()

    def dealToRows(self):
        frames, ncards = 0, len(self.s.talon.cards)
        for i in range(8):
            if not self.s.talon.cards:
                break
            if i == 4 or len(self.s.talon.cards) <= ncards // 2:
                self.startDealSample()
                frames = 4
            self.s.talon.dealRow(
                rows=self.s.rows[:self.Deal_Rows(i)], frames=frames)
        self.moveMove(
            len(self.s.rows[-1].cards), self.s.rows[-1], self.s.talon,
            frames=0)
        self.active_row = None

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        i, j = (stack1 in self.s.foundations), (stack2 in self.s.foundations)
        if not (i or j):
            return 0
        if i:
            stack = stack1
        else:
            stack = stack2
        i = 0
        for f in self.s.foundations:
            if f == stack:
                break
            i = i + 1 % self.ROW_LENGTH
        return (card1.suit == card2.suit and
                ((card1.rank + 1) % self.Mod(i) == card2.rank or
                 (card1.rank - 1) % self.Mod(i) == card2.rank))

    def getHighlightPilesStacks(self):
        return ()

    # Finish the current move.
    # Append current active_row to moves.current.
    # Append moves.current to moves.history.
    def finishMove(self):
        moves, stats = self.moves, self.stats
        if not moves.current:
            return 0
        # invalidate hints
        self.hints.list = None
        # resize (i.e. possibly shorten list from previous undos)
        if not moves.index == 0:
            moves.history[len(moves.history) - 1]
        del moves.history[moves.index:]
        # update stats
        if self.demo:
            stats.demo_moves = stats.demo_moves + 1
            if moves.index == 0:
                stats.player_moves = 0  # clear all player moves
        else:
            stats.player_moves = stats.player_moves + 1
            if moves.index == 0:
                stats.demo_moves = 0    # clear all demo moves
        stats.total_moves = stats.total_moves + 1
        # add current move to history (which is a list of lists)
        moves.current.append(self.active_row)
        moves.history.append(moves.current)
        moves.index = moves.index + 1
        assert moves.index == len(moves.history)
        moves.current = []
        self.updateText()
        self.updateStatus(moves=(moves.index, self.stats.total_moves))
        self.updateMenus()
        return 1

    def undo(self):
        assert self.canUndo()
        assert self.moves.state == self.S_PLAY and self.moves.current == []
        assert 0 <= self.moves.index <= len(self.moves.history)
        if self.moves.index == 0:
            return
        self.moves.index = self.moves.index - 1
        m = self.moves.history[self.moves.index]
        m = m[:len(m) - 1]
        m.reverse()
        self.moves.state = self.S_UNDO
        for atomic_move in m:
            atomic_move.undo(self)
        self.moves.state = self.S_PLAY
        m = self.moves.history[max(0, self.moves.index - 1)]
        self.active_row = m[len(m) - 1]
        self.stats.undo_moves = self.stats.undo_moves + 1
        self.stats.total_moves = self.stats.total_moves + 1
        self.hints.list = None
        self.updateText()
        self.updateStatus(moves=(self.moves.index, self.stats.total_moves))
        self.updateMenus()

    def redo(self):
        assert self.canRedo()
        assert self.moves.state == self.S_PLAY and self.moves.current == []
        assert 0 <= self.moves.index <= len(self.moves.history)
        if self.moves.index == len(self.moves.history):
            return
        m = self.moves.history[self.moves.index]
        self.moves.index = self.moves.index + 1
        self.active_row = m[len(m) - 1]
        m = m[:len(m) - 1]
        self.moves.state = self.S_REDO
        for atomic_move in m:
            atomic_move.redo(self)
        self.moves.state = self.S_PLAY
        self.stats.redo_moves = self.stats.redo_moves + 1
        self.stats.total_moves = self.stats.total_moves + 1
        self.hints.list = None
        self.updateText()
        self.updateStatus(moves=(self.moves.index, self.stats.total_moves))
        self.updateMenus()

    def _restoreGameHook(self, game):
        self.active_row = game.loadinfo.active_row

    def _loadGameHook(self, p):
        self.loadinfo.addattr(active_row=0)    # register extra load var.
        self.loadinfo.active_row = p.load()

    def _saveGameHook(self, p):
        p.dump(self.active_row)


# ************************************************************************
# * Relaxed Lara's Game
# ************************************************************************

class RelaxedLarasGame(LarasGame):
    Reserve_Class = LarasGame_Reserve
    Reserve_Cards = 1
    DEAL_TO_TALON = 3
    MAX_ROUNDS = 2


# ************************************************************************
# * Double Lara's Game
# ************************************************************************

class DoubleLarasGame(RelaxedLarasGame):
    Reserve_Cards = 2
    MAX_ROUNDS = 3

    def Max_Cards(self, i):
        return 26


# register the game

registerGame(GameInfo(37, LarasGame, "Lara's Game",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED,
                      altnames=("Thirteen Packs",)))
registerGame(GameInfo(13006, RelaxedLarasGame, "Lara's Game Relaxed",
                      GI.GT_2DECK_TYPE, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(13007, DoubleLarasGame, "Lara's Game Doubled",
                      GI.GT_2DECK_TYPE, 4, 2, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.stack import \
        AbstractFoundationStack, \
        BasicRowStack, \
        FullStackWrapper, \
        InitialDealTalonStack, \
        OpenStack, \
        ReserveStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ANY_RANK, ANY_SUIT, UNLIMITED_REDEALS

# ************************************************************************
# * Osmosis
# ************************************************************************


class Osmosis_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # search foundation with max number of cards
        assert len(cards) == 1
        max_s, max_cards = None, -1
        for s in self.game.s.foundations:
            if len(s.cards) > max_cards:
                max_s, max_cards = s, len(s.cards)
        # if we have less cards, then rank must match the card in this
        # foundation
        if len(self.cards) < max_cards:
            if cards[0].rank != max_s.cards[len(self.cards)].rank:
                return False
        #
        return True

    def getHelp(self):
        return _('Foundation. Build in suit regardless of rank.')


class Osmosis(Game):
    Foundation_Class = Osmosis_Foundation

    #
    # game layout
    #

    def createGame(self, max_rounds=-1, num_deal=1):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = 3*l.XM+3*l.XS+(4+13)*l.XOFFSET, l.YM+4*l.YS
        self.setSize(w, h)

        # create stacks
        x, y, = l.XM, l.YM
        for i in range(4):
            stack = BasicRowStack(x, y, self, max_move=1, max_accept=0)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
            s.rows.append(stack)
            y = y + l.YS
        x, y, = 2*l.XM+l.XS+4*l.XOFFSET, l.YM
        for i in range(4):
            stack = self.Foundation_Class(x, y, self, suit=i,
                                          base_rank=ANY_RANK, max_move=0)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
            s.foundations.append(stack)
            y = y + l.YS
        x, y, = self.width - l.XS, l.YM + l.YS
        s.talon = WasteTalonStack(x, y, self,
                                  max_rounds=max_rounds, num_deal=num_deal)
        l.createText(s.talon, "sw")
        y = y + l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "sw")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self, flip=0):
        # deal first card to foundation
        base_card = self.s.talon.getCard()
        n = base_card.suit * self.gameinfo.decks
        to_stack = self.s.foundations[n]
        self.startDealSample()
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, to_stack)
        # deal cards
        for i in range(3):
            self.s.talon.dealRow(flip=flip)
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack


# ************************************************************************
# * Peek
# ************************************************************************

class Peek(Osmosis):
    def startGame(self):
        Osmosis.startGame(self, flip=1)


# ************************************************************************
# * Treasure Trove
# * Peek II
# ************************************************************************

class OsmosisII_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        assert len(cards) == 1
        indx = list(self.game.s.foundations).index(self)
        c0 = cards[0]
        below_found = self.game.s.foundations[indx-1]
        if indx == 0:
            if not self.cards:
                return True
            return c0.suit == self.cards[0].suit
        if not below_found.cards:
            return False
        if not self.cards:
            return c0.rank == below_found.cards[0].rank
        if c0.suit != self.cards[0].suit:
            return False
        for c1 in below_found.cards:
            if c0.rank == c1.rank:
                return True
        return False

    def getHelp(self):
        return _('Foundation. Build in suit regardless of rank.')


class OsmosisII(Osmosis):
    Foundation_Class = FullStackWrapper(
        OsmosisII_Foundation, base_rank=ANY_RANK, suit=ANY_SUIT, max_move=0)

    def createGame(self, max_rounds=-1, num_deal=3):
        Osmosis.createGame(self, num_deal=3)

    def startGame(self, flip=0):
        self.startDealSample()
        # deal cards
        for i in range(3):
            self.s.talon.dealRow(flip=flip)
        self.s.talon.dealRow()
        # deal one card to foundation
        self.s.talon.dealRow(rows=self.s.foundations[:1])
        # deal cards to WasteStack
        self.s.talon.dealCards()


class PeekII(OsmosisII):
    def startGame(self):
        OsmosisII.startGame(self, flip=1)


# ************************************************************************
# * Open Peek
# ************************************************************************

class OpenPeek(Game):

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = max(2*l.XM+2*l.XS+(5+13)*l.XOFFSET, l.XM + 8*l.XS), l.YM+8*l.YS
        self.setSize(w, h)

        # create stacks
        x, y, = l.XM, l.YM
        for i in range(4):
            stack = BasicRowStack(x, y, self, max_move=1, max_accept=0)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
            s.rows.append(stack)
            y += l.YS
        x, y, = 2*l.XM+l.XS+5*l.XOFFSET, l.YM
        for i in range(4):
            stack = Osmosis_Foundation(
                x, y, self, i, base_rank=ANY_RANK, max_move=0)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
            s.foundations.append(stack)
            y += l.YS
        y = l.YM + 4*l.YS
        for i in range(4):
            x = l.XM
            for j in range(8):
                s.reserves.append(OpenStack(x, y, self, max_accept=0))
                x += l.XS
            y += l.YS

        x, y = w-l.XS, l.YM
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(5)
        self.s.talon.dealRow(rows=self.s.reserves)


# ************************************************************************
# * Genesis
# ************************************************************************

class Genesis(Game):

    def createGame(self, rows=13, reserves=False):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+rows*l.XS, l.YM+2*l.YS+20*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y, = l.XM+(rows-4)*l.XS//2, l.YM
        for i in range(4):
            stack = Osmosis_Foundation(
                x, y, self, i, base_rank=ANY_RANK, max_move=0)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, l.YOFFSET
            s.foundations.append(stack)
            x += l.XS

        x, y, = l.XM, h-2*l.YS-3*l.YOFFSET
        for i in range(rows):
            s.rows.append(BasicRowStack(x, y, self))
            x += l.XS

        x, y, = l.XM, h-l.YS-3*l.YOFFSET
        for i in range(rows):
            s.rows.append(BasicRowStack(x, y, self))
            x += l.XS

        if reserves:
            s.reserves.append(ReserveStack(l.XM, l.YM, self))
            s.reserves.append(ReserveStack(w-l.XS, l.YM, self))

        s.talon = InitialDealTalonStack(l.XM, l.YM, self)

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        for i in range(3):
            self.s.talon.dealRow(rows=self.s.rows[13:], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:13])


class GenesisPlus(Genesis):
    def createGame(self):
        Genesis.createGame(self, reserves=True)


# ************************************************************************
# * Bridesmaids
# ************************************************************************

class Bridesmaids(Game):
    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+3*l.XS+12*l.XOFFSET, l.YM+4*l.YS
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=UNLIMITED_REDEALS,
                                  num_deal=3)
        l.createText(s.talon, 'se')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'se')

        x, y = l.XM+2*l.XS, l.YM
        for i in range(4):
            stack = OsmosisII_Foundation(x, y, self, suit=ANY_SUIT,
                                         base_rank=ANY_RANK, max_move=0)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
            s.foundations.append(stack)
            y += l.YS

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self, flip=0):
        # deal first card to foundation
        self.s.talon.getCard()
        to_stack = self.s.foundations[0]
        self.startDealSample()
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, to_stack)
        self.s.talon.dealCards()          # deal first card to WasteStack


# register the game
registerGame(GameInfo(59, Osmosis, "Osmosis",
                      GI.GT_1DECK_TYPE, 1, -1, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(60, Peek, "Peek",
                      GI.GT_1DECK_TYPE, 1, -1, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(298, OpenPeek, "Open Peek",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(370, Genesis, "Genesis",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(371, GenesisPlus, "Genesis +",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(409, Bridesmaids, "Bridesmaids",
                      GI.GT_1DECK_TYPE, 1, -1, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(715, OsmosisII, "Treasure Trove",
                      GI.GT_1DECK_TYPE, 1, -1, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(716, PeekII, "Peek II",
                      GI.GT_1DECK_TYPE, 1, -1, GI.SL_MOSTLY_LUCK,
                      rules_filename='treasuretrove.html'))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        AC_RowStack, \
        InitialDealTalonStack, \
        OpenStack, \
        ReserveStack, \
        SS_FoundationStack, \
        StackWrapper

# ************************************************************************
# * Needle
# * Haystack
# * Pitchfork
# ************************************************************************


class Needle(Game):

    Hint_Class = CautiousDefaultHint
    ReserveStack_Class = StackWrapper(ReserveStack, max_cards=18)

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+max(9*l.XS, 5*l.XS+18*l.XOFFSET), l.YM+2*l.YS+12*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        stack = self.ReserveStack_Class(x, y, self)
        stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
        s.reserves.append(stack)
        self.setRegion(
            s.reserves, (-999, -999, w-4*l.XS-l.CW//2, l.YM+l.YS-l.CH//2))

        x = w-4*l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += l.XS

        x, y = l.XM+(w-(l.XM+9*l.XS))//2, l.YM+l.YS
        for i in range(9):
            s.rows.append(AC_RowStack(x, y, self, max_move=1))
            x += l.XS

        s.talon = InitialDealTalonStack(w-l.XS, h-l.YS, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        for i in range(8):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        for i in (4, 4, 3, 3):
            self.s.talon.dealRow(rows=self.s.rows[:i], frames=0)
            self.s.talon.dealRow(rows=self.s.rows[-i:], frames=0)
        self.startDealSample()
        for i in (2, 2, 2, 2):
            self.s.talon.dealRow(rows=self.s.rows[:i])
            self.s.talon.dealRow(rows=self.s.rows[-i:])

    shallHighlightMatch = Game._shallHighlightMatch_AC

    def getQuickPlayScore(self, ncards, from_stack, to_stack):
        if to_stack in self.s.reserves:
            return 0
        return 1+int(len(to_stack.cards) != 0)


class Haystack(Needle):
    ReserveStack_Class = StackWrapper(ReserveStack, max_cards=8)


class Pitchfork(Needle):
    ReserveStack_Class = StackWrapper(OpenStack, max_accept=0)


# register the game
registerGame(GameInfo(318, Needle, "Needle",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(319, Haystack, "Haystack",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(367, Pitchfork, "Pitchfork",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.layout import Layout
from pysollib.stack import \
        AC_RowStack, \
        InitialDealTalonStack, \
        OpenStack, \
        SS_RowStack, \
        isAlternateColorSequence, \
        isSameSuitSequence
from pysollib.util import ANY_RANK

# ************************************************************************
# * Wave Motion
# ************************************************************************


class WaveMotion(Game):
    RowStack_Class = SS_RowStack

    #
    # game layout
    #

    def createGame(self, rows=8, reserves=8, playcards=7):
        # create layout
        l, s = Layout(self), self.s

        # set window
        max_rows = max(rows, reserves)
        w, h = l.XM + max_rows*l.XS, l.YM + 2*l.YS + (12+playcards)*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y = l.XM + (max_rows-rows)*l.XS//2, l.YM
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self, base_rank=ANY_RANK)
            stack.getBottomImage = stack._getReserveBottomImage
            s.rows.append(stack)
            x += l.XS
        x, y = l.XM + (max_rows-reserves)*l.XS//2, l.YM+l.YS+12*l.YOFFSET
        for i in range(reserves):
            stack = OpenStack(x, y, self, max_accept=0)
            s.reserves.append(stack)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, l.YOFFSET
            x += l.XS

        s.talon = InitialDealTalonStack(l.XM, l.YM, self)

        # default
        l.defaultAll()

    #
    # game overrides
    #

    def startGame(self):
        for i in range(5):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRow(rows=self.s.reserves[:4])

    def isGameWon(self):
        for s in self.s.rows:
            if s.cards:
                if len(s.cards) != 13 or not isSameSuitSequence(s.cards):
                    return False
        return True

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Flourish
# ************************************************************************

class Flourish(WaveMotion):
    RowStack_Class = AC_RowStack

    def createGame(self):
        WaveMotion.createGame(self, rows=7, reserves=8, playcards=7)

    def isGameWon(self):
        for s in self.s.rows:
            if s.cards:
                if len(s.cards) != 13 or not isAlternateColorSequence(s.cards):
                    return False
        return True

    shallHighlightMatch = Game._shallHighlightMatch_AC


# register the game
registerGame(GameInfo(314, WaveMotion, "Wave Motion",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(753, Flourish, "Flourish",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.spider import Spider_SS_Foundation
from pysollib.hint import Yukon_Hint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
    DealRowTalonStack, \
    InitialDealTalonStack, \
    OpenStack, \
    RedealTalonStack, \
    ReserveStack, \
    SS_FoundationStack, \
    StackWrapper, \
    WasteStack, \
    WasteTalonStack, \
    Yukon_AC_RowStack, \
    Yukon_SS_RowStack
from pysollib.util import ANY_SUIT, KING


# ************************************************************************
# * Yukon
# ************************************************************************

class Yukon(Game):
    Layout_Method = staticmethod(Layout.yukonLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = StackWrapper(Yukon_AC_RowStack, base_rank=KING)
    Hint_Class = Yukon_Hint

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s
        kwdefault(layout, rows=7, texts=0, playcards=25)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self, suit=r.suit, max_move=0))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        # default
        l.defaultAll()
        return l

    def startGame(self):
        for i in range(1, len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=0, frames=0)
        for i in range(4):
            self.s.talon.dealRow(rows=self.s.rows[1:], flip=1, frames=0)
        self._startAndDealRow()

    def getHighlightPilesStacks(self):
        return ()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Russian Solitaire (like Yukon, but build down by suit)
# ************************************************************************

class RussianSolitaire(Yukon):
    RowStack_Class = StackWrapper(Yukon_SS_RowStack, base_rank=KING)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Moosehide (build down in any suit but the same)
# ************************************************************************

class Moosehide_RowStack(Yukon_AC_RowStack):
    def _isSequence(self, c1, c2):
        return (c1.suit != c2.suit and c1.rank == c2.rank+1)

    def getHelp(self):
        return _('Tableau. Build down in any suit but the same, can move '
                 'any face-up cards regardless of sequence.')


class Moosehide(Yukon):
    RowStack_Class = StackWrapper(Moosehide_RowStack, base_rank=KING)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit != card2.suit and
                abs(card1.rank-card2.rank) == 1)


# ************************************************************************
# * Odessa (just like Russian Solitaire, only a different initial
# * card layout)
# ************************************************************************

class Odessa(RussianSolitaire):
    def startGame(self):
        for i in range(3):
            self.s.talon.dealRow(flip=0, frames=0)
        self._dealNumRows(2)
        for i in range(2):
            self.s.talon.dealRow(rows=self.s.rows[1:6], frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Grandfather
# ************************************************************************

class Grandfather_Talon(RedealTalonStack):
    def dealCards(self, sound=False):
        self.redealCards(sound=sound, shuffle=True)


class Grandfather(RussianSolitaire):
    Talon_Class = StackWrapper(Grandfather_Talon, max_rounds=3)

    def createGame(self):
        layout = Yukon.createGame(self)
        layout.createRoundText(self.s.talon, 'nn')

    def startGame(self):
        frames = 0
        sound = False
        for i,  j in ((1, 7), (1, 6), (2, 6), (2, 5), (3, 5), (3, 4)):
            if len(self.s.talon.cards) <= j-i:
                frames = -1
                sound = True
                self.startDealSample()
            self.s.talon.dealRowAvail(rows=self.s.rows[i:j],
                                      flip=0, frames=frames)
        if not sound:
            self.startDealSample()
        self.s.talon.dealRowAvail()
        for i in range(4):
            self.s.talon.dealRowAvail(rows=self.s.rows[1:])

    redealCards = startGame


# ************************************************************************
# * Alaska (like Russian Solitaire, but build up or down in suit)
# ************************************************************************

class Alaska_RowStack(Yukon_SS_RowStack):
    def _isSequence(self, c1, c2):
        return (c1.suit == c2.suit and
                ((c1.rank + self.cap.dir) % self.cap.mod == c2.rank or
                 (c2.rank + self.cap.dir) % self.cap.mod == c1.rank))

    def getHelp(self):
        return _('Tableau. Build up or down by suit, can move any face-up '
                 'cards regardless of sequence.')


class Alaska(RussianSolitaire):
    RowStack_Class = StackWrapper(Alaska_RowStack, base_rank=KING)


# ************************************************************************
# * Roslin (like Yukon, but build up or down by alternate color)
# ************************************************************************

class Roslin_RowStack(Yukon_AC_RowStack):
    def _isSequence(self, c1, c2):
        return (c1.color != c2.color and
                ((c1.rank + self.cap.dir) % self.cap.mod == c2.rank or
                 (c2.rank + self.cap.dir) % self.cap.mod == c1.rank))

    def getHelp(self):
        return _('Tableau. Build up or down by alternate color, can move '
                 'any face-up cards regardless of sequence.')


class Roslin(Yukon):
    RowStack_Class = StackWrapper(Roslin_RowStack, base_rank=KING)


# ************************************************************************
# * Chinese Discipline
# * Chinese Solitaire
# ************************************************************************

class ChineseDiscipline(Yukon):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = DealRowTalonStack

    def createGame(self):
        return Yukon.createGame(self, waste=0, texts=1)

    def startGame(self):
        for i in (3, 3, 3, 4, 5, 6):
            self.s.talon.dealRow(rows=self.s.rows[:i], flip=1, frames=0)
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=0, frames=0)
        self._startAndDealRow()


class ChineseSolitaire(ChineseDiscipline):
    RowStack_Class = Yukon_AC_RowStack      # anything on an empty space


# ************************************************************************
# * Queenie
# ************************************************************************

class Queenie(Yukon):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = DealRowTalonStack

    def createGame(self):
        return Yukon.createGame(self, waste=0, texts=1)

    def startGame(self, flip=1, reverse=1):
        for i in range(1, len(self.s.rows)):
            self.s.talon.dealRow(
                rows=self.s.rows[i:], flip=flip, frames=0, reverse=reverse)
        self.startDealSample()
        self.s.talon.dealRow(reverse=reverse)


# ************************************************************************
# * Rushdike (like Queenie, but built down by suit)
# ************************************************************************

class Rushdike(RussianSolitaire):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = DealRowTalonStack

    def createGame(self):
        return RussianSolitaire.createGame(self, waste=0, texts=1)

    def startGame(self, flip=0, reverse=1):
        for i in range(1, len(self.s.rows)):
            self.s.talon.dealRow(
                rows=self.s.rows[i:], flip=flip, frames=0, reverse=reverse)
        self.startDealSample()
        self.s.talon.dealRow(reverse=reverse)


# ************************************************************************
# * Russian Point (Rushdike in a different layout)
# ************************************************************************

class RussianPoint(Rushdike):
    def startGame(self):
        r = self.s.rows
        for i in (1, 1, 2, 2, 3, 3):
            self.s.talon.dealRow(rows=r[i:len(r)-i], flip=0, frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Abacus
# ************************************************************************

class Abacus_Foundation(SS_FoundationStack):
    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, base_rank=suit, mod=13, dir=suit+1, max_move=0)
        SS_FoundationStack.__init__(self, x, y, game, suit, **cap)


class Abacus_RowStack(Yukon_SS_RowStack):
    def _isSequence(self, c1, c2):
        dir, mod = -(c1.suit + 1), 13
        return c1.suit == c2.suit and (c1.rank + dir) % mod == c2.rank


class Abacus(Rushdike):
    Foundation_Class = Abacus_Foundation
    RowStack_Class = Abacus_RowStack

    def createGame(self):
        layout = Rushdike.createGame(self)
        help = (_('''\
Club:    A 2 3 4 5 6 7 8 9 T J Q K
Spade:   2 4 6 8 T Q A 3 5 7 9 J K
Heart:   3 6 9 Q 2 5 8 J A 4 7 T K
Diamond: 4 8 Q 3 7 J 2 6 T A 5 9 K'''))
        self.texts.help = MfxCanvasText(self.canvas,
                                        layout.XM, self.height - layout.YM,
                                        text=help,
                                        anchor="sw",
                                        font=self.app.getFont("canvas_fixed"))

    def _shuffleHook(self, cards):
        # move Twos to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.id in (0, 14, 28, 42), c.suit))

    def startGame(self, flip=1, reverse=1):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        for i in range(1, len(self.s.rows)):
            self.s.talon.dealRow(
                rows=self.s.rows[i:], flip=flip, frames=0, reverse=reverse)
        self.startDealSample()
        self.s.talon.dealRow(reverse=reverse)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        dir, mod = -(card1.suit + 1), 13
        return (card1.suit == card2.suit and
                ((card1.rank + dir) % mod == card2.rank or
                 (card2.rank + dir) % mod == card1.rank))


# ************************************************************************
# * Double Yukon
# * Double Russian Solitaire
# ************************************************************************

class DoubleYukon(Yukon):
    def createGame(self):
        Yukon.createGame(self, rows=10)

    def startGame(self):
        for i in range(1, len(self.s.rows)-1):
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=0, frames=0)
        # self.s.talon.dealRow(rows=self.s.rows, flip=0, frames=0)
        for i in range(5):
            self.s.talon.dealRow(flip=1, frames=0)
        self._startAndDealRow()


class DoubleRussianSolitaire(DoubleYukon):
    RowStack_Class = StackWrapper(Yukon_SS_RowStack, base_rank=KING)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Triple Yukon
# * Triple Russian Solitaire
# ************************************************************************

class TripleYukon(Yukon):
    def createGame(self):
        Yukon.createGame(self, rows=13, playcards=34)

    def startGame(self):
        for i in range(1, len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=0, frames=0)
        for i in range(5):
            self.s.talon.dealRow(rows=self.s.rows, flip=1, frames=0)
        self._startAndDealRow()


class TripleRussianSolitaire(TripleYukon):
    RowStack_Class = StackWrapper(Yukon_SS_RowStack, base_rank=KING)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Ten Across
# ************************************************************************

class TenAcross(Yukon):

    Foundation_Class = Spider_SS_Foundation
    RowStack_Class = StackWrapper(Yukon_SS_RowStack, base_rank=KING)
    Layout_Method = staticmethod(Layout.freeCellLayout)

    #
    # game layout
    #

    def createGame(self, **layout):
        # create layout
        lay, s = Layout(self), self.s
        kwdefault(layout, rows=10, reserves=2, texts=0)
        self.Layout_Method(lay, **layout)
        self.setSize(lay.size[0], lay.size[1])
        # create stacks
        s.talon = InitialDealTalonStack(lay.s.talon.x, lay.s.talon.y, self)
        for r in lay.s.foundations:
            self.s.foundations.append(
                self.Foundation_Class(r.x, r.y, self, suit=r.suit))
        for r in lay.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        for r in lay.s.reserves:
            self.s.reserves.append(ReserveStack(r.x, r.y, self))
        # default
        lay.defaultAll()

    #
    # game overrides
    #

    def startGame(self):
        n = 1
        for i in range(4):
            self.s.talon.dealRow(rows=self.s.rows[:n], frames=0)
            self.s.talon.dealRow(rows=self.s.rows[n:-n], frames=0, flip=0)
            self.s.talon.dealRow(rows=self.s.rows[-n:], frames=0)
            n += 1
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Panopticon
# ************************************************************************

class Panopticon(TenAcross):

    Foundation_Class = SS_FoundationStack

    def createGame(self):
        TenAcross.createGame(self, rows=8, reserves=4)

    def startGame(self):
        self.s.talon.dealRow(frames=0, flip=0)
        n = 1
        for i in range(3):
            self.s.talon.dealRow(rows=self.s.rows[:n], frames=0)
            self.s.talon.dealRow(rows=self.s.rows[n:-n], frames=0, flip=0)
            self.s.talon.dealRow(rows=self.s.rows[-n:], frames=0)
            n += 1
        self.s.talon.dealRow(frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)


# ************************************************************************
# * Australian Patience
# * Raw Prawn
# * Bim Bom
# ************************************************************************

class AustralianPatience(RussianSolitaire):

    RowStack_Class = StackWrapper(Yukon_SS_RowStack, base_rank=KING)

    def createGame(self, rows=7):
        l, s = Layout(self), self.s
        Layout.klondikeLayout(l, rows=rows, waste=1)
        self.setSize(l.size[0], l.size[1])
        s.talon = WasteTalonStack(l.s.talon.x, l.s.talon.y, self, max_rounds=1)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                SS_FoundationStack(r.x, r.y, self, suit=r.suit))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        l.defaultAll()

    def startGame(self):
        self._startDealNumRowsAndDealRowAndCards(3)


class RawPrawn(AustralianPatience):
    RowStack_Class = Yukon_SS_RowStack


class BimBom(AustralianPatience):
    RowStack_Class = Yukon_SS_RowStack

    def createGame(self):
        AustralianPatience.createGame(self, rows=8)

    def startGame(self):
        self._startDealNumRowsAndDealRowAndCards(4)


# ************************************************************************
# * Geoffrey
# ************************************************************************

class Geoffrey(Yukon):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    RowStack_Class = StackWrapper(Yukon_SS_RowStack, base_rank=KING)

    def createGame(self):
        Yukon.createGame(self, rows=8, waste=0)

    def startGame(self):
        for i in (4, 4, 4, 4, 8):
            self.s.talon.dealRow(rows=self.s.rows[:i], flip=1, frames=0)
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.rows[:4])

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Queensland
# ************************************************************************

class Queensland(Yukon):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    RowStack_Class = Yukon_SS_RowStack

    def createGame(self):
        Yukon.createGame(self, waste=0)

    def startGame(self):
        for i in range(1, len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=0, frames=0)
        self._startDealNumRows(3)
        self.s.talon.dealRow()
        self.s.talon.dealRowAvail()

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Russian Spider
# * Double Russian Spider
# ************************************************************************

class RussianSpider_RowStack(Yukon_SS_RowStack):  # Spider_SS_RowStack
    def canDropCards(self, stacks):
        if len(self.cards) < 13:
            return (None, 0)
        cards = self.cards[-13:]
        for s in stacks:
            if s is not self and s.acceptsCards(self, cards):
                return (s, 13)
        return (None, 0)


class RussianSpider(RussianSolitaire):
    RowStack_Class = StackWrapper(RussianSpider_RowStack, base_rank=KING)
    Foundation_Class = Spider_SS_Foundation

    def createGame(self, rows=7):
        # create layout
        l, s = Layout(self), self.s
        l.yukonLayout(rows=rows, texts=0, playcards=25)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self, suit=ANY_SUIT, max_move=0))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        # default
        l.defaultAll()


class DoubleRussianSpider(RussianSpider, DoubleRussianSolitaire):
    def createGame(self):
        RussianSpider.createGame(self, rows=10)

    def startGame(self):
        DoubleRussianSolitaire.startGame(self)


# ************************************************************************
# * Brisbane
# ************************************************************************

class Brisbane_RowStack(Yukon_AC_RowStack):
    def _isSequence(self, c1, c2):
        return (c1.rank + self.cap.dir) % self.cap.mod == c2.rank

    def getHelp(self):
        return _('Tableau. Build down regardless of suit, can move any '
                 'face-up cards regardless of sequence.')


class Brisbane(Yukon):
    RowStack_Class = Brisbane_RowStack

    def startGame(self):
        for i in range(1, len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=0, frames=0)
        self._startDealNumRows(3)
        self.s.talon.dealRow()
        self.s.talon.dealRowAvail()

    def getHighlightPilesStacks(self):
        return ()

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Hawaiian
# ************************************************************************

class Hawaiian(Game):
    Hint_Class = Yukon_Hint

    def createGame(self, rows=10, playcards=20):
        l, s = Layout(self), self.s
        self.setSize(l.XM+max(rows, 8)*l.XS,
                     l.YM+2*l.YS+playcards*l.YOFFSET)
        x, y = l.XM, l.YM
        stack = OpenStack(x, y, self, max_move=1, max_accept=0)
        s.reserves.append(stack)
        l.createText(stack, 'ne')
        x, y = self.width-8*l.XS, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2))
            x += l.XS
        x, y = self.width-rows*l.XS, l.YM+l.YS
        for i in range(rows):
            s.rows.append(Yukon_AC_RowStack(x, y, self))
            x += l.XS
        x, y = l.XM, self.height-l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        l.defaultStackGroups()

    def startGame(self):
        for i in range(104-5*10):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self._startDealNumRowsAndDealSingleRow(4)

    def getHighlightPilesStacks(self):
        return ()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Wave
# ************************************************************************

class WaveTalon(DealRowTalonStack):
    def dealCards(self, sound=False):
        if sound and self.game.app.opt.animations:
            self.game.startDealSample()
        n = self.dealRowAvail(flip=0, sound=False)
        n += self.dealRowAvail(sound=False)
        if sound:
            self.game.stopSamples()
        return n


class Wave(Game):
    Hint_Class = Yukon_Hint

    def createGame(self, rows=8):
        l, s = Layout(self), self.s
        l.klondikeLayout(rows=rows, waste=0, playcards=25)
        self.setSize(l.size[0], l.size[1])
        s.talon = WaveTalon(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(SS_FoundationStack(r.x, r.y, self,
                                                    suit=r.suit))
        for r in l.s.rows:
            s.rows.append(Yukon_AC_RowStack(r.x, r.y, self))
        l.defaultAll()

    def startGame(self):
        self.s.talon.dealRow(frames=0)
        self.s.talon.dealRow(frames=0, flip=0)
        self._startAndDealRow()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# register the game
registerGame(GameInfo(19, Yukon, "Yukon",
                      GI.GT_YUKON, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(20, RussianSolitaire, "Russian Solitaire",
                      GI.GT_YUKON, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(27, Odessa, "Odessa",
                      GI.GT_YUKON, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(278, Grandfather, "Grandfather",
                      GI.GT_YUKON, 1, 2, GI.SL_BALANCED))
registerGame(GameInfo(186, Alaska, "Alaska",
                      GI.GT_YUKON, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(187, ChineseDiscipline, "Chinese Discipline",
                      GI.GT_YUKON | GI.GT_XORIGINAL, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(188, ChineseSolitaire, "Chinese Solitaire",
                      GI.GT_YUKON | GI.GT_XORIGINAL, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(189, Queenie, "Queenie",
                      GI.GT_YUKON | GI.GT_XORIGINAL, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(190, Rushdike, "Rushdike",
                      GI.GT_YUKON | GI.GT_XORIGINAL, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(191, RussianPoint, "Russian Point",
                      GI.GT_YUKON | GI.GT_XORIGINAL, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(192, Abacus, "Abacus",
                      GI.GT_YUKON | GI.GT_XORIGINAL, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(271, DoubleYukon, "Double Yukon",
                      GI.GT_YUKON, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(272, TripleYukon, "Triple Yukon",
                      GI.GT_YUKON, 3, 0, GI.SL_BALANCED))
registerGame(GameInfo(284, TenAcross, "Ten Across",
                      GI.GT_YUKON, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(285, Panopticon, "Panopticon",
                      GI.GT_YUKON | GI.GT_ORIGINAL, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(339, Moosehide, "Moosehide",
                      GI.GT_YUKON, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(387, Roslin, "Roslin",
                      GI.GT_YUKON, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(447, AustralianPatience, "Australian Patience",
                      GI.GT_YUKON, 1, 0, GI.SL_BALANCED,
                      altnames=('Outback Patience',)))
registerGame(GameInfo(450, RawPrawn, "Raw Prawn",
                      GI.GT_YUKON, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(456, BimBom, "Bim Bom",
                      GI.GT_YUKON | GI.GT_ORIGINAL, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(466, DoubleRussianSolitaire, "Double Russian Solitaire",
                      GI.GT_YUKON, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(488, TripleRussianSolitaire, "Triple Russian Solitaire",
                      GI.GT_YUKON, 3, 0, GI.SL_BALANCED))
registerGame(GameInfo(492, Geoffrey, "Geoffrey",
                      GI.GT_YUKON, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(525, Queensland, "Queensland",
                      GI.GT_YUKON, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(530, RussianSpider, "Russian Spider",
                      GI.GT_SPIDER, 1, 0, GI.SL_BALANCED,
                      altnames=('Ukrainian Solitaire',)))
registerGame(GameInfo(531, DoubleRussianSpider, "Double Russian Spider",
                      GI.GT_SPIDER | GI.GT_ORIGINAL, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(603, Brisbane, "Brisbane",
                      GI.GT_SPIDER, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(707, Hawaiian, "Hawaiian",
                      GI.GT_2DECK_TYPE | GI.GT_ORIGINAL, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(732, Wave, "Wave",
                      GI.GT_2DECK_TYPE | GI.GT_ORIGINAL, 2, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.gypsy import \
        DieKoenigsbergerin_Talon, DieRussische_Foundation
from pysollib.layout import Layout
from pysollib.stack import AC_RowStack

# ************************************************************************
# * Die böse Sieben
# ************************************************************************


class DieBoeseSieben_Talon(DieKoenigsbergerin_Talon):
    def canDealCards(self):
        return len(self.cards) or self.round != self.max_rounds

    def dealCards(self, sound=False):
        if self.cards:
            return DieKoenigsbergerin_Talon.dealCards(self, sound=sound)
        game, num_cards = self.game, len(self.cards)
        for r in game.s.rows:
            while r.cards:
                num_cards = num_cards + 1
                if r.cards[-1].face_up:
                    game.flipMove(r)
                game.moveMove(1, r, self, frames=0)
        assert len(self.cards) == num_cards
        if sound:
            game.startDealSample()
        # shuffle
        game.shuffleStackMove(self)
        # redeal
        game.nextRoundMove(self)
        n = len(game.s.rows)
        flip = (num_cards // n) & 1
        while self.cards:
            if len(self.cards) <= n:
                flip = 1
            self.dealRow(flip=flip)
            flip = not flip
        # done
        if sound:
            game.stopSamples()
        return num_cards


class DieBoeseSieben(Game):
    #
    # game layout
    #

    def createGame(self, rows=7):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + max(8, rows)*l.XS, l.YM + 5*l.YS)

        # create stacks
        for i in range(8):
            x, y, = l.XM + i*l.XS, l.YM
            s.foundations.append(
                DieRussische_Foundation(
                    x, y, self, i//2, max_move=0, max_cards=8))
        for i in range(rows):
            x, y, = l.XM + (2*i+8-rows)*l.XS//2, l.YM + l.YS
            s.rows.append(AC_RowStack(x, y, self))
        s.talon = DieBoeseSieben_Talon(
            l.XM, self.height-l.YS, self, max_rounds=2)
        l.createText(s.talon, 'ne')
        l.createRoundText(s.talon, 'se')

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        for flip in (1, 0, 1, 0, 1, 0, 1):
            self.s.talon.dealRow(flip=flip)

    shallHighlightMatch = Game._shallHighlightMatch_AC


# register the game
registerGame(GameInfo(120, DieBoeseSieben, "Bad Seven",
                      GI.GT_2DECK_TYPE, 2, 1, GI.SL_MOSTLY_LUCK,
                      ranks=(0, 6, 7, 8, 9, 10, 11, 12),
                      altnames=("Die boese Sieben",)))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import pysollib.game
from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import AbstractHint, CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.stack import \
        AC_RowStack, \
        AbstractFoundationStack, \
        BasicRowStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        OpenStack, \
        OpenTalonStack, \
        RK_RowStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        StackWrapper, \
        TalonStack, \
        WasteStack, \
        WasteTalonStack, \
        isRankSequence, \
        isSameSuitSequence
from pysollib.util import ACE, ANY_RANK, ANY_SUIT, KING, UNLIMITED_ACCEPTS, \
        UNLIMITED_MOVES

# ************************************************************************
# * Curds and Whey
# * Miss Muffet
# * Nordic
# ************************************************************************


class CurdsAndWhey_RowStack(BasicRowStack):

    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return True
        c1, c2 = self.cards[-1], cards[0]
        if c1.rank == c2.rank:
            return True
        if c1.suit == c2.suit:
            return c1.rank == c2.rank+1
        return False

    def canMoveCards(self, cards):
        return isSameSuitSequence(cards) or isRankSequence(cards, dir=0)

    def getHelp(self):
        return _('Tableau. Build down by suit or of the same rank.')


class CurdsAndWhey(Game):

    Hint_Class = CautiousDefaultHint
    RowStack_Class = StackWrapper(
        CurdsAndWhey_RowStack, base_rank=KING,
        max_move=UNLIMITED_MOVES, max_accept=UNLIMITED_ACCEPTS)

    #
    # game layout
    #

    def createGame(self, rows=13):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+rows*l.XS, l.YM+l.YS+16*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self)
            s.rows.append(stack)
            x += l.XS

        s.talon = InitialDealTalonStack(w-l.XS, h-l.YS, self)

        # default
        l.defaultAll()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(3)

    def isGameWon(self):
        for s in self.s.rows:
            if s.cards:
                if len(s.cards) != 13 or not isSameSuitSequence(s.cards):
                    return False
        return True

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank == card2.rank or (
            card1.suit == card2.suit and abs(card1.rank-card2.rank) == 1)


class MissMuffet(CurdsAndWhey):

    def createGame(self):
        CurdsAndWhey.createGame(self, rows=10)

    def startGame(self):
        self._dealNumRows(4)
        self.s.talon.dealRow(rows=[self.s.rows[0], self.s.rows[-1]], frames=0)
        self._startAndDealRow()


class Nordic(MissMuffet):
    RowStack_Class = StackWrapper(
        CurdsAndWhey_RowStack, base_rank=ANY_RANK,
        max_move=UNLIMITED_MOVES, max_accept=UNLIMITED_ACCEPTS)


# ************************************************************************
# * Dumfries
# * Galloway
# * Robin
# ************************************************************************

class Dumfries_TalonStack(OpenTalonStack):
    rightclickHandler = OpenStack.rightclickHandler
    doubleclickHandler = OpenStack.doubleclickHandler


class Dumfries_RowStack(BasicRowStack):

    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return True
        c1, c2 = self.cards[-1], cards[0]
        if c1.color == c2.color:
            return False
        return c1.rank == c2.rank or c1.rank == c2.rank+1

    def canMoveCards(self, cards):
        return len(cards) == 1 or len(cards) == len(self.cards)


class Dumfries(Game):

    # Hint_Class = KlondikeType_Hint

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=0, texts=1, playcards=20)
        l.klondikeLayout(**layout)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = Dumfries_TalonStack(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(SS_FoundationStack(r.x, r.y, self,
                                                    suit=r.suit))
        for r in l.s.rows:
            s.rows.append(Dumfries_RowStack(r.x, r.y, self,
                                            max_move=UNLIMITED_MOVES,
                                            max_accept=UNLIMITED_ACCEPTS))
        # default
        l.defaultAll()
        self.sg.dropstacks.append(s.talon)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.fillStack()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.color != card2.color and \
            abs(card1.rank-card2.rank) in (0, 1)


class Galloway(Dumfries):
    def createGame(self):
        Dumfries.createGame(self, rows=7)


class Robin(Dumfries):
    def createGame(self):
        Dumfries.createGame(self, rows=12)

# ************************************************************************
# * Arachnida
# * Harvestman
# ************************************************************************


class Arachnida_RowStack(BasicRowStack):

    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return True
        c1, c2 = self.cards[-1], cards[0]
        if c1.rank == c2.rank+1:
            return True
        return c1.rank == c2.rank

    def canMoveCards(self, cards):
        return isSameSuitSequence(cards) or isRankSequence(cards, dir=0)


class Arachnida(CurdsAndWhey):
    RowStack_Class = Arachnida_RowStack

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+12*l.XS, l.YM+l.YS+16*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, "s")
        x += l.XS
        for i in range(10):
            stack = self.RowStack_Class(x, y, self, base_rank=ANY_RANK,
                                        max_move=UNLIMITED_MOVES,
                                        max_accept=UNLIMITED_ACCEPTS)
            s.rows.append(stack)
            x += l.XS
        s.foundations.append(
            AbstractFoundationStack(
                x, y, self, suit=ANY_SUIT,
                max_accept=0, max_cards=104))
        l.createText(s.foundations[0], "s")

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        for i in range(4):
            self.s.talon.dealRow(flip=0, frames=0)
        self.s.talon.dealRow(rows=self.s.rows[:4], flip=0, frames=0)
        self._startAndDealRow()

    def canDealCards(self):
        if not CurdsAndWhey.canDealCards(self):
            return False
        # no row may be empty
        for r in self.s.rows:
            if not r.cards:
                return False
        return True

    def fillStack(self, stack):
        for r in self.s.rows:
            if len(r.cards) >= 13 and isSameSuitSequence(r.cards[-13:]):
                old_state = self.enterState(self.S_FILL)
                self.playSample("drop", priority=200)
                self.moveMove(13, r, self.s.foundations[0])
                self.leaveState(old_state)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank == card2.rank or abs(card1.rank-card2.rank) == 1


class Harvestman(Arachnida):
    RowStack_Class = CurdsAndWhey_RowStack


# ************************************************************************
# * German Patience
# * Bavarian Patience
# ************************************************************************

class GermanPatience(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self, rows=8):

        l, s = Layout(self), self.s

        w, h = l.XM+rows*l.XS, l.YM+2*l.YS+14*l.YOFFSET
        self.setSize(w, h)

        x, y = l.XM, l.YM
        for i in range(rows):
            s.rows.append(
                RK_RowStack(
                    x, y, self, max_cards=13, mod=13, dir=1, max_move=1))
            x += l.XS
        x, y = l.XM, h-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'n')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'n')

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def isGameWon(self):
        if self.s.waste.cards or self.s.talon.cards:
            return False
        for s in self.s.rows:
            if s.cards:
                if len(s.cards) != 13:  # or not isRankSequence(s.cards):
                    return False
        return True

    shallHighlightMatch = Game._shallHighlightMatch_RKW


class BavarianPatience(GermanPatience):
    def createGame(self, rows=10):
        GermanPatience.createGame(self, rows=10)


# ************************************************************************
# * Trusty Twelve
# * Knotty Nines
# * Sweet Sixteen
# ************************************************************************

class TrustyTwelve_Hint(AbstractHint):
    def computeHints(self):
        game = self.game
        for r in game.s.rows:
            for t in game.s.rows:
                if r is t:
                    continue
                card = r.cards[-1]
                if len(r.cards) == 1 and t.acceptsCards(r, [card]):
                    if len(t.cards) > 1:
                        self.addHint(6000+card.rank, 1, r, t)
                    else:
                        self.addHint(5000+card.rank, 1, r, t)


class TrustyTwelve(Game):
    Hint_Class = TrustyTwelve_Hint

    def createGame(self, rows=12):
        l, s = Layout(self), self.s
        self.setSize(l.XM+(rows+1)*l.XS, l.YM+l.YS+12*l.YOFFSET)
        x, y = l.XM, l.YM
        s.talon = TalonStack(x, y, self)
        l.createText(s.talon, "s")
        x += l.XS
        for i in range(rows):
            s.rows.append(RK_RowStack(x, y, self, max_move=1))
            x += l.XS
        l.defaultStackGroups()

    def startGame(self):
        self._startAndDealRow()

    def fillStack(self, stack):
        if not stack.cards and stack in self.s.rows:
            if self.s.talon.cards:
                old_state = self.enterState(self.S_FILL)
                self.s.talon.flipMove()
                self.s.talon.moveMove(1, stack)
                self.leaveState(old_state)

    def isGameWon(self):
        return len(self.s.talon.cards) == 0

    shallHighlightMatch = Game._shallHighlightMatch_RK


class KnottyNines(TrustyTwelve):
    def createGame(self):
        TrustyTwelve.createGame(self, rows=9)


class SweetSixteen(TrustyTwelve):

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+9*l.XS, l.YM+2*l.YS+20*l.YOFFSET)
        x, y = l.XM, l.YM
        s.talon = TalonStack(x, y, self)
        l.createText(s.talon, "s")
        y = l.YM
        for i in range(2):
            x = l.XM+l.XS
            for j in range(8):
                s.rows.append(AC_RowStack(x, y, self, max_move=1))
                x += l.XS
            y += l.YS+10*l.YOFFSET
        l.defaultStackGroups()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Glacier
# ************************************************************************

class Glacier(pysollib.game.StartDealRowAndCards, Game):

    def createGame(self, rows=12):
        l, s = Layout(self), self.s
        self.setSize(l.XM+rows*l.XS, l.YM+2*l.YS+l.TEXT_HEIGHT+20*l.YOFFSET)

        x, y = l.XM+(rows-4)//2*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                 mod=13, max_cards=26))
            x += l.XS
        x, y = l.XM, l.YM+l.YS+l.TEXT_HEIGHT
        for i in range(rows):
            s.rows.append(RK_RowStack(x, y, self, mod=13))
            x += l.XS
        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, num_deal=2, max_rounds=1)
        l.createText(s.talon, 's')
        x = x + l.XS
        s.waste = WasteStack(x, y, self, max_cards=2)
        s.waste.CARD_XOFFSET = l.XOFFSET

        l.defaultStackGroups()

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# ************************************************************************
# * Eight Packs (ex. Four Packs)
# * Four Packs
# ************************************************************************

class EightPacks(Game):
    RowStack_Class = SS_RowStack

    def createGame(self, max_rounds=3, width=10, playcards=14):
        l, s = Layout(self), self.s
        self.setSize(l.XM+width*l.XS,
                     l.YM+2*l.YS+l.TEXT_HEIGHT+playcards*l.YOFFSET)

        x, y = l.XM, l.YM
        for i in range(10):
            s.rows.append(self.RowStack_Class(x, y, self, dir=1))
            x += l.XS

        x, y = self.width-l.XS, self.height-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=max_rounds)
        l.createText(s.talon, 'n')
        l.createRoundText(s.talon, 'nnn')

        x -= l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'n')

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def isGameWon(self):
        if self.s.talon.cards or self.s.waste.cards:
            return False
        for s in self.s.rows:
            if s.cards:
                if len(s.cards) != 13:
                    return False
        return True

    shallHighlightMatch = Game._shallHighlightMatch_SS


class FourPacks_RowStack(SS_RowStack):
    def canMoveCards(self, cards):
        if not self.basicCanMoveCards(cards):
            return False
        return len(cards) == len(self.cards)


class FourPacks(EightPacks):
    RowStack_Class = StackWrapper(FourPacks_RowStack, mod=13)

    def createGame(self):
        EightPacks.createGame(self, max_rounds=2, width=12, playcards=18)

    def isGameWon(self):
        if self.s.talon.cards or self.s.waste.cards:
            return False
        for s in self.s.rows:
            if s.cards:
                if s.cards[0].rank != ACE:
                    return False
                if len(s.cards) != 26:
                    return False
        return True


# register the game
registerGame(GameInfo(294, CurdsAndWhey, "Curds and Whey",
                      GI.GT_SPIDER | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(311, Dumfries, "Dumfries",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(312, Galloway, "Galloway",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(313, Robin, "Robin",
                      GI.GT_2DECK_TYPE | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(348, Arachnida, "Arachnida",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(349, MissMuffet, "Miss Muffet",
                      GI.GT_SPIDER | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(352, Nordic, "Nordic",
                      GI.GT_SPIDER | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(414, GermanPatience, "German Patience",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(415, BavarianPatience, "Bavarian Patience",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(480, TrustyTwelve, "Trusty Twelve",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(481, KnottyNines, "Knotty Nines",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(482, SweetSixteen, "Sweet Sixteen",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(534, Harvestman, "Harvestman",
                      GI.GT_SPIDER | GI.GT_ORIGINAL, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(687, Glacier, "Glacier",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(724, EightPacks, "Eight Packs",
                      GI.GT_2DECK_TYPE | GI.GT_ORIGINAL, 2, 2,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(762, FourPacks, "Four Packs",
                      GI.GT_2DECK_TYPE, 2, 1, GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import pysollib.game
from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.golf import BlackHole_Foundation
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        AC_RowStack, \
        RK_FoundationStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        Stack, \
        StackWrapper, \
        UD_RK_RowStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, ANY_SUIT, KING, UNLIMITED_CARDS

# ************************************************************************
# *
# ************************************************************************


class Windmill_Foundation(RK_FoundationStack):
    def getBottomImage(self):
        if self.cap.base_rank == ACE:
            return self.game.app.images.getLetter(ACE)
        return RK_FoundationStack.getBottomImage(self)


class Windmill_RowStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        # this stack accepts one card from the Waste pile
        return from_stack is self.game.s.waste


# ************************************************************************
# * Windmill
# * Dutch Solitaire
# ************************************************************************

class Windmill(Game):

    Foundation_Classes = [
        StackWrapper(Windmill_Foundation, mod=13, min_cards=1, max_cards=52),
        StackWrapper(Windmill_Foundation, base_rank=KING, dir=-1),
        ]
    RowStack_Class = Windmill_RowStack

    FOUNDATIONS_LAYOUT = ((1, 0.6), (3, 0.6), (1, 3.4), (3, 3.4))
    ROWS_LAYOUT = ((2, 0), (2, 1), (0, 2), (1, 2), (3, 2), (4, 2),
                   (2, 3), (2, 4))
    FILL_STACK = True

    #
    # game layout
    #

    def createGame(self, card_x_space=20):
        # create layout
        l, s = Layout(self, card_x_space=card_x_space), self.s

        # set window
        max_x = max([i[0] for i in self.FOUNDATIONS_LAYOUT+self.ROWS_LAYOUT])
        max_y = max([i[1] for i in self.FOUNDATIONS_LAYOUT+self.ROWS_LAYOUT])
        self.setSize((3+max_x)*l.XS+l.XM, (1+max_y)*l.YS+l.YM+l.YM)

        # create stacks
        x = l.XM
        y = l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "s")
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")
        x0, y0 = x + l.XS, y
        for d in self.ROWS_LAYOUT:
            x, y = x0 + d[0] * l.XS, y0 + d[1] * l.YS
            stack = self.RowStack_Class(x, y, self)
            s.rows.append(stack)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
        x, y = x0 + 2 * l.XS, y0 + 2 * l.YS
        fnd_cls = self.Foundation_Classes[0]
        s.foundations.append(fnd_cls(x, y, self))
        fnd_cls = self.Foundation_Classes[1]
        for d in self.FOUNDATIONS_LAYOUT:
            x, y = x0 + d[0] * l.XS, y0 + d[1] * l.YS
            s.foundations.append(fnd_cls(x, y, self))

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        for c in cards:
            if c.id == 0:
                break
        cards.remove(c)
        return cards + [c]

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=(self.s.foundations[0],))
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack

    def fillStack(self, stack):
        if self.FILL_STACK and len(stack.cards) == 0:
            if stack is self.s.waste and self.s.talon.cards:
                self.s.talon.dealCards()
            elif stack in self.s.rows and self.s.waste.cards:
                self.s.waste.moveMove(1, stack)

    shallHighlightMatch = Game._shallHighlightMatch_RK

    def getHighlightPilesStacks(self):
        return ()

    def getAutoStacks(self, event=None):
        # disable auto drop - this would ruin the whole gameplay
        return ((), (), ())


class DutchSolitaire_RowStack(UD_RK_RowStack):
    getBottomImage = Stack._getReserveBottomImage


class DutchSolitaire(Windmill):
    Hint_Class = CautiousDefaultHint
    Foundation_Classes = [
        StackWrapper(BlackHole_Foundation, suit=ANY_SUIT, mod=13,
                     max_cards=UNLIMITED_CARDS, min_cards=1),
        StackWrapper(BlackHole_Foundation, suit=ANY_SUIT, mod=13,
                     max_cards=UNLIMITED_CARDS, min_cards=1),
        ]
    RowStack_Class = DutchSolitaire_RowStack

    FOUNDATIONS_LAYOUT = ((1, 1), (3, 1), (1, 3), (3, 3))
    ROWS_LAYOUT = ((2, 0.5), (-0.5, 2), (0.5, 2), (3.5, 2), (4.5, 2), (2, 3.5))
    FILL_STACK = False

    def createGame(self):
        Windmill.createGame(self, card_x_space=10)

    def _shuffleHook(self, cards):
        # move 5 Aces to top of the Talon (i.e. first cards to be dealt)
        def select_cards(c):
            if c.rank == ACE:
                if c.suit in (0, 1):
                    return True, c.suit
                if c.suit == 3 and c.deck == 0:
                    return True, c.suit
            return False, None
        return self._shuffleHookMoveToTop(cards, select_cards)

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startDealNumRows(8)
        self.s.talon.dealRow()
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack

    def getAutoStacks(self, event=None):
        return (self.sg.dropstacks, self.sg.dropstacks, self.sg.dropstacks)


# ************************************************************************
# * Napoleon's Tomb
# ************************************************************************

class NapoleonsTomb(pysollib.game.StartDealRowAndCards, Game):

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self, card_x_space=20, card_y_space=20), self.s

        # set window
        self.setSize(5*l.XS+l.XM, 3*l.YS+l.YM+l.YM)

        # create stacks
        x = l.XM
        y = l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "s")
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")
        x0, y0 = x + l.XS, y
        for d in ((0, 1), (1, 0), (1, 2), (2, 1)):
            x, y = x0 + d[0] * l.XS, y0 + d[1] * l.YS
            s.rows.append(Windmill_RowStack(x, y, self))
        x, y = x0 + l.XS, y0 + l.YS
        s.foundations.append(Windmill_Foundation(x, y, self, base_rank=5,
                             mod=13, max_cards=24, dir=-1))
        for d in ((0.1, 0.1), (1.9, 0.1), (0.1, 1.9), (1.9, 1.9)):
            x, y = x0 + d[0] * l.XS, y0 + d[1] * l.YS
            s.foundations.append(Windmill_Foundation(x, y, self,
                                 max_cards=7, base_rank=6, mod=13))

        # define stack-groups
        l.defaultStackGroups()


# ************************************************************************
# * Corners
# ************************************************************************

class Corners(Game):
    RowStack_Class = ReserveStack

    def createGame(self, max_rounds=3):
        # create layout
        l, s = Layout(self, card_x_space=20, card_y_space=20), self.s

        # set window
        self.setSize(5*l.XS+l.XM, 4*l.YS+3*l.YM)

        # create stacks
        x, y = l.XM+1.5*l.XS, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=max_rounds)
        l.createText(s.talon, "sw")
        if max_rounds > 1:
            l.createRoundText(self.s.talon, 'nw')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "se")
        x0, y0 = l.XM, l.YM+l.YS
        i = 0
        for d in ((0, 0), (4, 0), (0, 2), (4, 2)):
            x, y = x0+d[0]*l.XS, y0+d[1]*l.YS
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                    max_move=0, mod=13))
            i += 1
        for d in ((2, 0), (1, 1), (2, 1), (3, 1), (2, 2)):
            x, y = x0+d[0]*l.XS, y0+d[1]*l.YS
            stack = self.RowStack_Class(x, y, self)
            s.rows.append(stack)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0

        # define stack-groups
        l.defaultStackGroups()

    def fillStack(self, stack):
        if len(stack.cards) == 0:
            if stack is self.s.waste and self.s.talon.cards:
                self.s.talon.dealCards()
            elif stack in self.s.rows and self.s.waste.cards:
                self.s.waste.moveMove(1, stack)

    def _shuffleHook(self, cards):
        suits = []
        top_cards = []
        for c in cards[:]:
            if c.suit not in suits:
                suits.append(c.suit)
                cards.remove(c)
                top_cards.append(c)
                if len(suits) == 4:
                    break
        top_cards = sorted(top_cards, key=lambda x: -x.suit)
        return cards+top_cards

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack


# ************************************************************************
# * Czarina
# * Four Seasons
# * Florentine Patience
# ************************************************************************

class Czarina_RowStack(RK_RowStack):
    getBottomImage = Stack._getReserveBottomImage


class Czarina(Corners):
    Hint_Class = CautiousDefaultHint
    RowStack_Class = StackWrapper(Czarina_RowStack, mod=13, max_move=1)

    def createGame(self, max_rounds=1):
        # extra settings
        self.base_card = None
        Corners.createGame(self, max_rounds=max_rounds)

    def startGame(self):
        self.startDealSample()
        self.base_card = None
        # deal base_card to Foundations, update foundations cap.base_rank
        self.base_card = self.s.talon.getCard()
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, self.s.foundations[self.base_card.suit])
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first 3 cards to WasteStack

    def _shuffleHook(self, cards):
        return cards

    shallHighlightMatch = Game._shallHighlightMatch_RKW

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)


class FourSeasons(Czarina):
    def fillStack(self, stack):
        pass


class FlorentinePatience(FourSeasons):
    def createGame(self):
        Czarina.createGame(self, max_rounds=2)


# ************************************************************************
# * Simplicity
# ************************************************************************

class Simplicity(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self, max_rounds=2):

        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+4*l.YS)

        self.base_card = None

        i = 0
        for x, y in ((l.XM,        l.YM),
                     (l.XM+7*l.XS, l.YM),
                     (l.XM,        l.YM+3*l.YS),
                     (l.XM+7*l.XS, l.YM+3*l.YS),
                     ):
            s.foundations.append(
                SS_FoundationStack(x, y, self, suit=i, mod=13))
            i += 1
        y = l.YM+l.YS
        for i in range(2):
            x = l.XM+l.XS
            for j in range(6):
                stack = AC_RowStack(x, y, self, max_move=1, mod=13)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
                s.rows.append(stack)
                x += l.XS
            y += l.YS
        x, y = l.XM+3*l.XS, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'sw')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'se')

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        # deal base_card to Foundations, update foundations cap.base_rank
        self.base_card = self.s.talon.getCard()
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, self.s.foundations[self.base_card.suit])
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_ACW

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)


# register the game
registerGame(GameInfo(30, Windmill, "Windmill",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(277, NapoleonsTomb, "Napoleon's Tomb",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(417, Corners, "Corners",
                      GI.GT_1DECK_TYPE, 1, 2, GI.SL_MOSTLY_LUCK,
                      rules_filename='fourseasons.html'))
registerGame(GameInfo(437, Simplicity, "Simplicity",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_LUCK,
                      rules_filename='fourseasons.html'))
registerGame(GameInfo(483, Czarina, "Czarina",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_LUCK,
                      rules_filename='fourseasons.html'))
registerGame(GameInfo(484, FourSeasons, "Four Seasons",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_LUCK,
                      altnames=('Corner Card', 'Vanishing Cross')))
registerGame(GameInfo(561, DutchSolitaire, "Dutch Solitaire",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(696, FlorentinePatience, "Florentine Patience",
                      GI.GT_1DECK_TYPE, 1, 1, GI.SL_MOSTLY_LUCK))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.gypsy import DieRussische_Foundation
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        AC_RowStack, \
        InitialDealTalonStack, \
        RK_FoundationStack, \
        RedealTalonStack, \
        SS_FoundationStack, \
        StackWrapper, \
        UD_SS_RowStack
from pysollib.util import ANY_SUIT, KING


# ************************************************************************
# * Capricieuse
# ************************************************************************

class Capricieuse(Game):
    Hint_Class = CautiousDefaultHint
    Talon_Class = StackWrapper(RedealTalonStack, max_rounds=3)
    RowStack_Class = UD_SS_RowStack

    #
    # game layout
    #

    def createGame(self, rows=12, round_text=True):

        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+rows*l.XS, l.YM+2*l.YS+15*l.YOFFSET)

        # create stacks
        x, y, = l.XM+(rows-8)*l.XS//2, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                    base_rank=KING, dir=-1))
            x += l.XS
        x, y, = l.XM, y + l.YS
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self,
                                              max_move=1, max_accept=1))
            x += l.XS
        s.talon = self.Talon_Class(l.XM, l.YM, self)
        if round_text:
            l.createRoundText(self.s.talon, 'ne')

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(7)
        self.s.talon.dealRow()
        self.s.talon.dealRow(self.s.foundations)

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToBottom(
            cards,
            lambda c: (c.deck == 0 and c.rank in (0, 12), (c.rank, c.suit)), 8)

    def redealCards(self):
        while self.s.talon.cards:
            self.s.talon.dealRowAvail(frames=4)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Nationale
# ************************************************************************

class Nationale(Capricieuse):
    Talon_Class = InitialDealTalonStack
    RowStack_Class = StackWrapper(UD_SS_RowStack, mod=13)

    def createGame(self):
        Capricieuse.createGame(self, round_text=False)

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * Strata
# ************************************************************************

class Strata(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+9*l.XS, l.YM+2*l.YS+12*l.YOFFSET)

        # create stacks
        x, y, = l.XM+l.XS, l.YM
        for i in range(8):
            s.foundations.append(DieRussische_Foundation(x, y, self,
                                 suit=i % 4, max_cards=8))
            x += l.XS
        x, y, = l.XM+l.XS, l.YM+l.YS
        for i in range(8):
            s.rows.append(AC_RowStack(x, y, self, max_move=1, max_accept=1))
            x += l.XS
        s.talon = RedealTalonStack(l.XM, l.YM+l.YS//2, self, max_rounds=3)
        l.createRoundText(s.talon, 'nn')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(7)

    def redealCards(self):
        while self.s.talon.cards:
            self.s.talon.dealRowAvail(frames=4)

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Fifteen
# ************************************************************************

class Fifteen(Capricieuse):
    Talon_Class = InitialDealTalonStack

    def createGame(self):
        Capricieuse.createGame(self, rows=15, round_text=False)

    def startGame(self):
        self._startDealNumRows(6)
        self.s.talon.dealRowAvail()

    def _shuffleHook(self, cards):
        return cards


# ************************************************************************
# * Choice
# ************************************************************************

class Choice_Foundation(RK_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # check the suit
        num_cards = len(self.cards)
        for f in self.game.s.foundations:
            if len(f.cards) > num_cards:
                suit = f.cards[num_cards].suit
                break
        else:
            return True
        return cards[0].suit == suit


class Choice(Game):

    def createGame(self, rows=8, playcards=16):
        # create layout
        l, s = Layout(self), self.s

        # set window
        decks = self.gameinfo.decks
        max_rows = max(8, rows)
        self.setSize(l.XM + max_rows*l.XS,
                     l.YM + 2*l.YS + (playcards+4*decks)*l.YOFFSET)

        # create stacks
        x, y = l.XM + (max_rows-8)*l.XS//2, l.YM
        for i in range(8):
            stack = Choice_Foundation(x, y, self, base_rank=(i+5), dir=0,
                                      suit=ANY_SUIT, max_cards=(4*decks))
            stack.CARD_YOFFSET = l.YOFFSET
            s.foundations.append(stack)
            x += l.XS

        x = l.XM + (max_rows-rows)*l.XS//2
        y = l.YM + l.YS + (4*decks)*l.YOFFSET
        for i in range(rows):
            s.rows.append(AC_RowStack(x, y, self))
            x += l.XS

        x, y = self.width - l.XS, self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        for i in range(11):
            self.s.talon.dealRowAvail(frames=0)
        self.startDealSample()
        self.s.talon.dealRowAvail()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# register the game
registerGame(GameInfo(292, Capricieuse, "Capricieuse",
                      GI.GT_BAKERS_DOZEN | GI.GT_OPEN, 2, 2,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(293, Nationale, "Nationale",
                      GI.GT_BAKERS_DOZEN | GI.GT_OPEN, 2, 0,
                      GI.SL_MOSTLY_SKILL,
                      altnames=('Zigzag Course',)))
registerGame(GameInfo(606, Strata, "Strata",
                      GI.GT_BAKERS_DOZEN | GI.GT_OPEN, 2, 2,
                      GI.SL_MOSTLY_SKILL,
                      ranks=(0, 6, 7, 8, 9, 10, 11, 12),
                      altnames=('Persian Patience',)))
registerGame(GameInfo(673, Fifteen, "Fifteen",
                      GI.GT_BAKERS_DOZEN | GI.GT_OPEN, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(755, Choice, "Choice",
                      GI.GT_3DECK_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL, 3, 0,
                      GI.SL_MOSTLY_SKILL,
                      ranks=(5, 6, 7, 8, 9, 10, 11, 12)))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.braid import Braid_Foundation
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        BasicRowStack, \
        InitialDealTalonStack, \
        ReserveStack, \
        SS_FoundationStack, \
        Stack, \
        StackWrapper, \
        UD_SS_RowStack
from pysollib.util import ACE, KING, RANKS, UNLIMITED_CARDS


# ************************************************************************
# * stacks
# ************************************************************************


class Napoleon_RowStack(UD_SS_RowStack):
    getBottomImage = Stack._getReserveBottomImage


class Napoleon_ReserveStack(BasicRowStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=1, max_accept=0)
        BasicRowStack.__init__(self, x, y, game, **cap)


class Napoleon_SingleFreeCell(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        #         if from_stack.id >= 8:
        #             # from_stack must be a Napoleon_RowStack
        #             return False
        return ReserveStack.acceptsCards(self, from_stack, cards)

    def canMoveCards(self, cards):
        if self.game.s.rows[8].cards and self.game.s.rows[9].cards:
            return False
        return ReserveStack.canMoveCards(self, cards)


class Napoleon_FreeCell(ReserveStack):
    def canMoveCards(self, cards):
        if self.game.s.rows[self.id-2].cards:
            return False
        return ReserveStack.canMoveCards(self, cards)


# ************************************************************************
# * Der kleine Napoleon
# ************************************************************************

class DerKleineNapoleon(Game):

    Hint_Class = CautiousDefaultHint
    Foundation_Class = Braid_Foundation
    RowStack_Class = StackWrapper(Napoleon_RowStack, mod=13)

    #
    # game layout
    #

    def createGame(self, cells=1):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 2*24 + 2*l.XM + 11*l.XS, l.YM + 5*l.YS + 2*l.XM)
        x0 = l.XM + 24 + 4*l.XS
        x1 = x0 + l.XS + l.XM
        x2 = x1 + l.XS + l.XM

        # create stacks
        y = l.YM
        for i in range(4):
            s.rows.append(self.RowStack_Class(x0, y, self))
            s.rows.append(self.RowStack_Class(x2, y, self))
            y = y + l.YS
        y = self.height - l.YS
        if cells == 1:
            s.rows.append(Napoleon_ReserveStack(x0, y, self))
            s.rows.append(Napoleon_ReserveStack(x2, y, self))
            s.reserves.append(Napoleon_SingleFreeCell(x1, y, self))
        else:
            s.rows.append(Napoleon_ReserveStack(x0 - l.XS, y, self))
            s.rows.append(Napoleon_ReserveStack(x2 + l.XS, y, self))
            s.reserves.append(Napoleon_FreeCell(x0, y, self))
            s.reserves.append(Napoleon_FreeCell(x2, y, self))
        # foundations
        x, y = x1, l.YM
        for i in range(4):
            s.foundations.append(self.Foundation_Class(x, y, self, i))
            y = y + l.YS
        # talon
        if cells == 1:
            # x, y = l.XM, self.height - l.YS
            y = self.height + l.YS
        else:
            y = self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # update stack building direction
        for r in s.rows:
            if r.id & 1 == 0:
                r.CARD_XOFFSET = 4*[-l.XS] + 13*[-2]
            else:
                r.CARD_XOFFSET = 4*[l.XS] + 13*[2]
            r.CARD_YOFFSET = 0

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        # move 4 cards of the same rank to bottom of the Talon (i.e.
        #   last cards to be dealt)
        rank = cards[-1].rank
        return self._shuffleHookMoveToBottom(
            cards, lambda c, rank=rank: (c.rank == rank, c.suit))

    def startGame(self):
        for i in range(4):
            self.s.talon.dealRow(rows=self.s.rows[:8], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:8])
        for i in range(4):
            self.s.talon.dealRow(rows=self.s.rows[8:])
        self.s.talon.dealBaseCards(ncards=4)

    shallHighlightMatch = Game._shallHighlightMatch_SSW

    #
    # game extras
    #

    def updateText(self):
        if self.preview > 1 or not self.texts.info:
            return
        t = ""
        f = self.s.foundations[0]
        if f.cards:
            t = RANKS[f.cards[0].rank]
            dir = self.getFoundationDir()
            if dir == 1:
                t = t + _(" Ascending")
            elif dir == -1:
                t = t + _(" Descending")
        self.texts.info.config(text=t)


# ************************************************************************
# * Der freie Napoleon (completely equivalent to Der kleine Napoleon,
# * just a different layout)
# ************************************************************************

class DerFreieNapoleon(DerKleineNapoleon):

    Foundation_Class = Braid_Foundation
    RowStack_Class = StackWrapper(Napoleon_RowStack, mod=13)
    ReserveStack_Class = Napoleon_ReserveStack
    FreeCell_Class = Napoleon_SingleFreeCell

    #
    # game layout
    #

    def createGame(self, cells=1, reserves=2, texts=True):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # set size so that at least 2/3 of a card is visible with 15 cards
        h = l.CH*2//3 + (15-1)*l.YOFFSET
        h = l.YS + max(h, 3*l.YS)
        max_rows = 8+max(cells, reserves)
        self.setSize(l.XM + 2*l.XM + max_rows*l.XS, l.YM + h)
        x1 = l.XM + 8*l.XS + 2*l.XM

        # create stacks
        y = l.YM + l.YS
        for j in range(8):
            x = l.XM + j*l.XS
            s.rows.append(self.RowStack_Class(x, y, self))
        for j in range(reserves):
            x = x1 + j*l.XS
            s.rows.append(self.ReserveStack_Class(x, y, self))
        self.setRegion(s.rows, (-999, y - l.CH//2, 999999, 999999))
        y = l.YM
        x = x1+(max(cells, reserves)-cells)*l.XS//2
        for i in range(cells):
            s.reserves.append(self.FreeCell_Class(x, y, self))
            x += l.XS
        # foundations
        x = l.XM + 2*l.XS
        for i in range(4):
            s.foundations.append(self.Foundation_Class(x, y, self, i))
            x = x + l.XS
        if texts:
            tx, ty, ta, tf = l.getTextAttr(s.foundations[-1], "se")
            font = self.app.getFont("canvas_default")
            self.texts.info = MfxCanvasText(self.canvas, tx, ty, anchor=ta,
                                            font=font)
        # talon
        x, y = l.XM, self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()


# ************************************************************************
# * Napoleon (two FreeCells instead of one SingleFreeCell)
# ************************************************************************

class Napoleon(DerKleineNapoleon):
    def createGame(self):
        DerKleineNapoleon.createGame(self, cells=2)


class FreeNapoleon(DerFreieNapoleon):
    FreeCell_Class = Napoleon_FreeCell

    def createGame(self):
        DerFreieNapoleon.createGame(self, cells=2)


# ************************************************************************
# * Master
# ************************************************************************

class Master(DerFreieNapoleon):

    Foundation_Class = SS_FoundationStack

    def createGame(self):
        DerFreieNapoleon.createGame(self, cells=2, texts=False)

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToBottom(cards,
                                             lambda c: (c.rank == ACE, c.suit))


# ************************************************************************
# * The Little Corporal
# * Bonaparte
# ************************************************************************

class TheLittleCorporal_RowStack(UD_SS_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not UD_SS_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack in self.game.s.reserves:
            return not self.cards
        return True


class TheLittleCorporal(DerFreieNapoleon):

    def createGame(self, rows=10):
        l, s = Layout(self), self.s
        # set size so that at least 2/3 of a card is visible with 15 cards
        h = l.CH*2//3 + (15-1)*l.YOFFSET
        h = l.YS + max(h, 3*l.YS)
        self.setSize(l.XM+rows*l.XS, l.YM + h)

        x, y = l.XM+(rows-8)*l.XS, l.YM
        for i in range(4):
            s.foundations.append(Braid_Foundation(x, y, self, suit=i))
            x += l.XS
        tx, ty, ta, tf = l.getTextAttr(s.foundations[-1], "se")
        font = self.app.getFont("canvas_default")
        self.texts.info = MfxCanvasText(
            self.canvas, tx, ty, anchor=ta, font=font)
        x += 2*l.XS
        stack = ReserveStack(x, y, self, max_cards=UNLIMITED_CARDS)
        s.reserves.append(stack)
        l.createText(stack, 'se')
        x, y = l.XM, l.YM+l.YS
        for i in range(rows):
            s.rows.append(TheLittleCorporal_RowStack(x, y, self, mod=13))
            x += l.XS

        # talon
        x, y = l.XM, self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        for i in range(4):
            self.s.talon.dealRow(rows=self.s.rows, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[1:-1])
        self.s.talon.dealBaseCards(ncards=4)

    def getQuickPlayScore(self, ncards, from_stack, to_stack):
        if to_stack in self.s.reserves:
            return 0
        return int(len(to_stack.cards) != 0)+1


class Bonaparte(TheLittleCorporal):

    def createGame(self):
        TheLittleCorporal.createGame(self, rows=8)

    def startGame(self):
        self._startDealNumRows(5)
        self.s.talon.dealRow()
        self.s.talon.dealBaseCards(ncards=4)


# ************************************************************************
# * Busy Cards
# ************************************************************************

class BusyCards_FreeCell(ReserveStack):
    def canMoveCards(self, cards):
        if not ReserveStack.canMoveCards(self, cards):
            return False
        rows = self.game.s.rows
        index = list(self.game.s.reserves).index(self)
        if rows[2*index].cards or rows[2*index+1].cards:
            return False
        return True


class BusyCards(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):
        rows = 12

        l, s = Layout(self), self.s
        self.setSize(l.XM+rows*l.XS, l.YM + 3*l.YS+16*l.YOFFSET)

        x, y = l.XM+(rows-8)*l.XS//2, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                 base_rank=KING, dir=-1))
            x += l.XS

        x, y = l.XM+l.XS//2, l.YM+l.YS
        for i in range(rows//2):
            s.reserves.append(BusyCards_FreeCell(x, y, self))
            x += 2*l.XS

        x, y = l.XM, l.YM+2*l.YS
        for i in range(rows):
            s.rows.append(UD_SS_RowStack(x, y, self))
            x += l.XS

        x, y = l.XM, self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: ((c.rank in (ACE, KING) and c.deck == 0),
                       (c.rank, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startDealNumRowsAndDealSingleRow(7)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# register the game
registerGame(GameInfo(167, DerKleineNapoleon, "Der kleine Napoleon",
                      GI.GT_NAPOLEON | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(168, DerFreieNapoleon, "Der freie Napoleon",
                      GI.GT_NAPOLEON | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(169, Napoleon, "Napoleon",
                      GI.GT_NAPOLEON | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(170, FreeNapoleon, "Free Napoleon",
                      GI.GT_NAPOLEON | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(536, Master, "Master",
                      GI.GT_NAPOLEON | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(537, TheLittleCorporal, "The Little Corporal",
                      GI.GT_NAPOLEON | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(538, Bonaparte, "Bonaparte",
                      GI.GT_NAPOLEON | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(705, BusyCards, "Busy Cards",
                      GI.GT_NAPOLEON | GI.GT_OPEN | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AC_RowStack, \
        KingAC_RowStack, \
        OpenStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import KING, QUEEN, RANKS, UNLIMITED_REDEALS


class Canfield_Hint(CautiousDefaultHint):
    # FIXME: demo is not too clever in this game

    # Score for moving a pile (usually a single card) from the WasteStack.
    def _getMoveWasteScore(self, score, color, r, t, pile, rpile):
        score, color = CautiousDefaultHint._getMovePileScore(
            self, score, color, r, t, pile, rpile)
        # we prefer moving cards from the waste over everything else
        return score + 100000, color


# ************************************************************************
# * a Canfield row stack only accepts a full other row stack
# * (cannot move part of a sequence from row to row)
# ************************************************************************

class Canfield_AC_RowStack(AC_RowStack):
    def basicAcceptsCards(self, from_stack, cards):
        if from_stack in self.game.s.rows:
            if len(cards) != 1 and len(cards) != len(from_stack.cards):
                return False
        return AC_RowStack.basicAcceptsCards(self, from_stack, cards)


class Canfield_SS_RowStack(SS_RowStack):
    def basicAcceptsCards(self, from_stack, cards):
        if from_stack in self.game.s.rows:
            if len(cards) != 1 and len(cards) != len(from_stack.cards):
                return False
        return SS_RowStack.basicAcceptsCards(self, from_stack, cards)


class Canfield_RK_RowStack(RK_RowStack):
    def basicAcceptsCards(self, from_stack, cards):
        if from_stack in self.game.s.rows:
            if len(cards) != 1 and len(cards) != len(from_stack.cards):
                return False
        return RK_RowStack.basicAcceptsCards(self, from_stack, cards)


# ************************************************************************
# * Canfield
# ************************************************************************

class Canfield(Game):
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = StackWrapper(Canfield_AC_RowStack, mod=13)
    ReserveStack_Class = OpenStack
    Hint_Class = Canfield_Hint

    INITIAL_RESERVE_CARDS = 13
    INITIAL_RESERVE_FACEUP = 0
    FILL_EMPTY_ROWS = 1

    #
    # game layout
    #

    def createGame(self, rows=4, max_rounds=-1, num_deal=3,
                   text=True, round_text=False):
        # create layout
        lay, s = Layout(self), self.s
        decks = self.gameinfo.decks

        # set window
        if self.INITIAL_RESERVE_FACEUP == 1:
            yoffset = lay.YOFFSET  # min(lay.YOFFSET, 14)
        else:
            yoffset = 10
            if self.INITIAL_RESERVE_CARDS > 30:
                yoffset = 5
        # (piles up to 20 cards are playable in default window size)
        h = max(3*lay.YS, lay.YS+self.INITIAL_RESERVE_CARDS*yoffset)
        if round_text:
            h += lay.TEXT_HEIGHT
        self.setSize(
            lay.XM + (2+max(rows, 4*decks))*lay.XS + lay.XM,
            lay.YM + lay.YS + lay.TEXT_HEIGHT + h)

        # extra settings
        self.base_card = None

        # create stacks
        x, y = lay.XM, lay.YM
        s.talon = self.Talon_Class(x, y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        lay.createText(s.talon, "s")
        if round_text:
            lay.createRoundText(s.talon, 'sss')
        x += lay.XS
        s.waste = WasteStack(x, y, self)
        lay.createText(s.waste, "s")
        x += lay.XM
        y = lay.YM
        for i in range(4):
            for j in range(decks):
                x += lay.XS
                s.foundations.append(self.Foundation_Class(x, y, self, i,
                                                           mod=13, max_move=0))
        if text:
            if rows > 4 * decks:
                tx, ty, ta, tf = lay.getTextAttr(None, "se")
                tx, ty = x + tx + lay.XM, y + ty
            else:
                tx, ty, ta, tf = lay.getTextAttr(None, "ss")
                tx, ty = x + tx, y + ty
            font = self.app.getFont("canvas_default")
            self.texts.info = MfxCanvasText(self.canvas, tx, ty,
                                            anchor=ta, font=font)
        x, y = lay.XM, lay.YM + lay.YS + lay.TEXT_HEIGHT
        if round_text:
            y += lay.TEXT_HEIGHT
        s.reserves.append(self.ReserveStack_Class(x, y, self))
        s.reserves[0].CARD_YOFFSET = yoffset
        x, y = lay.XM + 2 * lay.XS + lay.XM, lay.YM + lay.YS
        if text:
            y += lay.TEXT_HEIGHT
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += lay.XS

        # define stack-groups
        lay.defaultStackGroups()

    #
    # game extras
    #

    def updateText(self):
        if self.preview > 1:
            return
        if not self.texts.info:
            return
        if not self.base_card:
            t = ""
        else:
            t = RANKS[self.base_card.rank]
        self.texts.info.config(text=t)

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        self.base_card = None
        self.updateText()
        # deal base_card to Foundations, update foundations cap.base_rank
        self.base_card = self.s.talon.getCard()
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        n = self.base_card.suit * self.gameinfo.decks
        if self.s.foundations[n].cards:
            assert self.gameinfo.decks > 1
            n = n + 1
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, self.s.foundations[n])
        self.updateText()
        # fill the Reserve
        for i in range(self.INITIAL_RESERVE_CARDS):
            if self.INITIAL_RESERVE_FACEUP:
                self.flipMove(self.s.talon)
            self.moveMove(
                1, self.s.talon, self.s.reserves[0], frames=4, shadow=0)
        if self.s.reserves[0].canFlipCard():
            self.flipMove(self.s.reserves[0])
        self.s.talon.dealRow(reverse=1)
        self.s.talon.dealCards()          # deal first 3 cards to WasteStack

    def fillStack(self, stack):
        if stack in self.s.rows and self.s.reserves:
            if self.FILL_EMPTY_ROWS:
                if not stack.cards and self.s.reserves[0].cards:
                    if not self.s.reserves[0].cards[-1].face_up:
                        self.s.reserves[0].flipMove()
                    self.s.reserves[0].moveMove(1, stack)

    shallHighlightMatch = Game._shallHighlightMatch_ACW

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)


# ************************************************************************
# * Superior Canfield
# ************************************************************************

class SuperiorCanfield(Canfield):
    INITIAL_RESERVE_FACEUP = 1
    FILL_EMPTY_ROWS = 0


# ************************************************************************
# * Rainfall
# ************************************************************************

class Rainfall(Canfield):
    def createGame(self):
        Canfield.createGame(self, max_rounds=3, num_deal=1, round_text=True)


# ************************************************************************
# * Rainbow
# ************************************************************************

class Rainbow(Canfield):
    RowStack_Class = StackWrapper(Canfield_RK_RowStack, mod=13)

    def createGame(self):
        Canfield.createGame(self, max_rounds=1, num_deal=1)

    shallHighlightMatch = Game._shallHighlightMatch_RKW

# ************************************************************************
# * Storehouse (aka Straight Up)
# ************************************************************************


class Storehouse(Canfield):
    RowStack_Class = StackWrapper(Canfield_SS_RowStack, mod=13)

    def createGame(self):
        Canfield.createGame(self, max_rounds=3, num_deal=1, round_text=True)

    def _shuffleHook(self, cards):
        # move Twos to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 1, c.suit))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations[:3])
        Canfield.startGame(self)

    shallHighlightMatch = Game._shallHighlightMatch_SSW

    def updateText(self):
        pass


# ************************************************************************
# * Chameleon (aka Kansas)
# ************************************************************************

class Chameleon(Canfield):
    RowStack_Class = StackWrapper(Canfield_RK_RowStack, mod=13)

    INITIAL_RESERVE_CARDS = 12

    def createGame(self):
        Canfield.createGame(self, rows=3, max_rounds=1, num_deal=1)

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# ************************************************************************
# * Double Canfield (Canfield with 2 decks and 5 rows)
# ************************************************************************

class DoubleCanfield(Canfield):
    def createGame(self):
        Canfield.createGame(self, rows=5)


# ************************************************************************
# * American Toad
# ************************************************************************

class AmericanToad(Canfield):
    RowStack_Class = StackWrapper(Canfield_SS_RowStack, mod=13)

    INITIAL_RESERVE_CARDS = 20
    INITIAL_RESERVE_FACEUP = 1

    def createGame(self):
        Canfield.createGame(self, rows=8, max_rounds=2, num_deal=1,
                            round_text=True)

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * Variegated Canfield
# ************************************************************************

class VariegatedCanfield(Canfield):
    RowStack_Class = Canfield_AC_RowStack

    INITIAL_RESERVE_FACEUP = 1

    def createGame(self):
        Canfield.createGame(self, rows=5, max_rounds=3,
                            text=False, round_text=True)

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations[:7])
        Canfield.startGame(self)

    shallHighlightMatch = Game._shallHighlightMatch_AC

    def updateText(self):
        pass


# ************************************************************************
# * Eagle Wing
# ************************************************************************

class EagleWing_ReserveStack(OpenStack):
    def canFlipCard(self):
        return len(self.cards) == 1 and not self.cards[-1].face_up


class EagleWing(Canfield):
    RowStack_Class = StackWrapper(SS_RowStack, mod=13, max_move=1, max_cards=3)
    ReserveStack_Class = EagleWing_ReserveStack

    def createGame(self):
        # Canfield.createGame(self, rows=8, max_rounds=3, num_deal=1)
        # create layout
        lay, s = Layout(self), self.s

        # set window
        self.setSize(lay.XM + 9*lay.XS + lay.XM, lay.YM + 4*lay.YS)

        # extra settings
        self.base_card = None

        # create stacks
        x, y = lay.XM, lay.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=3, num_deal=1)
        lay.createText(s.talon, "s")
        lay.createRoundText(s.talon, 'ne', dx=lay.XS)
        x += lay.XS
        s.waste = WasteStack(x, y, self)
        lay.createText(s.waste, "s")
        for i in range(4):
            x = lay.XM + (i+3)*lay.XS
            s.foundations.append(
                self.Foundation_Class(x, y, self, i, mod=13, max_move=0))
        tx, ty, ta, tf = lay.getTextAttr(None, "se")
        tx, ty = x + tx + lay.XM, y + ty
        font = self.app.getFont("canvas_default")
        self.texts.info = MfxCanvasText(
            self.canvas, tx, ty, anchor=ta, font=font)
        ry = lay.YM + 2*lay.YS
        for i in range(8):
            x = lay.XM + (i + (i >= 4))*lay.XS
            y = ry - (0.2, 0.4, 0.6, 0.4, 0.4, 0.6, 0.4, 0.2)[i]*lay.CH
            s.rows.append(self.RowStack_Class(x, y, self))
        x, y = lay.XM + 4*lay.XS, ry
        s.reserves.append(self.ReserveStack_Class(x, y, self))
        # s.reserves[0].CARD_YOFFSET = 0
        lay.createText(s.reserves[0], "s")

        # define stack-groups
        lay.defaultStackGroups()

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * Gate
# * Little Gate
# * Doorway
# ************************************************************************

class Gate(Game):

    #
    # game layout
    #

    def createGame(self):
        # create layout
        lay, s = Layout(self), self.s

        # set window
        w = max(8*lay.XS, 6*lay.XS+8*lay.XOFFSET)
        h = lay.YM+3*lay.YS+12*lay.YOFFSET
        self.setSize(w+lay.XM, h)

        # create stacks
        y = lay.YM
        for x in (lay.XM, lay.XM+w-lay.XS-4*lay.XOFFSET):
            stack = OpenStack(x, y, self, max_accept=0)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = lay.XOFFSET, 0
            s.reserves.append(stack)
        x, y = lay.XM+(w-4*lay.XS)//2, lay.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += lay.XS
        x, y = lay.XM+(w-8*lay.XS)//2, lay.YM+lay.YS
        for i in range(8):
            s.rows.append(AC_RowStack(x, y, self))
            x += lay.XS
        s.talon = WasteTalonStack(lay.XM, h-lay.YS, self, max_rounds=1)
        lay.createText(s.talon, "n")
        s.waste = WasteStack(lay.XM+lay.XS, h-lay.YS, self)
        lay.createText(s.waste, "n")

        # define stack-groups
        lay.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        for i in range(5):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def fillStack(self, stack):
        r1, r2 = self.s.reserves
        if stack in self.s.rows and not stack.cards:
            from_stack = None
            if r1.cards or r2.cards:
                from_stack = r1
                if len(r1.cards) < len(r2.cards):
                    from_stack = r2
            elif self.s.waste.cards:
                from_stack = self.s.waste
            if from_stack:
                from_stack.moveMove(1, stack)

    shallHighlightMatch = Game._shallHighlightMatch_AC


class LittleGate(Gate):

    RowStack_Class = AC_RowStack
    ReserveStack_Class = StackWrapper(OpenStack, max_accept=0)

    #
    # game layout
    #

    def createGame(self, rows=4):
        # create layout
        lay, s = Layout(self), self.s

        # set window
        max_rows = max(7, rows+3)
        w, h = lay.XM+max_rows*lay.XS, lay.YM+2*lay.YS+12*lay.YOFFSET
        self.setSize(w, h)

        # create stacks
        y = lay.YM+lay.YS+lay.TEXT_HEIGHT
        for x in (lay.XM, w-lay.XS):
            stack = self.ReserveStack_Class(x, y, self)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, lay.YOFFSET
            s.reserves.append(stack)
        x, y = lay.XM+(max_rows-4)*lay.XS, lay.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += lay.XS
        x, y = lay.XM+(max_rows-rows)*lay.XS//2, lay.YM+lay.YS+lay.TEXT_HEIGHT
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += lay.XS
        s.talon = WasteTalonStack(lay.XM, lay.YM, self, max_rounds=1)
        lay.createText(s.talon, "s")
        s.waste = WasteStack(lay.XM+lay.XS, lay.YM, self)
        lay.createText(s.waste, "s")

        # define stack-groups
        lay.defaultStackGroups()

        return lay


class Doorway(LittleGate):

    Hint_Class = CautiousDefaultHint
    RowStack_Class = StackWrapper(RK_RowStack, max_move=1)
    ReserveStack_Class = ReserveStack

    def createGame(self):
        lay = LittleGate.createGame(self, rows=5)
        king_stack, queen_stack = self.s.reserves
        tx, ty, ta, tf = lay.getTextAttr(king_stack, "s")
        font = self.app.getFont("canvas_default")
        king_stack.texts.misc = MfxCanvasText(self.canvas, tx, ty,
                                              anchor=ta, font=font,
                                              text=_('King'))
        tx, ty, ta, tf = lay.getTextAttr(queen_stack, "s")
        font = self.app.getFont("canvas_default")
        queen_stack.texts.misc = MfxCanvasText(self.canvas, tx, ty,
                                               anchor=ta, font=font,
                                               text=_('Queen'))
        king_stack.cap.base_rank = KING
        queen_stack.cap.base_rank = QUEEN

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def fillStack(self, stack):
        pass

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Minerva
# * Munger
# * Mystique
# ************************************************************************

class Minerva(Canfield):
    RowStack_Class = KingAC_RowStack

    FILL_EMPTY_ROWS = 0
    INITIAL_RESERVE_CARDS = 11

    def createGame(self):
        Canfield.createGame(self, rows=7, max_rounds=2, num_deal=1,
                            text=False, round_text=True)

    def startGame(self):
        self.s.talon.dealRow(frames=0, flip=0)
        self.s.talon.dealRow(frames=0)
        self.s.talon.dealRow(frames=0, flip=0)
        self.startDealSample()
        self.s.talon.dealRow()
        for i in range(self.INITIAL_RESERVE_CARDS):
            self.moveMove(
                1, self.s.talon, self.s.reserves[0], frames=4, shadow=0)
        self.flipMove(self.s.reserves[0])
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_AC

    def _restoreGameHook(self, game):
        pass

    def _loadGameHook(self, p):
        pass

    def _saveGameHook(self, p):
        pass


class Munger(Minerva):
    INITIAL_RESERVE_CARDS = 7

    def createGame(self):
        Canfield.createGame(self, rows=7, max_rounds=1, num_deal=1, text=False)


class Mystique(Munger):
    RowStack_Class = AC_RowStack
    INITIAL_RESERVE_CARDS = 9


# ************************************************************************
# * Triple Canfield
# ************************************************************************

class TripleCanfield(Canfield):
    INITIAL_RESERVE_CARDS = 26

    def createGame(self):
        Canfield.createGame(self, rows=7)


# ************************************************************************
# * Acme
# ************************************************************************

class Acme(Canfield):
    Foundation_Class = SS_FoundationStack
    RowStack_Class = StackWrapper(SS_RowStack, max_move=1)
    Hint_Class = Canfield_Hint

    def createGame(self):
        Canfield.createGame(self, max_rounds=2, num_deal=1, round_text=True)

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self.startDealSample()
        for i in range(13):
            self.moveMove(
                1, self.s.talon, self.s.reserves[0], frames=4, shadow=0)
        self.flipMove(self.s.reserves[0])
        self.s.talon.dealRow(reverse=1)
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_SS

    def updateText(self):
        pass

    def _restoreGameHook(self, game):
        pass

    def _loadGameHook(self, p):
        pass

    def _saveGameHook(self, p):
        pass


# ************************************************************************
# * Duke
# ************************************************************************

class Duke(Game):
    Foundation_Class = SS_FoundationStack
    ReserveStack_Class = OpenStack
    RowStack_Class = AC_RowStack

    def createGame(self):
        lay, s = Layout(self), self.s

        w, h = lay.XM + 6*lay.XS + 4*lay.XOFFSET, \
            lay.YM + lay.TEXT_HEIGHT + 2*lay.YS + 12*lay.YOFFSET
        self.setSize(w, h)

        x, y = lay.XM, lay.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        lay.createText(s.talon, 's')
        lay.createRoundText(s.talon, 'ne', dx=lay.XS)
        x += lay.XS
        s.waste = WasteStack(x, y, self)
        lay.createText(s.waste, 's')
        x += lay.XS+4*lay.XOFFSET
        y = lay.YM
        for i in range(4):
            s.foundations.append(self.Foundation_Class(x, y, self, suit=i))
            x += lay.XS
        x0, y0, w = lay.XM, lay.YM+lay.YS+2*lay.TEXT_HEIGHT,\
            lay.XS+2*lay.XOFFSET
        for i, j in ((0, 0), (0, 1), (1, 0), (1, 1)):
            x, y = x0+i*w, y0+j*lay.YS
            stack = self.ReserveStack_Class(x, y, self, max_accept=0)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = lay.XOFFSET, 0
            s.reserves.append(stack)
        x, y = lay.XM+2*lay.XS+4*lay.XOFFSET, lay.YM+lay.YS
        for i in range(4):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += lay.XS

        lay.defaultStackGroups()

    def startGame(self):
        for i in range(3):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Demon
# ************************************************************************

class Demon(Canfield):
    INITIAL_RESERVE_CARDS = 40
    RowStack_Class = StackWrapper(AC_RowStack, mod=13)

    def createGame(self):
        Canfield.createGame(
            self, rows=8, max_rounds=UNLIMITED_REDEALS, num_deal=3)


# ************************************************************************
# * Canfield Rush
# ************************************************************************

class CanfieldRush_Talon(WasteTalonStack):
    def dealCards(self, sound=False):
        self.num_deal = 4-self.round
        return WasteTalonStack.dealCards(self, sound=sound)


class CanfieldRush(Canfield):
    Talon_Class = CanfieldRush_Talon
    # RowStack_Class = StackWrapper(AC_RowStack, mod=13)

    def createGame(self):
        Canfield.createGame(self, max_rounds=3, round_text=True)


# ************************************************************************
# * Skippy
# ************************************************************************

class Skippy(Canfield):
    FILL_EMPTY_ROWS = 0

    def createGame(self):
        # create layout
        lay, s = Layout(self), self.s

        # set window
        playcards = 8
        w0 = lay.XS+playcards*lay.XOFFSET
        w = lay.XM+lay.XS//2+max(10*lay.XS, lay.XS+4*w0)
        h = lay.YM+5*lay.YS+lay.TEXT_HEIGHT
        self.setSize(w, h)

        # extra settings
        self.base_card = None

        # create stacks
        x, y = lay.XM, lay.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        lay.createText(s.talon, 's')
        x += lay.XS
        s.waste = WasteStack(x, y, self)
        lay.createText(s.waste, 's')
        x = self.width - 8*lay.XS
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self,
                                                    suit=i % 4, mod=13))
            x += lay.XS
        tx, ty, ta, tf = lay.getTextAttr(None, "ss")
        tx, ty = x-lay.XS+tx, y+ty
        font = self.app.getFont("canvas_default")
        self.texts.info = MfxCanvasText(self.canvas, tx, ty,
                                        anchor=ta, font=font)
        x, y = lay.XM, lay.YM+lay.YS+lay.TEXT_HEIGHT
        for i in range(4):
            s.reserves.append(ReserveStack(x, y, self))
            y += lay.YS
        y = lay.YM+lay.YS+lay.TEXT_HEIGHT
        for i in range(4):
            x = lay.XM+lay.XS+lay.XS//2
            for j in range(4):
                stack = RK_RowStack(x, y, self, max_move=1, mod=13)
                s.rows.append(stack)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = lay.XOFFSET, 0
                x += w0
            y += lay.YS

        # define stack-groups
        lay.defaultStackGroups()

    def startGame(self):
        self.base_card = None
        self.updateText()
        # deal base_card to Foundations, update foundations cap.base_rank
        self.base_card = self.s.talon.getCard()
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        n = self.base_card.suit
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, self.s.foundations[n], frames=0)
        self.updateText()
        # update rows cap.base_rank
        row_base_rank = (self.base_card.rank-1) % 13
        for s in self.s.rows:
            s.cap.base_rank = row_base_rank
        #
        self._startDealNumRowsAndDealRowAndCards(3)

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# ************************************************************************
# * Lafayette
# ************************************************************************

class Lafayette(Game):
    def createGame(self):
        lay, s = Layout(self), self.s
        self.setSize(lay.XM+8*lay.XS, lay.YM+2*lay.YS+12*lay.YOFFSET)

        x, y = lay.XM, lay.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            s.foundations.append(SS_FoundationStack(x+4*lay.XS, y, self,
                                 suit=i,
                                 base_rank=KING, dir=-1))
            x += lay.XS
        x, y = lay.XM, lay.YM+lay.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=UNLIMITED_REDEALS,
                                  num_deal=3)
        lay.createText(s.talon, 'ne')
        y += lay.YS
        s.waste = WasteStack(x, y, self)
        lay.createText(s.waste, 'ne')
        x, y = lay.XM+2*lay.XS, lay.YM+lay.YS
        for i in range(4):
            s.rows.append(AC_RowStack(x, y, self, base_rank=6))
            x += lay.XS
        x += lay.XS
        stack = OpenStack(x, y, self)
        s.reserves.append(stack)
        stack.CARD_YOFFSET = lay.YOFFSET

        lay.defaultStackGroups()

    def startGame(self):
        for i in range(13):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            if self.s.reserves[0].cards:
                old_state = self.enterState(self.S_FILL)
                self.s.reserves[0].moveMove(1, stack)
                self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_AC


# register the game
registerGame(GameInfo(105, Canfield, "Canfield",                # was: 262
                      GI.GT_CANFIELD | GI.GT_CONTRIB, 1, -1, GI.SL_BALANCED))
registerGame(GameInfo(101, SuperiorCanfield, "Superior Canfield",
                      GI.GT_CANFIELD, 1, -1, GI.SL_BALANCED))
registerGame(GameInfo(99, Rainfall, "Rainfall",
                      GI.GT_CANFIELD | GI.GT_ORIGINAL, 1, 2, GI.SL_BALANCED))
registerGame(GameInfo(108, Rainbow, "Rainbow",
                      GI.GT_CANFIELD, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(100, Storehouse, "Storehouse",
                      GI.GT_CANFIELD, 1, 2, GI.SL_BALANCED,
                      altnames=("Provisions", "Straight Up", "Thirteen Up")))
registerGame(GameInfo(43, Chameleon, "Chameleon",
                      GI.GT_CANFIELD, 1, 0, GI.SL_BALANCED,
                      altnames="Kansas"))
registerGame(GameInfo(106, DoubleCanfield, "Double Canfield",   # was: 22
                      GI.GT_CANFIELD, 2, -1, GI.SL_BALANCED))
registerGame(GameInfo(103, AmericanToad, "American Toad",
                      GI.GT_CANFIELD, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(102, VariegatedCanfield, "Variegated Canfield",
                      GI.GT_CANFIELD, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(112, EagleWing, "Eagle Wing",
                      GI.GT_CANFIELD, 1, 2, GI.SL_BALANCED))
registerGame(GameInfo(315, Gate, "Gate",
                      GI.GT_CANFIELD, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(316, LittleGate, "Little Gate",
                      GI.GT_CANFIELD, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(360, Munger, "Munger",
                      GI.GT_CANFIELD, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(396, TripleCanfield, "Triple Canfield",
                      GI.GT_CANFIELD, 3, -1, GI.SL_BALANCED))
registerGame(GameInfo(403, Acme, "Acme",
                      GI.GT_CANFIELD, 1, 1, GI.SL_BALANCED))
registerGame(GameInfo(413, Duke, "Duke",
                      GI.GT_CANFIELD, 1, 2, GI.SL_BALANCED))
registerGame(GameInfo(422, Minerva, "Minerva",
                      GI.GT_CANFIELD, 1, 1, GI.SL_BALANCED))
registerGame(GameInfo(476, Demon, "Demon",
                      GI.GT_CANFIELD, 2, -1, GI.SL_BALANCED))
registerGame(GameInfo(494, Mystique, "Mystique",
                      GI.GT_CANFIELD, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(521, CanfieldRush, "Canfield Rush",
                      GI.GT_CANFIELD, 1, 2, GI.SL_BALANCED))
registerGame(GameInfo(527, Doorway, "Doorway",
                      GI.GT_KLONDIKE, 1, 0, GI.SL_BALANCED,
                      altnames=('Solstice',)))
registerGame(GameInfo(605, Skippy, "Skippy",
                      GI.GT_FAN_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(642, Lafayette, "Lafayette",
                      GI.GT_CANFIELD, 1, -1, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.hint import FreeCellSolverWrapper
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.stack import \
        AC_FoundationStack, \
        AC_RowStack, \
        InitialDealTalonStack, \
        RK_RowStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        StackWrapper, \
        SuperMoveAC_RowStack, \
        TalonStack, \
        UD_AC_RowStack, \
        UD_SS_RowStack
from pysollib.util import ACE, KING, NO_RANK, UNLIMITED_ACCEPTS, \
        UNLIMITED_MOVES


# ************************************************************************
# * Castles in Spain
# ************************************************************************

class CastlesInSpain(Game):
    Layout_Method = staticmethod(Layout.bakersDozenLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = SuperMoveAC_RowStack
    Hint_Class = CautiousDefaultHint
    Solver_Class = FreeCellSolverWrapper()

    #
    # game layout
    #

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s
        kwdefault(layout, rows=13, playcards=9)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(r.x, r.y, self, suit=r.suit))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        # default
        l.defaultAll()
        return l

    def startGame(self, flip=(0, 0, 0)):
        for f in flip:
            self.s.talon.dealRow(flip=f, frames=0)
        self._startAndDealRow()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Martha
# ************************************************************************

class Martha_RowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        # when empty, only accept a single card
        return self.cards or len(cards) == 1


class Martha(CastlesInSpain):
    Solver_Class = None
    RowStack_Class = Martha_RowStack

    def createGame(self):
        CastlesInSpain.createGame(self, rows=12, playcards=13)

    def _shuffleHook(self, cards):
        # move Aces to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        CastlesInSpain.startGame(self, flip=(0, 1, 0))
        self.s.talon.dealRow(rows=self.s.foundations)


# ************************************************************************
# * Baker's Dozen
# ************************************************************************

class BakersDozen(CastlesInSpain):
    RowStack_Class = StackWrapper(RK_RowStack, max_move=1, max_accept=1,
                                  base_rank=NO_RANK)
    Solver_Class = FreeCellSolverWrapper(preset='bakers_dozen')

    def _shuffleHook(self, cards):
        # move Kings to bottom of each stack
        i, n = 0, len(self.s.rows)
        kings = []
        for c in cards:
            if c.rank == KING:
                kings.append(i)
            i = i + 1
        for i in kings:
            j = i % n
            while j < i:
                if cards[j].rank != KING:
                    cards[i], cards[j] = cards[j], cards[i]
                    break
                j = j + n
        cards.reverse()
        return cards

    def startGame(self):
        CastlesInSpain.startGame(self, flip=(1, 1, 1))

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Spanish Patience
# * Portuguese Solitaire
# ************************************************************************

class SpanishPatience(BakersDozen):
    Foundation_Class = AC_FoundationStack
    Solver_Class = None


class PortugueseSolitaire(BakersDozen):
    RowStack_Class = StackWrapper(RK_RowStack, base_rank=KING, max_move=1)
    Solver_Class = FreeCellSolverWrapper(sbb='rank', esf='kings')

    def _shuffleHook(self, cards):
        return cards


class SpanishPatienceII(PortugueseSolitaire):
    RowStack_Class = StackWrapper(RK_RowStack, max_move=1)
    Solver_Class = FreeCellSolverWrapper(sbb='rank')


# ************************************************************************
# * Good Measure
# ************************************************************************

class GoodMeasure(BakersDozen):
    Solver_Class = FreeCellSolverWrapper(preset='good_measure')

    def createGame(self):
        CastlesInSpain.createGame(self, rows=10)

    def _shuffleHook(self, cards):
        cards = BakersDozen._shuffleHook(self, cards)
        # move 2 Aces to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == 0, c.suit), 2)

    def startGame(self):
        CastlesInSpain.startGame(self, flip=(1, 1, 1, 1))
        for i in range(2):
            c = self.s.talon.cards[-1]
            assert c.rank == ACE
            self.flipMove(self.s.talon)
            self.moveMove(1, self.s.talon, self.s.foundations[c.suit])


# ************************************************************************
# * Cruel
# ************************************************************************

class Cruel_Talon(TalonStack):
    def canDealCards(self):
        # FIXME: this is to avoid loops in the demo
        # if self.game.demo and self.game.moves.index >= 100:
        #    return False
        if self.round == self.max_rounds:
            return False
        return not self.game.isGameWon()

    def dealCards(self, sound=False):
        lr = len(self.game.s.rows)
        # move all cards to the Talon and redeal (no shuffling)
        num_cards = 0
        assert len(self.cards) == 0
        rows = list(self.game.s.rows)[:]
        rows.reverse()
        for r in rows:
            for i in range(len(r.cards)):
                num_cards = num_cards + 1
                self.game.moveMove(1, r, self, frames=0)
        assert len(self.cards) == num_cards
        if num_cards == 0:          # game already finished
            return 0
        # redeal in packs of 4 cards
        self.game.nextRoundMove(self)
        n, i = num_cards, 0
        deal = [4] * lr
        extra_cards = n - 4 * lr
        while extra_cards > 0:
            # note: this can only happen in Tarock games like Nasty
            deal[i] = deal[i] + 1
            i = (i + 1) % lr
            extra_cards = extra_cards - 1
        # print n, deal
        self.game.startDealSample()
        for i in range(lr):
            k = min(deal[i], n)
            frames = (0, 4)[n <= 3*4]
            for j in range(k):
                self.game.moveMove(1, self, self.game.s.rows[i], frames=frames)
            n = n - k
            if n == 0:
                break
        # done
        self.game.stopSamples()
        assert n == len(self.cards) == 0
        return num_cards


class Cruel(CastlesInSpain):
    Talon_Class = StackWrapper(Cruel_Talon, max_rounds=-1)
    RowStack_Class = StackWrapper(SS_RowStack, base_rank=NO_RANK)
    # Solver_Class = FreeCellSolverWrapper(preset='cruel')
    Solver_Class = None

    def createGame(self):
        return CastlesInSpain.createGame(self, rows=12)

    def _shuffleHook(self, cards):
        # move Aces to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        CastlesInSpain.startGame(self, flip=(1, 1, 1))
        self.s.talon.dealRow(rows=self.s.foundations)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Royal Family
# * Indefatigable
# ************************************************************************

class RoyalFamily(Cruel):
    Foundation_Class = StackWrapper(SS_FoundationStack, base_rank=KING, dir=-1)
    Talon_Class = StackWrapper(Cruel_Talon, max_rounds=2)
    RowStack_Class = UD_AC_RowStack

    def createGame(self):
        lay = Cruel.createGame(self)
        lay.createRoundText(self.s.talon, 'sw')

    def _shuffleHook(self, cards):
        # move Kings to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == KING, c.suit))

    shallHighlightMatch = Game._shallHighlightMatch_AC


class Indefatigable(Cruel):
    Foundation_Class = StackWrapper(SS_FoundationStack, max_move=0)
    Talon_Class = StackWrapper(Cruel_Talon, max_rounds=3)
    RowStack_Class = UD_SS_RowStack

    def createGame(self):
        lay = Cruel.createGame(self)
        lay.createRoundText(self.s.talon, 'sw')

    def _shuffleHook(self, cards):
        # move Aces to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == ACE, c.suit))

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Perseverance
# ************************************************************************

class Perseverance(Cruel, BakersDozen):
    Talon_Class = StackWrapper(Cruel_Talon, max_rounds=3)
    RowStack_Class = StackWrapper(SS_RowStack, base_rank=NO_RANK, dir=-1,
                                  max_move=UNLIMITED_MOVES,
                                  max_accept=UNLIMITED_ACCEPTS)
    Solver_Class = None

    def createGame(self):
        lay = Cruel.createGame(self)
        lay.createRoundText(self.s.talon, 'sw')

    def _shuffleHook(self, cards):
        # move Kings to bottom of each stack (???)
        # cards = BakersDozen._shuffleHook(self, cards)
        # move Aces to bottom of the Talon (i.e. last cards to be dealt)
        cards = Cruel._shuffleHook(self, cards)
        return cards

#      def dealCards(self, sound=True):
#          Cruel.dealCards(self, sound)


# ************************************************************************
# * Ripple Fan
# ************************************************************************

class RippleFan(CastlesInSpain):
    Solver_Class = None

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        Layout.bakersDozenLayout(l, rows=13)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = Cruel_Talon(l.s.talon.x, l.s.talon.y, self, max_rounds=-1)
        for r in l.s.foundations:
            s.foundations.append(
                SS_FoundationStack(r.x, r.y, self, suit=r.suit))
        for r in l.s.rows:
            s.rows.append(SS_RowStack(r.x, r.y, self, base_rank=NO_RANK))
        # default
        l.defaultAll()

    def startGame(self):
        CastlesInSpain.startGame(self, flip=(1, 1, 1))

    shallHighlightMatch = Game._shallHighlightMatch_SS


# register the game
registerGame(GameInfo(83, CastlesInSpain, "Castles in Spain",
                      GI.GT_BAKERS_DOZEN, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(84, Martha, "Martha",
                      GI.GT_BAKERS_DOZEN, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(31, BakersDozen, "Baker's Dozen",
                      GI.GT_BAKERS_DOZEN | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(85, SpanishPatience, "Spanish Patience",
                      GI.GT_BAKERS_DOZEN | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(86, GoodMeasure, "Good Measure",
                      GI.GT_BAKERS_DOZEN | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(104, Cruel, "Cruel",
                      GI.GT_BAKERS_DOZEN | GI.GT_OPEN, 1, -1, GI.SL_BALANCED))
registerGame(GameInfo(291, RoyalFamily, "Royal Family",
                      GI.GT_BAKERS_DOZEN | GI.GT_OPEN, 1, 1,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(308, PortugueseSolitaire, "Portuguese Solitaire",
                      GI.GT_BAKERS_DOZEN | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(404, Perseverance, "Perseverance",
                      GI.GT_BAKERS_DOZEN | GI.GT_OPEN, 1, 2, GI.SL_BALANCED))
registerGame(GameInfo(369, RippleFan, "Ripple Fan",
                      GI.GT_BAKERS_DOZEN, 1, -1, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(515, Indefatigable, "Indefatigable",
                      GI.GT_BAKERS_DOZEN | GI.GT_OPEN, 1, 2,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(664, SpanishPatienceII, "Spanish Patience II",
                      GI.GT_BAKERS_DOZEN | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import DefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        BasicRowStack, \
        InitialDealTalonStack, \
        InvisibleStack, \
        Stack, \
        StackWrapper, \
        TalonStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, NO_SUIT

# ************************************************************************
# *
# ************************************************************************


class Montana_Hint(DefaultHint):
    def computeHints(self):
        game = self.game
        RSTEP, RBASE = game.RSTEP, game.RBASE
        freerows = [s for s in game.s.rows if not s.cards]
        # for each stack
        for r in game.s.rows:
            if not r.cards:
                continue
            assert len(r.cards) == 1 and r.cards[-1].face_up
            c, pile, rpile = r.cards[0], r.cards, []
            if r.id % RSTEP > 0:
                left = game.s.rows[r.id - 1]
            else:
                left = None
                if c.rank == RBASE:
                    # do not move the leftmost card of a row if the
                    # rank is correct
                    continue
            for t in freerows:
                if self.shallMovePile(r, t, pile, rpile):
                    # FIXME: this scoring is completely simple
                    if left and left.cards:
                        # prefer low-rank left neighbours
                        score = 40000 + (self.K - left.cards[-1].rank)
                    else:
                        score = 50000
                    self.addHint(score, 1, r, t)


# ************************************************************************
# * Montana
# ************************************************************************

class Montana_Talon(TalonStack):
    def canDealCards(self):
        return self.round != self.max_rounds and not self.game.isGameWon()

    def _inSequence(self, card, suit, rank):
        return card.suit == suit and card.rank == rank

    def dealCards(self, sound=False):
        # move cards to the Talon, shuffle and redeal
        game = self.game
        decks = game.gameinfo.decks
        RSTEP, RBASE = game.RSTEP, game.RBASE
        num_cards = 0
        assert len(self.cards) == 0
        rows = game.s.rows
        # move out-of-sequence cards from the Tableau to the Talon
        stacks = []
        gaps = [None] * 4 * decks
        for g in range(4*decks):
            i = g * RSTEP
            r = rows[i]
            if r.cards and r.cards[-1].rank == RBASE:
                in_sequence, suit = 1, r.cards[-1].suit
            else:
                in_sequence, suit = 0, NO_SUIT
            for j in range(RSTEP):
                r = rows[i + j]
                if in_sequence:
                    if (not r.cards or
                            not self._inSequence(r.cards[-1], suit, RBASE+j)):
                        in_sequence = 0
                if not in_sequence:
                    stacks.append(r)
                    if gaps[g] is None:
                        gaps[g] = r
                    if r.cards:
                        game.moveMove(1, r, self, frames=0)
                        num_cards = num_cards + 1
        assert len(self.cards) == num_cards
        assert len(stacks) == num_cards + len(gaps)
        if num_cards == 0:          # game already finished
            return 0
        if sound:
            game.startDealSample()
        # shuffle
        game.shuffleStackMove(self)
        # redeal
        game.nextRoundMove(self)
        spaces = self.getRedealSpaces(stacks, gaps)
        for r in stacks:
            if r not in spaces:
                self.game.moveMove(1, self, r, frames=4)
        # done
        assert len(self.cards) == 0
        if sound:
            game.stopSamples()
        return num_cards

    def getRedealSpaces(self, stacks, gaps):
        # the spaces are directly after the sorted sequence in each row
        return gaps


class Montana_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if self.id % self.game.RSTEP == 0:
            return cards[0].rank == self.game.RBASE
        left = self.game.s.rows[self.id - 1]
        return left.cards and left.cards[-1].suit == cards[0].suit \
            and left.cards[-1].rank + 1 == cards[0].rank

    def clickHandler(self, event):
        if not self.cards:
            return self.quickPlayHandler(event)
        return BasicRowStack.clickHandler(self, event)

    # bottom to get events for an empty stack
    prepareBottom = Stack.prepareInvisibleBottom

    getBottomImage = Stack._getReserveBottomImage


class Montana(Game):
    Talon_Class = StackWrapper(Montana_Talon, max_rounds=3)
    RowStack_Class = Montana_RowStack
    Hint_Class = Montana_Hint

    RLEN, RSTEP, RBASE = 52, 13, 1

    def createGame(self, round_text=True):
        decks = self.gameinfo.decks

        # create layout
        l, s = Layout(self, card_x_space=4), self.s

        # set window
        w, h = l.XM + self.RSTEP*l.XS, l.YM + (4*decks)*l.YS
        if round_text:
            h += l.YS
        self.setSize(w, h)

        # create stacks
        for k in range(decks):
            for i in range(4):
                x, y = l.XM, l.YM + (i+k*4)*l.YS
                for j in range(self.RSTEP):
                    s.rows.append(self.RowStack_Class(x, y, self,
                                  max_accept=1, max_cards=1))
                    x += l.XS
        if round_text:
            x, y = l.XM + (self.RSTEP-1)*l.XS//2, self.height-l.YS
            s.talon = self.Talon_Class(x, y, self)
            l.createRoundText(s.talon, 'se')
        else:
            # Talon is invisible
            x, y = self.getInvisibleCoords()
            s.talon = self.Talon_Class(x, y, self)
        if self.RBASE:
            # create an invisible stack to hold the four Aces
            s.internals.append(InvisibleStack(self))

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        frames = 0
        for i in range(52):
            c = self.s.talon.cards[-1]
            if c.rank == ACE:
                self.s.talon.dealRow(rows=self.s.internals, frames=0)
            else:
                if frames == 0 and i >= 39:
                    self.startDealSample()
                    frames = 4
                self.s.talon.dealRow(rows=(self.s.rows[i],), frames=frames)

    def isGameWon(self):
        rows = self.s.rows
        for i in range(0, self.RLEN, self.RSTEP):
            if not rows[i].cards:
                return False
            suit = rows[i].cards[-1].suit
            for j in range(self.RSTEP - 1):
                r = rows[i + j]
                if not r.cards or r.cards[-1].rank != self.RBASE + j \
                        or r.cards[-1].suit != suit:
                    return False
        return True

    def getHighlightPilesStacks(self):
        return ()

    def getAutoStacks(self, event=None):
        return (self.sg.dropstacks, (), self.sg.dropstacks)

    shallHighlightMatch = Game._shallHighlightMatch_SS

    def getQuickPlayScore(self, ncards, from_stack, to_stack):
        if from_stack.cards:
            if from_stack.id % self.RSTEP == 0 and \
                    from_stack.cards[-1].rank == self.RBASE:
                # do not move the leftmost card of a row if the rank is correct
                return -1
        return 1


# ************************************************************************
# * Spaces
# ************************************************************************

class Spaces_Talon(Montana_Talon):
    def getRedealSpaces(self, stacks, gaps):
        # use four random spaces, ignore gaps
        # note: the random.seed is already saved in shuffleStackMove
        spaces = []
        while len(spaces) != 4:
            r = self.game.random.choice(stacks)
            if r not in spaces:
                spaces.append(r)
        return spaces


class Spaces(Montana):
    Talon_Class = StackWrapper(Spaces_Talon, max_rounds=3)


# ************************************************************************
# * Blue Moon
# ************************************************************************

class BlueMoon(Montana):
    RLEN, RSTEP, RBASE = 56, 14, 0

    def startGame(self):
        frames = 0
        for i in range(self.RLEN):
            if i == self.RLEN-self.RSTEP:  # last row
                self.startDealSample()
                frames = -1
            if i % self.RSTEP == 0:     # left column
                continue
            self.s.talon.dealRow(rows=(self.s.rows[i],), frames=frames)
        ace_rows = [r for r in self.s.rows
                    if r.cards and r.cards[-1].rank == ACE]
        j = 0
        for r in ace_rows:
            self.moveMove(1, r, self.s.rows[j])
            j += self.RSTEP


# ************************************************************************
# * Red Moon
# ************************************************************************

class RedMoon(BlueMoon):
    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        decks = self.gameinfo.decks
        frames = 0
        r = self.s.rows
        self.s.talon.dealRow(rows=(r[::14]), frames=frames)
        for i in range(4*decks):
            if i == 4*decks-1:
                self.startDealSample()
                frames = 4
            n = i * 14 + 2
            self.s.talon.dealRow(rows=r[n:n+12], frames=frames)


# ************************************************************************
# * Galary
# ************************************************************************


class Galary_Hint(Montana_Hint):
    def shallMovePile(self, from_stack, to_stack, pile, rpile):
        if from_stack is to_stack or \
                not to_stack.acceptsCards(from_stack, pile):
            return False
        # now check for loops
        rr = self.ClonedStack(from_stack, stackcards=rpile)
        if rr.acceptsCards(to_stack, pile):
            # the pile we are going to move could be moved back -
            # this is dangerous as we can create endless loops...
            return False
        return True


class Galary_RowStack(Montana_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if self.id % self.game.RSTEP == 0:
            return cards[0].rank == self.game.RBASE
        r = self.game.s.rows
        left = r[self.id - 1]
        if left.cards and left.cards[-1].suit == cards[0].suit \
                and left.cards[-1].rank + 1 == cards[0].rank:
            return True
        if self.id < len(r)-1:
            right = r[self.id + 1]
            if right.cards and right.cards[-1].suit == cards[0].suit \
                    and right.cards[-1].rank - 1 == cards[0].rank:
                return True
        return False


class Galary(RedMoon):
    RowStack_Class = Galary_RowStack
    Hint_Class = Galary_Hint


# ************************************************************************
# * Moonlight
# ************************************************************************

class Moonlight(Montana):
    RowStack_Class = Galary_RowStack
    Hint_Class = Galary_Hint


# ************************************************************************
# * Jungle
# ************************************************************************

class Jungle_RowStack(Montana_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if self.id % self.game.RSTEP == 0:
            return cards[0].rank == self.game.RBASE
        left = self.game.s.rows[self.id - 1]
        return left.cards and left.cards[-1].rank + 1 == cards[0].rank


class Jungle(BlueMoon):
    Talon_Class = StackWrapper(Montana_Talon, max_rounds=2)
    RowStack_Class = Jungle_RowStack
    Hint_Class = Galary_Hint


# ************************************************************************
# * Spaces and Aces
# ************************************************************************

class SpacesAndAces_RowStack(Montana_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if self.id % self.game.RSTEP == 0:
            return cards[0].rank == self.game.RBASE
        left = self.game.s.rows[self.id - 1]
        return left.cards and left.cards[-1].suit == cards[0].suit \
            and left.cards[-1].rank < cards[0].rank


class SpacesAndAces(BlueMoon):
    Hint_Class = Galary_Hint
    Talon_Class = InitialDealTalonStack
    RowStack_Class = SpacesAndAces_RowStack

    def createGame(self):
        Montana.createGame(self, round_text=False)

    def startGame(self):
        frames = 0
        for i in range(self.RLEN):
            if i == self.RLEN-self.RSTEP:  # last row
                self.startDealSample()
                frames = -1
            if i % self.RSTEP == 0:     # left column
                continue
            self.s.talon.dealRow(rows=(self.s.rows[i],), frames=frames)

# ************************************************************************
# * Paganini
# ************************************************************************


class Paganini_Talon(Montana_Talon):
    def _inSequence(self, card, suit, rank):
        card_rank = card.rank
        if card_rank >= 5:
            card_rank -= 4
        return card.suit == suit and card_rank == rank


class Paganini_RowStack(Montana_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if self.id % self.game.RSTEP == 0:
            return cards[0].rank == self.game.RBASE
        left = self.game.s.rows[self.id - 1]
        if not left.cards:
            return False
        if left.cards[-1].suit != cards[0].suit:
            return False
        if left.cards[-1].rank == ACE:
            return cards[0].rank == 5
        return left.cards[-1].rank+1 == cards[0].rank


class Paganini(BlueMoon):
    RLEN, RSTEP, RBASE = 40, 10, 0

    Talon_Class = StackWrapper(Paganini_Talon, max_rounds=2)
    RowStack_Class = Paganini_RowStack

    def isGameWon(self):
        rows = self.s.rows
        for i in range(0, self.RLEN, self.RSTEP):
            if not rows[i].cards:
                return False
            suit = rows[i].cards[-1].suit
            for j in range(self.RSTEP - 1):
                r = rows[i + j]
                if not r.cards:
                    return False
                card = r.cards[-1]
                card_rank = card.rank
                if card_rank >= 5:
                    card_rank -= 4
                if card_rank != self.RBASE + j or card.suit != suit:
                    return False
        return True


# ************************************************************************
# * Spoilt
# ************************************************************************

class Spoilt_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        # if not BasicRowStack.acceptsCards(self, from_stack, cards):
        #    return False

        card = cards[0]
        RSTEP = self.game.RSTEP
        RBASE = self.game.RBASE
        row, col = divmod(self.id, RSTEP)
        # check rank
        if card.rank == ACE:
            if col != RSTEP-1:
                return False
        else:
            if card.rank - RBASE != col:
                return False
        # check suit
        suit = None
        for i in range(row*RSTEP, (row+1)*RSTEP):
            r = self.game.s.rows[i]
            if r.cards and r.cards[0].face_up:
                suit = r.cards[0].suit
                break
        if suit is not None:
            return card.suit == suit
        for r in self.game.s.rows:      # check other rows
            if r.cards and r.cards[0].face_up and r.cards[0].suit == card.suit:
                return False
        return True

    def canFlipCard(self):
        return False


class Spoilt_Waste(WasteStack):

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        assert ncards == 1 and to_stack in self.game.s.rows
        if to_stack.cards:
            self._swapPairMove(ncards, to_stack, frames=-1, shadow=0)
        else:
            WasteStack.moveMove(self, ncards, to_stack, frames, shadow)

    def _swapPairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        old_state = game.enterState(game.S_FILL)
        swap = game.s.internals[0]
        game.flipMove(other_stack)
        game.moveMove(n, self, swap, frames=0)
        game.moveMove(n, other_stack, self, frames=frames, shadow=shadow)
        game.moveMove(n, swap, other_stack, frames=0)
        game.leaveState(old_state)


class Spoilt(Game):
    RSTEP, RBASE = 8, 6

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + self.RSTEP*l.XS, l.YM + 5.5*l.YS)

        # create stacks
        for i in range(4):
            x, y, = l.XM, l.YM + i*l.YS
            for j in range(self.RSTEP):
                s.rows.append(Spoilt_RowStack(x, y, self,
                              max_accept=1, max_cards=2, min_cards=1))
                x += l.XS
        x, y = self.width//2 - l.XS, self.height-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'n')
        x += l.XS
        s.waste = Spoilt_Waste(x, y, self, max_cards=1)

        # create an invisible stack
        s.internals.append(InvisibleStack(self))

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        for i in range(4):
            rows = self.s.rows[self.RSTEP*i+1:self.RSTEP*(i+1)]
            self.s.talon.dealRow(rows=rows, frames=4, flip=False)
        self.s.talon.dealCards()

    def isGameWon(self):
        for r in self.s.rows:
            if not r.cards:
                return False
            if not r.cards[0].face_up:
                return False
        return True

    def getHighlightPilesStacks(self):
        return ()

    def getAutoStacks(self, event=None):
        return (), (), ()


# ************************************************************************
# * Double Montana
# ************************************************************************

class DoubleMontana(Montana):
    Talon_Class = InitialDealTalonStack
    Hint_Class = Galary_Hint
    RLEN, RSTEP, RBASE = 112, 14, 0

    def createGame(self):
        Montana.createGame(self, round_text=False)

    def startGame(self):
        frames = 0
        for i in range(self.RLEN):
            if i == self.RLEN-self.RSTEP:  # last row
                self.startDealSample()
                frames = -1
            if i % self.RSTEP == 0:     # left column
                continue
            self.s.talon.dealRow(rows=(self.s.rows[i],), frames=frames)


class DoubleBlueMoon(DoubleMontana, BlueMoon):
    Talon_Class = StackWrapper(Montana_Talon, max_rounds=3)
    RLEN, RSTEP, RBASE = 112, 14, 0

    def createGame(self):
        BlueMoon.createGame(self, round_text=True)
    startGame = BlueMoon.startGame


class DoubleRedMoon(DoubleMontana, RedMoon):
    Talon_Class = StackWrapper(Montana_Talon, max_rounds=3)
    RLEN, RROWS = 112, 8
    _shuffleHook = RedMoon._shuffleHook

    def createGame(self):
        RedMoon.createGame(self, round_text=True)
    startGame = RedMoon.startGame


# register the game
registerGame(GameInfo(53, Montana, "Montana",
                      GI.GT_MONTANA | GI.GT_OPEN, 1, 2, GI.SL_MOSTLY_SKILL,
                      si={"ncards": 48}, altnames="Gaps"))
registerGame(GameInfo(116, Spaces, "Spaces",
                      GI.GT_MONTANA | GI.GT_OPEN, 1, 2, GI.SL_MOSTLY_SKILL,
                      si={"ncards": 48}))
registerGame(GameInfo(63, BlueMoon, "Blue Moon",
                      GI.GT_MONTANA | GI.GT_OPEN, 1, 2, GI.SL_MOSTLY_SKILL,
                      altnames=("Rangoon",)))
registerGame(GameInfo(117, RedMoon, "Red Moon",
                      GI.GT_MONTANA | GI.GT_OPEN, 1, 2, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(275, Galary, "Galary",
                      GI.GT_MONTANA | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 2,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(276, Moonlight, "Moonlight",
                      GI.GT_MONTANA | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 2,
                      GI.SL_MOSTLY_SKILL,
                      si={"ncards": 48}))
registerGame(GameInfo(380, Jungle, "Jungle",
                      GI.GT_MONTANA | GI.GT_OPEN, 1, 1, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(381, SpacesAndAces, "Spaces and Aces",
                      GI.GT_MONTANA | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(706, Paganini, "Paganini",
                      GI.GT_MONTANA | GI.GT_OPEN, 1, 1, GI.SL_MOSTLY_SKILL,
                      ranks=(0, 5, 6, 7, 8, 9, 10, 11, 12),
                      altnames=('Long Trip',)))
registerGame(GameInfo(736, Spoilt, "Spoilt",
                      GI.GT_MONTANA, 1, 0, GI.SL_MOSTLY_LUCK,
                      ranks=(0, 6, 7, 8, 9, 10, 11, 12),
                      ))
registerGame(GameInfo(759, DoubleMontana, "Double Montana",
                      GI.GT_MONTANA | GI.GT_OPEN, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(770, DoubleBlueMoon, "Double Blue Moon",
                      GI.GT_MONTANA | GI.GT_OPEN, 2, 2, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(771, DoubleRedMoon, "Double Red Moon",
                      GI.GT_MONTANA | GI.GT_OPEN, 2, 2, GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.freecell import FreeCell
from pysollib.hint import DefaultHint
from pysollib.hint import FreeCellSolverWrapper, FreeCellType_Hint
from pysollib.layout import Layout
from pysollib.stack import \
        AC_RowStack, \
        FreeCell_SS_RowStack, \
        InitialDealTalonStack, \
        KingSS_RowStack, \
        OpenStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        StackWrapper, \
        SuperMoveSS_RowStack
from pysollib.util import KING

# ************************************************************************
# * Baker's Game
# ************************************************************************


class BakersGame(FreeCell):
    RowStack_Class = SuperMoveSS_RowStack
    Solver_Class = FreeCellSolverWrapper(sbb='suit')
    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# *
# ************************************************************************

class KingOnlyBakersGame(BakersGame):
    RowStack_Class = StackWrapper(FreeCell_SS_RowStack, base_rank=KING)
    Solver_Class = FreeCellSolverWrapper(sbb='suit', esf='kings')


# ************************************************************************
# * Eight Off (Baker's Game in a different layout)
# ************************************************************************

class EightOff(KingOnlyBakersGame):

    #
    # game layout
    #

    def createGame(self, rows=8, reserves=8):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (piles up to 16 cards are playable without
        # overlap in default window size)
        h = max(2*l.YS, l.YS+(16-1)*l.YOFFSET)
        maxrows = max(rows, reserves)
        self.setSize(l.XM + maxrows*l.XS, l.YM + l.YS + h + l.YS)

        # create stacks
        x, y = l.XM + (maxrows-4)*l.XS//2, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, i))
            x = x + l.XS
        x, y = l.XM + (maxrows-rows)*l.XS//2, y + l.YS
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self))
            x = x + l.XS
        x, y = l.XM + (maxrows-reserves)*l.XS//2, self.height - l.YS
        for i in range(reserves):
            s.reserves.append(ReserveStack(x, y, self))
            x = x + l.XS
        self.setRegion(s.reserves, (-999, y - l.CH // 2, 999999, 999999))
        s.talon = InitialDealTalonStack(l.XM, l.YM, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(5)
        self.s.talon.dealRow()
        r = self.s.reserves
        self.s.talon.dealRow(rows=[r[0], r[2], r[4], r[6]])


# ************************************************************************
# * Seahaven Towers (Baker's Game in a different layout)
# ************************************************************************

class SeahavenTowers(KingOnlyBakersGame):

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (piles up to 20 cards are playable in default window size)
        h = max(3*l.YS, 20*l.YOFFSET)
        self.setSize(l.XM + 10*l.XS, l.YM + l.YS + h)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(4):
            s.reserves.append(ReserveStack(x + (i+3)*l.XS, y, self))
        for suit in range(4):
            i = (9, 0, 1, 8)[suit]
            s.foundations.append(SS_FoundationStack(x + i*l.XS, y, self, suit))
        x, y = l.XM, l.YM + l.YS
        for i in range(10):
            s.rows.append(self.RowStack_Class(x, y, self))
            x = x + l.XS
        self.setRegion(s.rows, (-999, y - l.CH // 2, 999999, 999999))
        s.talon = InitialDealTalonStack(l.XM, self.height-l.YS, self)

        # define stack-groups
        self.sg.openstacks = s.foundations + s.rows + s.reserves
        self.sg.talonstacks = [s.talon]
        self.sg.dropstacks = s.rows + s.reserves
        self.sg.reservestacks = s.reserves

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(4)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=(self.s.reserves[1:3]))


# ************************************************************************
# *
# ************************************************************************

class RelaxedSeahavenTowers(SeahavenTowers):
    RowStack_Class = KingSS_RowStack
    Solver_Class = FreeCellSolverWrapper(
        sbb='suit', esf='kings', sm='unlimited')


# ************************************************************************
# * Tuxedo
# * Penguin
# * Opus
# ************************************************************************

class Tuxedo(Game):

    RowStack_Class = StackWrapper(SS_RowStack, mod=13)
    ReserveStack_Class = ReserveStack
    Foundation_Class = StackWrapper(SS_FoundationStack, mod=13, max_move=0)
    Hint_Class = FreeCellType_Hint
    Solver_Class = FreeCellSolverWrapper(sbb='suit', sm='unlimited')

    def createGame(self, rows=7, reserves=7):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (piles up to 16 cards are playable without
        #  overlap in default window size)
        h = max(3*l.YS, l.YS+(16-1)*l.YOFFSET)
        maxrows = max(rows, reserves)
        self.setSize(l.XM + (maxrows+1)*l.XS, l.YM + h + l.YS)

        # extra settings
        self.base_card = None

        # create stacks
        x, y = self.width - l.XS, l.YM
        for i in range(4):
            s.foundations.append(self.Foundation_Class(x, y, self, suit=i))
            y = y + l.YS
        self.setRegion(s.foundations, (x - l.CW//2, -999, 999999, 999999))
        x, y = l.XM + (maxrows-rows)*l.XS//2, l.YM
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self))
            x = x + l.XS
        x, y = l.XM + (maxrows-reserves)*l.XS//2, self.height - l.YS
        for i in range(reserves):
            s.reserves.append(self.ReserveStack_Class(x, y, self))
            x = x + l.XS
        self.setRegion(s.reserves, (-999, y - l.CH // 2, 999999, 999999))
        s.talon = InitialDealTalonStack(l.XM+1, y, self)

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRows(6)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.rows[::3])

    shallHighlightMatch = Game._shallHighlightMatch_SSW


class Penguin(Tuxedo):
    GAME_VERSION = 2
    Solver_Class = FreeCellSolverWrapper(
        sbb='suit', esf='kings', sm='unlimited')

    def _shuffleHook(self, cards):
        # move base cards to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards,
            lambda c, rank=cards[-1].rank: (c.rank == rank, 0))

    def _updateStacks(self):
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        for s in self.s.rows:
            s.cap.base_rank = (self.base_card.rank - 1) % 13

    def startGame(self):
        self.base_card = self.s.talon.cards[-4]
        self._updateStacks()
        # deal base cards to Foundations
        for i in range(3):
            c = self.s.talon.getCard()
            assert c.rank == self.base_card.rank
            to_stack = self.s.foundations[c.suit * self.gameinfo.decks]
            self.flipMove(self.s.talon)
            self.moveMove(1, self.s.talon, to_stack, frames=0)
        # deal rows
        self._startDealNumRowsAndDealSingleRow(6)

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        self._updateStacks()

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)


class Opus(Penguin):
    def createGame(self):
        Tuxedo.createGame(self, reserves=5)


# ************************************************************************
# * Flipper
# ************************************************************************

class Flipper_Row(AC_RowStack):
    def canFlipCard(self):
        if not OpenStack.canFlipCard(self):
            return False
        i = list(self.game.s.rows).index(self)
        return len(self.game.s.reserves[i].cards) == 0


class Flipper(Tuxedo):

    RowStack_Class = Flipper_Row
    Foundation_Class = SS_FoundationStack
    Hint_Class = DefaultHint
    Solver_Class = None

    def fillStack(self, stack):
        i = 0
        for s in self.s.reserves:
            r = self.s.rows[i]
            if r.cards:
                if ((s.cards and r.cards[-1].face_up) or
                        (not s.cards and not r.cards[-1].face_up)):
                    r.flipMove(animation=True)
            i += 1

    shallHighlightMatch = Game._shallHighlightMatch_AC


# register the game
registerGame(GameInfo(45, BakersGame, "Baker's Game",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_SKILL))
registerGame(GameInfo(26, KingOnlyBakersGame, "King Only Baker's Game",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_SKILL))
registerGame(GameInfo(258, EightOff, "Eight Off",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(9, SeahavenTowers, "Seahaven Towers",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_SKILL,
                      altnames=("Sea Towers", "Towers")))
registerGame(GameInfo(6, RelaxedSeahavenTowers, "Relaxed Seahaven Towers",
                      GI.GT_FREECELL | GI.GT_RELAXED | GI.GT_OPEN, 1, 0,
                      GI.SL_SKILL))
registerGame(GameInfo(64, Penguin, "Penguin",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL,
                      altnames=("Beak and Flipper",)))
registerGame(GameInfo(427, Opus, "Opus",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(629, Tuxedo, "Tuxedo",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(713, Flipper, "Flipper",
                      GI.GT_FREECELL | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import pysollib.game
from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.pileon import FourByFour_Hint
from pysollib.hint import AbstractHint, CautiousDefaultHint, DefaultHint
from pysollib.hint import BlackHoleSolverWrapper
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AbstractFoundationStack, \
        BasicRowStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        OpenStack, \
        RK_FoundationStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        Stack, \
        StackWrapper, \
        TalonStack, \
        UD_RK_RowStack, \
        WasteStack, \
        WasteTalonStack, \
        isSameSuitSequence
from pysollib.util import ACE, ANY_RANK, ANY_SUIT, KING, NO_RANK, RANKS, \
        SUITS, \
        UNLIMITED_REDEALS


class Golf_Hint(AbstractHint):
    # FIXME: this is very simple

    def computeHints(self):
        game = self.game
        # for each stack
        for r in game.sg.dropstacks:
            # try if we can drop a card to the Waste
            w, ncards = r.canDropCards(game.s.foundations)
            if not w:
                continue
            # this assertion must hold for Golf
            assert ncards == 1
            # clone the Waste (including the card that will be dropped) to
            # form our new foundations
            ww = (self.ClonedStack(w, stackcards=w.cards+[r.cards[-1]]), )
            # now search for a stack that would benefit from this card
            score, color = 10000 + r.id, None
            for t in game.sg.dropstacks:
                if not t.cards:
                    continue
                if t is r:
                    t = self.ClonedStack(r, stackcards=r.cards[:-1])
                if t.canFlipCard():
                    score = score + 100
                elif t.canDropCards(ww)[0]:
                    score = score + 100
            # add hint
            self.addHint(score, ncards, r, w, color)


# ************************************************************************
# *
# ************************************************************************

class Golf_Talon(WasteTalonStack):
    def canDealCards(self):
        if not WasteTalonStack.canDealCards(self):
            return False
        return not self.game.isGameWon()


class Golf_Waste(WasteStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=0, max_accept=1)
        WasteStack.__init__(self, x, y, game, **cap)

    def acceptsCards(self, from_stack, cards):
        if from_stack is self.game.s.talon:
            return True
        if not WasteStack.acceptsCards(self, from_stack, cards):
            return False
        # check cards
        r1, r2 = self.cards[-1].rank, cards[0].rank
        if self.game.getStrictness() == 1:
            # nothing on a King
            if r1 == KING:
                return False
        return (r1 + 1) % self.cap.mod == r2 or (r2 + 1) % self.cap.mod == r1

    def getHelp(self):
        return _('Waste. Build up or down regardless of suit.')


class Golf_RowStack(BasicRowStack):
    def clickHandler(self, event):
        return self.doubleclickHandler(event)

    def getHelp(self):
        return _('Tableau. No building.')


# ************************************************************************
# * Golf
# ************************************************************************

class Golf(Game):
    Solver_Class = BlackHoleSolverWrapper(preset='golf', base_rank=0,
                                          queens_on_kings=True)
    Waste_Class = Golf_Waste
    Hint_Class = Golf_Hint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        playcards = 5
        w1, w2 = 8*l.XS+l.XM, 2*l.XS
        if w2 + 52*l.XOFFSET > w1:
            l.XOFFSET = int((w1 - w2) / 52)
        self.setSize(w1, l.YM+3*l.YS+(playcards-1)*l.YOFFSET+l.TEXT_HEIGHT)

        # create stacks
        x, y = l.XM + l.XS // 2, l.YM
        for i in range(7):
            s.rows.append(Golf_RowStack(x, y, self))
            x = x + l.XS
        x, y = l.XM, self.height - l.YS
        s.talon = Golf_Talon(x, y, self, max_rounds=1)
        l.createText(s.talon, "n")
        x = x + l.XS
        s.waste = self.Waste_Class(x, y, self)
        s.waste.CARD_XOFFSET = l.XOFFSET
        l.createText(s.waste, "n")
        # the Waste is also our only Foundation in this game
        s.foundations.append(s.waste)

        # define stack-groups (non default)
        self.sg.openstacks = [s.waste]
        self.sg.talonstacks = [s.talon]
        self.sg.dropstacks = s.rows

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(4)
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack

    def isGameWon(self):
        for r in self.s.rows:
            if r.cards:
                return False
        return True

    shallHighlightMatch = Game._shallHighlightMatch_RK

    def getHighlightPilesStacks(self):
        return ()

    def getAutoStacks(self, event=None):
        if event is None:
            # disable auto drop - this would ruin the whole gameplay
            return (self.sg.dropstacks, (), ())
        else:
            # rightclickHandler
            return (self.sg.dropstacks, self.sg.dropstacks, ())


# ************************************************************************
# *
# ************************************************************************

class DeadKingGolf(Golf):
    Solver_Class = BlackHoleSolverWrapper(preset='golf', base_rank=0)

    def getStrictness(self):
        return 1

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        if card1.rank == KING:
            return False
        return Golf.shallHighlightMatch(self, stack1, card1, stack2, card2)


class RelaxedGolf(Golf):
    Solver_Class = BlackHoleSolverWrapper(preset='golf', base_rank=0,
                                          wrap_ranks=True)
    Waste_Class = StackWrapper(Golf_Waste, mod=13)

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# ************************************************************************
# * Elevator - Relaxed Golf in a Pyramid layout
# ************************************************************************

class Elevator_RowStack(Golf_RowStack):
    STEP = (1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6)

    def basicIsBlocked(self):
        r, step = self.game.s.rows, self.STEP
        i, n, mylen = self.id, 1, len(step)
        while i < mylen:
            i = i + step[i]
            n = n + 1
            for j in range(i, i+n):
                if r[j].cards:
                    return True
        return False


class Elevator(RelaxedGolf):

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(9*l.XS+l.XM, 4*l.YS+l.YM)

        # create stacks
        for i in range(7):
            x = l.XM + (8-i) * l.XS // 2
            y = l.YM + i * l.YS // 2
            for j in range(i+1):
                s.rows.append(Elevator_RowStack(x, y, self))
                x = x + l.XS
        x, y = l.XM, l.YM
        s.talon = Golf_Talon(x, y, self, max_rounds=1)
        l.createText(s.talon, "s")
        x = x + l.XS
        s.waste = self.Waste_Class(x, y, self)
        l.createText(s.waste, "s")
        # the Waste is also our only Foundation in this game
        s.foundations.append(s.waste)

        # define stack-groups (non default)
        self.sg.openstacks = [s.waste]
        self.sg.talonstacks = [s.talon]
        self.sg.dropstacks = s.rows

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:21], flip=0)
        self.s.talon.dealRow(rows=self.s.rows[21:])
        self.s.talon.dealCards()          # deal first card to WasteStack


class Escalator(pysollib.game.StartDealRowAndCards, Elevator):
    pass


# ************************************************************************
# * Black Hole
# ************************************************************************

class BlackHole_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # check the rank
        if self.cards:
            r1, r2 = self.cards[-1].rank, cards[0].rank
            return (r1 + 1) % self.cap.mod == r2 or \
                (r2 + 1) % self.cap.mod == r1
        return True

    def getHelp(self):
        return _('Foundation. Build up or down regardless of suit.')


class BlackHole_RowStack(ReserveStack):
    def clickHandler(self, event):
        return self.doubleclickHandler(event)

    def getHelp(self):
        return _('Tableau. No building.')


class BlackHole(Game):
    RowStack_Class = StackWrapper(
        BlackHole_RowStack, max_accept=0, max_cards=3)
    Hint_Class = Golf_Hint
    Solver_Class = BlackHoleSolverWrapper(preset='black_hole')

    #
    # game layout
    #

    def createGame(self, playcards=5):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w = max(2*l.XS, l.XS+(playcards-1)*l.XOFFSET)
        self.setSize(l.XM + 5*w, l.YM + 4*l.YS)

        # create stacks
        y = l.YM
        for i in range(5):
            x = l.XM + i*w
            s.rows.append(self.RowStack_Class(x, y, self))
        for i in range(2):
            y = y + l.YS
            for j in (0, 1, 3, 4):
                x = l.XM + j*w
                s.rows.append(self.RowStack_Class(x, y, self))
        y = y + l.YS
        for i in range(4):
            x = l.XM + i*w
            s.rows.append(self.RowStack_Class(x, y, self))
        for r in s.rows:
            r.CARD_XOFFSET = l.XOFFSET
            r.CARD_YOFFSET = 0
        x, y = l.XM + 2*w, l.YM + 3*l.YS//2
        s.foundations.append(BlackHole_Foundation(x, y, self, suit=ANY_SUIT,
                             dir=0, mod=13, max_move=0, max_cards=52))
        l.createText(s.foundations[0], "s")
        x, y = l.XM + 4*w, self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        # move Ace to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.id == 13, c.suit), 1)

    def startGame(self):
        self._startDealNumRows(2)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.foundations)

    def getAutoStacks(self, event=None):
        if event is None:
            # disable auto drop - this would ruin the whole gameplay
            return ((), (), self.sg.dropstacks)
        else:
            # rightclickHandler
            return ((), self.sg.dropstacks, self.sg.dropstacks)


# ************************************************************************
# * Four Leaf Clovers
# ************************************************************************

class FourLeafClovers_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # check the rank
        if self.cards:
            r1, r2 = self.cards[-1].rank, cards[0].rank
            return (r1 + 1) % self.cap.mod == r2
        return True

    def getHelp(self):
        return _('Foundation. Build up regardless of suit.')


class FourLeafClovers(Game):

    Hint_Class = CautiousDefaultHint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        h = l.YS + 6*l.YOFFSET
        self.setSize(l.XM + 7*l.XS, l.YM + 2*h)

        # create stacks
        y = l.YM
        for i in range(7):
            x = l.XM + i*l.XS
            s.rows.append(
                UD_RK_RowStack(x, y, self, mod=13, base_rank=NO_RANK))
        y = l.YM+h
        for i in range(6):
            x = l.XM + i*l.XS
            s.rows.append(
                UD_RK_RowStack(x, y, self, mod=13, base_rank=NO_RANK))
        stack = FourLeafClovers_Foundation(l.XM+6*l.XS, self.height-l.YS, self,
                                           suit=ANY_SUIT, dir=0, mod=13,
                                           max_move=0, max_cards=52)
        s.foundations.append(stack)
        l.createText(stack, 'n')
        x, y = l.XM + 7*l.XS, self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(3)

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# ************************************************************************
# * All in a Row
# ************************************************************************

class AllInARow(BlackHole):

    Solver_Class = BlackHoleSolverWrapper(preset='all_in_a_row')

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        h = l.YM+l.YS+4*l.YOFFSET
        self.setSize(l.XM+7*l.XS, 3*l.YM+2*h+l.YS)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(7):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += l.XS
        x, y = l.XM, l.YM+h
        for i in range(6):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += l.XS
        for r in s.rows:
            r.CARD_XOFFSET, r.CARD_YOFFSET = 0, l.YOFFSET

        x, y = l.XM, self.height-l.YS
        stack = BlackHole_Foundation(
            x, y, self, ANY_SUIT, dir=0, mod=13, max_move=0, max_cards=52,
            base_rank=ANY_RANK)
        s.foundations.append(stack)
        stack.CARD_XOFFSET, stack.CARD_YOFFSET = (self.width-l.XS)//51, 0
        l.createText(stack, 'n')
        x = self.width-l.XS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(3)


# ************************************************************************
# * Robert
# * Wasatch
# ************************************************************************

class Robert(Game):

    def createGame(self, max_rounds=3, num_deal=1):
        l, s = Layout(self), self.s
        self.setSize(l.XM+4*l.XS, l.YM+2*l.YS)
        x, y = l.XM+3*l.XS//2, l.YM
        stack = BlackHole_Foundation(x, y, self, ANY_SUIT,
                                     dir=0, mod=13, max_move=0, max_cards=52)
        s.foundations.append(stack)
        l.createText(stack, 'ne')
        x, y = l.XM+l.XS, l.YM+l.YS
        s.talon = WasteTalonStack(x, y, self,
                                  max_rounds=max_rounds, num_deal=num_deal)
        l.createText(s.talon, 'nw')
        if max_rounds > 0:
            l.createRoundText(self.s.talon, 'se', dx=l.XS)
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'ne')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealCards()


class Wasatch(Robert):

    def createGame(self):
        Robert.createGame(self, max_rounds=UNLIMITED_REDEALS, num_deal=3)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealCards()


# ************************************************************************
# * Diamond Mine
# ************************************************************************

DIAMOND = 3


class DiamondMine_RowStack(RK_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if cards[0].suit == DIAMOND:
            return False
        if self.cards:
            return self.cards[-1].suit != DIAMOND
        return True


class DiamondMine(Game):

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+13*l.XS, l.YM+2*l.YS+15*l.YOFFSET)

        x, y = l.XM+6*l.XS, l.YM
        s.foundations.append(SS_FoundationStack(x, y, self,
                             base_rank=ANY_RANK, suit=DIAMOND, mod=13))
        x, y = l.XM, l.YM+l.YS
        for i in range(13):
            s.rows.append(DiamondMine_RowStack(x, y, self))
            x += l.XS
        s.talon = InitialDealTalonStack(l.XM, self.height-l.YS, self)

        l.defaultAll()

    def startGame(self):
        for i in range(3):
            self.s.talon.dealRow(flip=0, frames=0)
        self._startAndDealRow()

    def isGameWon(self):
        if len(self.s.foundations[0].cards) != 13:
            return False
        for s in self.s.rows:
            if len(s.cards) == 0:
                continue
            if len(s.cards) != 13:
                return False
            if not isSameSuitSequence(s.cards):
                return False
        return True

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Dolphin
# ************************************************************************

class Dolphin(Game):

    def createGame(self, rows=8, reserves=4, playcards=6):
        l, s = Layout(self), self.s
        self.setSize(l.XM+rows*l.XS, l.YM+3*l.YS+playcards*l.YOFFSET)

        dx = (self.width-l.XM-(reserves+1)*l.XS)//3
        x, y = l.XM+dx, l.YM
        for i in range(reserves):
            s.reserves.append(ReserveStack(x, y, self))
            x += l.XS
        x += dx
        max_cards = 52*self.gameinfo.decks
        s.foundations.append(RK_FoundationStack(x, y, self,
                             base_rank=ANY_RANK, mod=13, max_cards=max_cards))
        l.createText(s.foundations[0], 'ne')
        x, y = l.XM, l.YM+l.YS
        for i in range(rows):
            s.rows.append(BasicRowStack(x, y, self))
            x += l.XS
        s.talon = InitialDealTalonStack(l.XM, self.height-l.YS, self)

        l.defaultAll()

    def startGame(self):
        self._startDealNumRows(5)
        self.s.talon.dealRow()
        self.s.talon.dealRowAvail()


class DoubleDolphin(Dolphin):

    def createGame(self):
        Dolphin.createGame(self, rows=10, reserves=5, playcards=10)

    def startGame(self):
        self._startDealNumRows(9)
        self.s.talon.dealRow()
        self.s.talon.dealRowAvail()


# ************************************************************************
# * Waterfall
# ************************************************************************

class Waterfall_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        c1 = cards[0]
        if not self.cards:
            return c1.rank == ACE and c1.suit == 0
        c2 = self.cards[-1]
        if c2.rank == KING:
            suit = (c2.suit+1) % 4
            rank = ACE
        else:
            suit = c2.suit
            rank = c2.rank+1
        return c1.suit == suit and c1.rank == rank


class Waterfall(Game):

    def createGame(self):
        rows = 8
        l, s = Layout(self), self.s
        self.setSize(l.XM+rows*l.XS, l.YM+2*l.YS+20*l.YOFFSET)

        x, y = l.XM, l.YM
        for i in range(rows):
            s.rows.append(RK_RowStack(x, y, self))
            x += l.XS
        x, y = l.XM+(rows-1)*l.XS//2, self.height-l.YS
        s.foundations.append(Waterfall_Foundation(x, y, self, suit=ANY_SUIT,
                                                  max_cards=104))
        stack = s.foundations[0]
        tx, ty, ta, tf = l.getTextAttr(stack, 'se')
        font = self.app.getFont('canvas_default')
        stack.texts.misc = MfxCanvasText(self.canvas, tx, ty,
                                         anchor=ta, font=font)
        x, y = self.width-l.XS, self.height-l.YS
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, 'sw')

        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(3)

    def updateText(self):
        if self.preview > 1:
            return
        f = self.s.foundations[0]
        if len(f.cards) == 104:
            t = ''
        elif len(f.cards) == 0:
            t = SUITS[0]
        else:
            c = f.cards[-1]
            if c.rank == KING:
                suit = (c.suit+1) % 4
            else:
                suit = c.suit
            t = SUITS[suit]
        f.texts.misc.config(text=t)

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Vague
# * Thirty Two Cards
# ************************************************************************

class Vague_RowStack(BasicRowStack):
    clickHandler = BasicRowStack.doubleclickHandler


class Vague(Game):
    Foundation_Classes = [StackWrapper(SS_FoundationStack,
                                       base_rank=ANY_RANK, mod=13)]

    def createGame(self, rows=3, columns=6):
        l, s = Layout(self), self.s
        decks = self.gameinfo.decks
        maxrows = max(columns, 2+decks*4)
        self.setSize(l.XM+maxrows*l.XS, l.YM+(rows+1)*l.YS)

        x, y = l.XM, l.YM
        s.talon = TalonStack(x, y, self)
        l.createText(s.talon, 'ne')

        x, y = l.XM+2*l.XS, l.YM
        for found in self.Foundation_Classes:
            for i in range(4):
                s.foundations.append(found(x, y, self, suit=i))
                x += l.XS

        y = l.YM+l.YS
        for i in range(rows):
            x = l.XM + (maxrows-columns)*l.XS//2
            for j in range(columns):
                s.rows.append(Vague_RowStack(x, y, self))
                x += l.XS
            y += l.YS

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.flipMove()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            if self.s.talon.cards:
                old_state = self.enterState(self.S_FILL)
                if not self.s.talon.cards[-1].face_up:
                    self.s.talon.flipMove()
                self.s.talon.moveMove(1, stack)
                self.leaveState(old_state)

    def getAutoStacks(self, event=None):
        if event is None:
            # disable auto drop - this would ruin the whole gameplay
            return ((), (), self.sg.dropstacks)
        else:
            # rightclickHandler
            return ((), self.sg.dropstacks, self.sg.dropstacks)


class ThirtyTwoCards(Vague):
    Foundation_Classes = [
        SS_FoundationStack,
        StackWrapper(SS_FoundationStack, base_rank=KING, dir=-1)]

    def createGame(self):
        Vague.createGame(self, rows=4, columns=8)

    def startGame(self):
        self._startAndDealRow()


# ************************************************************************
# * Devil's Solitaire
# ************************************************************************

class DevilsSolitaire_Foundation(RK_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if self.cards:
            return True
        if self.game.s.reserves[0].cards:
            c = self.game.s.reserves[0].cards[-1]
            return (c.rank+1) % 13 == cards[-1].rank
        return True


class DevilsSolitaire_WasteStack(WasteStack):
    clickHandler = WasteStack.doubleclickHandler


class DevilsSolitaire(Game):

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+9*l.XS, l.YM+3*l.YS+7*l.YOFFSET+2*l.TEXT_HEIGHT)

        x, y = l.XM+4*l.XS, l.YM
        stack = DevilsSolitaire_Foundation(
            x, y, self, suit=ANY_SUIT, base_rank=ANY_RANK, mod=13)
        tx, ty, ta, tf = l.getTextAttr(stack, 'nw')
        font = self.app.getFont('canvas_default')
        stack.texts.misc = MfxCanvasText(self.canvas, tx, ty,
                                         anchor=ta, font=font)
        s.foundations.append(stack)

        x, y = self.width-l.XS, l.YM
        stack = AbstractFoundationStack(
            x, y, self,
            suit=ANY_SUIT, max_move=0, max_cards=104,
            max_accept=0, base_rank=ANY_RANK)
        l.createText(stack, 'nw')
        s.foundations.append(stack)

        x, y = l.XM, l.YM+l.YS
        for i in range(4):
            s.rows.append(Vague_RowStack(x, y, self))
            x += l.XS
        x += l.XS
        for i in range(4):
            s.rows.append(Vague_RowStack(x, y, self))
            x += l.XS

        x, y = l.XM+4*l.XS, l.YM+l.YS
        stack = OpenStack(x, y, self)
        stack.CARD_YOFFSET = l.YOFFSET
        s.reserves.append(stack)

        x, y = l.XM+4.5*l.XS, self.height-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, 'n')
        l.createRoundText(s.talon, 'nnn')
        x -= l.XS
        s.waste = DevilsSolitaire_WasteStack(x, y, self)
        l.createText(s.waste, 'n')

        l.defaultStackGroups()

    def startGame(self):
        for i in range(8):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def fillStack(self, stack):
        old_state = self.enterState(self.S_FILL)
        if stack in self.s.rows and not stack.cards:
            if not self.s.waste.cards:
                self.s.talon.dealCards()
            if self.s.waste.cards:
                self.s.waste.moveMove(1, stack)
        f0 = self.s.foundations[0]
        if len(f0.cards) == 12:
            self.moveMove(1, self.s.reserves[0], f0, frames=4)
            f1 = self.s.foundations[1]
            for i in range(13):
                self.moveMove(1, f0, f1, frames=4)
        self.leaveState(old_state)

    def updateText(self):
        if self.preview > 1:
            return
        f = self.s.foundations[0]
        r = self.s.reserves[0]
        if not r.cards:
            t = ''
        else:
            c = r.cards[-1]
            t = RANKS[(c.rank+1) % 13]
        f.texts.misc.config(text=t)


# ************************************************************************
# * Three Fir-trees
# ************************************************************************

class ThreeFirTrees_RowStack(Golf_RowStack):
    def __init__(self, x, y, game):
        Golf_RowStack.__init__(self, x, y, game, max_accept=0, max_cards=1)
        self.CARD_YOFFSET = 0
        self.blockmap = []

    def basicIsBlocked(self):
        for r in self.blockmap:
            if r.cards:
                return True
        return False

    getBottomImage = Stack._getNoneBottomImage


class FirTree_GameMethods:
    def _createFirTree(self, l, x0, y0):
        rows = []
        # create stacks
        for i in range(11):
            x = x0 + ((i+1) % 2) * l.XS // 2
            y = y0 + i * l.YS // 4
            for j in range((i % 2) + 1):
                rows.append(ThreeFirTrees_RowStack(x, y, self))
                x += l.XS
        # compute blocking
        n = 0
        for i in range(10):
            if i % 2:
                rows[n].blockmap = [rows[n+2]]
                rows[n+1].blockmap = [rows[n+2]]
                n += 2
            else:
                rows[n].blockmap = [rows[n+1], rows[n+2]]
                n += 1
        return rows


class ThreeFirTrees(Golf, FirTree_GameMethods):
    Hint_Class = CautiousDefaultHint
    Waste_Class = Golf_Waste

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+max(7*l.XS, 2*l.XS+26*l.XOFFSET), l.YM+5*l.YS)

        x0, y0 = (self.width-7*l.XS)//2, l.YM
        for i in range(3):
            s.rows += self._createFirTree(l, x0, y0)
            x0 += 2.5*l.XS

        x, y = l.XM, self.height - l.YS
        s.talon = Golf_Talon(x, y, self, max_rounds=1)
        l.createText(s.talon, 'n')
        x += l.XS
        s.waste = self.Waste_Class(x, y, self)
        s.waste.CARD_XOFFSET = l.XOFFSET//4
        l.createText(s.waste, 'n')
        # the Waste is also our only Foundation in this game
        s.foundations.append(s.waste)

        # define stack-groups (non default)
        self.sg.openstacks = [s.waste]
        self.sg.talonstacks = [s.talon]
        self.sg.dropstacks = s.rows

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(frames=4)
        self.s.talon.dealCards()


class RelaxedThreeFirTrees(ThreeFirTrees):
    Waste_Class = StackWrapper(Golf_Waste, mod=13)


# ************************************************************************
# * Napoleon Takes Moscow
# * Napoleon Leaves Moscow
# ************************************************************************

class NapoleonTakesMoscow(Game, FirTree_GameMethods):
    RowStack_Class = StackWrapper(SS_RowStack, base_rank=KING, max_move=1)
    Hint_Class = CautiousDefaultHint

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+10*l.XS, l.YM+3*l.YS+15*l.YOFFSET)

        x, y = l.XM+l.XS, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2))
            x += l.XS

        x, y = l.XM, l.YM+l.YS
        for i in range(2):
            for j in range(4):
                s.rows.append(self.RowStack_Class(x, y, self))
                x += l.XS
            x += 2*l.XS

        x, y = l.XM+4*l.XS, l.YM+l.YS
        s.reserves += self._createFirTree(l, x, y)

        x, y = l.XM, self.height-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, 'n')
        l.createRoundText(s.talon, 'nnn')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'n')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self._startDealNumRowsAndDealRowAndCards(3)

    shallHighlightMatch = Game._shallHighlightMatch_SS


class NapoleonLeavesMoscow(NapoleonTakesMoscow):
    RowStack_Class = StackWrapper(SS_RowStack, base_rank=KING)
    Hint_Class = DefaultHint

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self._startDealNumRowsAndDealRowAndCards(4)


# ************************************************************************
# * Flake
# * Flake (2 decks)
# ************************************************************************


class Flake(Game):
    Hint_Class = FourByFour_Hint  # CautiousDefaultHint

    def createGame(self, rows=6, playcards=18):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + rows*l.XS, l.YM + 2*l.YS + playcards*l.XOFFSET)

        # create stacks
        x, y, = l.XM, l.YM+l.YS
        for i in range(rows):
            s.rows.append(UD_RK_RowStack(x, y, self, mod=13))
            x += l.XS

        x, y = l.XM + (rows-1)*l.XS//2, l.YM
        stack = BlackHole_Foundation(x, y, self, max_move=0, suit=ANY_SUIT,
                                     base_rank=ANY_RANK, dir=0, mod=13,
                                     max_cards=52*self.gameinfo.decks)
        s.foundations.append(stack)
        l.createText(stack, 'ne')

        x, y = l.XM, self.height-l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRows(7)
        self.s.talon.dealRow()
        self.s.talon.dealRowAvail()

    shallHighlightMatch = Game._shallHighlightMatch_RKW


class Flake2Decks(Flake):
    def createGame(self):
        Flake.createGame(self, rows=8, playcards=22)

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(12)


# ************************************************************************
# * Beacon
# ************************************************************************

class Beacon(Game):

    def createGame(self, rows=8):
        # create layout
        l, s = Layout(self), self.s

        # set window
        playcards = 12
        self.setSize(l.XM+rows*l.XS, l.YM+3*l.YS+playcards*l.YOFFSET)

        # create stacks
        x, y = l.XM + (rows-1)*l.XS//2, l.YM
        stack = RK_FoundationStack(x, y, self, base_rank=ANY_RANK,
                                   max_cards=52, mod=13)
        s.foundations.append(stack)
        l.createText(stack, 'ne')

        x, y = l.XM, l.YM+l.YS
        for i in range(rows):
            s.rows.append(RK_RowStack(x, y, self, base_rank=NO_RANK, mod=13))
            x += l.XS

        x, y = l.XM, self.height-l.YS
        s.talon = TalonStack(x, y, self)
        l.createText(s.talon, 'se')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(3)

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            if self.s.talon.cards:
                old_state = self.enterState(self.S_FILL)
                self.s.talon.flipMove()
                self.s.talon.moveMove(1, stack)
                self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# register the game
registerGame(GameInfo(36, Golf, "Golf",
                      GI.GT_GOLF, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(259, DeadKingGolf, "Dead King Golf",
                      GI.GT_GOLF, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(260, RelaxedGolf, "Relaxed Golf",
                      GI.GT_GOLF | GI.GT_RELAXED, 1, 0, GI.SL_BALANCED,
                      altnames=("Putt Putt",)))
registerGame(GameInfo(40, Elevator, "Elevator",
                      GI.GT_GOLF, 1, 0, GI.SL_BALANCED,
                      altnames=("Egyptian Solitaire", "Pyramid Golf")))
registerGame(GameInfo(98, BlackHole, "Black Hole",
                      GI.GT_GOLF | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(267, FourLeafClovers, "Four Leaf Clovers",
                      GI.GT_GOLF | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(281, Escalator, "Escalator",
                      GI.GT_GOLF, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(405, AllInARow, "All in a Row",
                      GI.GT_GOLF | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(432, Robert, "Robert",
                      GI.GT_GOLF, 1, 2, GI.SL_LUCK))
registerGame(GameInfo(551, DiamondMine, "Diamond Mine",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(661, Dolphin, "Dolphin",
                      GI.GT_GOLF | GI.GT_ORIGINAL, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(662, DoubleDolphin, "Double Dolphin",
                      GI.GT_GOLF | GI.GT_ORIGINAL, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(709, Waterfall, "Waterfall",
                      GI.GT_2DECK_TYPE | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(720, Vague, "Vague",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(723, DevilsSolitaire, "Devil's Solitaire",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_BALANCED,
                      altnames=('Banner',)))
registerGame(GameInfo(728, ThirtyTwoCards, "Thirty Two Cards",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_LUCK))
registerGame(GameInfo(731, ThreeFirTrees, "Three Fir-trees",
                      GI.GT_GOLF, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(733, NapoleonTakesMoscow, "Napoleon Takes Moscow",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(734, NapoleonLeavesMoscow, "Napoleon Leaves Moscow",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(749, Flake, "Flake",
                      GI.GT_GOLF | GI.GT_OPEN | GI.GT_ORIGINAL,
                      1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(750, Flake2Decks, "Flake (2 decks)",
                      GI.GT_GOLF | GI.GT_OPEN | GI.GT_ORIGINAL,
                      2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(763, Wasatch, "Wasatch",
                      GI.GT_1DECK_TYPE, 1, UNLIMITED_REDEALS,
                      GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(764, Beacon, "Beacon",
                      GI.GT_1DECK_TYPE | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(768, RelaxedThreeFirTrees, "Relaxed Three Fir-trees",
                      GI.GT_GOLF, 2, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.numerica import Numerica_Hint
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.stack import \
        AbstractFoundationStack, \
        BasicRowStack, \
        DealRowTalonStack, \
        OpenStack, \
        OpenTalonStack, \
        RK_FoundationStack, \
        RedealTalonStack, \
        ReserveStack, \
        SS_FoundationStack, \
        Stack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, ANY_RANK, ANY_SUIT, KING, QUEEN


# ************************************************************************
# * Tam O'Shanter
# ************************************************************************

class TamOShanter(Game):
    Talon_Class = DealRowTalonStack
    Foundation_Class = RK_FoundationStack
    RowStack_Class = StackWrapper(BasicRowStack, max_move=1, max_accept=0)

    def createGame(self, rows=4, texts=False, yoffset=None):
        # create layout
        l, s = Layout(self), self.s

        # set window
        if yoffset is None:
            yoffset = l.YOFFSET
        max_rows = max(rows, 4*self.gameinfo.decks)
        self.setSize(l.XM+(2+max_rows)*l.XS, l.YM+2*l.YS+12*yoffset)

        # create stacks
        if texts:
            x, y, = l.XM, l.YM+l.YS//2
        else:
            x, y, = l.XM, l.YM
        s.talon = self.Talon_Class(x, y, self)
        l.createText(s.talon, "s")
        if texts:
            l.createRoundText(s.talon, 'nn')
        x, y = l.XM+2*l.XS, l.YM
        for i in range(4*self.gameinfo.decks):
            s.foundations.append(
                self.Foundation_Class(x, y, self, suit=i % 4))
            x += l.XS
        x, y = l.XM+2*l.XS, l.YM+l.YS
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self)
            s.rows.append(stack)
            stack.CARD_YOFFSET = yoffset
            x += l.XS

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self._startAndDealRow()

    def getAutoStacks(self, event=None):
        return ((), (), self.sg.dropstacks)


# ************************************************************************
# * Auld Lang Syne
# ************************************************************************

class AuldLangSyne(TamOShanter):
    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRow()

# ************************************************************************
# * Strategy
# * Strategy +
# ************************************************************************


class Strategy_Foundation(SS_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # we only accept cards if there are no cards in the talon
        return len(self.game.s.talon.cards) == 0


class Strategy_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        # this stack accepts any one card from the Talon
        return from_stack is self.game.s.talon and len(cards) == 1

    def canMoveCards(self, cards):
        if self.game.s.talon.cards:
            return False
        return BasicRowStack.canMoveCards(self, cards)

    def clickHandler(self, event):
        if self.game.s.talon.cards:
            self.game.s.talon.playMoveMove(1, self)
            return 1
        return BasicRowStack.clickHandler(self, event)

    def doubleclickHandler(self, event):
        if self.game.s.talon.cards:
            self.game.s.talon.playMoveMove(1, self)
            return 1
        return BasicRowStack.doubleclickHandler(self, event)

    getBottomImage = Stack._getReserveBottomImage

    def getHelp(self):
        return _('Tableau. Build regardless of rank and suit.')


class Strategy(Game):
    Hint_Class = Numerica_Hint

    def createGame(self, rows=8):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + rows*l.XS, l.YM + 4*l.YS)

        # create stacks
        x, y, = l.XM, l.YM
        s.talon = OpenTalonStack(x, y, self)
        l.createText(s.talon, "se")
        for i in range(4):
            x, y = l.XM + (i+2)*l.XS, l.YM
            s.foundations.append(
                Strategy_Foundation(x, y, self, suit=i, max_move=0))
        x, y = l.XM, l.YM+l.YS
        for i in range(rows):
            s.rows.append(Strategy_RowStack(x, y,
                                            self, max_move=1, max_accept=1))
            x += l.XS

        # define stack-groups
        l.defaultStackGroups()
        self.sg.dropstacks.append(s.talon)

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.fillStack()


class StrategyPlus(Strategy):

    def createGame(self):
        Strategy.createGame(self, rows=6)

    def _shuffleHook(self, cards):
        return cards

    def startGame(self):
        self.s.talon.fillStack()

    def fillStack(self, stack):
        if stack is self.s.talon and stack.cards:
            old_state = self.enterState(self.S_FILL)
            c = stack.cards[-1]
            while c.rank == ACE:
                self.moveMove(1, stack, self.s.foundations[c.suit])
                if stack.canFlipCard():
                    stack.flipMove(animation=True)
                if not stack.cards:
                    break
                c = stack.cards[-1]
            self.leaveState(old_state)


# ************************************************************************
# * Interregnum
# ************************************************************************

class Interregnum_Foundation(RK_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if len(self.cards) == 12:
            # the final card must come from the reserve above the foundation
            return from_stack.id == self.id - 8
        else:
            # card must come from rows
            return from_stack in self.game.s.rows


class Interregnum(Game):
    GAME_VERSION = 2

    Talon_Class = DealRowTalonStack
    RowStack_Class = StackWrapper(BasicRowStack, max_accept=0, max_move=1)

    #
    # game layout
    #

    def createGame(self, rows=8, playcards=12, texts=False):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+max(9, rows)*l.XS, l.YM+3*l.YS+playcards*l.YOFFSET)

        # extra settings
        self.base_cards = None

        # create stacks
        for i in range(8):
            x, y, = l.XM + i*l.XS, l.YM
            s.reserves.append(ReserveStack(x, y, self, max_accept=0))
        for i in range(8):
            x, y, = l.XM + i*l.XS, l.YM + l.YS
            s.foundations.append(
                Interregnum_Foundation(x, y, self, mod=13, max_move=0))
        for i in range(rows):
            x, y, = l.XM + (2*i+8-rows)*l.XS//2, l.YM + 2*l.YS
            s.rows.append(self.RowStack_Class(x, y, self))
        s.talon = self.Talon_Class(self.width-l.XS, self.height-l.YS, self)
        if texts:
            l.createRoundText(s.talon, 'nn')
        else:
            l.createText(s.talon, "n")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        # deal base_cards to reserves, update foundations cap.base_rank
        self.base_cards = []
        for i in range(8):
            self.base_cards.append(self.s.talon.getCard())
            self.s.foundations[i].cap.base_rank = \
                (self.base_cards[i].rank + 1) % 13
            self.flipMove(self.s.talon)
            self.moveMove(1, self.s.talon, self.s.reserves[i])

    def getAutoStacks(self, event=None):
        return ((), (), self.sg.dropstacks)

    shallHighlightMatch = Game._shallHighlightMatch_RKW

    def _restoreGameHook(self, game):
        self.base_cards = [None] * 8
        for i in range(8):
            id = game.loadinfo.base_card_ids[i]
            self.base_cards[i] = self.cards[id]
            self.s.foundations[i].cap.base_rank = \
                (self.base_cards[i].rank + 1) % 13

    def _loadGameHook(self, p):
        ids = []
        for i in range(8):
            ids.append(p.load())
        self.loadinfo.addattr(base_card_ids=ids)    # register extra load var.

    def _saveGameHook(self, p):
        for c in self.base_cards:
            p.dump(c.id)


# ************************************************************************
# * Primrose
# ************************************************************************

class Primrose_Talon(DealRowTalonStack):

    def canDealCards(self):
        if self.round == self.max_rounds and not self.cards:
            return False
        return not self.game.isGameWon()

    def _redeal(self):
        r = self.game.s.rows[self.round-1]
        for i in range(len(r.cards)):
            self.game.moveMove(1, r, self, frames=4)
            self.game.flipMove(self)
        self.game.nextRoundMove(self)

    def dealCards(self, sound=False):
        if sound:
            self.game.startDealSample()
        if len(self.cards) == 0:
            self._redeal()
        if self.round == 1:
            n = self.dealRowAvail(sound=False)
        else:
            rows = self.game.s.rows
            n = self.dealRowAvail(rows=rows[self.round-2:], sound=False)
            while self.cards:
                n += self.dealRowAvail(rows=rows, sound=False)
        if sound:
            self.game.stopSamples()
        return n


class Primrose(Interregnum):
    Talon_Class = StackWrapper(Primrose_Talon, max_rounds=9)

    def createGame(self):
        Interregnum.createGame(self, playcards=16, texts=True)

    def startGame(self):
        self._dealNumRows(11)
        Interregnum.startGame(self)


# ************************************************************************
# * Colorado
# ************************************************************************

class Colorado_RowStack(OpenStack):
    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return False
        # this stack accepts any one card from the Waste
        return from_stack is self.game.s.waste and len(cards) == 1


class Colorado(Game):

    Foundation_Class = SS_FoundationStack
    RowStack_Class = Colorado_RowStack

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+10*l.XS, l.YM+4*l.YS+l.TEXT_HEIGHT)

        # create stacks
        x, y, = l.XS, l.YM
        for i in range(4):
            s.foundations.append(self.Foundation_Class(x, y, self,
                                 suit=i, max_move=0))
            x += l.XS
        x += 2*l.XM
        for i in range(4):
            s.foundations.append(self.Foundation_Class(x, y, self,
                                 suit=i, max_move=0, base_rank=KING, dir=-1))
            x += l.XS

        y = l.YM+l.YS
        for i in range(2):
            x = l.XM
            for j in range(10):
                stack = self.RowStack_Class(x, y, self,
                                            max_move=1, max_accept=1)
                s.rows.append(stack)
                stack.CARD_XOFFSET = stack.CARD_YOFFSET = 0
                x += l.XS
            y += l.YS

        x, y = l.XM + 9*l.XS, self.height - l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "n")
        x -= l.XS
        s.waste = WasteStack(x, y, self, max_cards=1)

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.deck == 0 and c.rank in (0, 12),
                              (c.rank, c.suit)), 8)

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards and self.s.waste.cards:
            self.s.waste.moveMove(1, stack)


# ************************************************************************
# * Amazons
# ************************************************************************

class Amazons_Talon(RedealTalonStack):

    def canDealCards(self):
        return not self.game.isGameWon()

    def dealCards(self, sound=False):
        if not self.cards:
            RedealTalonStack.redealCards(self, frames=4, sound=sound)
        return self.dealRowAvail(sound=sound)

    def dealRowAvail(self, rows=None, flip=1, reverse=0,
                     frames=-1, sound=False):
        if rows is None:
            rows = []
            i = 0
            for f in self.game.s.foundations:
                if len(f.cards) < 7:
                    rows.append(self.game.s.rows[i])
                i += 1
        return RedealTalonStack.dealRowAvail(
            self, rows=rows, flip=flip, reverse=reverse, frames=frames,
            sound=sound)


class Amazons_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack not in self.game.s.rows:
            return False
        if cards[0].rank == ACE:
            return True
        if not self.cards:
            return False
        rank = self.cards[-1].rank
        if rank == ACE:
            rank = 5
        if (rank + self.cap.dir) % self.cap.mod != cards[0].rank:
            return False
        if cards[0].rank == QUEEN:
            return True
        i = list(self.game.s.foundations).index(self)
        j = list(self.game.s.rows).index(from_stack)
        return i == j


class Amazons(AuldLangSyne):
    Talon_Class = StackWrapper(Amazons_Talon, max_rounds=-1)
    Foundation_Class = StackWrapper(Amazons_Foundation, max_cards=7)

    def _shuffleHook(self, cards):
        return cards

    def startGame(self):
        self._startAndDealRow()


# ************************************************************************
# * Scuffle
# * Acquaintance
# ************************************************************************

class Scuffle_Talon(RedealTalonStack):

    def canDealCards(self):
        if self.round == self.max_rounds:
            return len(self.cards) != 0
        return not self.game.isGameWon()

    def dealCards(self, sound=False, shuffle=True):
        if self.cards:
            return self.dealRowAvail(sound=sound)
        self.redealCards(frames=4, shuffle=shuffle, sound=sound)
        return self.dealRowAvail(sound=sound)


class Scuffle(AuldLangSyne):
    Talon_Class = StackWrapper(Scuffle_Talon, max_rounds=3)

    def createGame(self):
        AuldLangSyne.createGame(self, texts=True, yoffset=0)


class Acquaintance_Talon(Scuffle_Talon):
    def dealCards(self, sound=False):
        Scuffle_Talon.dealCards(self, sound=sound, shuffle=False)


class Acquaintance(AuldLangSyne):
    Talon_Class = StackWrapper(Acquaintance_Talon, max_rounds=3)

    def createGame(self, texts=False, yoffset=None):
        AuldLangSyne.createGame(self, texts=True)


class DoubleAcquaintance(AuldLangSyne):
    Talon_Class = StackWrapper(Acquaintance_Talon, max_rounds=3)

    def createGame(self):
        AuldLangSyne.createGame(self, rows=8, texts=True)


# ************************************************************************
# * Formic
# ************************************************************************

class Formic_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # check the rank
        return ((self.cards[-1].rank+1) % 13 == cards[0].rank or
                (self.cards[-1].rank-1) % 13 == cards[0].rank)

    def getHelp(self):
        return _('Foundation. Build up or down regardless of suit.')


class Formic(TamOShanter):

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+6*l.XS, l.YM+2*l.YS+12*l.YOFFSET)

        x, y, = l.XM, l.YM
        s.talon = self.Talon_Class(x, y, self)
        l.createText(s.talon, "s")
        x, y = l.XM+2*l.XS, l.YM
        for i in range(4):
            s.foundations.append(Formic_Foundation(x, y, self,
                                 suit=ANY_SUIT, base_rank=ANY_RANK,
                                 max_cards=52, max_move=0))
            x += l.XS
        x, y = l.XM+2*l.XS, l.YM+l.YS
        for i in range(4):
            s.rows.append(BasicRowStack(x, y, self, max_move=1, max_accept=0))
            x += l.XS

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        suits = []
        top_cards = []
        for c in cards[:]:
            if c.suit not in suits:
                suits.append(c.suit)
                top_cards.append(c)
                cards.remove(c)
            if len(suits) == 4:
                break
        top_cards.sort(key=lambda x: -x.suit)  # sort by suit
        return cards+top_cards

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRow()


# register the game
registerGame(GameInfo(172, TamOShanter, "Tam O'Shanter",
                      GI.GT_NUMERICA, 1, 0, GI.SL_LUCK))
registerGame(GameInfo(95, AuldLangSyne, "Auld Lang Syne",
                      GI.GT_NUMERICA, 1, 0, GI.SL_LUCK,
                      altnames=("Patience",)))
registerGame(GameInfo(173, Strategy, "Strategy",
                      GI.GT_NUMERICA, 1, 0, GI.SL_SKILL))
registerGame(GameInfo(123, Interregnum, "Interregnum",
                      GI.GT_NUMERICA, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(296, Colorado, "Colorado",
                      GI.GT_NUMERICA, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(406, Amazons, "Amazons",
                      GI.GT_NUMERICA, 1, -1, GI.SL_LUCK,
                      ranks=(0, 6, 7, 8, 9, 10, 11),
                      ))
registerGame(GameInfo(490, Acquaintance, "Acquaintance",
                      GI.GT_NUMERICA, 1, 2, GI.SL_BALANCED))
registerGame(GameInfo(553, Scuffle, "Scuffle",
                      GI.GT_NUMERICA, 1, 2, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(560, DoubleAcquaintance, "Double Acquaintance",
                      GI.GT_NUMERICA, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(569, Primrose, "Primrose",
                      GI.GT_NUMERICA, 2, 8, GI.SL_BALANCED))
registerGame(GameInfo(636, StrategyPlus, "Strategy +",
                      GI.GT_NUMERICA, 1, 0, GI.SL_SKILL))
registerGame(GameInfo(688, Formic, "Formic",
                      GI.GT_NUMERICA, 1, 0, GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------
from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.montecarlo import MonteCarlo_RowStack
from pysollib.layout import Layout
from pysollib.stack import \
        AbstractFoundationStack, \
        BasicRowStack, \
        DealRowTalonStack, \
        OpenStack, \
        RK_RowStack, \
        ReserveStack, \
        Spider_RK_Foundation, \
        Stack, \
        StackWrapper, \
        TalonStack, \
        isRankSequence
from pysollib.util import ACE, ANY_RANK, ANY_SUIT, NO_RANK, \
        UNLIMITED_ACCEPTS, \
        UNLIMITED_MOVES


# ************************************************************************
# * Aces Up
# ************************************************************************

class AcesUp_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        c = cards[0]
        for s in self.game.s.rows:
            if s is not from_stack and s.cards and s.cards[-1].suit == c.suit:
                if s.cards[-1].rank > c.rank or s.cards[-1].rank == ACE:
                    # found a higher rank or an Ace on the row stacks
                    return c.rank != ACE
        return False


class AcesUp_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        return len(self.cards) == 0

    clickHandler = BasicRowStack.doubleclickHandler


class AcesUp(Game):
    Foundation_Class = AcesUp_Foundation
    Talon_Class = DealRowTalonStack
    RowStack_Class = StackWrapper(AcesUp_RowStack, max_accept=1)

    #
    # game layout
    #

    def createGame(self, rows=4, reserve=False, **layout):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + (rows+3)*l.XS, l.YM + 4*l.YS)

        # create stacks
        x, y, = l.XM, l.YM
        s.talon = self.Talon_Class(x, y, self)
        if reserve:
            l.createText(s.talon, "ne")
        else:
            l.createText(s.talon, "s")
        x = x + 3*l.XS//2
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self))
            x = x + l.XS
        x = x + l.XS//2
        stack = self.Foundation_Class(x, y, self, suit=ANY_SUIT, max_move=0,
                                      dir=0, base_rank=ANY_RANK, max_cards=48)
        l.createText(stack, "s")
        s.foundations.append(stack)

        if reserve:
            x, y = l.XM, l.YM+l.YS
            s.reserves.append(self.ReserveStack_Class(x, y, self))

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self._startAndDealRow()

    def isGameWon(self):
        if len(self.s.foundations[0].cards) != 48:
            return False
        for s in self.s.rows:
            if len(s.cards) != 1 or s.cards[0].rank != ACE:
                return False
        return True

    def getAutoStacks(self, event=None):
        if event is None:
            # disable auto drop - this would ruin the whole gameplay
            return (self.sg.dropstacks, (), self.sg.dropstacks)
        else:
            # rightclickHandler
            return (self.sg.dropstacks, self.sg.dropstacks, self.sg.dropstacks)


# ************************************************************************
# * Fortunes
# ************************************************************************

class Fortunes(AcesUp):
    RowStack_Class = StackWrapper(
        AcesUp_RowStack, max_move=UNLIMITED_MOVES,
        max_accept=UNLIMITED_ACCEPTS)


# ************************************************************************
# * Russian Aces
# ************************************************************************

class RussianAces_Talon(DealRowTalonStack):
    def dealCards(self, sound=False):
        rows = [s for s in self.game.s.rows if not s.cards]
        if not rows:
            rows = self.game.s.rows
        return self.dealRowAvail(rows=rows, sound=sound)


class RussianAces(AcesUp):
    Talon_Class = RussianAces_Talon


# ************************************************************************
# * Perpetual Motion
# ************************************************************************

class PerpetualMotion_Talon(DealRowTalonStack):
    def canDealCards(self):
        # FIXME: this is to avoid loops in the demo
        if self.game.demo and self.game.moves.index >= 500:
            return False
        return not self.game.isGameWon()

    def dealCards(self, sound=False):
        if self.cards:
            return DealRowTalonStack.dealCards(self, sound=sound)
        if sound:
            self.game.startDealSample()
        game, num_cards = self.game, len(self.cards)
        rows = list(game.s.rows)[:]
        rows.reverse()
        for r in rows:
            while r.cards:
                num_cards = num_cards + 1
                game.moveMove(1, r, self, frames=4)
                if self.cards[-1].face_up:
                    game.flipMove(self)
        assert len(self.cards) == num_cards
        n = DealRowTalonStack.dealCards(self, sound=False)
        if sound:
            self.game.stopSamples()
        return n


class PerpetualMotion_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        return isRankSequence(cards, dir=0)


class PerpetualMotion_RowStack(RK_RowStack):
    def canDropCards(self, stacks):
        pile = self.getPile()
        if not pile or len(pile) != 4:
            return (None, 0)
        for s in stacks:
            if s is not self and s.acceptsCards(self, pile):
                return (s, 4)
        return (None, 0)


class PerpetualMotion(Game):

    #
    # game layout
    #

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 7*l.XS, l.YM + 4*l.YS)

        # create stacks
        x, y, = l.XM, l.YM
        s.talon = PerpetualMotion_Talon(x, y, self, max_rounds=-1)
        l.createText(s.talon, "s")
        x = x + 3*l.XS//2
        for i in range(4):
            s.rows.append(
                PerpetualMotion_RowStack(x, y, self, dir=0, base_rank=NO_RANK))
            x = x + l.XS
        x = l.XM + 6*l.XS
        stack = PerpetualMotion_Foundation(x, y, self, ANY_SUIT,
                                           base_rank=ANY_RANK,
                                           max_cards=52, max_move=0,
                                           min_accept=4, max_accept=4)
        l.createText(stack, "s")
        s.foundations.append(stack)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self._startAndDealRow()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank == card2.rank


# ************************************************************************
# *
# ************************************************************************

class AcesUp5(AcesUp):

    def createGame(self):
        AcesUp.createGame(self, rows=5)

    def isGameWon(self):
        return len(self.s.foundations[0].cards) == 48


# ************************************************************************
# * Cover
# * Deck
# ************************************************************************

class Cover_RowStack(MonteCarlo_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return False
        return self.cards[-1].suit == cards[0].suit


class Cover(AcesUp):
    Foundation_Class = StackWrapper(AbstractFoundationStack, max_accept=0)
    Talon_Class = TalonStack
    RowStack_Class = StackWrapper(Cover_RowStack, max_accept=1)

    FILL_STACKS_AFTER_DROP = 0          # for MonteCarlo_RowStack

    def fillStack(self, stack):
        if not self.s.talon.cards:
            return
        self.startDealSample()
        for r in self.s.rows:
            if not r.cards:
                self.flipMove(self.s.talon)
                self.moveMove(1, self.s.talon, r)
        self.stopSamples()

    def isGameWon(self):
        if self.s.talon.cards:
            return False
        return len(self.s.foundations[0].cards) == 48


class Deck(Cover):
    Talon_Class = DealRowTalonStack

    def fillStack(self, stack):
        pass


# ************************************************************************
# * Firing Squad
# ************************************************************************

class FiringSquad_Foundation(AcesUp_Foundation):
    def acceptsCards(self, from_stack, cards):
        if not AcesUp_Foundation.acceptsCards(self, from_stack, cards):
            return False
        return from_stack in self.game.s.rows


class FiringSquad(AcesUp):
    Foundation_Class = FiringSquad_Foundation
    ReserveStack_Class = ReserveStack

    def createGame(self):
        AcesUp.createGame(self, reserve=True)


# ************************************************************************
# * Tabby Cat
# * Manx
# * Maine Coon
# ************************************************************************

class TabbyCatStack(RK_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_RowStack.acceptsCards(self, from_stack, cards):
            return False
        # Only allow a sequence if pile is empty
        if len(self.cards) > 0:
            return False
        return True

    getBottomImage = Stack._getReserveBottomImage


class TabbyCat(Game):
    Talon_Class = DealRowTalonStack
    Foundation_Class = Spider_RK_Foundation
    RowStack_Class = StackWrapper(RK_RowStack, mod=13)
    ReserveStack_Class = StackWrapper(TabbyCatStack, mod=13)

    #
    # game layout
    #

    def createGame(self, rows=4, playcards=20):
        # create layout
        l, s = Layout(self), self.s
        decks = self.gameinfo.decks

        # set window
        self.setSize(l.XM + (decks+rows+3.5)*l.XS,
                     l.YM + max(4*l.YS, l.YS+playcards*l.YOFFSET))

        # create stacks
        x = l.XM
        for i in range(decks):
            y = l.YM
            for j in range(4):
                s.foundations.append(self.Foundation_Class(x, y, self))
                y += l.YS
            x += l.XS

        x, y, = l.XM + (decks+0.5)*l.XS, l.YM
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self)
            s.rows.append(stack)
            stack.canDropCards = stack.spiderCanDropCards
            x += l.XS
        x += l.XS//2
        s.reserves.append(self.ReserveStack_Class(x, y, self))
        x += 1.5*l.XS
        s.talon = self.Talon_Class(x, y, self)
        l.createText(s.talon, "s")

        self.setRegion(s.foundations, (-999, -999, l.YS*decks-l.CH//2, 999999))

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startAndDealRow()

    shallHighlightMatch = Game._shallHighlightMatch_RKW


class Manx(TabbyCat):
    ReserveStack_Class = ReserveStack


class MaineCoon(TabbyCat):
    def createGame(self):
        TabbyCat.createGame(self, playcards=26)


# register the game
registerGame(GameInfo(903, AcesUp, "Aces Up",                   # was: 52
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_LUCK,
                      altnames=("Aces High", "Drivel")))
registerGame(GameInfo(206, Fortunes, "Fortunes",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_LUCK))
registerGame(GameInfo(213, RussianAces, "Russian Aces",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_LUCK))
registerGame(GameInfo(130, PerpetualMotion, "Perpetual Motion",
                      GI.GT_1DECK_TYPE, 1, -1, GI.SL_MOSTLY_LUCK,
                      altnames="First Law"))
registerGame(GameInfo(353, AcesUp5, "Aces Up 5",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_LUCK))
registerGame(GameInfo(552, Cover, "Cover",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_LUCK))
registerGame(GameInfo(583, FiringSquad, "Firing Squad",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(684, Deck, "Deck",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_LUCK))
registerGame(GameInfo(756, TabbyCat, "Tabby Cat",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(757, Manx, "Manx",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(758, MaineCoon, "Maine Coon",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import pysollib.game
from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.canfield import CanfieldRush_Talon
from pysollib.hint import CautiousDefaultHint
from pysollib.hint import FreeCellSolverWrapper
from pysollib.hint import KlondikeType_Hint
from pysollib.layout import Layout
from pysollib.mfxutil import Struct, kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AC_RowStack, \
        BO_RowStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        KingAC_RowStack, \
        OpenStack, \
        OpenTalonStack, \
        RK_FoundationStack, \
        RK_RowStack, \
        RedealTalonStack, \
        ReserveStack, \
        SC_RowStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        Stack, \
        StackWrapper, \
        SuperMoveAC_RowStack, \
        UD_SS_RowStack, \
        WasteStack, \
        WasteTalonStack, \
        isSameColorSequence
from pysollib.util import ACE, ANY_RANK, ANY_SUIT, KING, NO_RANK

# ************************************************************************
# * Klondike
# ************************************************************************


class Klondike(Game):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = KingAC_RowStack
    Hint_Class = KlondikeType_Hint

    def createGame(self, max_rounds=-1, num_deal=1, **layout):
        # create layout
        lay, s = Layout(self), self.s
        kwdefault(layout, rows=7, waste=1, texts=1, playcards=16)
        self.Layout_Method.__get__(lay, lay.__class__)(**layout)
        # self.__class__.Layout_Method(lay, **layout)
        self.setSize(lay.size[0], lay.size[1])
        # create stacks
        s.talon = self.Talon_Class(lay.s.talon.x, lay.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        if lay.s.waste:
            s.waste = WasteStack(lay.s.waste.x, lay.s.waste.y, self)
        for r in lay.s.foundations:
            s.foundations.append(
                self.Foundation_Class(r.x, r.y, self, suit=r.suit))
        for r in lay.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        # default
        lay.defaultAll()
        return lay

    def startGame(self, flip=0, reverse=1):
        for i in range(1, len(self.s.rows)):
            self.s.talon.dealRow(
                rows=self.s.rows[i:], flip=flip, frames=0, reverse=reverse)
        self.startDealSample()
        self.s.talon.dealRow(reverse=reverse)
        if self.s.waste:
            self.s.talon.dealCards()      # deal first card to WasteStack

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Vegas Klondike
# ************************************************************************

class VegasKlondike(Klondike):
    getGameScore = Game.getGameScoreCasino
    getGameBalance = Game.getGameScoreCasino

    def createGame(self, max_rounds=1):
        lay = Klondike.createGame(self, max_rounds=max_rounds)
        self.texts.score = MfxCanvasText(self.canvas,
                                         8, self.height - 8, anchor="sw",
                                         font=self.app.getFont("canvas_large"))
        return lay

    def updateText(self):
        if self.preview > 1:
            return
        b1, b2 = self.app.stats.gameid_balance, 0
        if self.shallUpdateBalance():
            b2 = self.getGameBalance()
        t = _("Balance $%d") % (b1 + b2)
        self.texts.score.config(text=t)

    def getDemoInfoTextAttr(self, tinfo):
        return tinfo[1]     # "se" corner


# ************************************************************************
# * Casino Klondike
# ************************************************************************

class CasinoKlondike(VegasKlondike):
    def createGame(self):
        lay = VegasKlondike.createGame(self, max_rounds=3)
        lay.createRoundText(self.s.talon, 'ne', dx=lay.XS)


# ************************************************************************
# * Klondike by Threes
# ************************************************************************

class KlondikeByThrees(Klondike):
    def createGame(self):
        Klondike.createGame(self, num_deal=3)


# ************************************************************************
# * Thumb and Pouch
# * Chinaman
# ************************************************************************

class ThumbAndPouch(Klondike):
    RowStack_Class = BO_RowStack

    def createGame(self):
        Klondike.createGame(self, max_rounds=1)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit != card2.suit and
                (card1.rank + 1 == card2.rank or
                 card2.rank + 1 == card1.rank))


class Chinaman(ThumbAndPouch):
    RowStack_Class = StackWrapper(BO_RowStack, base_rank=KING)

    def createGame(self):
        lay = Klondike.createGame(self, num_deal=3,
                                  max_rounds=2, round_text=True)
        lay.createRoundText(self.s.talon, 'ne', dx=lay.XS)


# ************************************************************************
# * Whitehead
# ************************************************************************

class Whitehead_RowStack(SS_RowStack):
    def _isAcceptableSequence(self, cards):
        return isSameColorSequence(cards, self.cap.mod, self.cap.dir)

    def getHelp(self):
        return _('Tableau. Build down by color. Sequences of cards '
                 'in the same suit can be moved as a unit.')


class Whitehead(Klondike):
    RowStack_Class = Whitehead_RowStack
    Hint_Class = CautiousDefaultHint

    def createGame(self):
        Klondike.createGame(self, max_rounds=1)

    def startGame(self):
        Klondike.startGame(self, flip=1)

    shallHighlightMatch = Game._shallHighlightMatch_SS
    getQuickPlayScore = Game._getSpiderQuickPlayScore


# ************************************************************************
# * Small Harp (Klondike in a different layout)
# ************************************************************************

class SmallHarp(Klondike):
    Layout_Method = staticmethod(Layout.gypsyLayout)

    def startGame(self):
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[:i], flip=0, frames=0)
        self._startAndDealRowAndCards()


# ************************************************************************
# * Eastcliff
# * Easthaven
# ************************************************************************

class Eastcliff(Klondike):
    RowStack_Class = AC_RowStack

    def createGame(self):
        Klondike.createGame(self, max_rounds=1)

    def startGame(self):
        for i in range(2):
            self.s.talon.dealRow(flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        if self.s.waste:
            self.s.talon.dealCards()      # deal first card to WasteStack


class Easthaven(Eastcliff):
    Talon_Class = DealRowTalonStack

    def createGame(self):
        Klondike.createGame(self, max_rounds=1, waste=0)


class DoubleEasthaven(Easthaven):
    def createGame(self):
        Klondike.createGame(self, rows=8, max_rounds=1, waste=0, playcards=20)


class TripleEasthaven(Easthaven):
    def createGame(self):
        Klondike.createGame(self, rows=12, max_rounds=1, waste=0, playcards=26)


# ************************************************************************
# * Westcliff
# * Westhaven
# ************************************************************************

class Westcliff(Eastcliff):
    Foundation_Class = StackWrapper(SS_FoundationStack, max_move=0)

    def createGame(self):
        Klondike.createGame(self, max_rounds=1, rows=10)


class Westhaven(Westcliff):
    Talon_Class = DealRowTalonStack

    def createGame(self):
        Klondike.createGame(self, max_rounds=1, rows=10, waste=0)


# ************************************************************************
# * Pas Seul
# ************************************************************************

class PasSeul(pysollib.game.StartDealRowAndCards, Eastcliff):
    def createGame(self):
        Klondike.createGame(self, max_rounds=1, rows=6)


# ************************************************************************
# * Blind Alleys
# ************************************************************************

class BlindAlleys(Eastcliff):
    def createGame(self):
        lay = Klondike.createGame(self, max_rounds=2, rows=6, round_text=True)
        lay.createRoundText(self.s.talon, 'ne', dx=lay.XS)

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        Eastcliff.startGame(self)


# ************************************************************************
# * Somerset
# * Morehead
# * Usk
# ************************************************************************

class Somerset(Klondike):
    Talon_Class = InitialDealTalonStack
    RowStack_Class = SuperMoveAC_RowStack
    Hint_Class = CautiousDefaultHint
    Solver_Class = FreeCellSolverWrapper()

    def createGame(self):
        Klondike.createGame(self, max_rounds=1, rows=10, waste=0, texts=0)

    def startGame(self):
        for i in range(6):
            self.s.talon.dealRow(rows=self.s.rows[i:], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[6:])
        self.s.talon.dealRow(rows=self.s.rows[7:])


class Morehead(Somerset):
    RowStack_Class = StackWrapper(BO_RowStack, max_move=1)
    Solver_Class = None


class Usk(Somerset):

    Talon_Class = RedealTalonStack
    RowStack_Class = StackWrapper(AC_RowStack, base_rank=KING)
    Solver_Class = None

    def createGame(self):
        lay = Klondike.createGame(self, max_rounds=2, rows=10,
                                  waste=False, texts=False, round_text=True)
        lay.createRoundText(self.s.talon, 'ne')

    def redealCards(self):
        n = 0
        while self.s.talon.cards:
            self.s.talon.dealRowAvail(rows=self.s.rows[n:], frames=4)
            n += 1

# ************************************************************************
# * Canister
# * American Canister
# * British Canister
# ************************************************************************


class AmericanCanister(Klondike):
    Talon_Class = InitialDealTalonStack
    RowStack_Class = AC_RowStack
    Solver_Class = FreeCellSolverWrapper(sm='unlimited')

    def createGame(self):
        Klondike.createGame(self, max_rounds=1, rows=8, waste=0, texts=0)

    def startGame(self):
        self._startDealNumRows(5)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.rows[2:6])


class Canister(AmericanCanister):
    RowStack_Class = RK_RowStack
    Solver_Class = FreeCellSolverWrapper(sbb='rank', sm='unlimited')
    shallHighlightMatch = Game._shallHighlightMatch_RK


class BritishCanister(AmericanCanister):
    RowStack_Class = StackWrapper(KingAC_RowStack, max_move=1)
    Solver_Class = FreeCellSolverWrapper(esf='kings')


# ************************************************************************
# * Agnes Sorel
# ************************************************************************

class AgnesSorel(Klondike):
    Talon_Class = DealRowTalonStack
    Foundation_Class = StackWrapper(
        SS_FoundationStack, mod=13, base_rank=NO_RANK, max_move=0)
    RowStack_Class = StackWrapper(SC_RowStack, mod=13, base_rank=NO_RANK)

    def createGame(self):
        Klondike.createGame(self, max_rounds=1, waste=0)

    def startGame(self):
        Klondike.startGame(self, flip=1)
        self.s.talon.dealSingleBaseCard()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color == card2.color and
                ((card1.rank + 1) % 13 == card2.rank or
                 (card2.rank + 1) % 13 == card1.rank))


# ************************************************************************
# * 8 x 8
# * Achtmal Acht
# * Eight by Eight
# ************************************************************************

class EightTimesEight(Klondike):
    Layout_Method = staticmethod(Layout.gypsyLayout)
    RowStack_Class = AC_RowStack

    def createGame(self):
        Klondike.createGame(self, rows=8)

    def startGame(self):
        self._startDealNumRows(7)
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack


class AchtmalAcht(EightTimesEight):
    def createGame(self):
        lay = Klondike.createGame(self, rows=8, max_rounds=3, round_text=True)
        lay.createRoundText(self.s.talon, 'sw', dx=-lay.XS)


class EightByEight_RowStack(RK_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return len(cards) == 1
        return True


class EightByEight(EightTimesEight):
    Layout_Method = staticmethod(Layout.klondikeLayout)  # gypsyLayout
    Talon_Class = CanfieldRush_Talon
    RowStack_Class = EightByEight_RowStack

    def createGame(self):
        lay = Klondike.createGame(self, rows=8, playcards=20,
                                  max_rounds=3, round_text=True)
        lay.createRoundText(self.s.talon, 'ne', dx=lay.XS)

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Batsford
# * Batsford Again
# ************************************************************************

class Batsford_ReserveStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        # must be a King
        return cards[0].rank == KING

    def getHelp(self):
        return _('Reserve. Only Kings are acceptable.')


class Batsford(Klondike):
    def createGame(self, **layout):
        kwdefault(layout, rows=10, max_rounds=1, playcards=22)
        round_text = (layout['max_rounds'] > 1)
        layout['round_text'] = round_text
        lay = Klondike.createGame(self, **layout)
        s = self.s
        x, y = lay.XM, self.height - lay.YS
        s.reserves.append(Batsford_ReserveStack(x, y, self, max_cards=3))
        self.setRegion(
            s.reserves, (-999, y - lay.YM - lay.CH//2,
                         x + lay.XS - lay.CW//2, 999999),
            priority=1)
        lay.createText(s.reserves[0], "se")
        if round_text:
            lay.createRoundText(self.s.talon, 'ne', dx=lay.XS)
        lay.defaultStackGroups()


class BatsfordAgain(Batsford):
    def createGame(self):
        Batsford.createGame(self, max_rounds=2)


# ************************************************************************
# * Jumbo
# ************************************************************************

class Jumbo(Klondike):
    def createGame(self):
        lay = Klondike.createGame(self, rows=9, max_rounds=2, round_text=True)
        lay.createRoundText(self.s.talon, 'ne', dx=lay.XS)

    def startGame(self, flip=0):
        for i in range(9):
            self.s.talon.dealRow(rows=self.s.rows[:i], flip=flip, frames=0)
        self._startAndDealRowAndCards()


class OpenJumbo(Jumbo):
    def startGame(self):
        Jumbo.startGame(self, flip=1)


# ************************************************************************
# * Stonewall
# * Flower Garden
# ************************************************************************

class Stonewall(Klondike):
    Talon_Class = InitialDealTalonStack
    RowStack_Class = AC_RowStack

    DEAL = (0, 1, 0, 1, -1, 0, 1)

    def createGame(self):
        lay = Klondike.createGame(self, rows=6, waste=0, max_rounds=1, texts=0)
        s = self.s
        h = max(self.height, lay.YM+4*lay.YS)
        self.setSize(self.width + lay.XM+4*lay.XS, h)
        for i in range(4):
            for j in range(4):
                x, y = self.width + (j-4)*lay.XS, lay.YM + i*lay.YS
                s.reserves.append(OpenStack(x, y, self, max_accept=0))
        lay.defaultStackGroups()

    def startGame(self):
        frames = 0
        for flip in self.DEAL:
            if flip < 0:
                frames = -1
                self.startDealSample()
            else:
                self.s.talon.dealRow(flip=flip, frames=frames)
        self.s.talon.dealRow(rows=self.s.reserves)


class FlowerGarden(Stonewall):
    RowStack_Class = StackWrapper(RK_RowStack, max_move=1)
    Hint_Class = CautiousDefaultHint

    DEAL = (1, 1, 1, 1, -1, 1, 1)

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * King Albert
# * Raglan
# * Brigade
# * Queen Victoria
# ************************************************************************

class KingAlbert(Klondike):
    Talon_Class = InitialDealTalonStack
    RowStack_Class = StackWrapper(AC_RowStack, max_move=1)
    Hint_Class = CautiousDefaultHint

    ROWS = 9
    RESERVES = (2, 2, 2, 1)

    def createGame(self):
        lay = Klondike.createGame(
            self, max_rounds=1, rows=self.ROWS, waste=0, texts=0)
        s = self.s
        rw, rh = max(self.RESERVES), len(self.RESERVES)
        h = max(self.height, lay.YM+rh*lay.YS)
        self.setSize(self.width + 2*lay.XM+rw*lay.XS, h)
        for i in range(rh):
            for j in range(self.RESERVES[i]):
                x, y = self.width + (j-rw)*lay.XS, lay.YM + i*lay.YS
                s.reserves.append(OpenStack(x, y, self, max_accept=0))
        lay.defaultStackGroups()

    def startGame(self):
        Klondike.startGame(self, flip=1, reverse=0)
        self.s.talon.dealRow(rows=self.s.reserves)


class Raglan(KingAlbert):
    RESERVES = (2, 2, 2)

    def _shuffleHook(self, cards):
        # move Aces to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        for i in range(6):
            self.s.talon.dealRow(rows=self.s.rows[i:], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[6:])
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRow(rows=self.s.foundations)


class Brigade(Raglan):
    RowStack_Class = StackWrapper(RK_RowStack, max_move=1)

    ROWS = 7
    RESERVES = (4, 4, 4, 1)

    def startGame(self):
        self._startDealNumRows(4)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRow(rows=self.s.foundations)

    shallHighlightMatch = Game._shallHighlightMatch_RK


class QueenVictoria(KingAlbert):
    RowStack_Class = AC_RowStack


# ************************************************************************
# * Jane
# * Agnes Bernauer
# ************************************************************************

class Jane_Talon(OpenTalonStack):
    rightclickHandler = OpenStack.rightclickHandler
    doubleclickHandler = OpenStack.doubleclickHandler

    def canFlipCard(self):
        return False

    def canDealCards(self):
        return len(self.cards) >= 2

    def dealCards(self, sound=False):
        c = 0
        if len(self.cards) > 2:
            c = self.dealRow(self.game.s.reserves, sound=sound)
        if len(self.cards) == 2:
            self.game.flipMove(self)
            self.game.moveMove(1, self, self.game.s.waste, frames=4, shadow=0)
            self.game.flipMove(self)
            c = c + 1
        return c


class Jane(Klondike):
    Talon_Class = Jane_Talon
    Foundation_Class = StackWrapper(
        SS_FoundationStack, mod=13, base_rank=NO_RANK, min_cards=1)
    RowStack_Class = StackWrapper(AC_RowStack, mod=13, base_rank=NO_RANK)

    def createGame(self, max_rounds=1, rows=7, reserves=7, playcards=16):
        lay, s = Layout(self), self.s
        maxrows = max(rows, 7)
        w = lay.XM+maxrows*lay.XS+lay.XM+2*lay.XS
        h = max(lay.YM+2*lay.YS+playcards*lay.YOFFSET+lay.TEXT_HEIGHT,
                lay.YM+4*lay.YS)
        self.setSize(w, h)

        x, y = lay.XM, lay.YM
        s.talon = self.Talon_Class(x, y, self, max_rounds=max_rounds)
        lay.createText(s.talon, 's')
        x += lay.XS
        s.waste = WasteStack(x, y, self)

        x += 2*lay.XS
        for i in range(4):
            s.foundations.append(self.Foundation_Class(x, y, self, suit=i))
            x += lay.XS

        x, y = lay.XM, lay.YM+lay.YS+lay.TEXT_HEIGHT
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += lay.XS

        x0, y = self.width - 2*lay.XS, lay.YM
        for i in range(reserves):
            x = x0 + ((i+1) & 1) * lay.XS
            stack = OpenStack(x, y, self, max_accept=0)
            stack.CARD_YOFFSET = lay.YM // 3
            s.reserves.append(stack)
            y = y + lay.YS // 2
        # not needed, as no cards may be placed on the reserves
        # self.setRegion(s.reserves, (x0-lay.XM//2, -999, 999999, 999999),
        #   priority=1)
        lay.defaultStackGroups()
        self.sg.dropstacks.append(s.talon)

    def startGame(self, flip=0, reverse=1):
        for i in range(1, len(self.s.rows)):
            self.s.talon.dealRow(
                rows=self.s.rows[i:], flip=flip, frames=0, reverse=reverse)
        self.startDealSample()
        self.s.talon.dealRow(reverse=reverse)
        self.s.talon.dealRow(rows=self.s.reserves)
        c = self.s.talon.dealSingleBaseCard()
        # update base rank of row stacks
        cap = Struct(base_rank=(c.rank - 1) % 13)
        for s in self.s.rows:
            s.cap.update(cap.__dict__)
            self.saveinfo.stack_caps.append((s.id, cap))

    shallHighlightMatch = Game._shallHighlightMatch_ACW

    def _autoDeal(self, sound=True):
        return 0


class AgnesBernauer_Talon(DealRowTalonStack):
    def dealCards(self, sound=False):
        return self.dealRowAvail(self.game.s.reserves, sound=sound)


class AgnesBernauer(Jane):
    Talon_Class = AgnesBernauer_Talon
    Foundation_Class = StackWrapper(
        SS_FoundationStack, mod=13, base_rank=NO_RANK, max_move=0)

    def startGame(self):
        Jane.startGame(self, flip=1)


# ************************************************************************
# * Senate
# ************************************************************************

class Senate(Jane):

    def createGame(self, rows=4):

        playcards = 10

        lay, s = Layout(self), self.s
        self.setSize(lay.XM+(rows+7)*lay.XS,
                     lay.YM+2*(lay.YS+playcards*lay.YOFFSET))

        x, y = lay.XM, lay.YM
        for i in range(rows):
            s.rows.append(SS_RowStack(x, y, self))
            x += lay.XS

        for y in lay.YM, lay.YM+lay.YS+playcards*lay.YOFFSET:
            x = lay.XM+rows*lay.XS+lay.XS//2
            for i in range(4):
                stack = OpenStack(x, y, self, max_accept=0)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, lay.YOFFSET
                s.reserves.append(stack)
                x += lay.XS
        x = lay.XM+(rows+5)*lay.XS
        for i in range(2):
            y = lay.YM+lay.YS
            for j in range(4):
                s.foundations.append(SS_FoundationStack(x, y, self, suit=j))
                y += lay.YS
            x += lay.XS
        x, y = self.width-lay.XS, lay.YM
        s.talon = AgnesBernauer_Talon(x, y, self)
        lay.createText(s.talon, 'nw')

        lay.defaultStackGroups()

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRow()

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank == ACE, (c.deck, c.suit)))

    shallHighlightMatch = Game._shallHighlightMatch_SS


class SenatePlus(Senate):
    def createGame(self):
        Senate.createGame(self, rows=5)

# ************************************************************************
# * Phoenix
# * Arizona
# ************************************************************************


class Phoenix(Klondike):

    Hint_Class = CautiousDefaultHint
    RowStack_Class = AC_RowStack

    def createGame(self):

        lay, s = Layout(self), self.s
        self.setSize(lay.XM + 10*lay.XS, lay.YM + 4*(lay.YS+lay.YM))

        for i in range(2):
            x = lay.XM + i*lay.XS
            for j in range(4):
                y = lay.YM + j*(lay.YS+lay.YM)
                s.reserves.append(OpenStack(x, y, self, max_accept=0))
        for i in range(2):
            x = lay.XM + (8+i)*lay.XS
            for j in range(4):
                y = lay.YM + j*(lay.YS+lay.YM)
                s.reserves.append(OpenStack(x, y, self, max_accept=0))
        for i in range(4):
            s.foundations.append(
                SS_FoundationStack(lay.XM+(3+i)*lay.XS, lay.YM, self, i))
        for i in range(6):
            s.rows.append(
                self.RowStack_Class(lay.XM+(2+i)*lay.XS, lay.YM+lay.YS, self))
        s.talon = InitialDealTalonStack(
            lay.XM+int(4.5*lay.XS), lay.YM+3*(lay.YS+lay.YM), self)

        lay.defaultStackGroups()

    def startGame(self):
        self._startDealNumRows(6)
        self.s.talon.dealRow(rows=self.s.reserves)


class Arizona(Phoenix):
    RowStack_Class = RK_RowStack

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Lanes
# ************************************************************************

class Lanes(Klondike):

    Hint_Class = CautiousDefaultHint
    Foundation_Class = StackWrapper(SS_FoundationStack, max_move=0)
    RowStack_Class = StackWrapper(AC_RowStack, base_rank=ANY_RANK, max_move=1)

    def createGame(self):
        lay = Klondike.createGame(self, rows=6, max_rounds=2, round_text=True)
        lay.createRoundText(self.s.talon, 'ne', dx=lay.XS)

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(cards,
                                          lambda c: (c.rank == ACE, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startDealNumRows(2)
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack


# ************************************************************************
# * Thirty Six
# ************************************************************************

class ThirtySix(Klondike):

    Foundation_Class = StackWrapper(SS_FoundationStack, max_move=0)
    RowStack_Class = StackWrapper(RK_RowStack, base_rank=ANY_RANK)

    def createGame(self):
        Klondike.createGame(self, rows=6, max_rounds=1)

    def _fillOne(self):
        for r in self.s.rows:
            if r.cards:
                c = r.cards[-1]
                for f in self.s.foundations:
                    if f.acceptsCards(r, [c]):
                        self.moveMove(1, r, f, frames=4, shadow=0)
                        return 1
        return 0

    def startGame(self):
        self.startDealSample()
        for i in range(6):
            self.s.talon.dealRow()
            while True:
                if not self._fillOne():
                    break
        self.s.talon.dealCards()          # deal first card to WasteStack

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Q.C.
# ************************************************************************

class Q_C_(Klondike):

    Hint_Class = CautiousDefaultHint
    Foundation_Class = StackWrapper(SS_FoundationStack, max_move=0)
    RowStack_Class = StackWrapper(SS_RowStack, base_rank=ANY_RANK, max_move=1)

    def createGame(self):
        lay = Klondike.createGame(self, rows=6, max_rounds=2)
        lay.createRoundText(self.s.talon, 'sss')

    def startGame(self):
        self._startDealNumRows(3)
        self.s.talon.dealRow()
        while self.s.talon.cards:
            self.s.talon.dealCards()    # deal first card to WasteStack
            if not self.fillWaste():
                break

    def fillWaste(self):
        waste = self.s.waste
        if waste.cards:
            c = waste.cards[-1]
            for f in self.s.foundations:
                if f.acceptsCards(self.s.waste, [c]):
                    waste.moveMove(1, f)
                    return True
        return False

    def fillStack(self, stack=None):
        waste = self.s.waste
        while True:
            if not self.fillWaste():
                break
        if stack in self.s.rows and not stack.cards:
            if not waste.cards:
                while self.s.talon.cards:
                    self.s.talon.dealCards()
                    if not self.fillWaste():
                        break
            if waste.cards:
                waste.moveMove(1, stack)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Northwest Territory
# * Artic Garden
# ************************************************************************

class NorthwestTerritory(KingAlbert):
    RowStack_Class = StackWrapper(AC_RowStack, base_rank=KING)
    RESERVES = (4, 4, 4, 4)
    ROWS = 8

    def startGame(self):
        Klondike.startGame(self, flip=0, reverse=0)
        self.s.talon.dealRow(rows=self.s.reserves)


class ArticGarden(NorthwestTerritory):
    def startGame(self):
        Klondike.startGame(self, flip=1, reverse=0)
        self.s.talon.dealRow(rows=self.s.reserves)


# ************************************************************************
# * Aunt Mary
# ************************************************************************

class AuntMary(Klondike):
    def createGame(self):
        Klondike.createGame(self, rows=6, max_rounds=1)

    def startGame(self):
        for i in range(5):
            j = i+1
            self.s.talon.dealRow(rows=self.s.rows[:j], frames=0, flip=1)
            self.s.talon.dealRow(rows=self.s.rows[j:], frames=0, flip=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()


# ************************************************************************
# * Double Dot
# ************************************************************************

class DoubleDot(Klondike):
    Talon_Class = DealRowTalonStack
    RowStack_Class = StackWrapper(RK_RowStack, dir=-2, mod=13)
    Foundation_Class = StackWrapper(SS_FoundationStack, dir=2, mod=13)

    def createGame(self):
        Klondike.createGame(self, max_rounds=1, rows=8, waste=0)

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: ((c.rank == ACE and c.suit in (0, 1)) or
                       (c.rank == 1 and c.suit in (2, 3)), c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRow()

    # def shallHighlightMatch(self, stack1, card1, stack2, card2):
    #     return abs(card1.rank-card2.rank) == 2

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# ************************************************************************
# * Seven Devils
# ************************************************************************

class SevenDevils_RowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        return from_stack not in self.game.s.reserves


class SevenDevils(Klondike):

    Hint_Class = CautiousDefaultHint
    RowStack_Class = StackWrapper(SevenDevils_RowStack, max_move=1)

    def createGame(self):

        lay, s = Layout(self), self.s
        self.setSize(lay.XM + 10*lay.XS, lay.YM+3*lay.YS+12*lay.YOFFSET)

        x, y = lay.XM, lay.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2))
            x += lay.XS
        x, y = lay.XM+lay.XS//2, lay.YM+lay.YS
        for i in range(7):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += lay.XS
        x0, y = self.width - 2*lay.XS, lay.YM
        for i in range(7):
            x = x0 + ((i+1) & 1) * lay.XS
            s.reserves.append(OpenStack(x, y, self, max_accept=0))
            y += lay.YS // 2
        x, y = lay.XM, self.height-lay.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        lay.createText(s.talon, 'n')
        x += lay.XS
        s.waste = WasteStack(x, y, self)
        lay.createText(s.waste, 'n')

        lay.defaultStackGroups()

    def startGame(self, flip=0, reverse=1):
        Klondike.startGame(self)
        self.s.talon.dealRow(rows=self.s.reserves)


# ************************************************************************
# * Moving Left
# * Souter
# ************************************************************************

class MovingLeft(Klondike):

    def createGame(self):
        Klondike.createGame(self, max_rounds=1, rows=10, playcards=24)

    def fillStack(self, stack):
        if not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if stack in self.s.rows:
                i = list(self.s.rows).index(stack)
                if i < len(self.s.rows)-1:
                    from_stack = self.s.rows[i+1]
                    pile = from_stack.getPile()
                    if pile:
                        from_stack.moveMove(len(pile), stack)
            self.leaveState(old_state)


class Souter(MovingLeft):
    def createGame(self):
        lay = Klondike.createGame(self, max_rounds=2, rows=10,
                                  playcards=24, round_text=True)
        lay.createRoundText(self.s.talon, 'ne', dx=lay.XS)


# ************************************************************************
# * Big Forty
# * Ali Baba
# * Cassim
# ************************************************************************

class BigForty(Klondike):
    RowStack_Class = SS_RowStack

    def createGame(self):
        Klondike.createGame(self, rows=10)

    def startGame(self):
        self._startDealNumRowsAndDealRowAndCards(3)

    shallHighlightMatch = Game._shallHighlightMatch_SS


class AliBaba(BigForty):
    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(cards,
                                          lambda c: (c.rank == ACE, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        BigForty.startGame(self)


class Cassim(AliBaba):
    def createGame(self):
        Klondike.createGame(self, rows=7)


# ************************************************************************
# * Saratoga
# ************************************************************************

class Saratoga(Klondike):
    def createGame(self):
        Klondike.createGame(self, num_deal=3)

    def startGame(self):
        Klondike.startGame(self, flip=1)


# ************************************************************************
# * Whitehorse
# ************************************************************************

class Whitehorse(Klondike):

    def createGame(self):
        Klondike.createGame(self, num_deal=3)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if stack in self.s.rows:
                if not self.s.waste.cards:
                    self.s.talon.dealCards()
                if self.s.waste.cards:
                    self.s.waste.moveMove(1, stack)
            self.leaveState(old_state)


# ************************************************************************
# * Boost
# ************************************************************************

class Boost(Klondike):
    def createGame(self):
        lay = Klondike.createGame(self, rows=4, max_rounds=3, round_text=True)
        lay.createRoundText(self.s.talon, 'ne', dx=lay.XS)


# ************************************************************************
# * Gold Rush
# ************************************************************************

class GoldRush(Klondike):
    Talon_Class = CanfieldRush_Talon

    def createGame(self):
        lay = Klondike.createGame(self, max_rounds=3, round_text=True)
        lay.createRoundText(self.s.talon, 'ne', dx=lay.XS)


# ************************************************************************
# * Gold Mine
# ************************************************************************

class GoldMine_RowStack(AC_RowStack):
    getBottomImage = Stack._getReserveBottomImage


class GoldMine(Klondike):
    RowStack_Class = GoldMine_RowStack

    def createGame(self):
        Klondike.createGame(self, max_rounds=1, num_deal=3)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealCards()


# ************************************************************************
# * Lucky Thirteen
# * Lucky Piles
# ************************************************************************

class LuckyThirteen(Game):
    Hint_Class = CautiousDefaultHint
    RowStack_Class = StackWrapper(RK_RowStack, base_rank=NO_RANK)

    def createGame(self, xoffset=0, playcards=0):
        lay, s = Layout(self), self.s
        if xoffset:
            xoffset = lay.XOFFSET
        w0 = lay.XS+playcards*lay.XOFFSET
        self.setSize(lay.XM + 5*w0, lay.YM+4*lay.YS)

        x, y = lay.XM, lay.YM+lay.YS
        for i in range(5):
            stack = self.RowStack_Class(x, y, self, max_move=1)
            s.rows.append(stack)
            stack.CARD_XOFFSET = xoffset
            stack.CARD_YOFFSET = 0
            x += w0
        x, y = lay.XM+w0, lay.YM+2*lay.YS
        for i in range(3):
            stack = self.RowStack_Class(x, y, self, max_move=1)
            s.rows.append(stack)
            stack.CARD_XOFFSET = xoffset
            stack.CARD_YOFFSET = 0
            x += w0
        x, y = lay.XM, lay.YM+3*lay.YS
        for i in range(5):
            stack = self.RowStack_Class(x, y, self, max_move=1)
            s.rows.append(stack)
            stack.CARD_XOFFSET = xoffset
            stack.CARD_YOFFSET = 0
            x += w0
        x, y = (self.width-4*lay.XS)//2, lay.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += lay.XS
        x, y = lay.XM, self.height-lay.YS
        s.talon = InitialDealTalonStack(x, y, self, max_rounds=1)

        lay.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(3)

    shallHighlightMatch = Game._shallHighlightMatch_RK


class LuckyPiles(LuckyThirteen):
    RowStack_Class = StackWrapper(UD_SS_RowStack, base_rank=KING)

    def createGame(self):
        LuckyThirteen.createGame(self, xoffset=1, playcards=7)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Legion
# ************************************************************************

class Legion(Klondike):

    def createGame(self):
        Klondike.createGame(self, max_rounds=1, rows=8)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        for i in (1, 2, 3):
            self.s.talon.dealRow(rows=self.s.rows[i:-i], flip=0)
            self.s.talon.dealRow(rows=self.s.rows[i:-i])
        self.s.talon.dealCards()


# ************************************************************************
# * Big Bertha
# ************************************************************************

class BigBertha(Game):

    def createGame(self):
        lay, s = Layout(self), self.s
        self.setSize(lay.XM+15*lay.XS, lay.YM+3*lay.YS+15*lay.YOFFSET)

        x, y = lay.XM, lay.YM
        s.talon = InitialDealTalonStack(x, y, self)

        x, y = lay.XM+3.5*lay.XS, lay.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self,
                                 suit=i % 4, max_cards=12))
            x += lay.XS

        x, y = lay.XM, lay.YM+lay.YS
        for i in range(15):
            s.rows.append(AC_RowStack(x, y, self))
            x += lay.XS

        x, y = lay.XM, self.height-lay.YS
        for i in range(14):
            s.reserves.append(OpenStack(x, y, self, max_accept=0))
            x += lay.XS

        s.foundations.append(RK_FoundationStack(x, y, self, suit=ANY_SUIT,
                             base_rank=KING, dir=0, max_cards=8))

        lay.defaultStackGroups()

    def startGame(self):
        self._startDealNumRows(5)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Athena
# ************************************************************************

class Athena(Klondike):

    def startGame(self):
        self.s.talon.dealRow(frames=0, flip=0)
        self.s.talon.dealRow(frames=0)
        self.s.talon.dealRow(frames=0, flip=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()


# ************************************************************************
# * Kingsley
# ************************************************************************

class Kingsley(Klondike):

    Foundation_Class = StackWrapper(SS_FoundationStack, base_rank=KING, dir=-1)
    RowStack_Class = StackWrapper(KingAC_RowStack, base_rank=ACE, dir=1)

    def createGame(self):
        Klondike.createGame(self, max_rounds=1)


# ************************************************************************
# * Scarp
# ************************************************************************

class Scarp(Klondike):
    Talon_Class = DealRowTalonStack
    RowStack_Class = AC_RowStack

    def createGame(self):
        Klondike.createGame(self, max_rounds=1, rows=13, waste=0, playcards=28)

    def startGame(self):
        Klondike.startGame(self, flip=1)


# ************************************************************************
# * Eight Sages
# ************************************************************************

class EightSages_Row(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        return from_stack is self.game.s.waste


class EightSages(Klondike):
    RowStack_Class = EightSages_Row

    def createGame(self):
        lay = Klondike.createGame(self, max_rounds=2, rows=8,
                                  playcards=12, round_text=True)
        lay.createRoundText(self.s.talon, 'ne', dx=lay.XS)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()


# register the game
registerGame(GameInfo(2, Klondike, "Klondike",
                      GI.GT_KLONDIKE, 1, -1, GI.SL_BALANCED))
registerGame(GameInfo(61, CasinoKlondike, "Casino Klondike",
                      GI.GT_KLONDIKE | GI.GT_SCORE, 1, 2, GI.SL_BALANCED))
registerGame(GameInfo(129, VegasKlondike, "Vegas Klondike",
                      GI.GT_KLONDIKE | GI.GT_SCORE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(18, KlondikeByThrees, "Klondike by Threes",
                      GI.GT_KLONDIKE, 1, -1, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(58, ThumbAndPouch, "Thumb and Pouch",
                      GI.GT_KLONDIKE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(67, Whitehead, "Whitehead",
                      GI.GT_KLONDIKE, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(39, SmallHarp, "Small Harp",
                      GI.GT_KLONDIKE, 1, -1, GI.SL_BALANCED,
                      altnames=("Die kleine Harfe",)))
registerGame(GameInfo(66, Eastcliff, "Eastcliff",
                      GI.GT_KLONDIKE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(224, Easthaven, "Easthaven",
                      GI.GT_GYPSY, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(33, Westcliff, "Westcliff",
                      GI.GT_KLONDIKE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(225, Westhaven, "Westhaven",
                      GI.GT_GYPSY, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(107, PasSeul, "Pas Seul",
                      GI.GT_KLONDIKE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(81, BlindAlleys, "Blind Alleys",
                      GI.GT_KLONDIKE, 1, 1, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(215, Somerset, "Somerset",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(231, Canister, "Canister",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(229, AgnesSorel, "Agnes Sorel",
                      GI.GT_GYPSY, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(4, EightTimesEight, "8 x 8",
                      GI.GT_KLONDIKE, 2, -1, GI.SL_BALANCED))
registerGame(GameInfo(127, AchtmalAcht, "Eight Times Eight",
                      GI.GT_KLONDIKE, 2, 2, GI.SL_BALANCED,
                      altnames=("Achtmal Acht",)))
registerGame(GameInfo(133, Batsford, "Batsford",
                      GI.GT_KLONDIKE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(221, Stonewall, "Stonewall",
                      GI.GT_RAGLAN, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(222, FlowerGarden, "Flower Garden",
                      GI.GT_RAGLAN | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL,
                      altnames=("The Bouquet", "The Garden",)))
registerGame(GameInfo(233, KingAlbert, "King Albert",
                      GI.GT_RAGLAN | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL,
                      altnames=("Idiot's Delight",)))
registerGame(GameInfo(232, Raglan, "Raglan",
                      GI.GT_RAGLAN | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(223, Brigade, "Brigade",
                      GI.GT_RAGLAN | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(230, Jane, "Jane",
                      GI.GT_RAGLAN, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(236, AgnesBernauer, "Agnes Bernauer",
                      GI.GT_RAGLAN, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(263, Phoenix, "Phoenix",
                      GI.GT_RAGLAN | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(283, Jumbo, "Jumbo",
                      GI.GT_KLONDIKE, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(333, OpenJumbo, "Open Jumbo",
                      GI.GT_KLONDIKE, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(326, Lanes, "Lanes",
                      GI.GT_KLONDIKE, 1, 1, GI.SL_BALANCED))
registerGame(GameInfo(327, ThirtySix, "Thirty Six",
                      GI.GT_KLONDIKE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(350, Q_C_, "Q.C.",
                      GI.GT_KLONDIKE, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(361, NorthwestTerritory, "Northwest Territory",
                      GI.GT_RAGLAN, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(362, Morehead, "Morehead",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(388, Senate, "Senate",
                      GI.GT_RAGLAN, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(389, SenatePlus, "Senate +",
                      GI.GT_RAGLAN, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(390, Arizona, "Arizona",
                      GI.GT_RAGLAN | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(407, AuntMary, "Aunt Mary",
                      GI.GT_KLONDIKE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(420, DoubleDot, "Double Dot",
                      GI.GT_KLONDIKE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(434, SevenDevils, "Seven Devils",
                      GI.GT_RAGLAN, 2, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(452, DoubleEasthaven, "Double Easthaven",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(453, TripleEasthaven, "Triple Easthaven",
                      GI.GT_GYPSY, 3, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(470, MovingLeft, "Moving Left",
                      GI.GT_KLONDIKE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(471, Souter, "Souter",
                      GI.GT_KLONDIKE, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(473, BigForty, "Big Forty",
                      GI.GT_KLONDIKE, 1, -1, GI.SL_BALANCED))
registerGame(GameInfo(474, AliBaba, "Ali Baba",
                      GI.GT_KLONDIKE, 1, -1, GI.SL_BALANCED))
registerGame(GameInfo(475, Cassim, "Cassim",
                      GI.GT_KLONDIKE, 1, -1, GI.SL_BALANCED))
registerGame(GameInfo(479, Saratoga, "Saratoga",
                      GI.GT_KLONDIKE, 1, -1, GI.SL_BALANCED))
registerGame(GameInfo(491, Whitehorse, "Whitehorse",
                      GI.GT_KLONDIKE, 1, -1, GI.SL_BALANCED))
registerGame(GameInfo(518, Boost, "Boost",
                      GI.GT_KLONDIKE | GI.GT_ORIGINAL, 1, 2, GI.SL_BALANCED))
registerGame(GameInfo(522, ArticGarden, "Artic Garden",
                      GI.GT_RAGLAN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(532, GoldRush, "Gold Rush",
                      GI.GT_KLONDIKE, 1, 2, GI.SL_BALANCED))
registerGame(GameInfo(539, Usk, "Usk",
                      GI.GT_KLONDIKE, 1, 1, GI.SL_BALANCED))
registerGame(GameInfo(541, BatsfordAgain, "Batsford Again",
                      GI.GT_KLONDIKE, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(572, GoldMine, "Gold Mine",
                      GI.GT_NUMERICA, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(585, LuckyThirteen, "Lucky Thirteen",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(586, LuckyPiles, "Lucky Piles",
                      GI.GT_FAN_TYPE, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(601, AmericanCanister, "American Canister",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(602, BritishCanister, "British Canister",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(607, Legion, "Legion",
                      GI.GT_KLONDIKE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(627, QueenVictoria, "Queen Victoria",
                      GI.GT_RAGLAN | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(630, BigBertha, "Big Bertha",
                      GI.GT_RAGLAN | GI.GT_OPEN, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(633, Athena, "Athena",
                      GI.GT_KLONDIKE, 1, -1, GI.SL_BALANCED))
registerGame(GameInfo(634, Chinaman, "Chinaman",
                      GI.GT_KLONDIKE, 1, 1, GI.SL_BALANCED))
registerGame(GameInfo(651, EightByEight, "Eight by Eight",
                      GI.GT_KLONDIKE, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(667, Kingsley, "Kingsley",
                      GI.GT_KLONDIKE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(669, Scarp, "Scarp",
                      GI.GT_GYPSY | GI.GT_ORIGINAL, 3, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(726, EightSages, "Eight Sages",
                      GI.GT_KLONDIKE, 2, 1, GI.SL_MOSTLY_LUCK))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.layout import Layout
from pysollib.stack import \
        BasicRowStack, \
        DealRowTalonStack, \
        SS_FoundationStack

# ************************************************************************
# * Labyrinth
# ************************************************************************


class Labyrinth_Talon(DealRowTalonStack):
    def dealCards(self, sound=False):
        top_stacks = []
        for i in range(8):
            for r in self.game.s.rows[i::8]:
                if not r.cards:
                    top_stacks.append(r)
                    break
        return self.dealRowAvail(rows=top_stacks, sound=sound)


class Labyrinth_RowStack(BasicRowStack):

    def clickHandler(self, event):
        BasicRowStack.doubleclickHandler(self, event)
        return True

    def basicIsBlocked(self):
        if self in self.game.s.rows[:8]:
            return False
        if self.id+8 >= len(self.game.allstacks):
            return False
        r = self.game.allstacks[self.id+8]
        if r in self.game.s.rows and r.cards:
            return True
        return False


class Labyrinth(Game):

    #
    # game layout
    #

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+8*l.XS, l.YM+l.YS+20*l.YOFFSET)

        # create stacks
        s.talon = Labyrinth_Talon(l.XM, l.YM, self)

        x, y, = l.XM+2*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += l.XS

        x, y = l.XM, l.YM+l.YS
        for i in range(6):
            x = l.XM
            for j in range(8):
                s.rows.append(Labyrinth_RowStack(x, y, self, max_move=1))
                x += l.XS
            y += l.YOFFSET

        # default
        l.defaultAll()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealRow(rows=self.s.rows[:8])

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 0, c.suit))

    def fillStack(self, stack):
        if stack in self.s.rows[:8] and not stack.cards:
            rows = self.s.rows
            to_stack = stack
            # if not self.demo:
            #    self.startDealSample()
            old_state = self.enterState(self.S_FILL)
            for r in rows[list(rows).index(stack)+8::8]:
                if r.cards:
                    self.moveMove(1, r, to_stack, frames=0)
                    to_stack = r
                else:
                    break
            if not stack.cards and self.s.talon.cards:
                self.s.talon.dealRow(rows=[stack])
            self.leaveState(old_state)
            # if not self.demo:
            #    self.stopSamples()


# register the game

# registerGame(GameInfo(400, Labyrinth, "Labyrinth",
#                      GI.GT_1DECK_TYPE, 1, 0))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.spider import Spider_Hint, Spider_RowStack, \
        Spider_SS_Foundation
from pysollib.hint import KlondikeType_Hint, YukonType_Hint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.stack import \
        AC_RowStack, \
        AbstractFoundationStack, \
        BasicRowStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        KingAC_RowStack, \
        OpenStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        Spider_SS_RowStack, \
        Stack, \
        StackWrapper, \
        TalonStack, \
        WasteStack, \
        WasteTalonStack, \
        Yukon_AC_RowStack
from pysollib.util import ACE, ANY_SUIT, KING, UNLIMITED_ACCEPTS, \
        UNLIMITED_MOVES

# ************************************************************************
# * Gypsy
# ************************************************************************


class Gypsy(Game):
    Layout_Method = staticmethod(Layout.gypsyLayout)
    Talon_Class = DealRowTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack
    Hint_Class = KlondikeType_Hint

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=0, texts=1)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        if l.s.waste:
            s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(r.x, r.y, self, suit=r.suit))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        # default
        l.defaultAll()

    def startGame(self):
        for i in range(2):
            self.s.talon.dealRow(flip=0, frames=0)
        self._startAndDealRow()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Giant
# ************************************************************************

class Giant_Foundation(SS_FoundationStack):
    def canMoveCards(self, cards):
        if not SS_FoundationStack.canMoveCards(self, cards):
            return False
        # can only move cards if the Talon is empty
        return len(self.game.s.talon.cards) == 0


class Giant(Gypsy):
    Foundation_Class = Giant_Foundation

    def startGame(self):
        self._startAndDealRow()


# ************************************************************************
# * Irmgard
# ************************************************************************

class Irmgard_Talon(TalonStack):
    # A single click deals 9 (or 7) new cards to the RowStacks.
    def dealCards(self, sound=False):
        if self.cards:
            if len(self.cards) > 7:
                c = self.dealRow(sound=sound)
            else:
                c = self.dealRow(self.game.s.rows[1:8], sound=sound)
            return c
        return 0


class Irmgard(Gypsy):
    GAME_VERSION = 2

    Layout_Method = staticmethod(Layout.harpLayout)
    Talon_Class = Irmgard_Talon
    RowStack_Class = KingAC_RowStack

    def createGame(self):
        Gypsy.createGame(self, rows=9, playcards=19)

    def startGame(self):
        r = self.s.rows
        for i in range(1, 5):
            self.s.talon.dealRow(rows=r[i:len(r)-i], flip=0, frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Die Königsbergerin
# ************************************************************************

class DieKoenigsbergerin_Talon(DealRowTalonStack):
    # all Aces go to Foundations
    dealToStacks = DealRowTalonStack.dealToStacksOrFoundations


class DieKoenigsbergerin(Gypsy):
    Talon_Class = DieKoenigsbergerin_Talon
    Foundation_Class = StackWrapper(SS_FoundationStack, max_move=0)

    def startGame(self):
        self.startDealSample()
        for i in range(3):
            self.s.talon.dealRow()


# ************************************************************************
# * Die Russische
# ************************************************************************

class DieRussische_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if self.cards:
            # check the rank - an ACE equals a Six
            rank = self.cards[-1].rank
            if rank == ACE:
                rank = 5
            if (rank + self.cap.dir) % self.cap.mod != cards[0].rank:
                return False
        return True


class DieRussische_RowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        # when empty, only accept a single card
        return self.cards or len(cards) == 1


class DieRussische(Gypsy):
    Talon_Class = InitialDealTalonStack
    Foundation_Class = StackWrapper(
        DieRussische_Foundation, min_cards=1, max_cards=8)
    RowStack_Class = DieRussische_RowStack

    def createGame(self):
        Gypsy.createGame(self, rows=7, texts=0)

    def _shuffleHook(self, cards):
        # move one Ace to bottom of the Talon (i.e. last card to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == 0, c.suit), 1)

    def startGame(self):
        self._startDealNumRows(6)
        for i in range(3):
            self.s.talon.dealRow()
        c = self.s.talon.cards[-1]
        self.s.talon.dealRow(rows=(self.s.foundations[c.suit*2],))


# ************************************************************************
# * Miss Milligan
# * Imperial Guards
# ************************************************************************

class MissMilligan_ReserveStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        # Note that this reserve stack accepts sequences if both
        # the reserve stack and the Talon are empty.
        return len(self.cards) == 0 and len(self.game.s.talon.cards) == 0

    getBottomImage = Stack._getReserveBottomImage


class MissMilligan(Gypsy):
    Foundation_Class = StackWrapper(SS_FoundationStack, max_move=0)
    RowStack_Class = KingAC_RowStack
    ReserveStack_Class = MissMilligan_ReserveStack

    def createGame(self, rows=8, reserves=1):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(
            l.XM + (1+max(8, rows))*l.XS,
            l.YM + (1+max(4, reserves))*l.YS+l.TEXT_HEIGHT)

        # create stacks
        x, y = l.XM, l.YM
        s.talon = self.Talon_Class(x, y, self)
        for i in range(8):
            x = x + l.XS
            s.foundations.append(self.Foundation_Class(x, y, self, suit=i//2))
        x, y = l.XM, y + l.YS
        rx, ry = x + l.XS - l.CW//2, y - l.CH//2
        for i in range(reserves):
            s.reserves.append(
                self.ReserveStack_Class(x, y+l.TEXT_HEIGHT, self))
            y = y + l.YS
        l.createText(s.talon, "s")
        if s.reserves:
            self.setRegion(s.reserves, (-999, ry+l.TEXT_HEIGHT, rx-1, 999999))
        else:
            rx = -999
        x, y = l.XM + (8-rows)*l.XS//2, l.YM + l.YS
        for i in range(rows):
            x = x + l.XS
            s.rows.append(self.RowStack_Class(x, y, self))
        self.setRegion(s.rows, (rx, ry, 999999, 999999))

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startAndDealRow()


class ImperialGuards(MissMilligan):
    RowStack_Class = AC_RowStack


# ************************************************************************
# * Nomad
# ************************************************************************

class Nomad(MissMilligan):
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack
    ReserveStack_Class = ReserveStack

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(3)


# ************************************************************************
# * Milligan Cell
# ************************************************************************

class MilliganCell(MissMilligan):
    ReserveStack_Class = ReserveStack

    def createGame(self):
        MissMilligan.createGame(self, reserves=4)

    def startGame(self):
        self._startAndDealRow()


# ************************************************************************
# * Milligan Harp
# * Carlton
# * Steve
# ************************************************************************

class MilliganHarp(Gypsy):
    Foundation_Class = StackWrapper(SS_FoundationStack, max_move=0)

    def startGame(self, flip=0):
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=flip, frames=0)
        self._startAndDealRow()


class Carlton(MilliganHarp):
    def startGame(self):
        MilliganHarp.startGame(self, flip=1)


class Steve(Carlton):
    Hint_Class = Spider_Hint
    RowStack_Class = Spider_SS_RowStack

    shallHighlightMatch = Game._shallHighlightMatch_RK
    getQuickPlayScore = Game._getSpiderQuickPlayScore


# ************************************************************************
# * Lexington Harp
# * Brunswick
# * Mississippi
# * Griffon
# ************************************************************************

class LexingtonHarp(MilliganHarp):
    GAME_VERSION = 2
    RowStack_Class = Yukon_AC_RowStack
    Hint_Class = YukonType_Hint

    def getHighlightPilesStacks(self):
        return ()


class Brunswick(LexingtonHarp):
    def startGame(self):
        LexingtonHarp.startGame(self, flip=1)


class Mississippi(LexingtonHarp):
    def createGame(self):
        LexingtonHarp.createGame(self, rows=7)


class Griffon(Mississippi):
    def startGame(self):
        Mississippi.startGame(self, flip=1)


# ************************************************************************
# * Blockade
# * Phantom Blockade
# ************************************************************************

class Blockade(Gypsy):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    RowStack_Class = SS_RowStack

    def createGame(self):
        Gypsy.createGame(self, rows=12)

    def startGame(self):
        self._startAndDealRow()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards and self.s.talon.cards:
            old_state = self.enterState(self.S_FILL)
            self.s.talon.flipMove()
            self.s.talon.moveMove(1, stack)
            self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_SS


class PhantomBlockade(Gypsy):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    RowStack_Class = KingAC_RowStack

    def createGame(self):
        Gypsy.createGame(self, rows=13, playcards=24)

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(2)


# ************************************************************************
# * Cone
# ************************************************************************

class Cone_Talon(DealRowTalonStack):
    def canDealCards(self):
        if not DealRowTalonStack.canDealCards(self):
            return False
        if len(self.cards) == 4:
            return True
        for r in self.game.s.rows:
            if not r.cards:
                return False
        return True

    def dealCards(self, sound=False):
        rows = self.game.s.rows
        if len(self.cards) == 4:
            rows = self.game.s.reserves
        return self.dealRowAvail(rows=rows, sound=sound)


class Cone(Gypsy):

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+9*l.XS, 3*l.YM+5*l.YS)

        # create stacks
        x, y = l.XM, l.YM
        s.talon = Cone_Talon(x, y, self)
        l.createText(s.talon, 's')
        y += l.YS+2*l.YM
        for i in range(4):
            s.reserves.append(OpenStack(x, y, self, max_accept=0))
            y += l.YS
        x, y = l.XM+l.XS, l.YM
        for i in range(7):
            s.rows.append(AC_RowStack(x, y, self, mod=13))
            x += l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                    mod=13, max_cards=26))
            y += l.YS

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        for i in (1, 2, 3):
            self.s.talon.dealRow(rows=self.s.rows[i:-i])

    shallHighlightMatch = Game._shallHighlightMatch_ACW


# ************************************************************************
# * Surprise
# ************************************************************************

class Surprise_ReserveStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        return len(self.game.s.talon.cards) == 0


class Surprise(Gypsy):

    def createGame(self, rows=8, reserves=1):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+11*l.XS, l.YM+2*l.YS+12*l.YOFFSET+20)

        # create stacks
        x, y = l.XM, l.YM
        s.talon = self.Talon_Class(x, y, self)
        l.createText(s.talon, 's')
        x += l.XS
        stack = Surprise_ReserveStack(x, y, self, max_cards=3)
        xoffset = min(l.XOFFSET, l.XS//3)
        stack.CARD_XOFFSET = xoffset
        s.reserves.append(stack)
        x += 2*l.XS
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2))
            x += l.XS
        x, y = l.XM, l.YM+l.YS+l.TEXT_HEIGHT
        for i in range(11):
            s.rows.append(KingAC_RowStack(x, y, self))
            x += l.XS

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        for i in range(1, 6):
            self.s.talon.dealRow(rows=self.s.rows[i:-i], flip=0, frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Elba
# ************************************************************************

class Elba(Gypsy):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    RowStack_Class = KingAC_RowStack

    def createGame(self):
        Gypsy.createGame(self, rows=10)

    def startGame(self):
        for i in range(4):
            self.s.talon.dealRow(flip=0, frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Millie
# ************************************************************************

class Millie(Gypsy):
    Layout_Method = staticmethod(Layout.klondikeLayout)

    def createGame(self):
        Gypsy.createGame(self, playcards=24)

    def startGame(self):
        self._startAndDealRow()


# ************************************************************************
# * Hypotenuse
# * Eternal Triangle
# * Right Triangle
# ************************************************************************

class Hypotenuse(Gypsy):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    RowStack_Class = KingAC_RowStack

    def createGame(self):
        Gypsy.createGame(self, rows=10, playcards=24)

    def startGame(self, flip=0, reverse=1):
        for i in range(1, 10):
            self.s.talon.dealRow(rows=self.s.rows[:i], flip=0, frames=0)
        self._startAndDealRow()


class EternalTriangle(Hypotenuse):

    def startGame(self, flip=0, reverse=1):
        for i in range(1, 10):
            self.s.talon.dealRow(rows=self.s.rows[i:], frames=0)
        self._startAndDealRow()


class RightTriangle_Talon(OpenStack, DealRowTalonStack):
    def __init__(self, x, y, game, max_rounds=1, num_deal=1, **cap):
        kwdefault(cap, max_move=1, max_accept=1, max_cards=999999)
        Stack.__init__(self, x, y, game, cap=cap)
        self.max_rounds = max_rounds
        self.num_deal = num_deal
        self.round = 1
        self.base_cards = []        # for DealBaseCard_StackMethods

    def clickHandler(self, event):
        if self.cards and not self.cards[-1].face_up:
            return self.game.dealCards(sound=True)
        return OpenStack.clickHandler(self, event)

    def canDealCards(self):
        if not DealRowTalonStack.canDealCards(self):
            return False
        if self.cards and self.cards[-1].face_up:
            return False
        return True

    def canFlipCard(self):
        return False

    getBottomImage = Stack._getReserveBottomImage

    prepareView = Stack.prepareView

    resize = Stack.resize

    def getHelp(self):
        return DealRowTalonStack.getHelp(self)


class RightTriangle(Hypotenuse):
    Talon_Class = RightTriangle_Talon

    def createGame(self):
        Gypsy.createGame(self, rows=10, playcards=24)
        self.sg.dropstacks.append(self.s.talon)
        self.sg.openstacks.append(self.s.talon)
        self.sg.reservestacks.append(self.s.talon)


# ************************************************************************
# * Trapdoor
# ************************************************************************

class Trapdoor_Talon(DealRowTalonStack):
    def dealCards(self, sound=False):
        if not self.cards:
            return 0
        if sound:
            self.game.startDealSample()
        n = 0
        rows = self.game.s.rows
        reserves = self.game.s.reserves
        for i in range(len(rows)):
            r1 = reserves[i]
            r2 = rows[i]
            if r1.cards:
                r1.moveMove(1, r2)
                n += 1
        n += self.dealRowAvail(rows=self.game.s.reserves, sound=False)
        if sound:
            self.game.stopSamples()
        return n


class Trapdoor(Gypsy):
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    def createGame(self, rows=8):
        kw = {'rows': rows,
              'waste': 0,
              'texts': 1,
              'reserves': rows}
        Layout(self).createGame(layout_method=Layout.gypsyLayout,
                                talon_class=Trapdoor_Talon,
                                foundation_class=self.Foundation_Class,
                                row_class=self.RowStack_Class,
                                reserve_class=OpenStack,
                                **kw
                                )

    def startGame(self):
        Gypsy.startGame(self)
        self.s.talon.dealCards()


class TrapdoorSpider(Trapdoor):
    Foundation_Class = Spider_SS_Foundation
    RowStack_Class = Spider_RowStack
    Hint_Class = Spider_Hint

    def createGame(self):
        Trapdoor.createGame(self, rows=10)

    def startGame(self, flip=0):
        for i in range(3):
            self.s.talon.dealRow(flip=flip, frames=0)
        r = self.s.rows
        rows = (r[0], r[3], r[6], r[9])
        self.s.talon.dealRow(rows=rows, flip=flip, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_RK
    getQuickPlayScore = Game._getSpiderQuickPlayScore


# ************************************************************************
# * Flamenco
# ************************************************************************

class Flamenco(Gypsy):

    def createGame(self):
        kw = {'rows': 8,
              'waste': 0,
              'texts': 1, }
        foundation_class = (
            SS_FoundationStack,
            StackWrapper(SS_FoundationStack, base_rank=KING, dir=-1))
        Layout(self).createGame(layout_method=Layout.gypsyLayout,
                                talon_class=DealRowTalonStack,
                                foundation_class=foundation_class,
                                row_class=AC_RowStack,
                                **kw
                                )

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (ACE, KING) and c.deck == 0,
                       (c.suit, c.rank)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startDealNumRowsAndDealSingleRow(2)


# ************************************************************************
# * Eclipse
# ************************************************************************

class Eclipse(Gypsy):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    RowStack_Class = SS_RowStack

    def createGame(self):
        Gypsy.createGame(self, rows=13)

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(3)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Brazilian Patience
# ************************************************************************

class BrazilianPatience(Gypsy):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    RowStack_Class = KingAC_RowStack

    def createGame(self):
        Gypsy.createGame(self, rows=10, playcards=22)

    def startGame(self, flip=0, reverse=1):
        for i in range(1, 10):
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=0, frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Leprechaun
# ************************************************************************

class Leprechaun_Reserve(OpenStack):
    def canFlipCard(self):
        if not OpenStack.canFlipCard(self):
            return False
        i = list(self.game.s.reserves).index(self)
        return len(self.game.s.foundations[i].cards) != 0


class Leprechaun(Game):

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+9.5*l.XS, l.YM+3*l.YS+l.TEXT_HEIGHT+12*l.YOFFSET)

        # create stacks
        x, y = l.XM+1.5*l.XS, l.TEXT_HEIGHT
        for i in range(8):
            stack = Leprechaun_Reserve(x, y, self)
            s.reserves.append(stack)
            l.createText(stack, 'n')
            x += l.XS

        x, y = l.XM+1.5*l.XS, l.YS+l.TEXT_HEIGHT
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2))
            x += l.XS

        x, y = l.XM+1.5*l.XS, 2*l.YS+l.TEXT_HEIGHT
        for i in range(8):
            s.rows.append(AC_RowStack(x, y, self))
            x += l.XS

        s.talon = DealRowTalonStack(l.XM, l.YM, self)
        l.createText(s.talon, 's')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        for i in range(4):
            self.s.talon.dealRow(rows=self.s.reserves, flip=0, frames=0)
        self.s.talon.dealRow(flip=0, frames=0)
        self.s.talon.dealRow(flip=0, frames=0)
        self._startAndDealRow()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Locked Cards
# * Topsy-Turvy Queens
# ************************************************************************

class LockedCards_Reserve(OpenStack):
    def canFlipCard(self):
        if not OpenStack.canFlipCard(self):
            return False
        i = list(self.game.s.reserves).index(self)
        return len(self.game.s.foundations[i].cards) == 13


class LockedCards_Foundation(SS_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if self.cards:
            # check suit
            return self.cards[-1].suit == cards[0].suit
        return True


class LockedCards(Game):
    Foundation_Class = LockedCards_Foundation
    RowStack_Class = AC_RowStack

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+10*l.XS, l.YM+3*l.YS+14*l.YOFFSET)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(7):
            s.reserves.append(LockedCards_Reserve(x, y, self))
            x += l.XS

        x, y = l.XM, l.YM+l.YS
        for i in range(8):
            s.foundations.append(self.Foundation_Class(x, y, self,
                                 suit=ANY_SUIT, max_move=0))
            x += l.XS

        x, y = l.XM, l.YM+2*l.YS
        for i in range(8):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += l.XS

        x, y = self.width-l.XS, self.height-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, 'n')
        l.createRoundText(s.talon, 'nnn')

        x -= l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'n')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self, rows=5):
        self.s.talon.dealRow(rows=self.s.reserves, flip=0, frames=0)
        self._startDealNumRowsAndDealRowAndCards(rows-1)

    shallHighlightMatch = Game._shallHighlightMatch_AC


class TopsyTurvyQueens(LockedCards):
    Foundation_Class = StackWrapper(LockedCards_Foundation,
                                    base_rank=KING, mod=13)
    RowStack_Class = StackWrapper(SS_RowStack, mod=13)

    def startGame(self):
        LockedCards.startGame(self, rows=4)

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * Thirty
# ************************************************************************

class Thirty_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if self.cards:
            # check the rank - an ACE equals a Six
            rank = self.cards[-1].rank
            if rank == ACE:
                rank = 5
            if (rank + self.cap.dir) % self.cap.mod != cards[0].rank:
                return False
        return True

    def canMoveCards(self, cards):
        if not BasicRowStack.canMoveCards(self, cards):
            return False
        c1 = cards[0]
        for c2 in cards[1:]:
            if c1.suit != c2.suit:
                return False
            # check the rank - an ACE equals a Six
            rank = c1.rank
            if rank == ACE:
                rank = 5
            if (rank + self.cap.dir) % self.cap.mod != c2.rank:
                return False
            c1 = c2
        return True


class Thirty(Game):
    Hint_Class = Spider_Hint

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+7*l.XS, l.YM+2*l.YS+12*l.YOFFSET)

        x, y = l.XM, l.YM
        for i in range(2):
            s.reserves.append(OpenStack(x, y, self))
            x += l.XS

        x, y = l.XM+3*l.XS, l.YM
        for i in range(4):
            s.foundations.append(DieRussische_Foundation(x, y, self,
                                                         suit=i, max_cards=8))
            x += l.XS

        x, y = l.XM+l.XS//2, l.YM+l.YS
        for i in range(6):
            s.rows.append(Thirty_RowStack(x, y, self,
                          max_move=UNLIMITED_MOVES,
                          max_accept=UNLIMITED_ACCEPTS))
            x += l.XS

        x, y = self.width-l.XS, self.height-l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        l.defaultAll()

    def startGame(self):
        self._startDealNumRows(4)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)

    shallHighlightMatch = Game._shallHighlightMatch_RK
    getQuickPlayScore = Game._getSpiderQuickPlayScore


# register the game
registerGame(GameInfo(1, Gypsy, "Gypsy",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(65, Giant, "Giant",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(3, Irmgard, "Irmgard",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(119, DieKoenigsbergerin, "Die Koenigsbergerin",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(174, DieRussische, "Russian Patience",
                      GI.GT_2DECK_TYPE | GI.GT_OPEN, 2, 0, GI.SL_MOSTLY_SKILL,
                      ranks=(0, 6, 7, 8, 9, 10, 11, 12),
                      altnames=("Die Russische",)))
registerGame(GameInfo(62, MissMilligan, "Miss Milligan",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(200, Nomad, "Nomad",
                      GI.GT_GYPSY | GI.GT_CONTRIB | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(78, MilliganCell, "Milligan Cell",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(217, MilliganHarp, "Milligan Harp",
                      GI.GT_GYPSY, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(218, Carlton, "Carlton",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(68, LexingtonHarp, "Lexington Harp",
                      GI.GT_YUKON, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(154, Brunswick, "Brunswick",
                      GI.GT_YUKON, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(121, Mississippi, "Mississippi",
                      GI.GT_YUKON | GI.GT_XORIGINAL, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(122, Griffon, "Griffon",
                      GI.GT_YUKON | GI.GT_XORIGINAL, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(226, Blockade, "Blockade",
                      GI.GT_GYPSY, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(412, Cone, "Cone",
                      GI.GT_GYPSY, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(463, Surprise, "Surprise",
                      GI.GT_GYPSY, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(469, PhantomBlockade, "Phantom Blockade",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(478, Elba, "Elba",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(486, ImperialGuards, "Imperial Guards",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(487, Millie, "Millie",
                      GI.GT_GYPSY, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(498, Steve, "Steve",
                      GI.GT_GYPSY, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(566, Hypotenuse, "Hypotenuse",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(567, EternalTriangle, "Eternal Triangle",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL,
                      altnames=('Lobachevsky',)))
registerGame(GameInfo(568, RightTriangle, "Right Triangle",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(580, Trapdoor, "Trapdoor",
                      GI.GT_GYPSY | GI.GT_ORIGINAL, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(581, Flamenco, "Flamenco",
                      GI.GT_GYPSY | GI.GT_ORIGINAL, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(584, Eclipse, "Eclipse",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(640, BrazilianPatience, "Brazilian Patience",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(666, TrapdoorSpider, "Trapdoor Spider",
                      GI.GT_SPIDER | GI.GT_ORIGINAL, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(712, Leprechaun, "Leprechaun",
                      GI.GT_GYPSY | GI.GT_ORIGINAL, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(718, LockedCards, "Locked Cards",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(721, Thirty, "Thirty",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL,
                      ranks=(0, 6, 7, 8, 9, 10, 11, 12)))
registerGame(GameInfo(725, TopsyTurvyQueens, "Topsy-Turvy Queens",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_BALANCED))
# vim:ts=4:et:nowrap:fileencoding=utf-8
#

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.layout import Layout
from pysollib.stack import \
        DealRowTalonStack, \
        StackWrapper, \
        Yukon_SS_RowStack, \
        isSameSuitSequence
from pysollib.util import ACE

# ***********************************************************************
# Daddy Longlegs (by Jim Sizelove)
# ***********************************************************************


class DaddyLonglegs(Game):
    Talon_Class = DealRowTalonStack
    RowStack_Class = StackWrapper(Yukon_SS_RowStack, dir=1, base_rank=ACE)

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 6*l.XS, l.YM + 7*l.YS)

        # create stacks
        x, y, = l.XM, l.YM
        s.talon = self.Talon_Class(x, y, self)
        l.createText(s.talon, "ss")
        x = x + 3*l.XS//2
        for i in range(4):
            s.rows.append(self.RowStack_Class(x, y, self))
            x = x + l.XS

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.s.talon.dealRow()

    def isGameWon(self):
        if self.s.talon.cards:
            return 0
        for row in self.s.rows:
            if not isSameSuitSequence(row.cards, dir=1):
                return 0
        return 1


# register the game
registerGame(GameInfo(555001, DaddyLonglegs, "Daddy Longlegs",
                      GI.GT_SPIDER, 1, 0, GI.SL_MOSTLY_SKILL,
                      rules_filename="daddylonglegs.html"))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AC_RowStack, \
        KingAC_RowStack, \
        OpenStack, \
        OpenTalonStack, \
        RK_FoundationStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        StackWrapper, \
        TalonStack, \
        WasteStack
from pysollib.util import ACE, ANY_RANK, KING, NO_RANK, RANKS, UNLIMITED_CARDS


class Bristol_Hint(CautiousDefaultHint):
    # FIXME: demo is not too clever in this game

    BONUS_CREATE_EMPTY_ROW = 0           # 0..9000
    BONUS_CAN_DROP_ALL_CARDS = 0           # 0..4000
    BONUS_CAN_CREATE_EMPTY_ROW = 0           # 0..4000

    # Score for moving a pile from stack r to stack t.
    # Increased score must be in range 0..9999
    def _getMovePileScore(self, score, color, r, t, pile, rpile):
        # prefer reserves
        if r not in self.game.s.reserves:
            score = score - 10000
            # an empty pile doesn't gain anything
            if len(pile) == len(r.cards):
                return -1, color
        return CautiousDefaultHint._getMovePileScore(
            self, score, color, r, t, pile, rpile)


# ************************************************************************
# * Bristol
# ************************************************************************

class Bristol_Talon(TalonStack):
    def dealCards(self, sound=False):
        return self.dealRowAvail(rows=self.game.s.reserves, sound=sound)


class Bristol(Game):
    Hint_Class = Bristol_Hint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 10*l.XS, l.YM + 5*l.YS)

        # create stacks
        x, y, = l.XM + 3*l.XS, l.YM
        for i in range(4):
            s.foundations.append(RK_FoundationStack(x, y, self, max_move=0))
            x += l.XS
        for i in range(2):
            y = l.YM + (i*2+3)*l.YS//2
            for j in range(4):
                x = l.XM + (j*5)*l.XS//2
                stack = RK_RowStack(x, y, self,  base_rank=NO_RANK, max_move=1)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
                s.rows.append(stack)
        x, y, = l.XM + 3*l.XS, l.YM + 4*l.YS
        s.talon = Bristol_Talon(x, y, self)
        l.createText(s.talon, "sw")
        x += l.XS
        for i in range(3):
            stack = WasteStack(x, y, self)
            l.createText(stack, 'n')
            s.reserves.append(stack)
            x += l.XS

        # define stack-groups
        self.sg.openstacks = s.foundations + s.rows
        self.sg.talonstacks = [s.talon]
        self.sg.dropstacks = s.rows + s.reserves

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        # move Kings to bottom of each stack
        i, n = 0, len(self.s.rows)
        kings = []
        for c in cards[:24]:    # search the first 24 cards only
            if c.rank == KING:
                kings.append(i)
            i += 1
        for i in kings:
            j = i % n           # j = card index of rowstack bottom
            while j < i:
                if cards[j].rank != KING:
                    cards[j], cards[i] = cards[i], cards[j]
                    break
                j += n
        cards.reverse()
        return cards

    def startGame(self):
        r = self.s.rows
        for i in range(2):
            self.s.talon.dealRow(rows=r, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=r)
        self.s.talon.dealCards()          # deal first cards to Reserves

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Belvedere
# ************************************************************************

class Belvedere(Bristol):
    def _shuffleHook(self, cards):
        # remove 1 Ace
        for c in cards:
            if c.rank == 0:
                cards.remove(c)
                break
        # move Kings to bottom
        cards = Bristol._shuffleHook(self, cards)
        # re-insert Ace
        return cards[:-24] + [c] + cards[-24:]

    def startGame(self):
        r = self.s.rows
        for i in range(2):
            self.s.talon.dealRow(rows=r, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=r)
        assert self.s.talon.cards[-1].rank == ACE
        self.s.talon.dealRow(rows=self.s.foundations[:1])
        self.s.talon.dealCards()          # deal first cards to Reserves


# ************************************************************************
# * Dover
# ************************************************************************

class Dover_RowStack(RK_RowStack):

    def acceptsCards(self, from_stack, cards):
        if not self.cards and from_stack in self.game.s.reserves:
            return True
        return RK_RowStack.acceptsCards(self, from_stack, cards)


class Dover(Bristol):

    Talon_Class = Bristol_Talon
    Foundation_Class = StackWrapper(SS_FoundationStack, max_move=0)
    RowStack_Class = StackWrapper(
        Dover_RowStack, base_rank=NO_RANK, max_move=1)
    ReserveStack_Class = StackWrapper(
        ReserveStack, max_accept=0, max_cards=UNLIMITED_CARDS)

    def createGame(self, rows=8, text=False):
        # create layout
        l, s = Layout(self), self.s

        # set window
        max_rows = max(rows, self.gameinfo.decks*4)
        w, h = 2*l.XM+l.XS+max_rows*l.XS+l.XS//2, l.YM+l.TEXT_HEIGHT+5*l.YS
        self.setSize(w, h)

        # create stacks
        x, y, = w-l.XS*self.gameinfo.decks*4, l.YM
        for j in range(self.gameinfo.decks):
            for i in range(4):
                s.foundations.append(self.Foundation_Class(x, y, self, suit=i))
                x += l.XS
        if text:
            x, y = w-l.XS, l.YM
            tx, ty, ta, tf = l.getTextAttr(None, "ss")
            tx, ty = x+tx, y+ty
            font = self.app.getFont("canvas_default")
            self.texts.info = MfxCanvasText(self.canvas, tx, ty,
                                            anchor=ta, font=font)

        x, y = w-rows*l.XS, l.YM+l.YS
        if text:
            y += l.TEXT_HEIGHT
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, l.YOFFSET
            s.rows.append(stack)
            x += l.XS
        x, y, = l.XM, l.YM
        s.talon = self.Talon_Class(x, y, self)
        l.createText(s.talon, "s")
        y += l.TEXT_HEIGHT
        for i in range(3):
            y += l.YS
            stack = self.ReserveStack_Class(x, y, self)
            s.reserves.append(stack)
            l.createText(stack, "se")

        # define stack-groups
        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return cards


# ************************************************************************
# * New York
# ************************************************************************

class NewYork_Hint(CautiousDefaultHint):
    def computeHints(self):
        CautiousDefaultHint.computeHints(self)
        if self.hints:
            return
        if not self.game.s.talon.cards:
            return
        c = self.game.s.talon.cards[-1].rank - self.game.base_card.rank
        if c < 0:
            c += 13
        if 0 <= c <= 3:
            r = self.game.s.reserves[0]
        elif 4 <= c <= 7:
            r = self.game.s.reserves[1]
        else:
            r = self.game.s.reserves[2]
        self.addHint(5000, 1, self.game.s.talon, r)


class NewYork_Talon(OpenTalonStack):
    rightclickHandler = OpenStack.rightclickHandler
    doubleclickHandler = OpenStack.doubleclickHandler


class NewYork_ReserveStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        return from_stack is self.game.s.talon


class NewYork_RowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return (from_stack is self.game.s.talon or
                    from_stack in self.game.s.reserves)
        return True


class NewYork(Dover):

    Hint_Class = NewYork_Hint
    Foundation_Class = StackWrapper(SS_FoundationStack, mod=13, max_move=0)
    Talon_Class = NewYork_Talon
    RowStack_Class = StackWrapper(
        NewYork_RowStack, base_rank=ANY_RANK, mod=13, max_move=1)
    ReserveStack_Class = StackWrapper(
        NewYork_ReserveStack, max_accept=1, max_cards=UNLIMITED_CARDS, mod=13)

    def createGame(self):
        # extra settings
        self.base_card = None
        Dover.createGame(self, text=True)
        self.sg.dropstacks.append(self.s.talon)

    def updateText(self):
        if self.preview > 1:
            return
        if not self.base_card:
            t = ""
        else:
            t = RANKS[self.base_card.rank]
        self.texts.info.config(text=t)

    def startGame(self):
        self.startDealSample()
        self.base_card = None
        self.updateText()
        # deal base_card to Foundations, update foundations cap.base_rank
        self.base_card = self.s.talon.getCard()
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        n = self.base_card.suit
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, self.s.foundations[n])
        # self.updateText()
        self.s.talon.dealRow()
        self.s.talon.fillStack()

    shallHighlightMatch = Game._shallHighlightMatch_ACW

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)


# ************************************************************************
# * Spike
# ************************************************************************

class Spike(Dover):

    Foundation_Class = SS_FoundationStack
    RowStack_Class = KingAC_RowStack

    def createGame(self):
        Dover.createGame(self, rows=7)

    def startGame(self):
        for i in range(1, 7):
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Gotham
# ************************************************************************

class Gotham_RowStack(RK_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return (from_stack is self.game.s.talon or
                    from_stack in self.game.s.reserves)
        return True


class Gotham(NewYork):
    RowStack_Class = StackWrapper(Gotham_RowStack, base_rank=ANY_RANK, mod=13)

    def startGame(self):
        self._dealNumRows(2)
        NewYork.startGame(self)

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# ************************************************************************
# * Interment
# ************************************************************************

class Interment_Hint(CautiousDefaultHint):
    def computeHints(self):
        CautiousDefaultHint.computeHints(self)
        if self.hints:
            return
        if not self.game.s.talon.cards:
            return
        c = self.game.s.talon.cards[-1].rank
        if 0 <= c <= 3:
            r = self.game.s.xwastes[0]
        elif 4 <= c <= 7:
            r = self.game.s.xwastes[1]
        else:
            r = self.game.s.xwastes[2]
        self.addHint(5000, 1, self.game.s.talon, r)


class Interment_Talon(OpenTalonStack):
    rightclickHandler = OpenStack.rightclickHandler
    doubleclickHandler = OpenStack.doubleclickHandler


class Interment_Reserve(OpenStack):
    def canFlipCard(self):
        return False


class Interment_Waste(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        return from_stack is self.game.s.talon


class Interment(Game):
    Hint_Class = Interment_Hint

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        s.addattr(xwastes=[])      # register extra stack variable

        # set window
        w, h = l.XM+11*l.XS, l.YM+6*l.YS
        self.setSize(w, h)

        # create stacks
        x, y, = l.XM, l.YM
        s.talon = Interment_Talon(x, y, self)
        l.createText(s.talon, 'ne')
        x += 1.5*l.XS
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2))
            x += l.XS
        x, y = l.XM, l.YM+l.YS
        for i in range(3):
            stack = Interment_Waste(x, y, self, max_cards=UNLIMITED_CARDS)
            l.createText(stack, 'ne')
            s.xwastes.append(stack)
            y += l.YS
        x, y = l.XM+1.5*l.XS, l.YM+l.YS
        for i in range(8):
            s.rows.append(SS_RowStack(x, y, self, max_move=1))
            x += l.XS
        x, y = self.width-l.XS, l.YM
        stack = Interment_Reserve(x, y, self)
        s.reserves.append(stack)
        l.createText(stack, 'nw')
        y += l.YS
        for i in range(5):
            s.reserves.append(OpenStack(x, y, self))
            y += l.YS

        # define stack-groups
        l.defaultStackGroups()
        self.sg.dropstacks += s.xwastes
        self.sg.openstacks += s.xwastes
        self.sg.dropstacks.append(s.talon)

    def startGame(self):
        for i in range(13):
            self.s.talon.dealRow(rows=[self.s.reserves[0]], flip=0, frames=0)
        self.s.talon.dealRow(rows=self.s.reserves[1:], frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.fillStack()

    def fillStack(self, stack):
        if not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if stack in self.s.rows:
                if self.s.talon.cards:
                    self.s.talon.moveMove(1, stack)
            if stack in self.s.reserves[1:]:
                from_stack = self.s.reserves[0]
                if from_stack.cards:
                    from_stack.flipMove()
                    from_stack.moveMove(1, stack)
            self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_SS

    def getQuickPlayScore(self, ncards, from_stack, to_stack):
        if to_stack in self.s.xwastes:
            return 0
        return 1+Game.getQuickPlayScore(self, ncards, from_stack, to_stack)


# register the game
registerGame(GameInfo(42, Bristol, "Bristol",
                      GI.GT_FAN_TYPE, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(214, Belvedere, "Belvedere",
                      GI.GT_FAN_TYPE, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(266, Dover, "Dover",
                      GI.GT_FAN_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(425, NewYork, "New York",
                      GI.GT_FAN_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(468, Spike, "Spike",
                      GI.GT_KLONDIKE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(519, Gotham, "Gotham",
                      GI.GT_FAN_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(604, Interment, "Interment",
                      GI.GT_FAN_TYPE, 2, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.fortythieves import FortyThieves_Hint
from pysollib.games.spider import Spider_Hint
from pysollib.layout import Layout
from pysollib.stack import \
        RK_RowStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        Spider_SS_RowStack, \
        StackWrapper, \
        UD_SS_RowStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, KING

# ************************************************************************
# * Diplomat
# ************************************************************************


class Diplomat(Game):
    Foundation_Class = SS_FoundationStack
    RowStack_Class = StackWrapper(RK_RowStack, max_move=1)
    Hint_Class = FortyThieves_Hint

    DEAL = (3, 1)
    FILL_EMPTY_ROWS = 0

    #
    # game layout
    #

    def createGame(self, max_rounds=1):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+8*l.XS, l.YM+3*l.YS+12*l.YOFFSET+l.TEXT_HEIGHT)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(8):
            s.foundations.append(self.Foundation_Class(x, y, self, suit=i//2))
            x = x + l.XS
        x, y = l.XM, y + l.YS
        for i in range(8):
            s.rows.append(self.RowStack_Class(x, y, self))
            x = x + l.XS
        x, y, = l.XM, self.height - l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=max_rounds)
        l.createText(s.talon, "n")
        if max_rounds > 1:
            l.createRoundText(self.s.talon, 'nnn')
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "n")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        for i in range(self.DEAL[0]):
            self.s.talon.dealRow(frames=0)
        self.startDealSample()
        for i in range(self.DEAL[1]):
            self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack

    def fillStack(self, stack):
        if self.FILL_EMPTY_ROWS and stack in self.s.rows and not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if self.s.waste.cards:
                self.s.waste.moveMove(1, stack)
            elif self.s.talon.canDealCards():
                self.s.talon.dealCards()
                self.s.waste.moveMove(1, stack)
            self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Lady Palk
# ************************************************************************

class LadyPalk(Diplomat):
    RowStack_Class = RK_RowStack


# ************************************************************************
# * Congress
# * Parliament
# ************************************************************************

class Congress(Diplomat):
    DEAL = (0, 1)
    FILL_EMPTY_ROWS = 1

    Foundation_Classes = [SS_FoundationStack, SS_FoundationStack]

    #
    # game layout (just rearrange the stacks a little bit)
    #

    def createGame(self, max_rounds=1):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 7*l.XS, l.YM + 4*l.YS)

        # create stacks
        x = l.XM+4*l.XS
        for fnd_cls in self.Foundation_Classes:
            y = l.YM
            for i in range(4):
                s.foundations.append(fnd_cls(x, y, self, suit=i))
                y += l.YS
            x += l.XS
        for i in range(4):
            for j in range(2):
                x, y = l.XM + (3+3*j)*l.XS, l.YM + i*l.YS
                stack = self.RowStack_Class(x, y, self)
                stack.CARD_YOFFSET = 0
                s.rows.append(stack)
        x, y, = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=max_rounds)
        l.createText(s.talon, "s")
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")
        if max_rounds > 1:
            l.createRoundText(s.talon, 'ne', dx=l.XS)

        # define stack-groups
        l.defaultStackGroups()


class Parliament(Congress):

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == ACE, (c.deck, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        Congress.startGame(self)


class Wheatsheaf(Congress):
    Foundation_Classes = [
        SS_FoundationStack,
        StackWrapper(SS_FoundationStack, base_rank=KING, dir=-1),
        ]
    RowStack_Class = UD_SS_RowStack

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Rows of Four
# ************************************************************************

class RowsOfFour(Diplomat):
    def createGame(self):
        Diplomat.createGame(self, max_rounds=3)


# ************************************************************************
# * Dieppe
# ************************************************************************

class Dieppe(Diplomat):
    RowStack_Class = RK_RowStack

    def _dealToFound(self):
        talon = self.s.talon
        if not talon.cards:
            return False
        talon.flipMove()
        for f in self.s.foundations:
            if f.acceptsCards(talon, talon.cards[-1:]):
                talon.moveMove(1, f)
                return True
        return False

    def startGame(self):
        self.startDealSample()
        talon = self.s.talon
        for i in range(3):
            for r in self.s.rows:
                while True:
                    if not self._dealToFound():
                        break
                if talon.cards:
                    talon.moveMove(1, r)
        talon.dealCards()


# ************************************************************************
# * Little Napoleon
# ************************************************************************

class LittleNapoleon(Diplomat):
    RowStack_Class = Spider_SS_RowStack
    Hint_Class = Spider_Hint

    def startGame(self):
        for i in range(3):
            self.s.talon.dealRow(frames=0, flip=0)
        self._startAndDealRowAndCards()

    getQuickPlayScore = Game._getSpiderQuickPlayScore


# ************************************************************************
# * Twin Queens
# ************************************************************************

class TwinQueens(Congress):
    Foundation_Classes = [
        StackWrapper(SS_FoundationStack, base_rank=KING, mod=13),
        StackWrapper(SS_FoundationStack, base_rank=KING, mod=13),
        ]
    RowStack_Class = StackWrapper(SS_RowStack, max_move=1)

    def createGame(self):
        Congress.createGame(self, max_rounds=2)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# register the game
registerGame(GameInfo(149, Diplomat, "Diplomat",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(151, LadyPalk, "Lady Palk",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(150, Congress, "Congress",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(433, RowsOfFour, "Rows of Four",
                      GI.GT_FORTY_THIEVES, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(485, Dieppe, "Dieppe",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(489, LittleNapoleon, "Little Napoleon",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(548, Parliament, "Parliament",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(549, Wheatsheaf, "Wheatsheaf",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(563, TwinQueens, "Twin Queens",
                      GI.GT_FORTY_THIEVES, 2, 1, GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.layout import Layout
from pysollib.stack import \
        OpenStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        UD_SS_RowStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import KING, NO_RANK, UNLIMITED_REDEALS


# ************************************************************************
# * Zodiac
# ************************************************************************

class Zodiac_Foundation(SS_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if self.game.s.waste.cards or self.game.s.talon.cards:
            return False
        return True


class Zodiac_RowStack(UD_SS_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not UD_SS_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack in self.game.s.rows:
            return False
        return True


class Zodiac_ReserveStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack in self.game.s.rows:
            return False
        return True


class Zodiac(Game):

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+12*l.XS, l.YM+5*l.YS
        self.setSize(w, h)

        # create stacks
        x = l.XM
        for i in range(12):
            for y in (l.YM, l.YM+4*l.YS):
                stack = Zodiac_RowStack(x, y, self, base_rank=NO_RANK)
                s.rows.append(stack)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
            x += l.XS

        x = l.XM+4*l.XS
        for i in range(4):
            y = l.YM+l.YS
            s.foundations.append(Zodiac_Foundation(x, y, self, suit=i))
            y += 2*l.YS
            s.foundations.append(Zodiac_Foundation(x, y, self, suit=i,
                                                   base_rank=KING, dir=-1))
            x += l.XS

        x, y = l.XM+2*l.XS, l.YM+2*l.YS
        for i in range(8):
            s.reserves.append(Zodiac_ReserveStack(x, y, self))
            x += l.XS

        x, y = l.XM+l.XS, l.YM+l.YS
        s.talon = WasteTalonStack(x, y, self,
                                  max_rounds=UNLIMITED_REDEALS)
        l.createText(s.talon, 'sw')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'se')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Twelve Sleeping Maids
# ************************************************************************

class TwelveSleepingMaids_Reserve(OpenStack):
    def canFlipCard(self):
        if not OpenStack.canFlipCard(self):
            return False
        for s in self.game.s.rows:
            if not s.cards:
                break
        else:
            return False
        i = list(self.game.s.reserves).index(self)
        if i == 0:
            return True
        if self.game.s.reserves[i-1].cards:
            return False
        return True


class TwelveSleepingMaids(Game):

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+12*l.XS, l.YM+3*l.YS+14*l.YOFFSET)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(12):
            stack = TwelveSleepingMaids_Reserve(x, y, self)
            stack.CARD_YOFFSET = l.YOFFSET
            s.reserves.append(stack)
            x += l.XS

        x, y = l.XM+2*l.XS, l.YM+l.YS+3*l.YOFFSET
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2,
                                                    base_rank=KING, mod=13))
            x += l.XS

        x, y = l.XM+2*l.XS, l.YM+2*l.YS+3*l.YOFFSET
        for i in range(8):
            s.rows.append(SS_RowStack(x, y, self))
            x += l.XS

        x, y = self.width-l.XS, self.height-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, 'n')
        l.createRoundText(s.talon, 'nnn')

        x -= l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'n')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        for i in range(4):
            self.s.talon.dealRow(rows=self.s.reserves, flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_SS


# register the game
registerGame(GameInfo(467, Zodiac, "Zodiac",
                      GI.GT_2DECK_TYPE, 2, -1, GI.SL_BALANCED))
registerGame(GameInfo(722, TwelveSleepingMaids, "Twelve Sleeping Maids",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
# Copyright (C) 2020 qunka
# Modified by Shlomi Fish, 2020, while disclaiming all copyrights.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.bisley import Bisley
from pysollib.layout import Layout
from pysollib.stack import \
        InitialDealTalonStack, \
        SS_FoundationStack, \
        UD_SS_RowStack
from pysollib.util import KING, NO_RANK


# ************************************************************************
# * Bisley 13
# ************************************************************************

class Bisley13(Bisley):

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = 2*l.XM+9*l.XS, max(2*(l.YM+l.YS+8*l.YOFFSET), l.YM+5*l.YS)
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(7):
            s.rows.append(UD_SS_RowStack(x, y, self, base_rank=NO_RANK))
            x += l.XS
        x, y = l.XM, l.YM+l.YS+8*l.YOFFSET
        for i in range(6):
            s.rows.append(UD_SS_RowStack(x, y, self, base_rank=NO_RANK))
            x += l.XS
        y = l.YM
        for i in range(4):
            x = l.XM+7*l.XS+l.XM
            s.foundations.append(SS_FoundationStack(x, y, self, i, max_move=0))
            x += l.XS
            s.foundations.append(SS_FoundationStack(x, y, self, i,
                                 base_rank=KING, max_move=0, dir=-1))
            y += l.YS

        s.talon = InitialDealTalonStack(w-l.XS, h-l.YS, self)

        # default
        l.defaultAll()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(3)
        self.s.talon.dealRow(rows=self.s.rows[4:13])
        self.s.talon.dealRow(rows=self.s.foundations[::2])


# register the game
registerGame(GameInfo(343001, Bisley13, "Bisley 13",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint, FreeCellType_Hint
from pysollib.hint import FreeCellSolverWrapper
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        InitialDealTalonStack, \
        OpenStack, \
        RK_FoundationStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        Spider_SS_RowStack, \
        StackWrapper, \
        SuperMoveRK_RowStack, \
        TalonStack, \
        UD_AC_RowStack, \
        UD_RK_RowStack, \
        UD_SS_RowStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, ANY_RANK, KING, NO_RANK, QUEEN, RANKS


class BeleagueredCastleType_Hint(CautiousDefaultHint):
    # FIXME: demo is not too clever in this game
    pass


# ************************************************************************
# * Streets and Alleys
# ************************************************************************

class StreetsAndAlleys(Game):
    Hint_Class = BeleagueredCastleType_Hint
    Solver_Class = FreeCellSolverWrapper(preset='streets_and_alleys')

    Foundation_Class = SS_FoundationStack
    # RowStack_Class = RK_RowStack
    RowStack_Class = SuperMoveRK_RowStack

    #
    # game layout
    #

    def createGame(self, playcards=13, reserves=0, texts=False):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (set size so that at least 13 cards are fully playable)
        w = max(3*l.XS, l.XS+(playcards-1)*l.XOFFSET)
        x0 = l.XM
        x1 = x0 + w + 2*l.XM
        x2 = x1 + l.XS + 2*l.XM
        x3 = x2 + w + l.XM
        h = l.YM + (4+int(reserves != 0))*l.YS + int(texts)*l.TEXT_HEIGHT
        self.setSize(x3, h)

        # create stacks
        y = l.YM
        if reserves:
            x = x1 - int(l.XS*(reserves-1)/2)
            for i in range(reserves):
                s.reserves.append(ReserveStack(x, y, self))
                x += l.XS
            y += l.YS
        x = x1
        for i in range(4):
            s.foundations.append(
                self.Foundation_Class(x, y, self, suit=i, max_move=0))
            y += l.YS
        if texts:
            tx, ty, ta, tf = l.getTextAttr(None, "ss")
            tx, ty = x+tx, y-l.YS+ty
            font = self.app.getFont("canvas_default")
            self.texts.info = MfxCanvasText(self.canvas, tx, ty,
                                            anchor=ta, font=font)
        for x in (x0, x2):
            y = l.YM+l.YS*int(reserves != 0)
            for i in range(4):
                stack = self.RowStack_Class(x, y, self)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
                s.rows.append(stack)
                y += l.YS
        x, y = self.width - l.XS, self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)
        if reserves:
            l.setRegion(
                s.rows[:4], (-999, l.YM+l.YS-l.CH//2, x1-l.CW//2, 999999))
        else:
            l.setRegion(s.rows[:4], (-999, -999, x1-l.CW//2, 999999))

        # default
        l.defaultAll()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(4)
        for i in range(3):
            self.s.talon.dealRowAvail()

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Beleaguered Castle
# ************************************************************************

class BeleagueredCastle(StreetsAndAlleys):
    def _shuffleHook(self, cards):
        # move Aces to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        self._startDealNumRows(4)
        for i in range(2):
            self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.foundations)


# ************************************************************************
# * Citadel
# * Exiled Kings
# ************************************************************************

class Citadel(StreetsAndAlleys):
    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 0, c.suit))

    # move cards to the Foundations during dealing
    def startGame(self):
        frames = 4
        talon = self.s.talon
        self.startDealSample()
        talon.dealRow(rows=self.s.foundations, frames=frames)
        while talon.cards:
            for r in self.s.rows:
                self.flipMove(talon)
                for s in self.s.foundations:
                    if s.acceptsCards(self, talon.cards[-1:]):
                        self.moveMove(1, talon, s, frames=frames)
                        break
                else:
                    self.moveMove(1, talon, r, frames=frames)
                if not talon.cards:
                    break


class ExiledKings(Citadel):
    Hint_Class = BeleagueredCastleType_Hint
    Solver_Class = FreeCellSolverWrapper(sbb='rank', esf='kings')
    RowStack_Class = StackWrapper(RK_RowStack, base_rank=KING)


# ************************************************************************
# * Fortress
# ************************************************************************

class Fortress(Game):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = UD_SS_RowStack
    Hint_Class = BeleagueredCastleType_Hint

    #
    # game layout
    #

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s
        kwdefault(layout, rows=10, waste=0, texts=0, playcards=16)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        if l.s.waste:
            s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(r.x, r.y, self, suit=r.suit))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        # default
        l.defaultAll()
        return l

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(3)
        for i in range(3):
            self.s.talon.dealRowAvail()

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * Bastion
# * Ten by One
# * Castles End
# ************************************************************************

class Bastion(Game):
    Layout_Method = staticmethod(Layout.freeCellLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = UD_SS_RowStack
    ReserveStack_Class = ReserveStack
    Hint_Class = BeleagueredCastleType_Hint

    #
    # game layout
    #

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s
        kwdefault(layout, rows=10, reserves=2, texts=0, playcards=16)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(r.x, r.y, self, suit=r.suit))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        for r in l.s.reserves:
            s.reserves.append(self.ReserveStack_Class(r.x, r.y, self))
        # default
        l.defaultAll()
        return l

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(3)
        for i in range(2):
            self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)

    shallHighlightMatch = Game._shallHighlightMatch_SS


class TenByOne(Bastion):
    def createGame(self):
        Bastion.createGame(self, reserves=1)

    def startGame(self):
        self._startDealNumRows(3)
        for i in range(3):
            self.s.talon.dealRowAvail()


class CastlesEnd_Foundation(SS_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if self.game.getState() == 0:
            if cards[0].suit != self.cap.base_suit:
                return False
            return True
        return SS_FoundationStack.acceptsCards(self, from_stack, cards)


class CastlesEnd_StackMethods:
    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        state = self.game.getState()
        self.game.moveMove(ncards, self, to_stack,
                           frames=frames, shadow=shadow)
        if state == 0:
            base_rank = to_stack.cards[0].rank
            self.game.base_rank = base_rank
            for s in self.game.s.foundations:
                s.cap.base_rank = base_rank
        self.fillStack()


class CastlesEnd_RowStack(CastlesEnd_StackMethods, UD_AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if self.game.getState() == 0:
            return False
        return UD_AC_RowStack.acceptsCards(self, from_stack, cards)


class CastlesEnd_Reserve(CastlesEnd_StackMethods, OpenStack):
    pass


class CastlesEnd(Bastion):
    Foundation_Class = StackWrapper(CastlesEnd_Foundation, min_cards=1, mod=13)
    RowStack_Class = StackWrapper(CastlesEnd_RowStack, mod=13)
    ReserveStack_Class = CastlesEnd_Reserve

    def createGame(self):
        lay = Bastion.createGame(self)
        self.base_rank = None
        tx, ty, ta, tf = lay.getTextAttr(self.s.foundations[-1], 'se')
        font = self.app.getFont('canvas_default')
        self.texts.info = MfxCanvasText(self.canvas, tx, ty,
                                        anchor=ta, font=font)

    def updateText(self):
        if self.preview > 1:
            return
        if not self.texts.info:
            return
        if not self.getState():
            t = ""
        else:
            t = RANKS[self.base_rank]
        self.texts.info.config(text=t)

    def getState(self):
        for s in self.s.foundations:
            if s.cards:
                return 1
        return 0

    def _restoreGameHook(self, game):
        self.base_rank = game.loadinfo.base_rank
        for s in self.s.foundations:
            s.cap.base_rank = game.loadinfo.base_rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_rank=p.load())

    def _saveGameHook(self, p):
        base_rank = NO_RANK
        for s in self.s.foundations:
            if s.cards:
                base_rank = s.cards[0].rank
                break
        p.dump(base_rank)

    shallHighlightMatch = Game._shallHighlightMatch_ACW


# ************************************************************************
# * Chessboard
# ************************************************************************

class Chessboard_Foundation(SS_FoundationStack):
    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, mod=13, min_cards=1, max_move=0, base_rank=ANY_RANK)
        SS_FoundationStack.__init__(self, x, y, game, suit, **cap)

    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            for s in self.game.s.foundations:
                if s.cards:
                    return cards[0].rank == s.cards[0].rank
        return True


class Chessboard_RowStack(UD_SS_RowStack):
    def canDropCards(self, stacks):
        if self.game.demo:
            return UD_SS_RowStack.canDropCards(self, stacks)
        for s in self.game.s.foundations:
            if s.cards:
                return UD_SS_RowStack.canDropCards(self, stacks)
        return (None, 0)


class Chessboard(Fortress):
    Foundation_Class = Chessboard_Foundation
    RowStack_Class = StackWrapper(Chessboard_RowStack, mod=13)

    def createGame(self):
        lay = Fortress.createGame(self)
        tx, ty, ta, tf = lay.getTextAttr(self.s.foundations[-1], "e")
        font = self.app.getFont("canvas_default")
        self.texts.info = MfxCanvasText(
            self.canvas, tx + lay.XM, ty, anchor=ta, font=font)

    def updateText(self):
        if self.preview > 1:
            return
        t = ""
        for s in self.s.foundations:
            if s.cards:
                t = RANKS[s.cards[0].rank]
                break
        self.texts.info.config(text=t)


# ************************************************************************
# * Stronghold
# * Fastness
# ************************************************************************

class Stronghold(StreetsAndAlleys):
    Hint_Class = FreeCellType_Hint
    Solver_Class = FreeCellSolverWrapper(sbb='rank')

    def createGame(self):
        StreetsAndAlleys.createGame(self, reserves=1)


class Fastness(StreetsAndAlleys):
    Hint_Class = FreeCellType_Hint
    Solver_Class = FreeCellSolverWrapper(sbb='rank')

    def createGame(self):
        StreetsAndAlleys.createGame(self, reserves=2)


# ************************************************************************
# * Zerline
# ************************************************************************

class Zerline_ReserveStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        return from_stack is not self.game.s.waste


class Zerline(Game):
    Hint_Class = BeleagueredCastleType_Hint

    #
    # game layout
    #

    def createGame(self, rows=8, playcards=13, reserve_max_cards=4):
        # create layout
        l, s = Layout(self), self.s
        decks = self.gameinfo.decks

        # set window
        # (set size so that at least 13 cards are fully playable)
        w = max(3*l.XS, l.XS+playcards*l.XOFFSET)
        self.setSize(l.XM+2*w+decks*l.XS, l.YM+l.TEXT_HEIGHT+(rows//2+1)*l.YS)

        # create stacks
        y = l.YM
        x = l.XM + w
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "s")
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")
        x += l.XS
        stack = Zerline_ReserveStack(x, y, self, max_cards=reserve_max_cards)
        s.reserves.append(stack)
        stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
        l.createText(stack, "s")
        x = l.XM + w
        for j in range(decks):
            y = l.YM+l.TEXT_HEIGHT+l.YS
            for i in range(4):
                s.foundations.append(
                    SS_FoundationStack(
                        x, y, self, i,
                        base_rank=KING, dir=1, max_move=0, mod=13))
                y += l.YS
            x += l.XS
        x = l.XM
        for j in range(2):
            y = l.YM+l.TEXT_HEIGHT+l.YS
            for i in range(rows//2):
                stack = RK_RowStack(
                    x, y, self, max_move=1, max_accept=1, base_rank=QUEEN)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
                s.rows.append(stack)
                y += l.YS
            x += l.XM+w+decks*l.XS

        l.setRegion(
            s.rows[:4], (-999, l.YM+l.YS+l.TEXT_HEIGHT-l.CH//2,
                         w-l.CW//2, 999999))

        # define stack-groups
        l.defaultStackGroups()
        # set regions
        l.defaultRegions()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRowsAndDealRowAndCards(4)

    shallHighlightMatch = Game._shallHighlightMatch_RK

    def getQuickPlayScore(self, ncards, from_stack, to_stack):
        return int(to_stack in self.s.rows)


class Zerline3Decks(Zerline):
    def createGame(self):
        Zerline.createGame(self, rows=8, reserve_max_cards=6)


# ************************************************************************
# * Chequers
# ************************************************************************

class Chequers(Fortress):

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (set size so that at least 7 cards are fully playable)
        dx = l.XM+l.XS+7*l.XOFFSET
        w = l.XM+max(5*dx, 9*l.XS+2*l.XM)
        h = l.YM+6*l.YS
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        s.talon = TalonStack(x, y, self)
        l.createText(s.talon, "se")
        x = max(l.XS+3*l.XM, (self.width-l.XM-8*l.XS)//2)
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                    base_rank=KING, dir=-1))
            x += l.XS
        y = l.YM+l.YS
        for i in range(5):
            x = l.XM
            for j in range(5):
                stack = UD_SS_RowStack(x, y, self)
                s.rows.append(stack)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
                x += dx
            y += l.YS

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(3)

    def fillStack(self, stack):
        if self.s.talon.cards and stack in self.s.rows and not stack.cards:
            self.s.talon.dealToStacks([stack])


# ************************************************************************
# * Castle of Indolence
# ************************************************************************

class CastleOfIndolence(Game):
    Hint_Class = BeleagueredCastleType_Hint

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (set size so that at least 13 cards are fully playable)
        w = max(3*l.XS, l.XS+13*l.XOFFSET)
        self.setSize(l.XM+2*w+2*l.XS, l.YM + 5*l.YS + l.TEXT_HEIGHT)

        # create stacks
        x, y = l.XM, l.YM+4*l.YS
        s.talon = InitialDealTalonStack(x, y, self)
        x, y = l.XM+w-l.XS, self.height-l.YS
        for i in range(4):
            stack = OpenStack(x, y, self, max_accept=0)
            s.reserves.append(stack)
            l.createText(stack, 'n')
            x += l.XS

        x = l.XM + w
        for x in (l.XM + w, l.XM + w + l.XS):
            y = l.YM
            for i in range(4):
                s.foundations.append(RK_FoundationStack(x, y, self,
                                     max_move=0))
                y += l.YS

        for x in (l.XM, l.XM + w + 2*l.XS):
            y = l.YM
            for i in range(4):
                stack = RK_RowStack(
                    x, y, self, max_move=1, max_accept=1, base_rank=ANY_RANK)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
                s.rows.append(stack)
                y += l.YS
        l.setRegion(s.rows[:4], (-999, -999, w-l.CW//2, l.YM+4*l.YS-l.CH//2))

        # define stack-groups
        l.defaultStackGroups()
        # set regions
        l.defaultRegions()

    def startGame(self):
        for i in range(13):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self._startDealNumRows(4)
        self.s.talon.dealRow()
        self.s.talon.dealRow()
        self.s.talon.dealRowAvail()

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Rittenhouse
# ************************************************************************

class Rittenhouse_Foundation(RK_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack in self.game.s.rows:
            ri = list(self.game.s.rows).index(from_stack)
            fi = list(self.game.s.foundations).index(self)
            if ri < 4:
                return ri == fi
            if ri == 4:
                return True
            return ri-1 == fi
        return False


class Rittenhouse(Game):
    Hint_Class = BeleagueredCastleType_Hint

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+9*l.XS, l.YM+3*l.YS+12*l.YOFFSET)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(4):
            s.foundations.append(
                Rittenhouse_Foundation(x, y, self, max_move=0))
            x += l.XS
        x += l.XS
        for i in range(4):
            s.foundations.append(Rittenhouse_Foundation(x, y, self,
                                 base_rank=KING, dir=-1, max_move=0))
            x += l.XS
        x, y = l.XM, l.YM+l.YS
        for i in range(9):
            s.rows.append(UD_RK_RowStack(x, y, self))
            x += l.XS

        s.talon = InitialDealTalonStack(l.XM, self.height-l.YS, self)

        # default
        l.defaultAll()

    def startGame(self):
        # move cards to the Foundations during dealing
        talon = self.s.talon
        self.startDealSample()
        while talon.cards:
            talon.dealRowAvail(frames=3)
            self.fillAll()

    def fillAll(self):
        while True:
            if not self._fillOne():
                break

    def _fillOne(self):
        for r in self.s.rows:
            for s in self.s.foundations:
                if s.acceptsCards(r, r.cards[-1:]):
                    self.moveMove(1, r, s)
                    return 1
        return 0

    def fillStack(self, stack):
        self.fillAll()

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Lightweight
# * Castle Mount
# ************************************************************************

class Lightweight(StreetsAndAlleys):
    DEAL = (7, 1)
    RowStack_Class = StackWrapper(RK_RowStack, base_rank=KING)
    Solver_Class = FreeCellSolverWrapper(sbb='rank', esf='kings',
                                         sm='unlimited')

    def createGame(self, rows=12, playcards=20):
        l, s = Layout(self), self.s
        decks = self.gameinfo.decks
        max_rows = max(decks*4, rows)
        self.setSize(l.XM+max_rows*l.XS, l.YM+2*l.YS+playcards*l.YOFFSET)

        x, y = l.XM+(max_rows-decks*4)*l.XS//2, l.YM
        for i in range(4):
            for j in range(decks):
                s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                        max_move=0))
                x += l.XS
        x, y = l.XM+(max_rows-rows)*l.XS//2, l.YM+l.YS
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += l.XS
        s.talon = InitialDealTalonStack(
            self.width-l.XS, self.height-l.YS, self)

        l.defaultAll()

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(cards,
                                          lambda c: (c.rank == ACE, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startDealNumRows(self.DEAL[0])
        for i in range(self.DEAL[1]):
            self.s.talon.dealRowAvail()


class CastleMount(Lightweight):
    DEAL = (11, 1)
    RowStack_Class = Spider_SS_RowStack
    Solver_Class = None

    shallHighlightMatch = Game._shallHighlightMatch_RK
    getQuickPlayScore = Game._getSpiderQuickPlayScore


# ************************************************************************
# * Selective Castle
# ************************************************************************

class SelectiveCastle_RowStack(RK_RowStack):
    def canDropCards(self, stacks):
        if self.game.demo:
            return RK_RowStack.canDropCards(self, stacks)
        for s in self.game.s.foundations:
            if s.cards:
                return RK_RowStack.canDropCards(self, stacks)
        return (None, 0)


class SelectiveCastle(StreetsAndAlleys, Chessboard):
    Foundation_Class = Chessboard_Foundation
    RowStack_Class = StackWrapper(SelectiveCastle_RowStack, mod=13)
    Solver_Class = None

    def createGame(self):
        StreetsAndAlleys.createGame(self, texts=True)

    def updateText(self):
        Chessboard.updateText(self)

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# ************************************************************************
# * Soother
# ************************************************************************

class Soother(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self, rows=9):
        l, s = Layout(self), self.s
        self.setSize(l.XM+11*l.XS, l.YM+4*l.YS+12*l.YOFFSET)

        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 's')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 's')

        y = l.YM
        for i in range(2):
            x = l.XM+2.5*l.XS
            for j in range(8):
                s.foundations.append(
                    SS_FoundationStack(x, y, self, suit=j % 4, max_move=1))
                x += l.XS
            y += l.YS
        x, y = l.XM, l.YM+2*l.YS
        stack = ReserveStack(x, y, self, max_cards=8)
        s.reserves.append(stack)
        stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, l.YOFFSET
        l.createText(stack, 'n')

        x, y = l.XM+2*l.XS, l.YM+2*l.YS
        for i in range(rows):
            s.rows.append(RK_RowStack(x, y, self, max_move=1, base_rank=KING))
            x += l.XS

        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealRowAndCards(4)

    shallHighlightMatch = Game._shallHighlightMatch_RK

    def getQuickPlayScore(self, ncards, from_stack, to_stack):
        return int(to_stack in self.s.rows)


# ************************************************************************
# * Penelope's Web
# ************************************************************************

class PenelopesWeb(StreetsAndAlleys):
    RowStack_Class = StackWrapper(RK_RowStack, base_rank=KING)
    Solver_Class = FreeCellSolverWrapper(sbb='rank', esf='kings')


# register the game
registerGame(GameInfo(146, StreetsAndAlleys, "Streets and Alleys",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(34, BeleagueredCastle, "Beleaguered Castle",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(145, Citadel, "Citadel",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(147, Fortress, "Fortress",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_SKILL))
registerGame(GameInfo(148, Chessboard, "Chessboard",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_SKILL))
registerGame(GameInfo(300, Stronghold, "Stronghold",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(301, Fastness, "Fastness",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN | GI.GT_ORIGINAL,
                      1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(306, Zerline, "Zerline",
                      GI.GT_BELEAGUERED_CASTLE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(324, Bastion, "Bastion",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(325, TenByOne, "Ten by One",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(351, Chequers, "Chequers",
                      GI.GT_BELEAGUERED_CASTLE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(393, CastleOfIndolence, "Castle of Indolence",
                      GI.GT_BELEAGUERED_CASTLE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(395, Zerline3Decks, "Zerline (3 decks)",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_ORIGINAL, 3, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(400, Rittenhouse, "Rittenhouse",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(507, Lightweight, "Lightweight",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN | GI.GT_ORIGINAL,
                      2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(508, CastleMount, "Castle Mount",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 3, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(524, SelectiveCastle, "Selective Castle",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(535, ExiledKings, "Exiled Kings",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(626, Soother, "Soother",
                      GI.GT_4DECK_TYPE | GI.GT_ORIGINAL, 4, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(650, CastlesEnd, "Castles End",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(665, PenelopesWeb, "Penelope's Web",
                      GI.GT_BELEAGUERED_CASTLE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.stack import \
        AC_FoundationStack, \
        AC_RowStack, \
        OpenStack, \
        SS_FoundationStack, \
        Stack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import KING, NO_RANK


class Terrace_Talon(WasteTalonStack):
    def canDealCards(self):
        if self.game.getState() == 0:
            return False
        return WasteTalonStack.canDealCards(self)


class Terrace_AC_Foundation(AC_FoundationStack):
    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, mod=13, min_cards=1, max_move=0)
        AC_FoundationStack.__init__(self, x, y, game, suit, **cap)

    def acceptsCards(self, from_stack, cards):
        if self.game.getState() == 0:
            if len(cards) != 1 or not cards[0].face_up:
                return False
            if cards[0].suit != self.cap.base_suit:
                return False
            return from_stack in self.game.s.rows
        return AC_FoundationStack.acceptsCards(self, from_stack, cards)

    def getBaseCard(self):
        if self.game.getState() == 0:
            return _('Base card - %s.') % _('any card')
        return AC_FoundationStack.getBaseCard(self)


class Terrace_SS_Foundation(SS_FoundationStack):
    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, mod=13, min_cards=1, max_move=0)
        SS_FoundationStack.__init__(self, x, y, game, suit, **cap)

    def acceptsCards(self, from_stack, cards):
        if self.game.getState() == 0:
            if len(cards) != 1 or not cards[0].face_up:
                return False
            if cards[0].suit != self.cap.base_suit:
                return False
            return from_stack in self.game.s.rows
        return SS_FoundationStack.acceptsCards(self, from_stack, cards)

    def getBaseCard(self):
        if self.game.getState() == 0:
            return _('Base card - %s.') % _('any card')
        return SS_FoundationStack.getBaseCard(self)


class Terrace_RowStack(AC_RowStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, mod=13, max_move=1)
        AC_RowStack.__init__(self, x, y, game, **cap)

    def acceptsCards(self, from_stack, cards):
        if self.game.getState() == 0:
            return False
        if from_stack in self.game.s.reserves:
            return False
        return AC_RowStack.acceptsCards(self, from_stack, cards)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        state = self.game.getState()
        if state > 0:
            AC_RowStack.moveMove(
                self, ncards, to_stack, frames=frames, shadow=shadow)
            return
        assert to_stack in self.game.s.foundations
        assert ncards == 1
        assert not self.game.s.waste.cards
        self.game.moveMove(
            ncards, self, to_stack, frames=frames, shadow=shadow)
        for s in self.game.s.foundations:
            s.cap.base_rank = to_stack.cards[0].rank
        freerows = [s for s in self.game.s.rows if not s.cards]
        self.game.s.talon.dealRow(rows=freerows, sound=True)
        self.game.s.talon.dealCards()     # deal first card to WasteStack

    getBottomImage = Stack._getReserveBottomImage


# ************************************************************************
# * Terrace
# ************************************************************************

class Terrace(Game):
    Talon_Class = Terrace_Talon
    Foundation_Class = Terrace_AC_Foundation
    RowStack_Class = Terrace_RowStack
    ReserveStack_Class = OpenStack
    Hint_Class = CautiousDefaultHint

    INITIAL_RESERVE_CARDS = 11

    #
    # game layout
    #

    def createGame(self, rows=9, max_rounds=1, num_deal=1, playcards=16):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (piles up to 16 cards are playable in default window size)
        decks = self.gameinfo.decks
        maxrows = max(rows, decks*4+1)
        w1, w2 = (maxrows - decks*4)*l.XS//2, (maxrows - rows)*l.XS//2
        h = max(3*l.YS, playcards*l.YOFFSET)
        self.setSize(l.XM + maxrows*l.XS + l.XM, l.YM + 3*l.YS + h)

        # extra settings
        self.base_rank = None

        # create stacks
        x, y = l.XM + w1, l.YM
        s.talon = self.Talon_Class(
            x, y, self, max_rounds=max_rounds, num_deal=num_deal)
        l.createText(s.talon, "sw")
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "se", text_format="%D")
        x = x + 2*l.XS
        stack = self.ReserveStack_Class(x, y, self)
        stack.CARD_XOFFSET = l.XOFFSET
        l.createText(stack, "sw")
        s.reserves.append(stack)
        x, y = l.XM + w1, y + l.YS
        for i in range(4):
            for j in range(decks):
                s.foundations.append(self.Foundation_Class(x, y, self, suit=i))
                x = x + l.XS
        x, y = l.XM + w2, y + l.YS
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self))
            x = x + l.XS

        # define stack-groups
        l.defaultStackGroups()

    #
    # game extras
    #

    def getState(self):
        for s in self.s.foundations:
            if s.cards:
                return 1
        return 0

    #
    # game overrides
    #

    def startGame(self, nrows=4):
        self.startDealSample()
        for i in range(self.INITIAL_RESERVE_CARDS):
            self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRow(rows=self.s.rows[:nrows])

    def fillStack(self, stack):
        if not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if stack is self.s.waste and self.s.talon.cards:
                self.s.talon.dealCards()
            elif stack in self.s.rows and self.s.waste.cards:
                self.s.waste.moveMove(1, stack)
            self.leaveState(old_state)

    def _restoreGameHook(self, game):
        for s in self.s.foundations:
            s.cap.base_rank = game.loadinfo.base_rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_rank=p.load())

    def _saveGameHook(self, p):
        base_rank = NO_RANK
        for s in self.s.foundations:
            if s.cards:
                base_rank = s.cards[0].rank
                break
        p.dump(base_rank)

    shallHighlightMatch = Game._shallHighlightMatch_ACW


# ************************************************************************
# * Queen of Italy
# ************************************************************************

class QueenOfItaly(Terrace):
    Foundation_Class = StackWrapper(Terrace_AC_Foundation, max_move=1)

    def fillStack(self, stack):
        pass


# ************************************************************************
# * General's Patience
# ************************************************************************

class GeneralsPatience(Terrace):
    Foundation_Class = Terrace_SS_Foundation
    INITIAL_RESERVE_CARDS = 13


# ************************************************************************
# * Blondes and Brunettes
# * Falling Star
# * Wood
# ************************************************************************

class BlondesAndBrunettes(Terrace):
    INITIAL_RESERVE_CARDS = 10

    def startGame(self):
        self.startDealSample()
        for i in range(self.INITIAL_RESERVE_CARDS):
            self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRow()
        # deal base_card to Foundations
        c = self.s.talon.getCard()
        for s in self.s.foundations:
            s.cap.base_rank = c.rank
        self.s.talon.dealRow(rows=(self.s.foundations[2*c.suit],))
        self.s.talon.dealCards()          # deal first card to WasteStack

    def getState(self):
        return 1


class FallingStar(BlondesAndBrunettes):
    INITIAL_RESERVE_CARDS = 11


class Wood_RowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return from_stack is self.game.s.waste
        return from_stack not in self.game.s.reserves


class Wood(BlondesAndBrunettes):
    RowStack_Class = StackWrapper(Wood_RowStack, mod=13, max_move=1)

    def fillStack(self, stack):
        pass


# ************************************************************************
# * Signora
# ************************************************************************

class Signora(Terrace):
    def startGame(self):
        Terrace.startGame(self, nrows=9)


# ************************************************************************
# * Madame
# ************************************************************************

class Madame(Terrace):
    INITIAL_RESERVE_CARDS = 15

    def createGame(self):
        Terrace.createGame(self, rows=10, playcards=20)

    def startGame(self):
        Terrace.startGame(self, nrows=10)


# ************************************************************************
# * Mamy Susan
# ************************************************************************

class MamySusan_RowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if from_stack in self.game.s.reserves:
            return False
        return AC_RowStack.acceptsCards(self, from_stack, cards)


class MamySusan(Terrace):

    Talon_Class = WasteTalonStack
    Foundation_Class = StackWrapper(SS_FoundationStack, max_move=0)
    RowStack_Class = StackWrapper(MamySusan_RowStack, max_move=1)

    def createGame(self):
        Terrace.createGame(self, rows=10)

    def startGame(self, nrows=4):
        for i in range(6):
            self.s.talon.dealRow(rows=self.s.reserves, flip=0, frames=0)
        self.flipMove(self.s.reserves[0])
        self._startDealNumRowsAndDealRowAndCards(3)

    def fillStack(self, stack):
        pass

    def _restoreGameHook(self, game):
        pass

    def _loadGameHook(self, p):
        pass

    def _saveGameHook(self, p):
        pass


# ************************************************************************
# * Bastille Day
# ************************************************************************

class BastilleDay_BastilleStack(Stack):
    def clickHandler(self, event):
        return self.dealCards(sound=True)

    def rightclickHandler(self, event):
        return self.clickHandler(event)

    def canDealCards(self):
        if self.game.s.reserves[-1].cards:
            return 0 < len(self.cards) < 12
        return len(self.cards) > 0

    def dealCards(self, sound=False):
        if not self.canDealCards():
            return 0
        old_state = self.game.enterState(self.game.S_DEAL)
        if sound and not self.game.demo:
            self.game.playSample("dealwaste")
        self.game.flipAndMoveMove(self, self.game.s.reserves[-1])
        self.game.leaveState(old_state)
        self.game.finishMove()
        return 1

    def getHelp(self):
        return ''  # FIXME


class BastilleDay(Game):

    def createGame(self, rows=9, max_rounds=1, num_deal=1, playcards=16):
        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+3*l.YS+12*l.YOFFSET+l.TEXT_HEIGHT)

        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 's')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 's')
        x += 2*l.XS
        stack = BastilleDay_BastilleStack(x, y, self)
        s.reserves.append(stack)
        l.createText(stack, 's')
        x += l.XS
        stack = OpenStack(x, y, self)
        stack.CARD_XOFFSET = l.XOFFSET
        l.createText(stack, 's')
        s.reserves.append(stack)

        x, y = l.XM, l.YM+l.YS+l.TEXT_HEIGHT
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i % 4))
            x = x + l.XS
        x, y = l.XM, l.YM+2*l.YS+l.TEXT_HEIGHT
        for i in range(8):
            s.rows.append(AC_RowStack(x, y, self))
            x = x + l.XS

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        # move Kings to top
        cards = self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank == KING, None))
        # move any 4 cards to top
        cards = cards[4:]+cards[:4]
        return cards

    def startGame(self, nrows=4):
        for i in range(12):  # deal to Bastille
            self.s.talon.dealRow(flip=0, rows=[self.s.reserves[0]], frames=0)
        for i in range(9):
            self.s.talon.dealRow(rows=[self.s.reserves[-1]], frames=0)
        for i in range(3):
            self.s.talon.dealRow(flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def dealCards(self, sound=True):
        # for demo-mode
        if self.demo:
            r = self.s.reserves[0]
            if r.canDealCards():
                # self.demo.last_deal = [] # don't check last deal
                return r.dealCards(sound=sound)
        return Game.dealCards(self, sound=sound)

    shallHighlightMatch = Game._shallHighlightMatch_AC


# register the game
registerGame(GameInfo(135, Terrace, "Terrace",
                      GI.GT_TERRACE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(136, GeneralsPatience, "General's Patience",
                      GI.GT_TERRACE, 2, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(137, BlondesAndBrunettes, "Blondes and Brunettes",
                      GI.GT_TERRACE, 2, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(138, FallingStar, "Falling Star",
                      GI.GT_TERRACE, 2, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(431, QueenOfItaly, "Queen of Italy",
                      GI.GT_TERRACE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(499, Signora, "Signora",
                      GI.GT_TERRACE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(500, Madame, "Madame",
                      GI.GT_TERRACE, 3, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(533, MamySusan, "Mamy Susan",
                      GI.GT_TERRACE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(582, Wood, "Wood",
                      GI.GT_TERRACE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(637, BastilleDay, "Bastille Day",
                      GI.GT_TERRACE, 2, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import math

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint, DefaultHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AbstractFoundationStack, \
        BasicRowStack, \
        DealRowRedealTalonStack, \
        OpenStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        Stack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, KING, NO_RANK, RANKS, UNLIMITED_CARDS


class Braid_Hint(DefaultHint):
    # FIXME: demo is not too clever in this game
    pass

# ************************************************************************
# *
# ************************************************************************


class Braid_Foundation(AbstractFoundationStack):
    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, mod=13, dir=0, base_rank=NO_RANK, max_move=0)
        AbstractFoundationStack.__init__(self, x, y, game, suit, **cap)

    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return True
        stack_dir = self.game.getFoundationDir()
        if stack_dir == 0:
            card_dir = self.getRankDir(cards=(self.cards[-1], cards[0]))
            return card_dir in (1, -1)
        else:
            return ((self.cards[-1].rank + stack_dir) %
                    self.cap.mod == cards[0].rank)


class Braid_BraidStack(OpenStack):
    def __init__(self, x, y, game, sine=0):
        OpenStack.__init__(self, x, y, game)
        self.CARD_YOFFSET = self.game.app.images.CARD_YOFFSET
        CW = self.game.app.images.CARDW
        if sine:
            # use a sine wave for the x offsets
            self.CARD_XOFFSET = []
            n = 9
            dx = 0.4 * CW * (2*math.pi/n)
            last_x = 0
            for i in range(n):
                x = int(round(dx * math.sin(i + 1)))
                # print x, x - last_x
                self.CARD_XOFFSET.append(x - last_x)
                last_x = x
        else:
            self.CARD_XOFFSET = (-0.45*CW, 0.35*CW, 0.55*CW, -0.45*CW)


class Braid_RowStack(ReserveStack):
    def fillStack(self):
        if not self.cards and self.game.s.braid.cards:
            self.game.moveMove(1, self.game.s.braid, self)

    getBottomImage = Stack._getBraidBottomImage


class Braid_ReserveStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if from_stack is self.game.s.braid or from_stack in self.game.s.rows:
            return False
        return ReserveStack.acceptsCards(self, from_stack, cards)

    getBottomImage = Stack._getTalonBottomImage


# ************************************************************************
# * Braid
# ************************************************************************

class Braid(Game):
    Hint_Class = Braid_Hint
    Foundation_Classes = [Braid_Foundation, Braid_Foundation]

    BRAID_CARDS = 20
    RANKS = RANKS           # pull into class Braid

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        font = self.app.getFont("canvas_default")

        # set window
        # (piles up to 20 cards are playable - needed for Braid_BraidStack)
        decks = self.gameinfo.decks
        h = max(4*l.YS + 30, l.YS+(self.BRAID_CARDS-1)*l.YOFFSET)
        self.setSize(l.XM+(8+decks)*l.XS, l.YM+h)

        # extra settings
        self.base_card = None

        # create stacks
        s.addattr(braid=None)      # register extra stack variable
        x, y = l.XM, l.YM
        for i in range(2):
            s.rows.append(Braid_RowStack(x + 0.5*l.XS, y, self))
            s.rows.append(Braid_RowStack(x + 4.5*l.XS, y, self))
            y = y + 3 * l.YS
        y = l.YM + l.YS
        for i in range(2):
            s.rows.append(Braid_ReserveStack(x, y, self))
            s.rows.append(Braid_ReserveStack(x + l.XS, y, self))
            s.rows.append(Braid_ReserveStack(x, y + l.YS, self))
            s.rows.append(Braid_ReserveStack(x + l.XS, y + l.YS, self))
            x = x + 4 * l.XS
        x, y = l.XM + l.XS * 5//2, l.YM
        s.braid = Braid_BraidStack(x, y, self)
        x, y = l.XM + 7 * l.XS, l.YM + l.YS * 3//2
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "s")
        l.createRoundText(s.talon, 'nn')
        x -= l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")
        y = l.YM
        for i in range(4):
            x = l.XM+8*l.XS
            for cl in self.Foundation_Classes:
                s.foundations.append(cl(x, y, self, suit=i))
                x += l.XS
            y = y + l.YS
        x = l.XM+8*l.XS+decks*l.XS//2
        self.texts.info = MfxCanvasText(self.canvas,
                                        x, y, anchor="n", font=font)

        # define stack-groups
        self.sg.talonstacks = [s.talon] + [s.waste]
        self.sg.openstacks = s.foundations + s.rows
        self.sg.dropstacks = [s.braid] + s.rows + [s.waste]

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        # do not play a trump as the base_card
        n = m = -1 - self.BRAID_CARDS - len(self.s.rows)
        while cards[n].suit >= len(self.gameinfo.suits):
            n = n - 1
        cards[n], cards[m] = cards[m], cards[n]
        return cards

    def startGame(self):
        self.base_card = None
        self.updateText()
        self.startDealSample()
        for i in range(self.BRAID_CARDS):
            self.s.talon.dealRow(rows=[self.s.braid], frames=4)
        self.s.talon.dealRow(frames=4)
        # deal base_card to foundations
        self.base_card = self.s.talon.cards[-1]
        to_stack = self.s.foundations[self.gameinfo.decks*self.base_card.suit]
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, to_stack)
        self.updateText()
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        # deal first card to WasteStack
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_SSW

    def getHighlightPilesStacks(self):
        return ()

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)

    #
    # game extras
    #

    def updateText(self):
        if self.preview > 1 or not self.texts.info:
            return
        if not self.base_card:
            t = ""
        else:
            t = self.RANKS[self.base_card.rank]
            dir = self.getFoundationDir()
            if dir == 1:
                t = t + _(" Ascending")
            elif dir == -1:
                t = t + _(" Descending")
        self.texts.info.config(text=t)


class LongBraid(Braid):
    BRAID_CARDS = 24


# ************************************************************************
# * Fort
# ************************************************************************

class Fort(Braid):

    Foundation_Classes = [SS_FoundationStack,
                          StackWrapper(SS_FoundationStack, base_rank=KING,
                                       dir=-1)]

    BRAID_CARDS = 21

    def _shuffleHook(self, cards):
        # move 4 Kings and 4 Aces to top of the Talon
        # (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (ACE, KING) and c.deck == 0,
                       (c.suit, c.rank)))

    def _restoreGameHook(self, game):
        pass

    def _loadGameHook(self, p):
        pass

    def _saveGameHook(self, p):
        pass

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self.startDealSample()
        for i in range(self.BRAID_CARDS):
            self.s.talon.dealRow(rows=[self.s.braid], frames=4)
        self.s.talon.dealRow(frames=4)
        self.s.talon.dealCards()


# ************************************************************************
# * Backbone
# ************************************************************************

class Backbone_BraidStack(OpenStack):
    def __init__(self, x, y, game, **cap):
        OpenStack.__init__(self, x, y, game, **cap)
        self.CARD_YOFFSET = self.game.app.images.CARD_YOFFSET

    def basicIsBlocked(self):
        return len(self.game.s.reserves[2].cards) != 0


class Backbone(Game):

    Hint_Class = CautiousDefaultHint

    def createGame(self, rows=8):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+(rows+2)*l.XS, max(
            l.YM+3*l.XS+10*l.YOFFSET, l.YM+2*l.YS+11*l.YOFFSET+l.TEXT_HEIGHT)
        self.setSize(w, h)

        # create stacks
        y = l.YM
        for i in range(4):
            x = l.XM+(rows-8)*l.XS//2 + i*l.XS
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x = l.XM+(rows//2+2)*l.XS + i*l.XS
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))

        x, y = l.XM+rows*l.XS//2, l.YM
        s.reserves.append(Backbone_BraidStack(x, y, self, max_accept=0))
        x += l.XS
        s.reserves.append(Backbone_BraidStack(x, y, self, max_accept=0))
        x, y = l.XM+(rows+1)*l.XS//2, l.YM+11*l.YOFFSET
        s.reserves.append(BasicRowStack(x, y, self, max_accept=0))

        x, y = l.XM, l.YM+l.YS
        for i in range(rows//2):
            s.rows.append(SS_RowStack(x, y, self, max_move=1))
            x += l.XS
        x, y = l.XM+(rows//2+2)*l.XS, l.YM+l.YS
        for i in range(rows//2):
            s.rows.append(SS_RowStack(x, y, self, max_move=1))
            x += l.XS

        x, y = l.XM+rows*l.XS//2, h-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "n")
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "n")

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        for i in range(10):
            self.s.talon.dealRow(rows=self.s.reserves[:2], frames=0)
        self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_SS


class BackbonePlus(Backbone):
    def createGame(self):
        Backbone.createGame(self, rows=10)


# ************************************************************************
# * Big Braid
# ************************************************************************

class BigBraid(Braid):
    Foundation_Classes = [Braid_Foundation, Braid_Foundation, Braid_Foundation]


# ************************************************************************
# * Casket
# ************************************************************************

class Casket_Hint(CautiousDefaultHint):
    def computeHints(self):
        CautiousDefaultHint.computeHints(self)
        if self.hints:
            return
        if not self.game.s.waste.cards:
            return
        r = self.game.s.waste.cards[-1].rank
        if 0 <= r <= 3:
            to_stack = self.game.s.reserves[0]
        elif 4 <= r <= 7:
            to_stack = self.game.s.reserves[1]
        else:
            to_stack = self.game.s.reserves[2]
        self.addHint(5000, 1, self.game.s.waste, to_stack)


class JewelsStack(OpenStack):
    def canFlipCard(self):
        return False


class Casket_RowStack(SS_RowStack):

    getBottomImage = Stack._getReserveBottomImage

    def acceptsCards(self, from_stack, cards):
        if not SS_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            # don't accepts from lid
            return from_stack not in self.game.s.lid
        return True


class Casket_Reserve(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        return from_stack is self.game.s.waste


class Casket(Game):
    Hint_Class = Casket_Hint

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+10*l.XS, l.YM+4.5*l.YS)

        # register extra stack variables
        s.addattr(jewels=None)
        s.addattr(lid=[])

        # create stacks
        # Lid
        x0, y0 = l.XM+2.5*l.XS, l.YM
        for xx, yy in ((0, 0.5),
                       (1, 0.25),
                       (2, 0),
                       (3, 0.25),
                       (4, 0.5),
                       ):
            x, y = x0+xx*l.XS, y0+yy*l.YS
            s.lid.append(BasicRowStack(x, y, self, max_accept=0))

        # Casket
        x0, y0 = l.XM+3*l.XS, l.YM+1.5*l.YS
        for xx, yy in ((0, 0),                 (3, 0),
                       (0, 1),                 (3, 1),
                       (0, 2), (1, 2), (2, 2), (3, 2),
                       ):
            x, y = x0+xx*l.XS, y0+yy*l.YS
            stack = Casket_RowStack(x, y, self, max_move=1)
            stack.CARD_YOFFSET = 0
            s.rows.append(stack)

        # Reserves
        x, y = l.XM, l.YM+1.5*l.YS
        for i in range(3):
            stack = Casket_Reserve(x, y, self, max_cards=UNLIMITED_CARDS)
            l.createText(stack, "ne")
            s.reserves.append(stack)
            y += l.YS

        # Foundations
        x = l.XM+8*l.XS
        for i in range(2):
            y = l.YM
            for j in range(4):
                s.foundations.append(SS_FoundationStack(x, y, self, suit=j))
                y += l.YS
            x += l.XS

        # Jewels
        x, y = l.XM+4.5*l.XS, l.YM+2*l.YS
        s.jewels = JewelsStack(x, y, self)
        l.createText(s.jewels, "s")

        # waste & talon
        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "s")
        x += l.XS
        s.waste = WasteStack(x, y, self, max_cards=1)

        # define stack-groups
        self.sg.talonstacks = [s.talon] + [s.waste]
        self.sg.openstacks = s.foundations + s.rows + s.reserves
        self.sg.dropstacks = s.lid + s.rows + [s.waste] + s.reserves

    def startGame(self):
        for i in range(13):
            self.s.talon.dealRow(rows=[self.s.jewels], frames=0, flip=0)
        self.startDealSample()
        self.s.talon.dealToStacksOrFoundations(stacks=self.s.lid)
        self.s.talon.dealToStacksOrFoundations(stacks=self.s.rows)
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if not stack.cards and stack in self.s.lid:
            if self.s.jewels.cards:
                old_state = self.enterState(self.S_FILL)
                self.s.jewels.flipMove()
                self.s.jewels.moveMove(1, stack)
                self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Well
# ************************************************************************

class Well_TalonStack(DealRowRedealTalonStack):

    def canDealCards(self):
        return DealRowRedealTalonStack.canDealCards(
            self, rows=self.game.s.wastes)

    def dealCards(self, sound=False):
        num_cards = 0
        if sound and self.game.app.opt.animations:
            self.game.startDealSample()
        if not self.cards:
            # move all cards to talon
            num_cards = self._redeal(rows=self.game.s.wastes, frames=3)
            self.game.nextRoundMove(self)
        wastes = self.game.s.wastes[:(6-self.round)]
        num_cards += self.dealRowAvail(rows=wastes, frames=4, sound=False)
        if sound:
            self.game.stopSamples()
        return num_cards


class Well(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+6*l.XS, l.YM+6*l.YS+l.TEXT_HEIGHT)

        # register extra stack variables
        s.addattr(wastes=[])

        # foundations
        suit = 0
        x0, y0 = l.XM+1.5*l.XS, l.YM+1.5*l.YS+l.TEXT_HEIGHT
        for xx, yy in ((3, 0),
                       (0, 3),
                       (3, 3),
                       (0, 0)):
            x, y = x0+xx*l.XS, y0+yy*l.YS
            s.foundations.append(SS_FoundationStack(x, y, self, suit=suit,
                                 base_rank=KING, mod=13, max_cards=26,
                                 dir=-1, max_move=0))
            suit += 1

        # rows
        x0, y0 = l.XM+l.XS, l.YM+l.YS+l.TEXT_HEIGHT
        for xx, yy in ((0, 2),
                       (2, 0),
                       (4, 2),
                       (2, 4)):
            x, y = x0+xx*l.XS, y0+yy*l.YS
            stack = SS_RowStack(x, y, self, dir=1, mod=13, max_move=1)
            stack.getBottomImage = stack._getReserveBottomImage
            stack.CARD_YOFFSET = 0
            s.rows.append(stack)

        # left stack
        x, y = l.XM, l.YM+l.YS+l.TEXT_HEIGHT
        stack = SS_RowStack(
            x, y, self, base_rank=ACE, dir=1, mod=13, max_move=1)
        stack.getBottomImage = stack._getReserveBottomImage
        stack.CARD_YOFFSET = 0
        s.rows.append(stack)

        # reserves
        x0, y0 = l.XM+2*l.XS, l.YM+2*l.YS+l.TEXT_HEIGHT
        for xx, yy, anchor in ((0, 1, 'e'),
                               (1, 0, 's'),
                               (2, 1, 'w'),
                               (1, 2, 'n')):
            x, y = x0+xx*l.XS, y0+yy*l.YS
            stack = OpenStack(x, y, self)
            l.createText(stack, anchor)
            s.reserves.append(stack)

        # wastes
        x, y = l.XM+l.XS, l.YM
        for i in range(5):
            stack = WasteStack(x, y, self)
            l.createText(stack, 's', text_format='%D')
            s.wastes.append(stack)
            x += l.XS

        # talon
        x, y = l.XM, l.YM
        s.talon = Well_TalonStack(x, y, self, max_rounds=5)
        l.createText(s.talon, "s")

        # define stack-groups
        self.sg.talonstacks = [s.talon] + s.wastes
        self.sg.openstacks = s.foundations + s.rows
        self.sg.dropstacks = s.rows + s.wastes + s.reserves

    def startGame(self):
        for i in range(10):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:4])
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if not stack.cards and stack in self.s.rows[:4]:
            indx = list(self.s.rows).index(stack)
            r = self.s.reserves[indx]
            if r.cards:
                old_state = self.enterState(self.S_FILL)
                r.moveMove(1, stack)
                self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# register the game
registerGame(GameInfo(12, Braid, "Braid",
                      GI.GT_NAPOLEON, 2, 2, GI.SL_BALANCED,
                      altnames=("Der Zopf", "Plait", "Pigtail")))
registerGame(GameInfo(175, LongBraid, "Long Braid",
                      GI.GT_NAPOLEON, 2, 2, GI.SL_BALANCED,
                      altnames=("Der lange Zopf",)))
registerGame(GameInfo(358, Fort, "Fort",
                      GI.GT_NAPOLEON, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(376, Backbone, "Backbone",
                      GI.GT_NAPOLEON, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(377, BackbonePlus, "Backbone +",
                      GI.GT_NAPOLEON, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(510, BigBraid, "Big Braid",
                      GI.GT_NAPOLEON | GI.GT_ORIGINAL, 3, 2, GI.SL_BALANCED))
registerGame(GameInfo(694, Casket, "Casket",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(717, Well, "Well",
                      GI.GT_2DECK_TYPE, 2, 4, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        SS_RowStack, \
        Stack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import KING, QUEEN, VARIABLE_REDEALS

# ************************************************************************
# * Talon
# ************************************************************************


class Matriarchy_Waste(WasteStack):
    def updateText(self):
        WasteStack.updateText(self)
        if self.game.s.talon._updateMaxRounds():
            self.game.s.talon.updateText()


class Matriarchy_Talon(WasteTalonStack):
    DEAL = (2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 11, 10, 9, 8, 7, 6, 5)

    def _updateMaxRounds(self):
        # recompute max_rounds
        old = self.max_rounds
        self.max_rounds = 11
        rows = self.game.s.rows
        for i in (0, 2, 4, 6):
            l1 = len(rows[i+0].cards) + len(rows[i+8].cards)
            l2 = len(rows[i+1].cards) + len(rows[i+9].cards)
            assert l1 + l2 <= 26
            if l1 + l2 == 26:
                self.max_rounds = self.max_rounds + 2
            elif l1 >= 13 or l2 >= 13:
                self.max_rounds = self.max_rounds + 1
        if self.max_rounds == 19:
            # game is won
            self.max_rounds = 18
        return old != self.max_rounds

    def canDealCards(self):
        if self._updateMaxRounds():
            self.updateText()
        if not self.cards and not self.game.s.waste.cards:
            return False
        ncards = self.DEAL[self.round-1]
        assert ncards > 0
        return len(self.cards) >= ncards or self.round < self.max_rounds

    def dealCards(self, sound=False):
        # get number of cards to deal
        ncards = self.DEAL[self.round-1]
        assert ncards > 0
        # init
        waste = self.game.s.waste
        n = 0
        update_flags = 1
        # deal
        if self.cards:
            if sound and not self.game.demo:
                self.game.playSample("dealwaste")
        while n < ncards:
            # from self to waste
            while n < ncards:
                card = self.getCard()
                if not card:
                    break
                assert not card.face_up
                self.game.flipMove(self)
                self.game.moveMove(1, self, waste, frames=3, shadow=0)
                n = n + 1
            # turn from waste to self
            if n < ncards and len(waste.cards) > 0:
                assert len(self.cards) == 0
                assert self.round < self.max_rounds or update_flags == 0
                if sound:
                    self.game.playSample("turnwaste", priority=20)
                self.game.turnStackMove(waste, self)
                if update_flags:
                    self.game.nextRoundMove(self)
                # do not update self.round anymore in this deal
                update_flags = 0
        assert self.round <= self.max_rounds
        assert n == ncards
        assert len(self.game.s.waste.cards) > 0
        # done
        return n

    def updateText(self):
        if self.game.preview > 1:
            return
        WasteTalonStack.updateText(self, update_rounds=0)
        # t = "Round %d" % self.round
        t = _("Round %(round)d/%(max_rounds)d") % {
            'round': self.round, 'max_rounds': self.max_rounds}
        self.texts.rounds.config(text=t)
        t = _("Deal %d") % self.DEAL[self.round-1]
        self.texts.misc.config(text=t)


# ************************************************************************
# * Rows
# ************************************************************************

class Matriarchy_UpRowStack(SS_RowStack):
    def __init__(self, x, y, game, suit):
        SS_RowStack.__init__(self, x, y, game, suit=suit,
                             base_rank=KING, mod=13, dir=1,
                             min_cards=1, max_cards=12)
        self.CARD_YOFFSET = -self.CARD_YOFFSET

    getBottomImage = Stack._getSuitBottomImage


class Matriarchy_DownRowStack(SS_RowStack):
    def __init__(self, x, y, game, suit):
        SS_RowStack.__init__(self, x, y, game, suit=suit,
                             base_rank=QUEEN, mod=13, dir=-1,
                             min_cards=1, max_cards=12)

    getBottomImage = Stack._getSuitBottomImage


# ************************************************************************
# * Matriarchy
# ************************************************************************

class Matriarchy(Game):
    Hint_Class = CautiousDefaultHint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (set piles so that at least 2/3 of a card is visible with 12 cards)
        h = max(2*l.YS, (12-1)*l.YOFFSET + l.CH*2//3)
        self.setSize(10*l.XS+l.XM, h + l.YM + h)

        # create stacks
        # center, c1, c2 = self.height // 2, h, self.height - h
        center = self.height // 2
        c1, c2 = center-l.TEXT_HEIGHT//2, center+l.TEXT_HEIGHT//2
        x, y = l.XM, c1 - l.CH
        for i in range(8):
            s.rows.append(Matriarchy_UpRowStack(x, y, self, i//2))
            x = x + l.XS
        x, y = l.XM, c2
        for i in range(8):
            s.rows.append(Matriarchy_DownRowStack(x, y, self, i//2))
            x = x + l.XS
        x, y = x + l.XS // 2, c1 - l.CH // 2 - l.CH
        tx = x + l.CW // 2
        s.waste = Matriarchy_Waste(x, y, self)
        l.createText(s.waste, "s")
        y = c2 + l.CH // 2
        s.talon = Matriarchy_Talon(x, y, self, max_rounds=VARIABLE_REDEALS)
        l.createText(s.talon, "n")
        l.createRoundText(s.talon, 'ss')
        s.talon.texts.misc = MfxCanvasText(
                self.canvas,
                tx, center, anchor="center",
                font=self.app.getFont("canvas_large"))

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        # move Queens to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 11, c.suit), 8)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(self.s.rows[8:])
        self.s.talon.dealCards()          # deal first cards to WasteStack

    def isGameWon(self):
        return len(self.s.talon.cards) == 0 and len(self.s.waste.cards) == 0

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        if card1.rank + card2.rank == QUEEN + KING:
            return False
        return (card1.suit == card2.suit and
                ((card1.rank + 1) % 13 == card2.rank or
                 (card2.rank + 1) % 13 == card1.rank))


# register the game
registerGame(GameInfo(17, Matriarchy, "Matriarchy",
                      GI.GT_2DECK_TYPE, 2, VARIABLE_REDEALS, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        BasicRowStack, \
        InitialDealTalonStack, \
        InvisibleStack, \
        ReserveStack, \
        SS_FoundationStack, \
        Stack, \
        getPileFromStacks, \
        isSameSuitSequence
from pysollib.util import ACE, KING, QUEEN

# ************************************************************************
# *
# ************************************************************************


class SiebenBisAs_Hint(CautiousDefaultHint):
    def computeHints(self):
        game = self.game
        freerows = [s for s in game.s.rows if not s.cards]
        # for each stack
        for r in game.sg.dropstacks:
            if not r.cards:
                continue
            assert len(r.cards) == 1 and r.cards[-1].face_up
            pile, rpile = r.cards, []
            # try if we can drop the card
            t, ncards = r.canDropCards(self.game.s.foundations)
            if t:
                score, color = 0, None
                score, color = self._getDropCardScore(
                    score, color, r, t, ncards)
                self.addHint(score, ncards, r, t, color)
            # try if we can move the card
            for t in freerows:
                if self.shallMovePile(r, t, pile, rpile):
                    # FIXME: this scoring
                    score = 50000
                    self.addHint(score, 1, r, t)

    def shallMovePile(self, from_stack, to_stack, pile, rpile):
        if from_stack is to_stack or \
                not to_stack.acceptsCards(from_stack, pile):
            return 0
        # now check for loops
        rr = self.ClonedStack(from_stack, stackcards=rpile)
        if rr.acceptsCards(to_stack, pile):
            # the pile we are going to move could be moved back -
            # this is dangerous as we can create endless loops...
            return 0
        return 1

# ************************************************************************
# * Sieben bis As (Seven to Ace)
# ************************************************************************


class SiebenBisAs_Foundation(SS_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # this stack accepts only a card from a rowstack with an empty
        # left neighbour
        if from_stack not in self.game.s.rows:
            return False
        if from_stack.id % 10 == 0:
            return False
        return len(self.game.s.rows[from_stack.id - 1].cards) == 0


class SiebenBisAs_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if self.id % 10 != 0:
            # left neighbour
            s = self.game.s.rows[self.id - 1]
            if s.cards and s.cards[-1].suit == cards[0].suit \
                    and (s.cards[-1].rank + 1) % 13 == cards[0].rank:
                return True
        if self.id % 10 != 10 - 1:
            # right neighbour
            s = self.game.s.rows[self.id + 1]
            if s.cards and s.cards[-1].suit == cards[0].suit \
                    and (s.cards[-1].rank - 1) % 13 == cards[0].rank:
                return True
        return False

    # bottom to get events for an empty stack
    #  prepareBottom = Stack.prepareInvisibleBottom

    getBottomImage = Stack._getReserveBottomImage


class SiebenBisAs(Game):
    Hint_Class = SiebenBisAs_Hint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 10*l.XS, l.YM + 5*l.YS)

        # create stacks
        for i in range(3):
            for j in range(10):
                x, y, = l.XM + j*l.XS, l.YM + (i+1)*l.YS
                s.rows.append(
                    SiebenBisAs_RowStack(
                        x, y, self, max_accept=1, max_cards=1))
        for i in range(2):
            x, y, = l.XM + (i+4)*l.XS, l.YM
            s.reserves.append(ReserveStack(x, y, self, max_accept=0))
        for i in range(4):
            x, y, = l.XM + (i+3)*l.XS, l.YM + 4*l.YS
            s.foundations.append(
                SiebenBisAs_Foundation(
                    x, y, self, i, base_rank=6, mod=13,
                    max_move=0, max_cards=8))
        s.talon = InitialDealTalonStack(l.XM, self.height-l.YS, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)
        stacks = [r for r in self.s.rows if r.cards[-1].rank == 6]
        for r in stacks:
            self.moveMove(1, r, self.s.foundations[r.cards[-1].suit])

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * Maze
# ************************************************************************

class Maze_Hint(SiebenBisAs_Hint):
    def shallMovePile(self, from_stack, to_stack, pile, rpile):
        if from_stack is to_stack or \
                not to_stack.acceptsCards(from_stack, pile):
            return False
        # now check for loops
        rr = self.ClonedStack(from_stack, stackcards=rpile)
        if rr.acceptsCards(to_stack, pile):
            # the pile we are going to move could be moved back -
            # this is dangerous as we can create endless loops...
            return False
        return True


class Maze_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        # left neighbour
        s = self.game.s.rows[(self.id - 1) % 54]
        if s.cards:
            if s.cards[-1].suit == cards[0].suit and \
                    s.cards[-1].rank + 1 == cards[0].rank:
                return True
            if s.cards[-1].rank == QUEEN and cards[0].rank == ACE:
                return True
        # right neighbour
        s = self.game.s.rows[(self.id + 1) % 54]
        if s.cards:
            if s.cards[-1].suit == cards[0].suit and \
                    s.cards[-1].rank - 1 == cards[0].rank:
                return True
        return False

    # bottom to get events for an empty stack
    prepareBottom = Stack.prepareInvisibleBottom

    getBottomImage = Stack._getReserveBottomImage


class Maze(Game):
    GAME_VERSION = 2

    Hint_Class = Maze_Hint  # SiebenBisAs_Hint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self, card_x_space=4, card_y_space=4), self.s

        # set window
        self.setSize(l.XM + 9*l.XS, l.YM + 6*l.YS)

        # create stacks
        for i in range(6):
            for j in range(9):
                x, y, = l.XM + j*l.XS, l.YM + i*l.YS
                s.rows.append(
                    Maze_RowStack(x, y, self, max_accept=1, max_cards=1))
        # s.talon = InitialDealTalonStack(-2*l.XS, l.YM+5*l.YS/2, self)
        s.talon = InitialDealTalonStack(
            self.width-l.XS+1, self.height-l.YS, self)
        # create an invisble stack to hold the four Kings
        s.internals.append(InvisibleStack(self))

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        frames = 0
        for i in range(54):
            #            if i == 8 or i == 17:       # these stay empty
            if i >= 52:                 # these stay empty
                continue
            c = self.s.talon.cards[-1]
            if c.rank == KING:
                self.s.talon.dealRow(rows=self.s.internals, frames=0)
            else:
                if frames == 0 and i >= 36:
                    self.startDealSample()
                    frames = -1
                self.s.talon.dealRow(rows=(self.s.rows[i],), frames=frames)

    def isGameWon(self):
        rows = [s for s in self.s.rows if s.cards]
        if len(rows) != 48:
            return False            # no cards dealt yet
        i = 0
        if 1:
            # allow wrap around: search first Ace
            while rows[i].cards[-1].rank != ACE:
                i = i + 1
            rows = rows + rows
        # now check for 4 sequences
        for j in (i+0, i+12, i+24, i+36):
            r1 = rows[j]
            r2 = rows[j+11]
            if (r2.id - r1.id) % 54 != 11:
                # found a space within the sequence
                return False
            if r1.cards[-1].rank != ACE or r2.cards[-1].rank != QUEEN:
                return False
            pile = getPileFromStacks(rows[j:j+12])
            if not pile or not isSameSuitSequence(pile, dir=1):
                return False
        return True


# register the game
registerGame(GameInfo(118, SiebenBisAs, "Sieben bis As",
                      GI.GT_MONTANA | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL,
                      ranks=(0, 6, 7, 8, 9, 10, 11, 12)))
registerGame(GameInfo(144, Maze, "Maze",
                      GI.GT_MONTANA | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL,
                      si={"ncards": 48}))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.numerica import Numerica_Hint
from pysollib.hint import AbstractHint, CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AbstractFoundationStack, \
        BasicRowStack, \
        OpenStack, \
        OpenTalonStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, ANY_RANK, ANY_SUIT, JACK, KING, NO_RANK, \
        QUEEN, RANKS, \
        UNLIMITED_CARDS
# ************************************************************************
# * Camelot
# ************************************************************************


class Camelot_Hint(AbstractHint):

    def computeHints(self):
        game = self.game
        if game.is_fill:
            nhints = 0
            i = 0
            for r in game.s.rows:
                i += 1
                if not r.cards:
                    continue
                if r.cards[0].rank == 9:
                    self.addHint(5000, 1, r, game.s.foundations[0])
                    nhints += 1
                    continue
                for t in game.s.rows[i:]:
                    if t.acceptsCards(r, [r.cards[0]]):
                        self.addHint(5000, 1, r, t)
                        nhints += 1
            if nhints:
                return
        if game.s.talon.cards:
            for r in game.s.rows:
                if r.acceptsCards(game.s.talon, [game.s.talon.cards[-1]]):
                    self.addHint(5000, 1, game.s.talon, r)


class Camelot_RowStack(ReserveStack):

    def acceptsCards(self, from_stack, cards):
        if from_stack is self.game.s.talon:
            if len(self.cards) > 0:
                return False
            cr = cards[0].rank
            if cr == KING:
                return self.id in (0, 3, 12, 15)
            elif cr == QUEEN:
                return self.id in (1, 2, 13, 14)
            elif cr == JACK:
                return self.id in (4, 7, 8, 11)
            return True
        else:
            if len(self.cards) == 0:
                return False
            return self.cards[-1].rank + cards[0].rank == 8

    def canMoveCards(self, cards):
        if not self.game.is_fill:
            return False
        return cards[0].rank not in (KING, QUEEN, JACK)

    def clickHandler(self, event):
        game = self.game
        if game.is_fill and self.cards and self.cards[0].rank == 9:
            game.playSample("autodrop", priority=20)
            self.playMoveMove(1, game.s.foundations[0], sound=False)
            self.fillStack()
            return True
        return False

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        if to_stack is not self.game.s.foundations[0]:
            self._dropPairMove(ncards, to_stack, frames=-1, shadow=shadow)
        else:
            ReserveStack.moveMove(
                self, ncards, to_stack, frames=frames, shadow=shadow)

    def _dropPairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        old_state = game.enterState(game.S_FILL)
        f = game.s.foundations[0]
        game.updateStackMove(game.s.talon, 2 | 16)            # for undo
        if not game.demo:
            game.playSample("droppair", priority=200)
        game.moveMove(n, self, f, frames=frames, shadow=shadow)
        game.moveMove(n, other_stack, f, frames=frames, shadow=shadow)
        self.fillStack()
        other_stack.fillStack()
        game.updateStackMove(game.s.talon, 1 | 16)            # for redo
        game.leaveState(old_state)


class Camelot_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        return True


class Camelot_Talon(OpenTalonStack):
    def fillStack(self):
        old_state = self.game.enterState(self.game.S_FILL)
        self.game.saveStateMove(2 | 16)            # for undo
        self.game.is_fill = self.game.isRowsFill()
        self.game.saveStateMove(1 | 16)            # for redo
        self.game.leaveState(old_state)
        OpenTalonStack.fillStack(self)


class Camelot(Game):

    Talon_Class = Camelot_Talon
    RowStack_Class = StackWrapper(Camelot_RowStack, max_move=0)
    Hint_Class = Camelot_Hint

    # game variables
    is_fill = False

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        # set window
        w = l.XS
        self.setSize(l.XM + w + 4*l.XS + w + l.XS, l.YM + 4*l.YS)
        # create stacks
        for i in range(4):
            for j in range(4):
                x, y = l.XM + w + j*l.XS, l.YM + i*l.YS
                s.rows.append(self.RowStack_Class(x, y, self))
        x, y = l.XM, l.YM
        s.talon = self.Talon_Class(x, y, self)
        l.createText(s.talon, 's')
        x, y = l.XM + w + 4*l.XS + w, l.YM
        s.foundations.append(Camelot_Foundation(x, y, self,
                             suit=ANY_SUIT, dir=0, base_rank=ANY_RANK,
                             max_accept=0, max_move=0, max_cards=52))
        l.createText(s.foundations[0], 's')
        # define stack-groups
        l.defaultStackGroups()
        return l

    #
    # game overrides
    #

    def startGame(self):
        self.is_fill = False
        self.s.talon.fillStack()

    def isGameWon(self):
        for i in (5, 6, 9, 10):
            if len(self.s.rows[i].cards) != 0:
                return False
        return len(self.s.talon.cards) == 0

    def isRowsFill(self):
        for i in range(16):
            if len(self.s.rows[i].cards) == 0:
                return False
        return True

    def _restoreGameHook(self, game):
        self.is_fill = game.loadinfo.is_fill

    def _loadGameHook(self, p):
        self.loadinfo.addattr(is_fill=p.load())

    def _saveGameHook(self, p):
        p.dump(self.is_fill)

    def getAutoStacks(self, event=None):
        return ((), (), ())

    def setState(self, state):
        # restore saved vars (from undo/redo)
        self.is_fill = state[0]

    def getState(self):
        # save vars (for undo/redo)
        return [self.is_fill]


# ************************************************************************
# * Sly Fox
# ************************************************************************

class SlyFox_Foundation(SS_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack in self.game.s.rows:
            if len(self.game.s.talon.cards) == 0:
                return True
            return self.game.num_dealled <= 0
        return True


class SlyFox_Talon(OpenTalonStack):
    rightclickHandler = OpenStack.rightclickHandler
    doubleclickHandler = OpenStack.doubleclickHandler

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        old_state = self.game.enterState(self.game.S_FILL)
        self.game.saveStateMove(2 | 16)            # for undo
        if old_state == self.game.S_PLAY and to_stack in self.game.s.rows:
            n = self.game.num_dealled
            if n < 0:
                n = 0
            self.game.num_dealled = (n+1) % 20
        self.game.saveStateMove(1 | 16)            # for redo
        self.game.leaveState(old_state)
        OpenTalonStack.moveMove(self, ncards, to_stack, frames, shadow)


class SlyFox_RowStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        return from_stack is self.game.s.talon


class SlyFox(Game):
    Hint_Class = Numerica_Hint

    num_dealled = -1

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+9*l.XS, l.YM+4*l.YS)

        x, y = l.XM, l.YM
        s.talon = SlyFox_Talon(x, y, self)
        s.waste = s.talon
        l.createText(s.talon, 'ne')
        tx, ty, ta, tf = l.getTextAttr(s.talon, "ss")
        font = self.app.getFont("canvas_default")
        self.texts.misc = MfxCanvasText(self.canvas, tx, ty,
                                        anchor=ta, font=font)

        y = l.YM
        for i in range(4):
            x = l.XM+1.5*l.XS
            for j in range(5):
                stack = SlyFox_RowStack(x, y, self, max_cards=UNLIMITED_CARDS)
                stack.CARD_YOFFSET = 0
                s.rows.append(stack)
                x += l.XS
            y += l.YS

        x, y = self.width-2*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SlyFox_Foundation(x, y, self, suit=i))
            s.foundations.append(SlyFox_Foundation(x+l.XS, y, self, suit=i,
                                                   base_rank=KING, dir=-1))
            y += l.YS

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (ACE, KING) and c.deck == 0,
                       (c.suit, c.rank)))

    def startGame(self):
        self.num_dealled = -1
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.fillStack()

    def _restoreGameHook(self, game):
        self.num_dealled = game.loadinfo.num_dealled

    def _loadGameHook(self, p):
        self.loadinfo.addattr(num_dealled=p.load())

    def _saveGameHook(self, p):
        p.dump(self.num_dealled)

    def setState(self, state):
        # restore saved vars (from undo/redo)
        self.num_dealled = state[0]

    def getState(self):
        # save vars (for undo/redo)
        return [self.num_dealled]

    def fillStack(self, stack):
        if self.num_dealled == -1 and stack in self.s.rows and not stack.cards:
            old_state = self.enterState(self.S_FILL)
            self.s.talon.moveMove(1, stack)
            self.leaveState(old_state)

    def updateText(self):
        if self.preview > 1:
            return
        n = self.num_dealled
        if n < 0:
            n = 0
        text = str(n)+'/20'
        self.texts.misc.config(text=text)


class OpenSlyFox(SlyFox):

    def createGame(self):
        playcards = 6

        l, s = Layout(self), self.s
        self.setSize(
            l.XM+10*l.XS, l.YM+3*l.YS+2*playcards*l.YOFFSET+l.TEXT_HEIGHT)

        x, y = l.XM, l.YM
        s.talon = SlyFox_Talon(x, y, self)
        s.waste = s.talon
        l.createText(s.talon, 'ne')
        tx, ty, ta, tf = l.getTextAttr(s.talon, "ss")
        font = self.app.getFont("canvas_default")
        self.texts.misc = MfxCanvasText(self.canvas, tx, ty,
                                        anchor=ta, font=font)

        x += 2*l.XS
        for i in range(4):
            s.foundations.append(SlyFox_Foundation(x, y, self, suit=i))
            s.foundations.append(SlyFox_Foundation(x+4*l.XS, y, self, suit=i,
                                                   base_rank=KING, dir=-1))
            x += l.XS
        y = l.YM+l.YS+l.TEXT_HEIGHT
        for i in range(2):
            x = l.XM
            for j in range(10):
                stack = SlyFox_RowStack(x, y, self, max_cards=UNLIMITED_CARDS)
                s.rows.append(stack)
                stack.CARD_YOFFSET = l.YOFFSET
                x += l.XS
            y += l.YS+playcards*l.YOFFSET

        l.defaultStackGroups()


# ************************************************************************
# * Princess Patience
# ************************************************************************

class PrincessPatience_RowStack(SS_RowStack):

    def canMoveCards(self, cards):
        if not SS_RowStack.canMoveCards(self, cards):
            return False
        # don't work in demo-mode with cloned stack
        # index = list(self.game.s.rows).index(self)
        index = self.id
        col = index % 4
        row = index // 4
        if index < 16:  # left
            for i in range(col+1, 4):
                r = self.game.s.rows[row*4+i]
                if r.cards:
                    return False
        else:  # right
            for i in range(0, col):
                r = self.game.s.rows[row*4+i]
                if r.cards:
                    return False
        return True

    def acceptsCards(self, from_stack, cards):
        if not SS_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return from_stack is self.game.s.waste
        return True


class PrincessPatience(Game):
    Hint_Class = CautiousDefaultHint
    RowStack_Class = PrincessPatience_RowStack

    def createGame(self, max_rounds=1):

        l, s = Layout(self), self.s
        self.setSize(l.XM+11*l.XS, l.YM+5*l.YS)

        y = l.YM
        for i in range(4):
            x = l.XM
            for j in range(4):
                stack = self.RowStack_Class(x, y, self, max_move=1)
                s.rows.append(stack)
                stack.CARD_YOFFSET = 0
                x += l.XS
            y += l.YS
        y = l.YM
        for i in range(4):
            x = l.XM+7*l.XS
            for j in range(4):
                stack = self.RowStack_Class(x, y, self, max_move=1)
                s.rows.append(stack)
                stack.CARD_YOFFSET = 0
                x += l.XS
            y += l.YS

        x, y = l.XM+4.5*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            s.foundations.append(SS_FoundationStack(x+l.XS, y, self, suit=i))
            y += l.YS

        x, y = l.XM+4.5*l.XS, self.height-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=max_rounds)
        l.createText(s.talon, 'sw')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'se')

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Grandmamma's Patience
# ************************************************************************

class GrandmammasPatience_Talon(OpenTalonStack):
    rightclickHandler = OpenStack.rightclickHandler
    doubleclickHandler = OpenStack.doubleclickHandler


class GrandmammasPatience_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        return from_stack not in self.game.s.rows


class GrandmammasPatience(Game):

    def createGame(self):

        l, s = Layout(self), self.s
        h0 = l.YS+4*l.YOFFSET
        self.setSize(l.XM+11*l.XS, l.YM+2*l.YS+2*h0)
        self.base_rank = ANY_RANK

        x, y = l.XM, l.YM
        s.talon = GrandmammasPatience_Talon(x, y, self)
        l.createText(s.talon, 'ne')

        x, y = self.width-4*l.XS, l.YM
        for i in range(4):
            s.foundations.append(
                SS_FoundationStack(
                    x, y, self, suit=i,
                    dir=-1, mod=13, max_move=0, base_rank=ANY_RANK))
            x += l.XS
        stack = s.foundations[0]
        tx, ty, ta, tf = l.getTextAttr(stack, "sw")
        font = self.app.getFont("canvas_default")
        stack.texts.misc = MfxCanvasText(
            self.canvas, tx, ty, anchor=ta, font=font)
        x, y = self.width-4*l.XS, self.height-l.YS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                 mod=13, max_move=0, base_rank=ANY_RANK))
            x += l.XS
        stack = s.foundations[4]
        tx, ty, ta, tf = l.getTextAttr(stack, "sw")
        font = self.app.getFont("canvas_default")
        stack.texts.misc = MfxCanvasText(
            self.canvas, tx, ty, anchor=ta, font=font)

        y = l.YM+l.YS
        for i in range(2):
            x = l.XM
            for j in range(11):
                s.rows.append(GrandmammasPatience_RowStack(x, y, self,
                              max_accept=1, max_cards=2))
                x += l.XS
            y += h0

        x, y = l.XM, self.height-l.YS
        for i in range(4):
            s.reserves.append(ReserveStack(x, y, self))
            x += l.XS

        l.defaultStackGroups()
        self.sg.dropstacks.append(s.talon)

    def startGame(self):
        c = self.s.talon.cards[-1]
        self.base_rank = c.rank
        to_stack = self.s.foundations[c.suit]
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, to_stack, frames=0)
        for s in self.s.foundations[:4]:
            s.cap.base_rank = c.rank
        for s in self.s.foundations[4:]:
            s.cap.base_rank = (c.rank+1) % 13
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.fillStack()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            if self.s.talon.cards:
                old_state = self.enterState(self.S_FILL)
                self.s.talon.moveMove(1, stack)
                self.leaveState(old_state)

    def updateText(self):
        if self.preview > 1:
            return
        base_rank = self.base_rank
        if base_rank == ANY_RANK:
            t1 = t2 = ''
        else:
            t1 = RANKS[base_rank]+_(" Descending")
            t2 = RANKS[(base_rank+1) % 13]+_(" Ascending")
        self.s.foundations[0].texts.misc.config(text=t1)
        self.s.foundations[4].texts.misc.config(text=t2)

    def _restoreGameHook(self, game):
        self.base_rank = game.loadinfo.base_rank
        for s in self.s.foundations[:4]:
            s.cap.base_rank = self.base_rank
        for s in self.s.foundations[4:]:
            s.cap.base_rank = (self.base_rank+1) % 13

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_rank=None)    # register extra load var.
        self.loadinfo.base_rank = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_rank)


# ************************************************************************
# * Double Line
# ************************************************************************

class DoubleLine_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        # this stack accepts any one card from the Waste pile
        return from_stack is self.game.s.waste

    def getHelp(self):
        return _('Tableau. Build regardless of rank and suit.')


class DoubleLine(Game):

    def createGame(self):

        l, s = Layout(self), self.s
        h0 = l.YS+3*l.YOFFSET
        self.setSize(l.XM+10*l.XS, l.YM+l.YS+l.TEXT_HEIGHT+2*h0)

        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 's')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 's')

        x += l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i % 4))
            x += l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                 base_rank=KING, dir=-1))
            x += l.XS

        y = l.YM+l.YS+l.TEXT_HEIGHT
        for i in range(2):
            x = l.XM
            for j in range(10):
                s.rows.append(DoubleLine_RowStack(x, y, self, max_cards=2,
                              max_move=1, max_accept=1, base_rank=NO_RANK))
                x += l.XS
            y += h0

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if not self.s.waste.cards:
                self.s.talon.dealCards()
            if self.s.waste.cards:
                self.s.waste.moveMove(1, stack)
            self.leaveState(old_state)


# register the game
registerGame(GameInfo(280, Camelot, "Camelot",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(610, SlyFox, "Sly Fox",
                      GI.GT_NUMERICA, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(614, OpenSlyFox, "Open Sly Fox",
                      GI.GT_NUMERICA | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(623, PrincessPatience, "Princess Patience",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(622, GrandmammasPatience, "Grandmamma's Patience",
                      GI.GT_NUMERICA, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(702, DoubleLine, "Double Line",
                      GI.GT_NUMERICA, 2, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import AbstractHint
from pysollib.layout import Layout
from pysollib.stack import \
        BasicRowStack, \
        DealRowTalonStack, \
        InvisibleStack, \
        RK_FoundationStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        Stack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, KING, QUEEN

# ************************************************************************
# *
# ************************************************************************


class PictureGallery_Hint(AbstractHint):
    def computeHints(self):
        game = self.game

        # 1) try if we can drop a card (i.e. an Ace)
        for r in game.sg.dropstacks:
            t, n = r.canDropCards(game.s.foundations)
            if t and n == 1:
                c = r.getCard()
                assert t is not r and c
                assert c.rank == ACE
                if r in game.s.tableaux:
                    base_score = 90000 + (4 - r.cap.base_rank)
                else:
                    base_score = 90000
                score = base_score + 100 * (self.K - c.rank)
                self.addHint(score, 1, r, t)

        # 2) try if we can move a card to the tableaux
        if not self.hints:
            for r in game.sg.dropstacks:
                pile = r.getPile()
                if not pile or len(pile) != 1:
                    continue
                if r in game.s.tableaux:
                    rr = self.ClonedStack(r, stackcards=r.cards[:-1])
                    if rr.acceptsCards(None, pile):
                        # do not move a card that is already in correct place
                        continue
                    base_score = 80000 + (4 - r.cap.base_rank)
                else:
                    base_score = 80000
                # find a stack that would accept this card
                for t in game.s.tableaux:
                    if t is not r and t.acceptsCards(r, pile):
                        score = base_score + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 3) Try if we can move a card from the tableaux
        #    to a row stack. This can only happen if there are
        #    no more cards to deal.
        if not self.hints:
            for r in game.s.tableaux:
                pile = r.getPile()
                if not pile or len(pile) != 1:
                    continue
                rr = self.ClonedStack(r, stackcards=r.cards[:-1])
                if rr.acceptsCards(None, pile):
                    # do not move a card that is already in correct place
                    continue
                # find a stack that would accept this card
                for t in game.s.rows:
                    if t is not r and t.acceptsCards(r, pile):
                        score = 70000 + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 4) try if we can move a card within the row stacks
        if not self.hints:
            for r in game.s.rows:
                pile = r.getPile()
                if not pile:
                    continue
                lp = len(pile)
                lr = len(r.cards)
                assert 1 <= lp <= lr
                rpile = r.cards[:(lr-lp)]   # remaining pile
                if not pile or len(pile) != 1 or len(pile) == len(r.cards):
                    continue
                base_score = 60000
                # find a stack that would accept this card
                for t in game.s.rows:
                    if self.shallMovePile(r, t, pile, rpile):
                        score = base_score + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 5) try if we can deal cards
        if self.level >= 2:
            if game.canDealCards():
                self.addHint(self.SCORE_DEAL, 0, game.s.talon, None)


# ************************************************************************
# * Picture Gallery
# ************************************************************************

# this Foundation only accepts Aces
class PictureGallery_Foundation(RK_FoundationStack):
    def __init__(self, x, y, game):
        RK_FoundationStack.__init__(
            self, x, y, game, base_rank=ACE, dir=0, max_move=0, max_cards=8)
        self.CARD_YOFFSET = min(30, self.game.app.images.CARD_YOFFSET + 10)

    def getBottomImage(self):
        return self.game.app.images.getLetter(ACE)

    def closeStack(self):
        if len(self.cards) == 8:
            if self.game.moves.state not in \
                    (self.game.S_REDO, self.game.S_RESTORE):
                self.game.flipAllMove(self)

    def canFlipCard(self):
        return False


class PictureGallery_TableauStack(SS_RowStack):
    def __init__(self, x, y, game, base_rank, yoffset, dir=3, max_cards=4):
        SS_RowStack.__init__(
            self, x, y, game,
            base_rank=base_rank, dir=dir, max_cards=max_cards, max_accept=1)
        self.CARD_YOFFSET = yoffset

    def acceptsCards(self, from_stack, cards):
        if not SS_RowStack.acceptsCards(self, from_stack, cards):
            return False
        # check that the base card is correct
        if self.cards and self.cards[0].rank != self.cap.base_rank:
            return False
        return True

    getBottomImage = Stack._getLetterImage


class PictureGallery_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        # check
        if self.cards or self.game.s.talon.cards:
            return False
        return True

    getBottomImage = Stack._getTalonBottomImage


# ************************************************************************
# *
# ************************************************************************

class PictureGallery(Game):
    Hint_Class = PictureGallery_Hint

    Foundation_Class = PictureGallery_Foundation
    TableauStack_Classes = [
        StackWrapper(
            PictureGallery_TableauStack, base_rank=3, max_cards=4, dir=3),
        StackWrapper(
            PictureGallery_TableauStack, base_rank=2, max_cards=4, dir=3),
        StackWrapper(
            PictureGallery_TableauStack, base_rank=1, max_cards=4, dir=3),
        ]
    RowStack_Class = StackWrapper(PictureGallery_RowStack, max_accept=1)
    Talon_Class = DealRowTalonStack

    #
    # game layout
    #

    def createGame(self, waste=False):
        rows = len(self.TableauStack_Classes)
        # create layout
        l, s = Layout(self), self.s
        TABLEAU_YOFFSET = min(9, max(3, l.YOFFSET // 3))

        # set window
        th = l.YS + (12//rows-1) * TABLEAU_YOFFSET
        # (set piles so that at least 2/3 of a card is visible with 10 cards)
        h = (10-1)*l.YOFFSET + l.CH*2//3
        self.setSize(10*l.XS+l.XM, l.YM + 3*th + l.YM + h)

        # create stacks
        s.addattr(tableaux=[])     # register extra stack variable
        x = l.XM + 8 * l.XS + l.XS // 2
        y = l.YM + l.CH // 2
        s.foundations.append(self.Foundation_Class(x, y, self))
        y = l.YM
        for cl in self.TableauStack_Classes:
            x = l.XM
            for j in range(8):
                s.tableaux.append(cl(x, y, self, yoffset=TABLEAU_YOFFSET))
                x = x + l.XS
            y = y + th
        x, y = l.XM, y + l.YM
        for i in range(8):
            s.rows.append(self.RowStack_Class(x, y, self))
            x = x + l.XS
        # self.setRegion(s.rows, (-999, -999, x - l.CW // 2, 999999))
        x = l.XM + 8 * l.XS + l.XS // 2
        y = self.height - l.YS
        s.talon = self.Talon_Class(x, y, self)
        l.createText(s.talon, "se")
        if waste:
            y -= l.YS
            s.waste = WasteStack(x, y, self)
            l.createText(s.waste, "se")
        self.setRegion(s.foundations, (x - l.CW // 2, -999, 999999, y - l.CH))

        # define stack-groups
        if waste:
            ws = [s.waste]
        else:
            ws = []
        self.sg.openstacks = s.foundations + s.tableaux + s.rows + ws
        self.sg.talonstacks = [s.talon] + ws
        self.sg.dropstacks = s.tableaux + s.rows + ws

    #
    # game overrides
    #

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.tableaux, frames=0)
        self._startAndDealRow()

    def isGameWon(self):
        if len(self.s.foundations[0].cards) != 8:
            return False
        for stack in self.s.tableaux:
            if len(stack.cards) != 4:
                return False
        return True

    def fillStack(self, stack):
        if self.s.talon.cards:
            if stack in self.s.rows and len(stack.cards) == 0:
                self.s.talon.dealRow(rows=[stack])

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        if card1.rank == ACE or card2.rank == ACE:
            return False
        return (card1.suit == card2.suit and
                (card1.rank + 3 == card2.rank or card2.rank + 3 == card1.rank))

    def getHighlightPilesStacks(self):
        return ()


# ************************************************************************
# * Great Wheel
# ************************************************************************


class GreatWheel_Hint(PictureGallery_Hint):
    shallMovePile = PictureGallery_Hint._cautiousShallMovePile


class GreatWheel_Foundation(PictureGallery_Foundation):
    def acceptsCards(self, from_stack, cards):
        if not PictureGallery_Foundation.acceptsCards(self, from_stack, cards):
            return False
        if self.cards and self.cards[-1].color == cards[0].color:
            return False
        return True


class GreatWheel_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if self.game.s.talon.cards:
            return False
        if not self.cards:
            return True
        c1, c2 = self.cards[-1], cards[0]
        return c1.suit == c2.suit and c1.rank == c2.rank+1

    getBottomImage = Stack._getTalonBottomImage


class GreatWheel(PictureGallery):

    Hint_Class = GreatWheel_Hint
    Foundation_Class = GreatWheel_Foundation
    TableauStack_Classes = [
        StackWrapper(
            PictureGallery_TableauStack, base_rank=2, max_cards=5, dir=2),
        StackWrapper(
            PictureGallery_TableauStack, base_rank=1, max_cards=6, dir=2),
        ]
    RowStack_Class = StackWrapper(GreatWheel_RowStack, max_accept=1)
    Talon_Class = StackWrapper(WasteTalonStack, max_rounds=1)

    def createGame(self):
        PictureGallery.createGame(self, waste=True)

    def fillStack(self, stack):
        if stack is self.s.waste and not stack.cards:
            self.s.talon.dealCards()
        if self.s.talon.cards or self.s.waste.cards:
            if stack in self.s.rows and len(stack.cards) == 0:
                old_state = self.enterState(self.S_FILL)
                for i in range(4):
                    if not self.s.waste.cards:
                        self.s.talon.dealCards()
                    if self.s.waste.cards:
                        self.s.waste.moveMove(1, stack)
                self.leaveState(old_state)

    def startGame(self):
        self.startDealSample()
        for i in range(4):
            self.s.talon.dealRow()
        self.s.talon.dealCards()

    def isGameWon(self):
        if len(self.s.foundations[0].cards) != 8:
            return False
        if self.s.talon.cards or self.s.waste.cards:
            return False
        for stack in self.s.rows:
            if stack.cards:
                return False
        return True

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        if card1.rank == ACE or card2.rank == ACE:
            return False
        return (card1.suit == card2.suit and
                (card1.rank + 2 == card2.rank or card2.rank + 2 == card1.rank))

# ************************************************************************
# * Mount Olympus
# * Zeus
# ************************************************************************


class MountOlympus_Foundation(SS_FoundationStack):
    def getHelp(self):
        return 'Build up in suit by twos.'


class MountOlympus_RowStack(SS_RowStack):
    def getHelp(self):
        return 'Build down in suit by twos.'


class MountOlympus(Game):
    RowStack_Class = MountOlympus_RowStack

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+9*l.XS, l.YM+3*l.YS+12*l.YOFFSET)

        # create stacks
        x, y = l.XM+l.XS, l.YM
        for i in range(8):
            s.foundations.append(
                MountOlympus_Foundation(
                    x, y, self,
                    suit=i//2, base_rank=ACE, dir=2, max_move=0, max_cards=7))
            x += l.XS
        x, y = l.XM+l.XS, l.YM+l.YS
        for i in range(8):
            s.foundations.append(
                MountOlympus_Foundation(
                    x, y, self,
                    suit=i//2, base_rank=1, dir=2, max_move=0, max_cards=6))
            x += l.XS
        x, y = l.XM, l.YM+2*l.YS
        for i in range(9):
            s.rows.append(self.RowStack_Class(x, y, self, dir=-2))
            x += l.XS
        s.talon = DealRowTalonStack(l.XM, l.YM, self)
        l.createText(s.talon, 's')

        # define stack-groups
        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (ACE, 1),  (c.rank, c.suit)))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealRow()

    def fillStack(self, stack):
        if self.s.talon.cards:
            if stack in self.s.rows and len(stack.cards) == 0:
                self.s.talon.dealRow(rows=[stack])

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                (card1.rank + 2 == card2.rank or card2.rank + 2 == card1.rank))


class Zeus_RowStack(MountOlympus_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not MountOlympus_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return cards[0].rank in (QUEEN, KING)
        return True


class Zeus(MountOlympus):
    RowStack_Class = Zeus_RowStack

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self.startDealSample()
        for i in range(4):
            self.s.talon.dealRow()


# ************************************************************************
# * Royal Parade
# ************************************************************************


class RoyalParade_TableauStack(PictureGallery_TableauStack):

    def _canSwapPair(self, from_stack):
        if from_stack not in self.game.s.tableaux:
            return False
        if len(self.cards) != 1 or len(from_stack.cards) != 1:
            return False
        c0, c1 = from_stack.cards[0], self.cards[0]
        return (c0.rank == self.cap.base_rank and
                c1.rank == from_stack.cap.base_rank)

    def acceptsCards(self, from_stack, cards):
        if self._canSwapPair(from_stack):
            return True
        return PictureGallery_TableauStack.acceptsCards(
            self, from_stack, cards)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        if self._canSwapPair(to_stack):
            self._swapPairMove(ncards, to_stack, frames=-1, shadow=0)
        else:
            PictureGallery_TableauStack.moveMove(self, ncards, to_stack,
                                                 frames=frames, shadow=shadow)

    def _swapPairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        old_state = game.enterState(game.S_FILL)
        swap = game.s.internals[0]
        game.moveMove(n, self, swap, frames=0)
        game.moveMove(n, other_stack, self, frames=frames, shadow=shadow)
        game.moveMove(n, swap, other_stack, frames=0)
        game.leaveState(old_state)


class RoyalParade(PictureGallery):
    Talon_Class = DealRowTalonStack
    TableauStack_Classes = [
        StackWrapper(RoyalParade_TableauStack,
                     base_rank=1, max_cards=4, dir=3),
        StackWrapper(RoyalParade_TableauStack,
                     base_rank=2, max_cards=4, dir=3),
        StackWrapper(RoyalParade_TableauStack,
                     base_rank=3, max_cards=4, dir=3),
        ]
    RowStack_Class = StackWrapper(BasicRowStack, max_accept=0)

    def createGame(self):
        PictureGallery.createGame(self)
        self.s.internals.append(InvisibleStack(self))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.tableaux)
        self.s.talon.dealRow()


# ************************************************************************
# * Virginia Reel
# ************************************************************************

class VirginiaReel_Talon(DealRowTalonStack):

    def canDealCards(self):
        if not DealRowTalonStack.canDealCards(self):
            return False
        for s in self.game.s.tableaux:
            if not s.cards:
                return False
        return True


class VirginiaReel(RoyalParade):
    Talon_Class = VirginiaReel_Talon

    def _shuffleHook(self, cards):
        bottom_cards = []
        ranks = []
        for c in cards[:]:
            if c.rank in (1, 2, 3) and c.rank not in ranks:
                ranks.append(c.rank)
                cards.remove(c)
                bottom_cards.append(c)
            if len(ranks) == 3:
                break
        bottom_cards.sort(key=lambda x: -x.rank)
        return cards+bottom_cards

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.tableaux[0::8], frames=0)
        self.startDealSample()
        for i in range(3):
            rows = self.s.tableaux[i*8+1:i*8+8]
            self.s.talon.dealRow(rows=rows)
        self.s.talon.dealRow()

    def fillStack(self, stack):
        pass


# register the game
registerGame(GameInfo(7, PictureGallery, "Picture Gallery",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED,
                      altnames=("Die Bildgallerie", "Mod-3")))
registerGame(GameInfo(397, GreatWheel, "Great Wheel",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED,
                      ranks=list(range(12))  # without Kings
                      ))
registerGame(GameInfo(398, MountOlympus, "Mount Olympus",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(399, Zeus, "Zeus",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(546, RoyalParade, "Royal Parade",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL,
                      rules_filename='virginiareel.html'))
registerGame(GameInfo(547, VirginiaReel, "Virginia Reel",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.spider import Spider_Hint
from pysollib.games.spider import Spider_RowStack, Spider_SS_Foundation
from pysollib.hint import CautiousDefaultHint
from pysollib.hint import KlondikeType_Hint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.stack import \
        AC_RowStack, \
        BO_RowStack, \
        KingAC_RowStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        Spider_SS_RowStack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, KING

# ************************************************************************
# * Double Klondike (Klondike with 2 decks and 9 rows)
# ************************************************************************


class DoubleKlondike(Game):
    Layout_Method = staticmethod(Layout.harpLayout)
    Foundation_Class = SS_FoundationStack
    RowStack_Class = KingAC_RowStack
    Hint_Class = KlondikeType_Hint

    def createGame(self, max_rounds=-1, num_deal=1, **layout):
        # create layout
        l, s = Layout(self), self.s
        kwdefault(layout, rows=9, waste=1, texts=1, playcards=19)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = WasteTalonStack(l.s.talon.x, l.s.talon.y, self,
                                  max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(r.x, r.y, self, suit=r.suit))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        # default
        l.defaultAll()
        # extra
        if max_rounds > 1:
            anchor = 'nn'
            if layout.get("texts"):
                anchor = 'nnn'
            l.createRoundText(s.talon, anchor)
        return l

    def startGame(self, flip=0):
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=flip, frames=0)
        self._startAndDealRowAndCards()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Double Klondike by Threes
# ************************************************************************

class DoubleKlondikeByThrees(DoubleKlondike):
    def createGame(self):
        DoubleKlondike.createGame(self, num_deal=3)


# ************************************************************************
# * Gargantua (Double Klondike with one redeal)
# * Pantagruel
# ************************************************************************

class Gargantua(DoubleKlondike):
    def createGame(self):
        DoubleKlondike.createGame(self, max_rounds=2)


class Pantagruel(DoubleKlondike):
    RowStack_Class = AC_RowStack

    def createGame(self):
        DoubleKlondike.createGame(self, max_rounds=1)

# ************************************************************************
# * Harp (Double Klondike with 10 non-king rows and no redeal)
# ************************************************************************


class BigHarp(DoubleKlondike):
    RowStack_Class = AC_RowStack

    def createGame(self):
        DoubleKlondike.createGame(self, max_rounds=1, rows=10)

    #
    # game overrides
    #

    # no real need to override, but this way the layout
    # looks a little bit different
    def startGame(self):
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[:i], flip=0, frames=0)
        self._startAndDealRowAndCards()


# ************************************************************************
# * Steps (Harp with 7 rows)
# ************************************************************************

class Steps(DoubleKlondike):
    RowStack_Class = AC_RowStack

    def createGame(self):
        DoubleKlondike.createGame(self, max_rounds=2, rows=7)


# ************************************************************************
# * Triple Klondike
# * Triple Klondike by Threes
# * Chinese Klondike
# ************************************************************************

class TripleKlondike(DoubleKlondike):
    def createGame(self):
        DoubleKlondike.createGame(self, rows=13)


class TripleKlondikeByThrees(DoubleKlondike):
    def createGame(self):
        DoubleKlondike.createGame(self, rows=13, num_deal=3)


class ChineseKlondike(DoubleKlondike):
    RowStack_Class = StackWrapper(BO_RowStack, base_rank=KING)

    def createGame(self):
        DoubleKlondike.createGame(self, rows=12)


# ************************************************************************
# * Lady Jane
# * Inquisitor
# ************************************************************************

class LadyJane(DoubleKlondike):
    Hint_Class = Spider_Hint
    RowStack_Class = Spider_SS_RowStack

    def createGame(self):
        DoubleKlondike.createGame(self, rows=10, max_rounds=2, num_deal=3)

    def startGame(self):
        DoubleKlondike.startGame(self, flip=1)

    shallHighlightMatch = Game._shallHighlightMatch_RK
    getQuickPlayScore = Game._getSpiderQuickPlayScore


class Inquisitor(DoubleKlondike):
    RowStack_Class = SS_RowStack

    def createGame(self):
        DoubleKlondike.createGame(self, rows=10, max_rounds=3, num_deal=3)

    def startGame(self):
        DoubleKlondike.startGame(self, flip=1)
    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Arabella
# ************************************************************************

class Arabella(DoubleKlondike):
    Hint_Class = Spider_Hint
    RowStack_Class = StackWrapper(Spider_SS_RowStack, base_rank=KING)

    def createGame(self):
        DoubleKlondike.createGame(self, rows=13, max_rounds=1, playcards=24)

    def startGame(self):
        DoubleKlondike.startGame(self, flip=1)

    shallHighlightMatch = Game._shallHighlightMatch_RK
    getQuickPlayScore = Game._getSpiderQuickPlayScore


# ************************************************************************
# * Big Deal
# ************************************************************************

class BigDeal(DoubleKlondike):
    RowStack_Class = KingAC_RowStack

    def createGame(self, rows=12, max_rounds=2, XOFFSET=0):
        l, s = Layout(self), self.s
        self.setSize(l.XM+(rows+2)*l.XS, l.YM+8*l.YS)
        x, y = l.XM, l.YM
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += l.XS
        for i in range(2):
            y = l.YM
            for j in range(8):
                s.foundations.append(
                    SS_FoundationStack(x, y, self, suit=j % 4))
                y += l.YS
            x += l.XS
        x, y = l.XM, self.height-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=max_rounds)
        l.createText(s.talon, 'n')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        s.waste.CARD_XOFFSET = XOFFSET
        l.createText(s.waste, 'n')
        if max_rounds > 1:
            l.createRoundText(s.talon, 'nnn')
        self.setRegion(s.rows, (-999, -999, l.XM+rows*l.XS-l.CW//2, 999999),
                       priority=1)
        l.defaultStackGroups()


# ************************************************************************
# * Delivery
# ************************************************************************

class Delivery(BigDeal):
    Hint_Class = CautiousDefaultHint
    RowStack_Class = StackWrapper(SS_RowStack, max_move=1)

    def createGame(self):
        dx = self.app.images.CARDW//10
        BigDeal.createGame(self, rows=12, max_rounds=1, XOFFSET=dx)

    shallHighlightMatch = Game._shallHighlightMatch_SS

    def startGame(self):
        self._startDealNumRows(2)
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack


# ************************************************************************
# * Double Kingsley
# ************************************************************************

class DoubleKingsley(DoubleKlondike):
    Foundation_Class = StackWrapper(SS_FoundationStack, base_rank=KING, dir=-1)
    RowStack_Class = StackWrapper(KingAC_RowStack, base_rank=ACE, dir=1)

    def createGame(self):
        DoubleKlondike.createGame(self, max_rounds=1)


# ************************************************************************
# * Thieves of Egypt
# ************************************************************************

class ThievesOfEgypt(DoubleKlondike):
    Layout_Method = staticmethod(Layout.klondikeLayout)

    def createGame(self):
        DoubleKlondike.createGame(self, rows=10, max_rounds=2)

    def startGame(self):
        # rows: 1 3 5 7 9 10 8 6 4 2
        row = 0
        for i in (0, 2, 4, 6, 8, 9, 7, 5, 3, 1):
            for j in range(i):
                self.s.talon.dealRow(rows=[self.s.rows[row]], frames=0)
            row += 1
        self._startAndDealRowAndCards()


# ************************************************************************
# * Brush
# ************************************************************************

class Brush(DoubleKlondike):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Foundation_Class = Spider_SS_Foundation
    RowStack_Class = Spider_RowStack
    Hint_Class = Spider_Hint

    def createGame(self):
        DoubleKlondike.createGame(self, rows=10, max_rounds=1)

    def startGame(self):
        self._startDealNumRows(3)
        self.s.talon.dealRow()
        self.s.talon.dealCards()        # deal first card to WasteStack

    shallHighlightMatch = Game._shallHighlightMatch_RK
    getQuickPlayScore = Game._getSpiderQuickPlayScore


# register the game
registerGame(GameInfo(21, DoubleKlondike, "Double Klondike",
                      GI.GT_KLONDIKE, 2, -1, GI.SL_BALANCED))
registerGame(GameInfo(28, DoubleKlondikeByThrees, "Double Klondike by Threes",
                      GI.GT_KLONDIKE, 2, -1, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(25, Gargantua, "Gargantua",
                      GI.GT_KLONDIKE, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(15, BigHarp, "Big Harp",
                      GI.GT_KLONDIKE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(51, Steps, "Steps",
                      GI.GT_KLONDIKE, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(273, TripleKlondike, "Triple Klondike",
                      GI.GT_KLONDIKE, 3, -1, GI.SL_BALANCED))
registerGame(GameInfo(274, TripleKlondikeByThrees, "Triple Klondike by Threes",
                      GI.GT_KLONDIKE, 3, -1, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(495, LadyJane, "Lady Jane",
                      GI.GT_KLONDIKE, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(496, Inquisitor, "Inquisitor",
                      GI.GT_KLONDIKE, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(497, Arabella, "Arabella",
                      GI.GT_KLONDIKE, 3, 0, GI.SL_BALANCED))
registerGame(GameInfo(545, BigDeal, "Big Deal",
                      GI.GT_KLONDIKE | GI.GT_ORIGINAL, 4, 1, GI.SL_BALANCED))
registerGame(GameInfo(562, Delivery, "Delivery",
                      GI.GT_FORTY_THIEVES | GI.GT_ORIGINAL, 4, 0,
                      GI.SL_BALANCED))
registerGame(GameInfo(590, ChineseKlondike, "Chinese Klondike",
                      GI.GT_KLONDIKE, 3, -1, GI.SL_BALANCED,
                      suits=(0, 1, 2)))
registerGame(GameInfo(591, Pantagruel, "Pantagruel",
                      GI.GT_KLONDIKE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(668, DoubleKingsley, "Double Kingsley",
                      GI.GT_KLONDIKE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(678, ThievesOfEgypt, "Thieves of Egypt",
                      GI.GT_KLONDIKE, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(689, Brush, "Brush",
                      GI.GT_2DECK_TYPE | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import AbstractHint
from pysollib.layout import Layout
from pysollib.stack import \
        InvisibleStack, \
        ReserveStack, \
        WasteStack, \
        WasteTalonStack


class PasDeDeux_Hint(AbstractHint):
    # FIXME: this is very simple

    def getDistance(self, stack, card):
        d = 0
        if card.rank != stack.id % 13:
            d = d + 1
        if card.suit != stack.id // 13:
            d = d + 1
        return d

    def computeHints(self):
        # find the single stack that can currently move a card
        rows = []
        for r in self.game.s.rows:
            if r.canMoveCards(r.cards):
                rows.append(r)
                break
        # for each stack
        for r in rows:
            r1_d = self.getDistance(r, r.cards[-1])
            column, row = r.id % 13, r.id // 13
            stack_ids = list(range(column, 52, 13)) + \
                list(range(13*row, 13*row+13))
            for i in stack_ids:
                t = self.game.s.rows[i]
                if t is r:
                    continue
                assert t.acceptsCards(r, r.cards)
                t1_d = self.getDistance(t, t.cards[-1])
                # compute distances after swap
                r2_d = self.getDistance(t, r.cards[-1])
                t2_d = self.getDistance(r, t.cards[-1])
                #
                rw, tw = 3, 2
                if self.game.s.talon.round >= 2:
                    rw, tw = 4, 2
                c = self.game.cards[t.cards[-1].id - 52]
                if 1 and c in self.game.s.waste.cards:
                    rw = rw - 1
                #
                score = int(((rw*r1_d + tw*t1_d) - (rw*r2_d + tw*t2_d)) * 1000)
                if score > 0:
                    self.addHint(score, 1, r, t)


# ************************************************************************
# * Pas de Deux
# ************************************************************************

class PasDeDeux_Waste(WasteStack):
    def canFlipCard(self):
        return False


class PasDeDeux_RowStack(ReserveStack):
    def canMoveCards(self, cards):
        if not ReserveStack.canMoveCards(self, cards):
            return False
        if not self.game.s.waste.cards:
            return False
        c = self.game.s.waste.cards[-1]
        return c.face_up and cards[0].suit == c.suit and \
            cards[0].rank == c.rank

    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        # must be neighbours
        return self.game.isNeighbour(from_stack, self)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        assert ncards == 1 and to_stack in self.game.s.rows
        assert len(to_stack.cards) == 1
        self._swapPairMove(ncards, to_stack, frames=-1, shadow=0)
        if self.game.s.talon.canDealCards():
            self.game.s.talon.dealCards()
        else:
            # mark game as finished by turning the Waste face down
            assert self.game.s.waste.cards[-1].face_up
            self.game.flipMove(self.game.s.waste)

    def _swapPairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        old_state = game.enterState(game.S_FILL)
        swap = game.s.internals[0]
        game.moveMove(n, self, swap, frames=0)
        game.moveMove(n, other_stack, self, frames=frames, shadow=shadow)
        game.moveMove(n, swap, other_stack, frames=0)
        game.leaveState(old_state)

    def getBottomImage(self):
        suit = self.id // 13
        return self.game.app.images.getSuitBottom(suit)

    def quickPlayHandler(self, event, from_stacks=None, to_stacks=None):
        # find the single stack that can currently move a card
        for r in self.game.s.rows:
            if r.canMoveCards(r.cards):
                if self.acceptsCards(r, r.cards):
                    r.playMoveMove(len(r.cards), self)
                    return 1
                break
        return 0


class PasDeDeux(Game):
    Hint_Class = PasDeDeux_Hint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self, card_x_space=4), self.s

        # set window
        self.setSize(l.XM + 13*l.XS, l.YM + 5*l.YS)

        # create stacks
        for i in range(4):
            for j in range(13):
                x, y, = l.XM + j*l.XS, l.YM + i*l.YS
                s.rows.append(
                    PasDeDeux_RowStack(x, y, self, max_accept=1, max_cards=2))
        x, y = self.width - 2*l.XS, self.height - l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=2)
        l.createText(s.talon, "se")
        l.createRoundText(s.talon, 'ne')
        x -= l.XS
        s.waste = PasDeDeux_Waste(x, y, self, max_move=0)
        l.createText(s.waste, "sw")
        s.internals.append(InvisibleStack(self))    # for _swapPairMove()

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def shuffle(self):
        self.shuffleSeparateDecks()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(frames=4)
        self.s.talon.dealCards()          # deal first card to WasteStack

    def getAutoStacks(self, event=None):
        return ((), (), (self.sg.dropstacks))

    def isGameWon(self):
        for r in self.s.rows:
            if len(r.cards) != 1:
                return False
            c = r.cards[-1]
            if c.suit != r.id // 13 or c.rank != r.id % 13:
                return False
        return True

    #
    # game extras
    #

    def isNeighbour(self, stack1, stack2):
        column1, row1 = stack1.id % 13, stack1.id // 13
        column2, row2 = stack2.id % 13, stack2.id // 13
        return column1 == column2 or row1 == row2

    def getHighlightPilesStacks(self):
        # Pas de Deux special: highlight all moveable cards
        return ((self.s.rows, 1),)


# register the game
registerGame(GameInfo(153, PasDeDeux, "Pas de Deux",
                      GI.GT_MONTANA | GI.GT_SEPARATE_DECKS, 2, 1,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.canfield import Canfield_Hint
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AC_RowStack, \
        AbstractFoundationStack, \
        OpenStack, \
        RedealTalonStack, \
        SS_RowStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ANY_RANK, RANKS

# ************************************************************************
# * Glenwood
# ************************************************************************


class Glenwood_Talon(WasteTalonStack):
    def canDealCards(self):
        if self.game.base_rank is None:
            return False
        return WasteTalonStack.canDealCards(self)


class Glenwood_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if self.game.base_rank is None:
            return True
        if not self.cards:
            return cards[-1].rank == self.game.base_rank
        # check the rank
        return (self.cards[-1].rank + self.cap.dir) % \
            self.cap.mod == cards[0].rank


class Glenwood_RowStack(AC_RowStack):
    def canMoveCards(self, cards):
        if self.game.base_rank is None:
            return False
        if not AC_RowStack.canMoveCards(self, cards):
            return False
        if len(cards) == 1 or len(self.cards) == len(cards):
            return True
        return False

    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards and from_stack is self.game.s.waste:
            for stack in self.game.s.reserves:
                if stack.cards:
                    return False
            return True
        if from_stack in self.game.s.rows and \
                len(cards) != len(from_stack.cards):
            return False
        return True


class Glenwood_ReserveStack(OpenStack):
    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        OpenStack.moveMove(self, ncards, to_stack, frames, shadow)
        if self.game.base_rank is None and to_stack in self.game.s.foundations:
            old_state = self.game.enterState(self.game.S_FILL)
            self.game.saveStateMove(2 | 16)            # for undo
            self.game.base_rank = to_stack.cards[-1].rank
            self.game.saveStateMove(1 | 16)            # for redo
            self.game.leaveState(old_state)


class Glenwood(Game):

    Foundation_Class = Glenwood_Foundation
    RowStack_Class = Glenwood_RowStack
    ReserveStack_Class = Glenwood_ReserveStack
    Hint_Class = Canfield_Hint

    base_rank = None

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 7*l.XS, l.YM + l.TEXT_HEIGHT + 5*l.YS)

        # create stacks
        x, y = l.XM, l.YM
        s.talon = Glenwood_Talon(x, y, self, max_rounds=2, num_deal=1)
        l.createText(s.talon, "s")
        l.createRoundText(s.talon, 'ne', dx=l.XS)
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")
        x += 2*l.XS
        for i in range(4):
            s.foundations.append(self.Foundation_Class(x, y, self, i, dir=1,
                                 mod=13, base_rank=ANY_RANK, max_move=0))
            x += l.XS

        tx, ty, ta, tf = l.getTextAttr(None, "ss")
        tx, ty = x - l.XS + tx, y + ty
        font = self.app.getFont("canvas_default")
        self.texts.info = MfxCanvasText(self.canvas, tx, ty,
                                        anchor=ta, font=font)

        for i in range(4):
            x = l.XM + (i+3)*l.XS
            y = l.YM+l.TEXT_HEIGHT+l.YS
            s.rows.append(self.RowStack_Class(x, y, self, mod=13))
        for i in range(4):
            x = l.XM
            y = l.YM+l.TEXT_HEIGHT+(i+1)*l.YS
            stack = self.ReserveStack_Class(x, y, self)
            s.reserves.append(stack)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.base_rank = None
        for i in range(3):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self._startAndDealRow()

    #
    # game extras
    #

    def updateText(self):
        if self.preview > 1:
            return
        if self.base_rank is None:
            t = ""
        else:
            t = RANKS[self.base_rank]
        self.texts.info.config(text=t)

    shallHighlightMatch = Game._shallHighlightMatch_ACW

    def _restoreGameHook(self, game):
        self.base_rank = game.loadinfo.base_rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_rank=p.load())

    def _saveGameHook(self, p):
        p.dump(self.base_rank)

    def setState(self, state):
        # restore saved vars (from undo/redo)
        self.base_rank = state[0]

    def getState(self):
        # save vars (for undo/redo)
        return [self.base_rank]


# ************************************************************************
# * Double Fives
# ************************************************************************

class DoubleFives_Talon(RedealTalonStack):

    def moveToStock(self):
        stock = self.game.s.stock
        for r in self.game.s.reserves[:5]:
            if r.cards:
                r.moveMove(1, stock)
                stock.flipMove()

    def canDealCards(self):
        if self.game.base_rank is None:
            return False
        if self.round == self.max_rounds:
            return len(self.cards) != 0
        return not self.game.isGameWon()

    def dealCards(self, sound=False):
        old_state = self.game.enterState(self.game.S_DEAL)
        num_cards = 0
        if self.round == 1:
            if sound:
                self.game.startDealSample()
            self.moveToStock()
            if not self.cards:
                num_cards += self.redealCards(rows=[self.game.s.stock],
                                              frames=4, sound=False)
            else:
                num_cards += self.dealRowAvail(rows=self.game.s.reserves[:5],
                                               sound=False)
            if sound:
                self.game.stopSamples()
        else:
            if sound and not self.game.demo:
                self.game.playSample("dealwaste")
            self.game.flipMove(self)
            self.game.moveMove(1, self, self.game.s.reserves[0],
                               frames=4, shadow=0)
            num_cards += 1
        self.game.leaveState(old_state)
        return num_cards


class DoubleFives_RowStack(SS_RowStack):
    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        SS_RowStack.moveMove(self, ncards, to_stack, frames, shadow)
        if self.game.base_rank is None and to_stack in self.game.s.foundations:
            old_state = self.game.enterState(self.game.S_FILL)
            self.game.saveStateMove(2 | 16)            # for undo
            self.game.base_rank = to_stack.cards[-1].rank
            self.game.saveStateMove(1 | 16)            # for redo
            self.game.leaveState(old_state)


class DoubleFives_WasteStack(WasteStack):
    def updateText(self):
        if self.game.s.talon.round == 2:
            WasteStack.updateText(self)
        elif self.texts.ncards:
            self.texts.ncards.config(text='')


class DoubleFives_Stock(WasteStack):
    def canFlipCard(self):
        return False

    def updateText(self):
        if self.cards:
            WasteStack.updateText(self)
        elif self.texts.ncards is not None:
            # self.texts.ncards is None in playable preview
            self.texts.ncards.config(text='')


class DoubleFives(Glenwood):
    Hint_Class = CautiousDefaultHint

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+11*l.XS, l.YM+3*l.YS+16*l.YOFFSET)

        # create stacks
        #
        x, y = l.XM, self.height-l.YS
        s.talon = DoubleFives_Talon(x, y, self, max_rounds=2, num_deal=1)
        l.createText(s.talon, "n")
        l.createRoundText(self.s.talon, 'nnn')
        x += l.XS
        for i in range(5):
            s.reserves.append(DoubleFives_WasteStack(x, y, self))
            x += l.XS
        l.createText(s.reserves[0], 'n')
        #
        x = self.width-l.XS
        s.addattr(stock=None)      # register extra stack variable
        s.stock = DoubleFives_Stock(x, y, self)
        l.createText(s.stock, "n")
        #
        x, y = l.XM, l.YM
        s.reserves.append(Glenwood_ReserveStack(x, y, self))
        x += l.XS
        s.reserves.append(Glenwood_ReserveStack(x, y, self))
        #
        x += 2*l.XS
        for i in range(8):
            s.foundations.append(Glenwood_Foundation(x, y, self, suit=i//2,
                                 mod=13, base_rank=ANY_RANK, max_move=0))
            x += l.XS
        tx, ty, ta, tf = l.getTextAttr(None, "ss")
        tx, ty = x - l.XS + tx, y + ty
        font = self.app.getFont("canvas_default")
        self.texts.info = MfxCanvasText(self.canvas, tx, ty,
                                        anchor=ta, font=font)
        x, y = l.XM+l.XS//2, l.YM+l.YS+l.TEXT_HEIGHT
        for i in range(10):
            s.rows.append(DoubleFives_RowStack(x, y, self, mod=13, max_move=1))
            x += l.XS

        # define stack-groups
        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(cards,
                                          lambda c: (c.deck == 0, None))

    def startGame(self):
        self.base_rank = None
        self._startDealNumRows(4)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves[-2:])

    def _autoDeal(self, sound=True):
        waste_cards = 0
        for r in self.s.reserves[:5]:
            waste_cards += len(r.cards)
        if waste_cards == 0 and self.canDealCards():
            return self.dealCards(sound=sound)
        return 0

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# register the game
registerGame(GameInfo(282, Glenwood, "Dutchess",
                      GI.GT_CANFIELD, 1, 1, GI.SL_BALANCED,
                      altnames=("Duchess", "Glenwood",)))
registerGame(GameInfo(587, DoubleFives, "Double Fives",
                      GI.GT_2DECK_TYPE, 2, 1, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import DefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        AbstractFoundationStack, \
        BasicRowStack, \
        DealRowRedealTalonStack, \
        InitialDealTalonStack, \
        OpenStack, \
        ReserveStack, \
        SS_FoundationStack, \
        StackWrapper, \
        TalonStack
from pysollib.util import ANY_RANK, ANY_SUIT, KING, NO_RANK, UNLIMITED_REDEALS

# ************************************************************************
# *
# ************************************************************************


class MonteCarlo_Hint(DefaultHint):
    # FIXME: demo is not too clever in this game
    pass


# ************************************************************************
# * Monte Carlo
# * Monte Carlo (2 decks)
# ************************************************************************

class MonteCarlo_Talon(TalonStack):
    def canDealCards(self):
        free = 0
        for r in self.game.s.rows:
            if not r.cards:
                free = 1
            elif free:
                return True
        return free and len(self.cards)

    def dealCards(self, sound=False):
        self.game.updateStackMove(self.game.s.talon, 2 | 16)  # for undo
        n = self.game.fillEmptyStacks()
        self.game.updateStackMove(self.game.s.talon, 1 | 16)  # for redo
        return n


class MonteCarlo_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return False
        # check the rank
        if self.cards[-1].rank != cards[0].rank:
            return False
        # now look if the stacks are neighbours
        return self.game.isNeighbour(from_stack, self)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        assert ncards == 1 and to_stack in self.game.s.rows
        if to_stack.cards:
            self._dropPairMove(ncards, to_stack, frames=-1, shadow=shadow)
        else:
            BasicRowStack.moveMove(
                self, ncards, to_stack, frames=frames, shadow=shadow)

    def _dropPairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        old_state = game.enterState(game.S_FILL)
        f = game.s.foundations[0]
        game.updateStackMove(game.s.talon, 2 | 16)            # for undo
        if not game.demo:
            game.playSample("droppair", priority=200)
        game.moveMove(n, self, f, frames=frames, shadow=shadow)
        game.moveMove(n, other_stack, f, frames=frames, shadow=shadow)
        self.fillStack()
        other_stack.fillStack()
        if self.game.FILL_STACKS_AFTER_DROP:
            game.fillEmptyStacks()
        game.updateStackMove(game.s.talon, 1 | 16)            # for redo
        game.leaveState(old_state)


class MonteCarlo(Game):
    Talon_Class = MonteCarlo_Talon
    Foundation_Class = StackWrapper(
        AbstractFoundationStack, max_accept=0)
    RowStack_Class = MonteCarlo_RowStack
    Hint_Class = MonteCarlo_Hint

    FILL_STACKS_AFTER_DROP = False

    #
    # game layout
    #

    def createGame(self, rows=5, cols=5):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + (cols+1.5)*l.XS, l.YM + rows*l.YS)

        # create stacks
        for i in range(rows):
            for j in range(cols):
                x, y = l.XM + j*l.XS, l.YM + i*l.YS
                s.rows.append(self.RowStack_Class(x, y, self,
                                                  max_accept=1, max_cards=2,
                                                  dir=0, base_rank=NO_RANK))
        x, y = self.width - l.XS, l.YM
        s.foundations.append(self.Foundation_Class(x, y, self, suit=ANY_SUIT,
                             max_move=0, base_rank=ANY_RANK,
                             max_cards=self.gameinfo.ncards))
        l.createText(s.foundations[0], "s")
        y += 2*l.YS
        s.talon = self.Talon_Class(x, y, self, max_rounds=1)
        l.createText(s.talon, "s", text_format="%D")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self._startAndDealRow()

    def getAutoStacks(self, event=None):
        return ((), (), self.sg.dropstacks)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank == card2.rank

    #
    # game extras
    #

    def isNeighbour(self, stack1, stack2):
        if not (0 <= stack1.id <= 24 and 0 <= stack2.id <= 24):
            return False
        column = stack2.id % 5
        diff = stack1.id - stack2.id
        if column == 0:
            return diff in (-5, -4, 1, 5, 6)
        elif column == 4:
            return diff in (-6, -5, -1, 4, 5)
        else:
            return diff in (-6, -5, -4, -1, 1, 4, 5, 6)

    def fillEmptyStacks(self):
        free, n = 0, 0
        self.startDealSample()
        for r in self.s.rows:
            assert len(r.cards) <= 1
            if not r.cards:
                free += 1
            elif free > 0:
                to_stack = self.allstacks[r.id - free]
                self.moveMove(1, r, to_stack, frames=4, shadow=0)
        if free > 0:
            for r in self.s.rows:
                if not r.cards:
                    if not self.s.talon.cards:
                        break
                    self.flipMove(self.s.talon)
                    self.moveMove(1, self.s.talon, r)
                    n += 1
        self.stopSamples()
        return n + free


class MonteCarlo2Decks(MonteCarlo):
    pass


# ************************************************************************
# * Weddings
# ************************************************************************

class Weddings_Talon(MonteCarlo_Talon):
    def canDealCards(self):
        free = 0
        for r in self.game.s.rows:
            if not r.cards:
                free = 1
            else:
                k = r.id
                while k >= 5 and not self.game.allstacks[k - 5].cards:
                    k = k - 5
                if k != r.id:
                    return True
        return free and len(self.cards)


class Weddings(MonteCarlo):
    Talon_Class = Weddings_Talon

    def fillEmptyStacks(self):
        free, n = 0, 0
        self.startDealSample()
        for r in self.s.rows:
            assert len(r.cards) <= 1
            if not r.cards:
                free = free + 1
            else:
                k = r.id
                while k >= 5 and not self.allstacks[k - 5].cards:
                    k = k - 5
                if k != r.id:
                    to_stack = self.allstacks[k]
                    self.moveMove(1, r, to_stack, frames=4, shadow=0)
        if free > 0:
            for r in self.s.rows:
                if not r.cards:
                    if not self.s.talon.cards:
                        break
                    self.flipMove(self.s.talon)
                    self.moveMove(1, self.s.talon, r)
                    n = n + 1
        self.stopSamples()
        return n


# ************************************************************************
# * Simple Carlo (Monte Carlo for Children, stacks do not
# * have to be neighbours)
# ************************************************************************

class SimpleCarlo(MonteCarlo):
    FILL_STACKS_AFTER_DROP = True

    def getAutoStacks(self, event=None):
        return ((), (), ())

    def isNeighbour(self, stack1, stack2):
        return 0 <= stack1.id <= 24 and 0 <= stack2.id <= 24


# ************************************************************************
# * Simple Pairs
# ************************************************************************

class SimplePairs(MonteCarlo):
    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 6*l.XS, l.YM + 4*l.YS)

        # create stacks
        for i in range(3):
            for j in range(3):
                x, y = l.XM + (2*j+3)*l.XS//2, l.YM + (2*i+1)*l.YS//2
                s.rows.append(self.RowStack_Class(x, y, self,
                                                  max_accept=1, max_cards=2,
                                                  dir=0, base_rank=NO_RANK))
        x, y = l.XM, l.YM + 3*l.YS//2
        s.talon = TalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "s")
        x = x + 5*l.XS
        s.foundations.append(self.Foundation_Class(x, y, self, suit=ANY_SUIT,
                             max_move=0, max_cards=52, base_rank=ANY_RANK))
        l.createText(s.foundations[0], "s")

        # define stack-groups
        l.defaultStackGroups()

    def fillStack(self, stack):
        if stack in self.s.rows:
            if len(stack.cards) == 0 and len(self.s.talon.cards) > 0:
                self.flipMove(self.s.talon)
                self.moveMove(1, self.s.talon, stack)

    def isNeighbour(self, stack1, stack2):
        return 0 <= stack1.id <= 15 and 0 <= stack2.id <= 15


# ************************************************************************
# * Neighbour
# ************************************************************************

class Neighbour_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # We accept any King. Pairs will get delivered by _dropPairMove.
        return cards[0].rank == KING


class Neighbour_RowStack(MonteCarlo_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return False
        # check the rank
        if self.cards[-1].rank + cards[0].rank != 11:
            return False
        # now look if the stacks are neighbours
        return self.game.isNeighbour(from_stack, self)

    def clickHandler(self, event):
        if self._dropKingClickHandler(event):
            return 1
        return MonteCarlo_RowStack.clickHandler(self, event)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        assert ncards == 1
        if self.cards[-1].rank == KING:
            assert to_stack in self.game.s.foundations
            BasicRowStack.moveMove(
                self, ncards, to_stack, frames=frames, shadow=shadow)
        else:
            MonteCarlo_RowStack.moveMove(
                self, ncards, to_stack, frames=frames, shadow=shadow)

    def _dropKingClickHandler(self, event):
        if not self.cards:
            return 0
        c = self.cards[-1]
        if c.face_up and c.rank == KING and not self.basicIsBlocked():
            self.game.playSample("autodrop", priority=20)
            self.playMoveMove(1, self.game.s.foundations[0], sound=False)
            return 1
        return 0

    def fillStack(self):
        if not self.cards and self.game.s.talon.canDealCards():
            old_state = self.game.enterState(self.game.S_FILL)
            self.game.s.talon.dealCards()
            self.game.leaveState(old_state)


class Neighbour(MonteCarlo):
    Foundation_Class = Neighbour_Foundation
    RowStack_Class = Neighbour_RowStack

    FILL_STACKS_AFTER_DROP = True

    def getAutoStacks(self, event=None):
        return ((), self.sg.dropstacks, ())

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank + card2.rank == 11


# ************************************************************************
# * Fourteen
# ************************************************************************

class Fourteen_RowStack(MonteCarlo_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return False
        # check the rank
        return self.cards[-1].rank + cards[0].rank == 12


class Fourteen(Game):
    Foundation_Class = StackWrapper(AbstractFoundationStack, max_accept=0)
    RowStack_Class = Fourteen_RowStack

    FILL_STACKS_AFTER_DROP = False

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 7*l.XS, l.YM + 5*l.YS)

        # create stacks
        for i in (0, 2.5):
            for j in range(6):
                x, y = l.XM + j*l.XS, l.YM + i*l.YS
                s.rows.append(self.RowStack_Class(x, y, self,
                                                  max_move=1, max_accept=1,
                                                  dir=0, base_rank=NO_RANK))
        x, y = l.XM + 6*l.XS, l.YM
        s.foundations.append(self.Foundation_Class(x, y, self, suit=ANY_SUIT,
                             max_move=0, max_cards=52, base_rank=ANY_RANK))
        l.createText(s.foundations[0], "s")
        x, y = self.width - l.XS, self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(3)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.rows[:4])

    def getAutoStacks(self, event=None):
        return ((), (), self.sg.dropstacks)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank + card2.rank == 12


# ************************************************************************
# * Nestor
# ************************************************************************

class Nestor_RowStack(MonteCarlo_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return False
        # check the rank
        return self.cards[-1].rank == cards[0].rank


class Nestor(Game):
    Foundation_Class = StackWrapper(AbstractFoundationStack, max_accept=0)
    RowStack_Class = Nestor_RowStack

    FILL_STACKS_AFTER_DROP = False

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+8*l.XS, l.YM+2*l.YS+12*l.YOFFSET)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(8):
            s.rows.append(self.RowStack_Class(x, y, self,
                                              max_move=1, max_accept=1,
                                              dir=0, base_rank=NO_RANK))
            x += l.XS
        x, y = l.XM+2*l.XS, self.height-l.YS
        for i in range(4):
            s.rows.append(self.RowStack_Class(x, y, self,
                                              max_move=1, max_accept=1,
                                              dir=0, base_rank=NO_RANK))
            x += l.XS
        x, y = self.width-l.XS, self.height-l.YS
        s.foundations.append(self.Foundation_Class(x, y, self, suit=ANY_SUIT,
                             max_move=0, max_cards=52, base_rank=ANY_RANK))
        l.createText(s.foundations[0], "n")
        x, y = l.XM, self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _checkRow(self, cards):
        for i in range(len(cards)):
            for j in range(i):
                if cards[i].rank == cards[j].rank:
                    return j
        return -1

    def _shuffleHook(self, cards):
        # no row will have two cards of the same rank
        for i in range(8):
            for t in range(1000):  # just in case
                j = self._checkRow(cards[i*6:(i+1)*6])
                if j < 0:
                    break
                j += i*6
                k = self.random.choice(list(range((i+1)*6, 52)))
                cards[j], cards[k] = cards[k], cards[j]
        cards.reverse()
        return cards

    def startGame(self):
        for r in self.s.rows[:8]:
            for j in range(6):
                self.s.talon.dealRow(rows=[r], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[8:])

    def getAutoStacks(self, event=None):
        return ((), (), self.sg.dropstacks)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank == card2.rank


# ************************************************************************
# * Vertical
# ************************************************************************

class Vertical(Nestor):

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+9*l.XS, l.YM+2*l.YS+12*l.YOFFSET)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(7):
            s.rows.append(self.RowStack_Class(x, y, self,
                                              max_move=1, max_accept=1,
                                              dir=0, base_rank=NO_RANK))
            x += l.XS
        x, y = l.XM, self.height-l.YS
        for i in range(9):
            s.rows.append(self.RowStack_Class(x, y, self,
                                              max_move=1, max_accept=1,
                                              dir=0, base_rank=NO_RANK))
            x += l.XS
        x, y = self.width-l.XS, l.YM
        s.foundations.append(self.Foundation_Class(x, y, self, suit=ANY_SUIT,
                             max_move=0, max_cards=52, base_rank=ANY_RANK))
        l.createText(s.foundations[0], "s")
        x -= l.XS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.s.talon.dealRow(frames=0)
        for i in range(4):
            self.s.talon.dealRow(rows=self.s.rows[:7], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:7])
        self.s.talon.dealRow(rows=[self.s.rows[3]])


# ************************************************************************
# * The Wish
# ************************************************************************

class TheWish(Game):

    FILL_STACKS_AFTER_DROP = False

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+6*l.XS, 2*l.YM+2*l.YS+6*l.YOFFSET)

        # create stacks
        for i in range(2):
            for j in range(4):
                x, y = l.XM + j*l.XS, l.YM+i*(l.YM+l.YS+3*l.YOFFSET)
                s.rows.append(Nestor_RowStack(x, y, self,
                                              max_move=1, max_accept=1,
                                              dir=0, base_rank=NO_RANK))

        x, y = self.width - l.XS, l.YM
        s.talon = InitialDealTalonStack(x, y, self)

        x, y = self.width - l.XS, self.height - l.YS
        s.foundations.append(
            AbstractFoundationStack(
                x, y, self, suit=ANY_SUIT,
                max_move=0, max_cards=32, max_accept=0, base_rank=ANY_RANK))
        l.createText(s.foundations[0], "n")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        for i in range(3):
            self.s.talon.dealRow(flip=0, frames=0)
        self._startAndDealRow()

    def fillStack(self, stack):
        if stack.cards:
            self.flipMove(stack)

    def getAutoStacks(self, event=None):
        return ((), (), self.sg.dropstacks)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank == card2.rank


class TheWishOpen(TheWish):
    def fillStack(self, stack):
        pass

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(3)

# ************************************************************************
# * Der letzte Monarch (The last Monarch)
# ************************************************************************


class DerLetzteMonarch_Foundation(SS_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if cards is None:
            # special hack for _getDropStack() below
            return SS_FoundationStack.acceptsCards(
                self, from_stack, from_stack.cards)
        #
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        # We only accept cards from a Reserve. Other cards will get
        # delivered by _handlePairMove.
        return from_stack in self.game.s.reserves


class DerLetzteMonarch_RowStack(ReserveStack):
    def canDropCards(self, stacks):
        return (None, 0)

    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        # must be neighbours
        if not self.game.isNeighbour(from_stack, self):
            return False
        # must be able to move our card to the foundations or reserves
        return self._getDropStack() is not None

    def _getDropStack(self):
        if len(self.cards) != 1:
            return None
        for s in self.game.s.foundations:
            if s.acceptsCards(self, None):      # special hack
                return s
        for s in self.game.s.reserves:
            if not s.cards:
                return s
        return None

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        assert ncards == 1 and to_stack in self.game.s.rows
        assert len(to_stack.cards) == 1
        self._handlePairMove(ncards, to_stack, frames=-1, shadow=0)
        self.fillStack()

    def _handlePairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        old_state = game.enterState(game.S_FILL)
        s = other_stack._getDropStack()
        assert s is not None
        game.moveMove(n, other_stack, s, frames=frames, shadow=shadow)
        game.moveMove(n, self, other_stack, frames=0)
        game.leaveState(old_state)


class DerLetzteMonarch_ReserveStack(ReserveStack):
    def clickHandler(self, event):
        return self.doubleclickHandler(event)


class DerLetzteMonarch(Game):
    Talon_Class = InitialDealTalonStack

    #
    # game layout
    #

    def createGame(self, texts=False):
        # create layout
        l, s = Layout(self, card_x_space=4), self.s

        # set window
        decks = self.gameinfo.decks
        if decks == 1:
            w = l.XM + 13*l.XS
            dx = 0
        else:
            w = l.XM + 15*l.XS
            dx = l.XS
        h = l.YM + 5*l.YS
        self.setSize(w, h)

        # create stacks
        for i in range(4):
            for j in range(13):
                x, y, = dx + l.XM + j*l.XS, l.YM + (i+1)*l.YS
                s.rows.append(
                    DerLetzteMonarch_RowStack(
                        x, y, self, max_accept=1, max_cards=2))
        for i in range(4):
            x, y, = l.XM + (i+2)*l.XS, l.YM
            s.reserves.append(
                DerLetzteMonarch_ReserveStack(
                    x, y, self, max_accept=0))
        for i in range(4*decks):
            x, y, = l.XM + (i+7)*l.XS, l.YM
            s.foundations.append(DerLetzteMonarch_Foundation(x, y, self,
                                 suit=i % 4, max_move=0))
        s.talon = self.Talon_Class(l.XM, l.YM, self)
        if texts:
            l.createText(s.talon, 'ne')

        # define stack-groups (non default)
        self.sg.talonstacks = [s.talon]
        self.sg.openstacks = s.foundations + s.rows
        self.sg.dropstacks = s.rows + s.reserves
        self.sg.reservestacks = s.reserves

    #
    # game overrides
    #

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.rows[:39], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[39:])

    def isGameWon(self):
        c = 0
        for s in self.s.foundations:
            c = c + len(s.cards)
        return c == self.gameinfo.ncards-1

    def getAutoStacks(self, event=None):
        return ((), self.s.reserves, ())

    def getDemoInfoText(self):
        return "Der letzte\nMonarch"

    #
    # game extras
    #

    def isNeighbour(self, stack1, stack2):
        if not (0 <= stack1.id <= 51 and 0 <= stack2.id <= 51):
            return False
        column = stack2.id % 13
        diff = stack1.id - stack2.id
        if column == 0:
            return diff in (-13, 1, 13)
        elif column == 12:
            return diff in (-13, -1, 13)
        else:
            return diff in (-13, -1, 1, 13)


class TheLastMonarchII(DerLetzteMonarch):
    Talon_Class = TalonStack

    def createGame(self):
        DerLetzteMonarch.createGame(self, texts=True)

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            if self.s.talon.cards:
                old_state = self.enterState(self.S_FILL)
                self.s.talon.flipMove()
                self.s.talon.moveMove(1, stack)
                self.leaveState(old_state)


# ************************************************************************
# * Doublets
# ************************************************************************

class DoubletsII(Game):
    FILL_STACKS_AFTER_DROP = False  # for Nestor_RowStack

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+12*l.XS, l.YM+3*l.YS+3*l.YOFFSET)

        x, y = l.XM, l.YM
        for i in range(12):
            s.rows.append(Nestor_RowStack(x, y, self,
                                          max_move=1, max_accept=1,
                                          dir=0, base_rank=NO_RANK))
            x += l.XS
        x, y = l.XM, self.height-l.YS
        s.talon = TalonStack(x, y, self)
        l.createText(s.talon, 'n')

        x, y = self.width-l.XS, self.height-l.YS
        s.foundations.append(AbstractFoundationStack(x, y, self, suit=ANY_SUIT,
                             max_move=0, max_cards=52,
                             base_rank=ANY_RANK, max_accept=0))
        l.createText(s.foundations[0], "n")

        l.defaultStackGroups()

    def startGame(self):
        for i in range(3):
            self.s.talon.dealRow(frames=0, flip=0)
        self._startAndDealRow()

    def fillStack(self, stack):
        if stack in self.s.rows:
            if stack.cards:
                stack.flipMove(animation=True)
            else:
                if self.s.talon.cards:
                    old_state = self.enterState(self.S_FILL)
                    self.s.talon.flipMove()
                    self.s.talon.moveMove(1, stack)
                    self.leaveState(old_state)


# ************************************************************************
# * Right and Left
# ************************************************************************

class RightAndLeft_Talon(DealRowRedealTalonStack):
    def _redeal(self, rows=None, reverse=False, frames=0):
        return DealRowRedealTalonStack._redeal(self, rows=rows,
                                               reverse=reverse, frames=3)


class RightAndLeft(Game):

    FILL_STACKS_AFTER_DROP = False

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+5*l.XS, l.YM+3*l.YS)

        # create stacks
        x, y = l.XM+l.XS, l.YM+2*l.YS
        s.talon = RightAndLeft_Talon(x, y, self, max_rounds=UNLIMITED_REDEALS)

        l.createText(s.talon, 'se')
        x, y = l.XM+0.5*l.XS, l.YM
        for i in range(2):
            stack = Nestor_RowStack(x, y, self, max_move=1, max_accept=1,
                                    dir=0, base_rank=NO_RANK)
            stack.CARD_YOFFSET = 0
            l.createText(stack, 's')
            s.rows.append(stack)
            x += l.XS

        x += 1.5*l.XS
        s.foundations.append(AbstractFoundationStack(x, y, self, suit=ANY_SUIT,
                             max_move=0, max_cards=104,
                             max_accept=0, base_rank=ANY_RANK))
        l.createText(s.foundations[0], 's')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startAndDealRow()


# register the game
registerGame(GameInfo(89, MonteCarlo, "Monte Carlo",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_MOSTLY_LUCK,
                      altnames=("Quilt",)))
registerGame(GameInfo(216, MonteCarlo2Decks, "Monte Carlo (2 decks)",
                      GI.GT_PAIRING_TYPE, 2, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(212, Weddings, "Weddings",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(90, SimpleCarlo, "Simple Carlo",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(91, SimplePairs, "Simple Pairs",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_LUCK,
                      altnames=("Jamestown",)))
registerGame(GameInfo(92, Neighbour, "Neighbour",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(96, Fourteen, "Fourteen",
                      GI.GT_PAIRING_TYPE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(235, Nestor, "Nestor",
                      GI.GT_PAIRING_TYPE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(152, DerLetzteMonarch, "The Last Monarch",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL,
                      altnames=("Der letzte Monarch",)))
registerGame(GameInfo(328, TheWish, "The Wish",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_MOSTLY_LUCK,
                      ranks=(0, 6, 7, 8, 9, 10, 11, 12)))
registerGame(GameInfo(329, TheWishOpen, "The Wish (open)",
                      GI.GT_PAIRING_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL,
                      ranks=(0, 6, 7, 8, 9, 10, 11, 12)))
registerGame(GameInfo(368, Vertical, "Vertical",
                      GI.GT_PAIRING_TYPE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(649, DoubletsII, "Doublets II",
                      GI.GT_PAIRING_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(663, TheLastMonarchII, "The Last Monarch II",
                      GI.GT_2DECK_TYPE | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(727, RightAndLeft, "Right and Left",
                      GI.GT_PAIRING_TYPE, 2, -1, GI.SL_LUCK))
from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import DefaultHint
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText, get_text_width
from pysollib.stack import \
        BasicRowStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        RK_FoundationStack, \
        Stack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ANY_SUIT, KING, RANKS


class Calculation_Hint(DefaultHint):
    # FIXME: demo logic is a complete nonsense
    def _getMoveWasteScore(self, score, color, r, t, pile, rpile):
        assert r is self.game.s.waste and len(pile) == 1
        score = 30000
        if len(t.cards) == 0:
            score = score - (KING - r.cards[0].rank) * 1000
        elif t.cards[-1].rank < r.cards[0].rank:
            score = 10000 + t.cards[-1].rank - len(t.cards)
        elif t.cards[-1].rank == r.cards[0].rank:
            score = 20000
        else:
            score = score - (t.cards[-1].rank - r.cards[0].rank) * 1000
        return score, color


# ************************************************************************
# *
# ************************************************************************

class BetsyRoss_Foundation(RK_FoundationStack):
    def updateText(self, update_empty=True):
        if self.game.preview > 1:
            return
        if self.texts.misc:
            if len(self.cards) == 0:
                if update_empty:
                    rank = self.cap.base_rank
                    self.texts.misc.config(text=RANKS[rank])
                else:
                    self.texts.misc.config(text="")
            elif len(self.cards) == self.cap.max_cards:
                self.texts.misc.config(text="")
            else:
                rank = (self.cards[-1].rank + self.cap.dir) % self.cap.mod
                self.texts.misc.config(text=RANKS[rank])


class Calculation_Foundation(BetsyRoss_Foundation):
    getBottomImage = Stack._getLetterImage


class Calculation_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        # this stack accepts any one card from the Waste pile
        return from_stack is self.game.s.waste and len(cards) == 1

    getBottomImage = Stack._getReserveBottomImage

    def getHelp(self):
        return _('Tableau. Build regardless of rank and suit.')


# ************************************************************************
# * Calculation
# ************************************************************************

class Calculation(Game):
    Hint_Class = Calculation_Hint
    Foundation_Class = Calculation_Foundation
    RowStack_Class = StackWrapper(
        Calculation_RowStack, max_move=1, max_accept=1)

    #
    # game layout
    #

    def _getHelpText(self):
        help = (_('''\
1: 2 3 4 5 6 7 8 9 T J Q K
2: 4 6 8 T Q A 3 5 7 9 J K
3: 6 9 Q 2 5 8 J A 4 7 T K
4: 8 Q 3 7 J 2 6 T A 5 9 K'''))
        # calculate text_width
        lines = help.split('\n')
        lines.sort(key=len)
        max_line = lines[-1]
        text_width = get_text_width(max_line,
                                    font=self.app.getFont("canvas_fixed"))
        return help, text_width

    def createGame(self):

        # create layout
        l, s = Layout(self, TEXT_HEIGHT=40), self.s
        help, text_width = self._getHelpText()
        text_width += 2*l.XM

        # set window
        w = l.XM+5.5*l.XS+text_width
        h = max(2*l.YS, 20*l.YOFFSET)
        self.setSize(w, l.YM + l.YS + l.TEXT_HEIGHT + h)

        # create stacks
        x0 = l.XM + l.XS * 3 // 2
        x, y = x0, l.YM
        for i in range(4):
            stack = self.Foundation_Class(x, y, self,
                                          mod=13, dir=i+1, base_rank=i)
            s.foundations.append(stack)
            tx, ty, ta, tf = l.getTextAttr(stack, "s")
            font = self.app.getFont("canvas_default")
            stack.texts.misc = MfxCanvasText(self.canvas, tx, ty,
                                             anchor=ta, font=font)
            x = x + l.XS
        self.texts.help = MfxCanvasText(
            self.canvas, x + l.XM, y + l.CH // 2, text=help,
            anchor="w", font=self.app.getFont("canvas_fixed"))
        x = x0
        y = l.YM + l.YS + l.TEXT_HEIGHT
        for i in range(4):
            s.rows.append(self.RowStack_Class(x, y, self))
            x = x + l.XS
        self.setRegion(s.rows, (-999, y-l.CH//2, 999999, 999999))
        x = l.XM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "n")
        y = y + l.YS
        s.waste = WasteStack(x, y, self, max_cards=1)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        # prepare first cards
        topcards = [None] * 4
        for c in cards[:]:
            if c.rank <= 3 and topcards[c.rank] is None:
                topcards[c.rank] = c
                cards.remove(c)
        topcards.reverse()
        return cards + topcards

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealCards()          # deal first card to WasteStack

    def getHighlightPilesStacks(self):
        return ()


# ************************************************************************
# * Hopscotch
# ************************************************************************

class Hopscotch(Calculation):
    def _shuffleHook(self, cards):
        # prepare first cards
        topcards = [None] * 4
        for c in cards[:]:
            if c.suit == 0 and c.rank <= 3 and topcards[c.rank] is None:
                topcards[c.rank] = c
                cards.remove(c)
        topcards.reverse()
        return cards + topcards


# ************************************************************************
# * Betsy Ross
# ************************************************************************

class BetsyRoss(Calculation):

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        help, text_width = self._getHelpText()
        text_width += 2*l.XM

        # set window
        self.setSize(5.5*l.XS+l.XM+text_width, l.YM+3*l.YS+l.TEXT_HEIGHT)

        # create stacks
        x0 = l.XM + l.XS * 3 // 2
        x, y = x0, l.YM
        for i in range(4):
            stack = BetsyRoss_Foundation(x, y, self, base_rank=i,
                                         max_cards=1, max_move=0, max_accept=0)
            s.foundations.append(stack)
            x += l.XS
        x = x0
        y = l.YM + l.YS
        for i in range(4):
            stack = BetsyRoss_Foundation(x, y, self, base_rank=2*i+1,
                                         mod=13, dir=i+1,
                                         max_cards=12, max_move=0)
            tx, ty, ta, tf = l.getTextAttr(stack, "s")
            font = self.app.getFont("canvas_default")
            stack.texts.misc = MfxCanvasText(self.canvas, tx, ty,
                                             anchor=ta, font=font)
            s.foundations.append(stack)
            x += l.XS
        self.texts.help = MfxCanvasText(self.canvas, x + l.XM, y + l.CH // 2,
                                        text=help, anchor="w",
                                        font=self.app.getFont("canvas_fixed"))
        x = l.XM
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "n")
        l.createRoundText(s.talon, 'nnn')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        # prepare first cards
        topcards = [None] * 8
        for c in cards[:]:
            if c.rank <= 3 and topcards[c.rank] is None:
                topcards[c.rank] = c
                cards.remove(c)
            elif c.rank in (1, 3, 5, 7):
                i = 4 + (c.rank - 1) // 2
                if topcards[i] is None:
                    topcards[i] = c
                    cards.remove(c)
        topcards.reverse()
        return cards + topcards


# ************************************************************************
# * One234
# ************************************************************************

class One234_Foundation(BetsyRoss_Foundation):
    def canMoveCards(self, cards):
        if not BetsyRoss_Foundation.canMoveCards(self, cards):
            return False
        return len(self.cards) > 1

    def updateText(self):
        BetsyRoss_Foundation.updateText(self, update_empty=False)


class One234_RowStack(BasicRowStack):
    # clickHandler = BasicRowStack.doubleclickHandler
    pass


class One234(Calculation):
    Foundation_Class = One234_Foundation
    RowStack_Class = StackWrapper(One234_RowStack, max_move=1, max_accept=0)

    def createGame(self):
        # create layout
        l, s = Layout(self, TEXT_HEIGHT=40), self.s
        help, text_width = self._getHelpText()
        text_width += 2*l.XM

        # set window
        # (piles up to 20 cards are playable in default window size)
        w = l.XM+max(4*l.XS+text_width, 8*l.XS)
        h = l.YM+2*l.YS+5*l.YOFFSET+l.TEXT_HEIGHT+l.YS
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(4):
            stack = self.Foundation_Class(x, y, self,
                                          mod=13, dir=i+1, base_rank=i)
            s.foundations.append(stack)
            tx, ty, ta, tf = l.getTextAttr(stack, "s")
            font = self.app.getFont("canvas_default")
            stack.texts.misc = MfxCanvasText(self.canvas, tx, ty,
                                             anchor=ta, font=font)
            x = x + l.XS
        self.texts.help = MfxCanvasText(
            self.canvas, x + l.XM, y + l.CH // 2, text=help,
            anchor="w", font=self.app.getFont("canvas_fixed"))
        x, y = l.XM, l.YM+l.YS+l.TEXT_HEIGHT
        for i in range(8):
            s.rows.append(self.RowStack_Class(x, y, self))
            x = x + l.XS

        s.talon = InitialDealTalonStack(l.XM, self.height-l.YS, self)

        # define stack-groups
        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return cards

    def startGame(self):
        self._startDealNumRows(4)
        self.s.talon.dealRow()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.foundations)


# ************************************************************************
# * Senior Wrangler
# ************************************************************************

class SeniorWrangler_Talon(DealRowTalonStack):

    def canDealCards(self):
        if self.round == self.max_rounds:
            return False
        return not self.game.isGameWon()

    def dealCards(self, sound=False):
        num_cards = 0
        r = self.game.s.rows[self.round-1]
        if not r.cards:
            self.game.nextRoundMove(self)
            return 1
        if sound:
            self.game.startDealSample()
        old_state = self.game.enterState(self.game.S_DEAL)
        while r.cards:
            self.game.flipMove(r)
            self.game.moveMove(1, r, self, frames=4, shadow=0)
        self.dealRowAvail(rows=self.game.s.rows[self.round-1:], sound=False)
        while self.cards:
            num_cards += self.dealRowAvail(sound=False)
        self.game.nextRoundMove(self)
        self.game.leaveState(old_state)
        if sound:
            self.game.stopSamples()
        return num_cards


class SeniorWrangler_RowStack(BasicRowStack):
    # clickHandler = BasicRowStack.doubleclickHandler
    pass


class SeniorWrangler(Game):

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+9.5*l.XS, l.YM+3*l.YS)

        x, y = l.XM+1.5*l.XS, l.YM
        for i in range(8):
            stack = BetsyRoss_Foundation(x, y, self, base_rank=i,
                                         mod=13, dir=i+1, max_move=0)
            tx, ty, ta, tf = l.getTextAttr(stack, "s")
            font = self.app.getFont("canvas_default")
            stack.texts.misc = MfxCanvasText(self.canvas, tx, ty,
                                             anchor=ta, font=font)
            s.foundations.append(stack)
            x = x + l.XS
        x, y = l.XM+1.5*l.XS, l.YM+2*l.YS
        for i in range(8):
            stack = SeniorWrangler_RowStack(x, y, self, max_accept=0)
            s.rows.append(stack)
            stack.CARD_YOFFSET = 0
            x += l.XS
        x, y = l.XM, l.YM+l.YS
        s.talon = SeniorWrangler_Talon(x, y, self, max_rounds=9)
        l.createRoundText(s.talon, 'nn')

        # define stack-groups
        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        top = []
        ranks = []
        for c in cards[:]:
            if c.rank in range(8) and c.rank not in ranks:
                ranks.append(c.rank)
                cards.remove(c)
                top.append(c)
        top.sort(key=lambda x: -x.rank)
        return cards+top

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations[:8], frames=0)
        self._startDealNumRowsAndDealSingleRow(11)


# ************************************************************************
# * S Patience
# ************************************************************************

class SPatience(Game):
    Hint_Class = Calculation_Hint

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+7.5*l.XS, l.YM+3.8*l.YS)

        x0, y0 = l.XM, l.YM
        for xx, yy in ((4, 0.4),
                       (3, 0.2),
                       (2, 0.0),
                       (1, 0.2),
                       (0, 0.7),
                       (1, 1.2),
                       (2, 1.4),
                       (3, 1.6),
                       (4, 2.0),
                       (3, 2.6),
                       (2, 2.8),
                       (1, 2.6),
                       (0, 2.4),
                       ):
            x, y = x0+xx*l.XS, y0+yy*l.YS
            s.foundations.append(RK_FoundationStack(x, y, self, suit=ANY_SUIT,
                                 max_cards=8, mod=13, max_move=0))

        x, y = l.XM+5.5*l.XS, l.YM+2*l.YS
        for i in (0, 1):
            stack = Calculation_RowStack(x, y, self, max_move=1, max_accept=1)
            stack.CARD_YOFFSET = 0
            s.rows.append(stack)
            l.createText(stack, 's')
            x += l.XS
        x, y = l.XM+5.5*l.XS, l.YM+l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'nw')
        x += l.XS
        s.waste = WasteStack(x, y, self, max_cards=1)

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        top = []
        ranks = []
        for c in cards[:]:
            if c.rank not in ranks:
                ranks.append(c.rank)
                cards.remove(c)
                top.append(c)
        top.sort(key=lambda x: -x.rank)
        return cards+top[7:]+top[:7]

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealCards()


# register the game
registerGame(GameInfo(256, Calculation, "Calculation",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_SKILL,
                      altnames=("Progression",)))
registerGame(GameInfo(94, Hopscotch, "Hopscotch",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(134, BetsyRoss, "Betsy Ross",
                      GI.GT_1DECK_TYPE, 1, 2, GI.SL_MOSTLY_LUCK,
                      altnames=("Fairest", "Four Kings", "Musical Patience",
                                "Quadruple Alliance", "Plus Belle")))
registerGame(GameInfo(550, One234, "One234",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(653, SeniorWrangler, "Senior Wrangler",
                      GI.GT_2DECK_TYPE, 2, 8, GI.SL_BALANCED))
registerGame(GameInfo(704, SPatience, "S Patience",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
from . import acesup  # noqa: F401
from . import algerian  # noqa: F401
from . import auldlangsyne  # noqa: F401
from . import bakersdozen  # noqa: F401
from . import bakersgame  # noqa: F401
from . import beleagueredcastle  # noqa: F401
from . import bisley  # noqa: F401
from . import bisley13  # noqa: F401
from . import braid  # noqa: F401
from . import bristol  # noqa: F401
from . import buffalobill  # noqa: F401
from . import calculation  # noqa: F401
from . import camelot  # noqa: F401
from . import canfield  # noqa: F401
from . import capricieuse  # noqa: F401
from . import curdsandwhey  # noqa: F401
from . import daddylonglegs  # noqa: F401
from . import dieboesesieben  # noqa: F401
from . import diplomat  # noqa: F401
from . import doublets  # noqa: F401
from . import eiffeltower  # noqa: F401
from . import fan  # noqa: F401
from . import fortythieves  # noqa: F401
from . import freecell  # noqa: F401
from . import glenwood  # noqa: F401
from . import golf  # noqa: F401
from . import grandduchess  # noqa: F401
from . import grandfathersclock  # noqa: F401
from . import gypsy  # noqa: F401
from . import harp  # noqa: F401
from . import headsandtails  # noqa: F401
from . import katzenschwanz  # noqa: F401
from . import klondike  # noqa: F401
from . import labyrinth  # noqa: F401
from . import larasgame  # noqa: F401
from . import matriarchy  # noqa: F401
from . import montana  # noqa: F401
from . import montecarlo  # noqa: F401
from . import napoleon  # noqa: F401
from . import needle  # noqa: F401
from . import numerica  # noqa: F401
from . import osmosis  # noqa: F401
from . import parallels  # noqa: F401
from . import pasdedeux  # noqa: F401
from . import picturegallery  # noqa: F401
from . import pileon  # noqa: F401
from . import pushpin  # noqa: F401
from . import pyramid  # noqa: F401
from . import royalcotillion  # noqa: F401
from . import royaleast  # noqa: F401
from . import sanibel  # noqa: F401
from . import siebenbisas  # noqa: F401
from . import simplex  # noqa: F401
from . import spider  # noqa: F401
from . import sthelena  # noqa: F401
from . import sultan  # noqa: F401
from . import takeaway  # noqa: F401
from . import terrace  # noqa: F401
from . import threepeaks  # noqa: F401
from . import tournament  # noqa: F401
from . import unionsquare  # noqa: F401
from . import wavemotion  # noqa: F401
from . import windmill  # noqa: F401
from . import yukon  # noqa: F401
from . import zodiac  # noqa: F401
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.stack import \
        AC_RowStack, \
        BasicRowStack, \
        DealRowRedealTalonStack, \
        DealRowTalonStack, \
        OpenStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        Stack
from pysollib.util import ACE, JACK, KING, QUEEN

# ************************************************************************
# * Tournament
# ************************************************************************


class Tournament_Talon(DealRowRedealTalonStack):
    def dealCards(self, sound=False):
        num_cards = 0
        if sound and self.game.app.opt.animations:
            self.game.startDealSample()
        if len(self.cards) == 0:
            num_cards = self._redeal(reverse=True, frames=0)
            self.game.nextRoundMove(self)
        for r in self.game.s.rows:
            for i in range(4):
                if not self.cards:
                    break
                num_cards += self.dealRow([r], sound=False, frames=4)
        if sound:
            self.game.stopSamples()
        return num_cards


class Tournament(Game):

    ROW_YOFFSET = True

    #
    # game layout
    #

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+10*l.XS, max(l.YM+l.YS+20*l.YOFFSET, 2*l.YM+5*l.YS))

        # create stacks
        x, y, = l.XM+2*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x = x + l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                    base_rank=KING, dir=-1))
            x = x + l.XS
        x, y = l.XM+2*l.XS, 2*l.YM+l.YS
        for i in range(6):
            stack = BasicRowStack(x, y, self, max_move=1, max_accept=0)
            s.rows.append(stack)
            if not self.ROW_YOFFSET:
                stack.CARD_YOFFSET = 0
            x = x + l.XS

        x, y = l.XM, 2*l.YM+l.YS
        for i in range(4):
            self.s.reserves.append(ReserveStack(x, y, self))
            y += l.YS
        x, y = l.XM+9*l.XS, 2*l.YM+l.YS
        for i in range(4):
            self.s.reserves.append(ReserveStack(x, y, self))
            y += l.YS

        s.talon = Tournament_Talon(l.XM, l.YM, self, max_rounds=3)
        l.createText(s.talon, "se")
        l.createRoundText(s.talon, 'ne')

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        for c in cards[-8:]:
            if c.rank in (ACE, KING):
                return cards
        #
        for c in cards:
            if c.rank in (ACE, KING):
                break
        cards.remove(c)
        return cards+[c]

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(self.s.reserves, frames=4)
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            if not self.demo:
                self.startDealSample()
            for i in range(4):
                if not self.s.talon.cards:
                    break
                self.s.talon.dealRow([stack])
            if not self.demo:
                self.stopSamples()


class LaNivernaise(Tournament):
    ROW_YOFFSET = False

# ************************************************************************
# * Kingsdown Eights
# ************************************************************************


class KingsdownEights_Talon(DealRowTalonStack):
    def dealCards(self, sound=False):
        if len(self.cards) == 0:
            self._redeal()
        self.game.startDealSample()
        n = 0
        for r in self.game.s.reserves:
            for i in range(4):
                if not self.cards:
                    break
                n += self.dealRow([r])
        self.game.stopSamples()
        return n


class KingsdownEights(Game):

    Hint_Class = CautiousDefaultHint

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+10*l.XS, max(l.YM+2*l.YS+12*l.YOFFSET,
                                       l.YM+5*l.YS))

        # create stacks
        x = l.XM
        for i in range(2):
            y = l.YM+l.YS
            for j in range(4):
                s.foundations.append(SS_FoundationStack(x, y, self, suit=j))
                y += l.YS
            x += l.XS
        x, y = l.XM+2*l.XS, l.YM
        for i in range(8):
            stack = AC_RowStack(x, y, self, max_move=1)
            stack.getBottomImage = stack._getReserveBottomImage
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
            s.rows.append(stack)
            x += l.XS
        x, y = l.XM+2*l.XS, l.YM+l.YS
        for i in range(8):
            stack = OpenStack(x, y, self, max_accept=0)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, l.YOFFSET
            s.reserves.append(stack)
            x += l.XS
        s.talon = KingsdownEights_Talon(l.XM, l.YM, self, max_rounds=1)
        l.createText(s.talon, "se")

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Saxony
# ************************************************************************

class Saxony_Reserve(SS_RowStack):
    getBottomImage = Stack._getReserveBottomImage

    def getHelp(self):
        return _('Reserve. Build down by suit.')


class Saxony_Talon(DealRowTalonStack):
    def dealCards(self, sound=False):
        return self.dealRowAvail(rows=self.game.s.reserves[:8], sound=sound)


class Saxony(Game):

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+11*l.XS, 2*l.YM+max(2*l.YS+12*l.YOFFSET, 5*l.YS))

        x, y, = l.XM+1.5*l.XS, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i % 4))
            x += l.XS
        x, y = l.XM+1.5*l.XS, 2*l.YM+l.YS
        for i in range(8):
            s.reserves.append(
                BasicRowStack(x, y, self, max_move=1, max_accept=0))
            x += l.XS
        x, y = l.XM, 2*l.YM+l.YS
        for i in range(4):
            stack = Saxony_Reserve(x, y, self, max_move=1)
            self.s.rows.append(stack)
            stack.CARD_YOFFSET = 0
            y += l.YS
        x, y = self.width-l.XS, 2*l.YM+l.YS
        for i in range(4):
            self.s.reserves.append(ReserveStack(x, y, self))
            y += l.YS
        s.talon = Saxony_Talon(l.XM, l.YM, self)
        l.createText(s.talon, "ne")

        l.defaultStackGroups()

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.reserves[8:], frames=0)
        self.s.talon.dealRow(frames=0)
        self.startDealSample()
        self.s.talon.dealCards()


# ************************************************************************
# * Ladies Battle
# ************************************************************************

class LadiesBattle_RowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack in self.game.s.reserves:
            return False
        return True


class LadiesBattle(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+9*l.XS, max(l.YM+l.YS+20*l.YOFFSET, l.YM+6*l.YS))

        x, y, = l.XM+1.5*l.XS, l.YM
        for i in range(6):
            s.rows.append(LadiesBattle_RowStack(x, y, self,
                                                max_move=1, mod=13))
            x = x + l.XS
        x, y = l.XM, l.YM+l.YS//2
        for i in range(4):
            s.reserves.append(OpenStack(x, y, self, max_accept=0))
            y += l.YS
        x, y = self.width-l.XS, l.YM+l.YS//2
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                    base_rank=QUEEN, mod=13))
            y += l.YS
        x, y = self.width-l.XS, self.height-l.YS
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, "sw")
        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (JACK, QUEEN), (c.rank, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRow()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            if self.s.talon.cards:
                self.s.talon.flipMove()
                self.s.talon.moveMove(1, stack)

    shallHighlightMatch = Game._shallHighlightMatch_ACW


# register the game
registerGame(GameInfo(303, Tournament, "Tournament",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(304, LaNivernaise, "La Nivernaise",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_MOSTLY_LUCK,
                      altnames=("Napoleon's Flank", ),))
registerGame(GameInfo(386, KingsdownEights, "Kingsdown Eights",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(645, Saxony, "Saxony",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(652, LadiesBattle, "Ladies Battle",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.spider import Spider_AC_Foundation
from pysollib.hint import DefaultHint
from pysollib.hint import FreeCellSolverWrapper, FreeCellType_Hint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.stack import \
        AC_FoundationStack, \
        AC_RowStack, \
        BasicRowStack, \
        FreeCell_AC_RowStack, \
        FreeCell_SS_RowStack, \
        InitialDealTalonStack, \
        KingAC_RowStack, \
        OpenStack, \
        RK_FoundationStack, \
        ReserveStack, \
        SS_FoundationStack, \
        Stack, \
        StackWrapper, \
        SuperMoveAC_RowStack, \
        SuperMoveRK_RowStack, \
        isAlternateColorSequence
from pysollib.util import ACE, ANY_SUIT, KING, NO_RANK, UNLIMITED_CARDS

# ************************************************************************
# * FreeCell
# ************************************************************************


class FreeCell(Game):
    Layout_Method = staticmethod(Layout.freeCellLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = SuperMoveAC_RowStack
    ReserveStack_Class = ReserveStack
    Hint_Class = FreeCellType_Hint
    Solver_Class = FreeCellSolverWrapper()

    #
    # game layout
    #

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, reserves=4, texts=0)
        self.Layout_Method(l, **layout)
        # self.__class__.__dict__['Layout_Method'](l, **layout)
        # self.__class__.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(r.x, r.y, self, suit=r.suit))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        for r in l.s.reserves:
            s.reserves.append(self.ReserveStack_Class(r.x, r.y, self))
        # default
        l.defaultAll()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(5)
        self.s.talon.dealRow()
        r = self.s.rows
        # self.s.talon.dealRow(rows=(r[0], r[2], r[4], r[6]))
        self.s.talon.dealRow(rows=r[:4])

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Relaxed FreeCell
# ************************************************************************

class RelaxedFreeCell(FreeCell):
    RowStack_Class = AC_RowStack
    Solver_Class = FreeCellSolverWrapper(sm='unlimited')


# ************************************************************************
# * ForeCell
# ************************************************************************

class ForeCell(FreeCell):
    RowStack_Class = StackWrapper(FreeCell_AC_RowStack, base_rank=KING)
    Solver_Class = FreeCellSolverWrapper(esf='kings')

    def startGame(self):
        self._startDealNumRows(5)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)


# ************************************************************************
# * Challenge FreeCell
# * Super Challenge FreeCell
# ************************************************************************

class ChallengeFreeCell(FreeCell):
    def _shuffleHook(self, cards):
        # move Aces and Twos to top of the Talon
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank in (ACE, 1), (-c.rank, c.suit)))


class SuperChallengeFreeCell(ChallengeFreeCell):
    RowStack_Class = StackWrapper(FreeCell_AC_RowStack, base_rank=KING)
    Solver_Class = FreeCellSolverWrapper(esf='kings')


# ************************************************************************
# * Stalactites
# ************************************************************************

class Stalactites(FreeCell):
    Foundation_Class = StackWrapper(
        RK_FoundationStack, suit=ANY_SUIT, mod=13, min_cards=1)
    RowStack_Class = StackWrapper(BasicRowStack, max_move=1, max_accept=0)
    Solver_Class = None

    def createGame(self):
        FreeCell.createGame(self, reserves=2)

    def startGame(self):
        self._startDealNumRows(5)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.foundations)
        self._restoreGameHook(None)

    def _restoreGameHook(self, game):
        for s in self.s.foundations:
            s.cap.base_rank = s.cards[0].rank


# ************************************************************************
# * Double Freecell
# ************************************************************************

class DoubleFreecell(FreeCell):
    Solver_Class = None

    #
    # game layout
    #

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = 3*l.XM+10*l.XS, 2*l.YM+2*l.YS+16*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        s.talon = self.Talon_Class(l.XM, h-l.YS, self)
        x, y = 3*l.XM + 6*l.XS, l.YM
        for i in range(4):
            s.foundations.append(
                self.Foundation_Class(
                    x, y, self, suit=i, mod=13, max_cards=26))
            x += l.XS
        x, y = 2*l.XM, l.YM + l.YS + l.YM
        for i in range(10):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += l.XS
        x, y = l.XM, l.YM
        for i in range(6):
            s.reserves.append(ReserveStack(x, y, self))
            x += l.XS
        # default
        l.defaultAll()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        # move 4 Aces to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == ACE and c.deck == 0, c.suit))

    def startGame(self):
        self._startDealNumRows(9)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.foundations)


# ************************************************************************
# * Triple Freecell
# ************************************************************************

class TripleFreecell(FreeCell):
    Solver_Class = None

    #
    # game layout
    #

    def createGame(self, rows=13, reserves=10, playcards=20):

        # create layout
        l, s = Layout(self), self.s

        # set window
        decks = self.gameinfo.decks
        max_rows = max(decks*4, rows, reserves)
        w, h = l.XM+max_rows*l.XS, l.YM+3*l.YS+playcards*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        s.talon = self.Talon_Class(l.XM, h-l.YS, self)

        x, y = l.XM+(max_rows-decks*4)*l.XS//2, l.YM
        for j in range(4):
            for i in range(decks):
                s.foundations.append(self.Foundation_Class(x, y, self, suit=j))
                x += l.XS
        x, y = l.XM+(max_rows-reserves)*l.XS//2, l.YM+l.YS
        for i in range(reserves):
            s.reserves.append(ReserveStack(x, y, self))
            x += l.XS
        x, y = l.XM+(max_rows-rows)*l.XS//2, l.YM+2*l.YS
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += l.XS

        # default
        l.defaultAll()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(11)


class Cell11(TripleFreecell):
    def createGame(self):
        TripleFreecell.createGame(self, rows=12, reserves=11)

    def startGame(self):
        self._startDealNumRows(12)
        self.s.talon.dealRow(rows=self.s.rows[1:-1])
        self.s.talon.dealRow(rows=[self.s.reserves[0], self.s.reserves[-1]])


class BigCell(TripleFreecell):
    RowStack_Class = AC_RowStack

    def createGame(self):
        TripleFreecell.createGame(self, rows=13, reserves=4)

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(11)


# ************************************************************************
# * Spidercells
# ************************************************************************

class Spidercells_RowStack(SuperMoveAC_RowStack):
    def canMoveCards(self, cards):
        if len(cards) == 13 and isAlternateColorSequence(cards):
            return True
        return SuperMoveAC_RowStack.canMoveCards(self, cards)

    def canDropCards(self, stacks):
        if len(self.cards) < 13:
            return (None, 0)
        cards = self.cards[-13:]
        for s in stacks:
            if s is not self and s.acceptsCards(self, cards):
                return (s, 13)
        return (None, 0)


class Spidercells(FreeCell):

    Solver_Class = None
    Foundation_Class = Spider_AC_Foundation
    RowStack_Class = Spidercells_RowStack

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, reserves=4, texts=0)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(r.x, r.y, self, suit=ANY_SUIT))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        for r in l.s.reserves:
            s.reserves.append(ReserveStack(r.x, r.y, self))
        # default
        l.defaultAll()


# ************************************************************************
# * Seven by Four
# * Seven by Five
# * Bath
# ************************************************************************

class SevenByFour(FreeCell):
    def createGame(self):
        FreeCell.createGame(self, rows=7)

    def startGame(self):
        self._startDealNumRows(6)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.rows[:3])


class SevenByFive(SevenByFour):
    def createGame(self):
        FreeCell.createGame(self, rows=7, reserves=5)


class Bath(FreeCell):
    Solver_Class = FreeCellSolverWrapper(esf='kings')
    RowStack_Class = StackWrapper(SuperMoveAC_RowStack, base_rank=KING)

    def createGame(self):
        FreeCell.createGame(self, rows=10, reserves=2)

    def startGame(self):
        for i in range(6):
            self.s.talon.dealRow(rows=self.s.rows[i:], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[6:])
        self.s.talon.dealRow(rows=self.s.rows[7:])


# ************************************************************************
# * Clink
# ************************************************************************

class Clink(FreeCell):
    Solver_Class = None

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+2*l.YS+12*l.YOFFSET)
        # create stacks
        x, y = l.XM, self.height-l.YS
        s.talon = InitialDealTalonStack(x, y, self)
        x, y = l.XM+l.XS, l.YM
        for i in range(2):
            s.reserves.append(ReserveStack(x, y, self))
            x += l.XS
        x += 2*l.XS
        for i in range(2):
            s.foundations.append(AC_FoundationStack(x, y, self, suit=ANY_SUIT,
                                 max_cards=26, mod=13, max_move=0))
            x += l.XS
        x, y = l.XM, l.YM+l.YS
        for i in range(8):
            s.rows.append(AC_RowStack(x, y, self))
            x += l.XS
        # default
        l.defaultAll()

    def startGame(self):
        self._startDealNumRows(4)
        self.s.talon.dealRow()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRow(rows=self.s.foundations)

    def _shuffleHook(self, cards):
        # move two Aces to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards,
            lambda c: (c.rank == ACE and c.suit in (0, 2), (c.suit)))


# ************************************************************************
# * Repair
# ************************************************************************

class Repair(FreeCell):
    Solver_Class = FreeCellSolverWrapper(sm='unlimited')
    RowStack_Class = AC_RowStack

    def createGame(self):
        FreeCell.createGame(self, rows=10, reserves=4, playcards=26)

    def startGame(self):
        self._startDealNumRows(9)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)


# ************************************************************************
# * Four Colours
# * German FreeCell
# ************************************************************************

class FourColours_RowStack(AC_RowStack):
    getBottomImage = Stack._getReserveBottomImage


class FourColours(FreeCell):
    Solver_Class = None
    RowStack_Class = AC_RowStack

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        self.setSize(l.XM+9*l.XS, l.YM+2*l.YS+12*l.YOFFSET)
        # create stacks
        x, y = self.width-l.XS, self.height-l.YS
        s.talon = InitialDealTalonStack(x, y, self)
        x, y = l.XM, l.YM
        for i in range(4):
            s.reserves.append(ReserveStack(x, y, self, base_suit=i))
            x += l.XS
        x += l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += l.XS
        x, y = l.XM, l.YM+l.YS
        for i in range(7):
            s.rows.append(FourColours_RowStack(x, y, self))
            x += l.XS
        # default
        l.defaultAll()

    def dealOne(self, frames):
        suit = self.s.talon.cards[-1].suit
        self.s.talon.dealRow(rows=[self.s.rows[suit]], frames=frames)

    def startGame(self):
        for i in range(40):
            self.dealOne(frames=0)
        self.startDealSample()
        while self.s.talon.cards:
            self.dealOne(frames=-1)


class GermanFreeCell_Reserve(ReserveStack):
    getBottomImage = Stack._getSuitBottomImage


class GermanFreeCell(SevenByFour):
    Solver_Class = None
    RowStack_Class = AC_RowStack
    ReserveStack_Class = GermanFreeCell_Reserve

    def createGame(self):
        FreeCell.createGame(self, rows=7)
        suit = 0
        for r in self.s.reserves:
            r.cap.base_suit = suit
            suit += 1


# ************************************************************************
# * Ocean Towers
# ************************************************************************

class OceanTowers(TripleFreecell):
    Solver_Class = FreeCellSolverWrapper(esf='kings', sbb='suit')
    RowStack_Class = StackWrapper(FreeCell_SS_RowStack, base_rank=KING)

    def createGame(self):
        TripleFreecell.createGame(self, rows=14, reserves=8, playcards=20)

    def startGame(self):
        self._startDealNumRows(6)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves[1:-1])

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * KingCell
# ************************************************************************

class KingCell(FreeCell):
    Solver_Class = FreeCellSolverWrapper(sbb='rank', esf='kings')
    RowStack_Class = StackWrapper(SuperMoveRK_RowStack, base_rank=KING)

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Headquarters
# ************************************************************************

class Headquarters_Reserve(ReserveStack):

    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        return len(self.cards) == 0


class Headquarters(Game):

    def createGame(self, rows=8, reserves=6):
        l, s = Layout(self), self.s
        w, h = l.XM+(rows+reserves+1)*l.XS, l.YM+3*l.YS+16*l.YOFFSET
        self.setSize(w, h)
        x, y = l.XM+(rows+reserves+1-8)*l.XS//2, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i % 4))
            x += l.XS
        x, y = l.XM, l.YM+l.YS
        for i in range(reserves):
            stack = Headquarters_Reserve(x, y, self,
                                         max_cards=UNLIMITED_CARDS,
                                         max_accept=UNLIMITED_CARDS,
                                         max_move=UNLIMITED_CARDS)
            s.reserves.append(stack)
            stack.CARD_YOFFSET = l.YOFFSET
            x += l.XS
        x, y = l.XM+(reserves+1)*l.XS, l.YM+l.YS
        for j in range(rows):
            s.rows.append(AC_RowStack(x, y, self, base_rank=NO_RANK))
            x += l.XS
        x, y = w-l.XS, h-l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(12)

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Can Can
# ************************************************************************

class CanCan(FreeCell):
    Hint_Class = DefaultHint
    Solver_Class = None
    RowStack_Class = KingAC_RowStack
    ReserveStack_Class = StackWrapper(OpenStack, max_accept=0)

    def createGame(self):
        FreeCell.createGame(self, rows=13, reserves=3)

    def startGame(self):
        self._startDealNumRows(3)
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRowAvail()


# ************************************************************************
# * Limpopo
# ************************************************************************

class Limpopo(Game):

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+10.5*l.XS, l.YM+2*l.YS+20*l.YOFFSET)

        # create stacks
        x, y = l.XM, l.YM+l.YS//2
        for i in (0, 1):
            stack = ReserveStack(x, y, self, max_cards=4)
            s.reserves.append(stack)
            stack.CARD_YOFFSET = l.YOFFSET
            l.createText(stack, 'n')
            x += l.XS

        x, y = l.XM+2.5*l.XS, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2))
            x += l.XS

        x, y = l.XM+2.5*l.XS, l.YM+l.YS
        for i in range(8):
            s.rows.append(AC_RowStack(x, y, self))
            x += l.XS

        x, y = l.XM, self.height-l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(12)

    shallHighlightMatch = Game._shallHighlightMatch_AC


class PairFcFreeCell(FreeCell):
    def createGame(self):
        FreeCell.createGame(self, reserves=2)


class ZeroFcFreeCell(FreeCell):
    def createGame(self):
        FreeCell.createGame(self, reserves=0)


# register the game
registerGame(GameInfo(5, RelaxedFreeCell, "Relaxed FreeCell",
                      GI.GT_FREECELL | GI.GT_RELAXED | GI.GT_OPEN, 1, 0,
                      GI.SL_SKILL))
registerGame(GameInfo(8, FreeCell, "FreeCell",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_SKILL))
registerGame(GameInfo(1901, ZeroFcFreeCell, "FreeCell with Zero Reserves",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_SKILL))
registerGame(GameInfo(1900, PairFcFreeCell, "FreeCell with Two Reserves",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_SKILL))
registerGame(GameInfo(46, ForeCell, "ForeCell",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(77, Stalactites, "Stalactites",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL,
                      altnames=("Grampus", "Old Mole")))
registerGame(GameInfo(264, DoubleFreecell, "Double FreeCell",
                      GI.GT_FREECELL | GI.GT_OPEN, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(265, TripleFreecell, "Triple FreeCell",
                      GI.GT_FREECELL | GI.GT_OPEN, 3, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(336, ChallengeFreeCell, "Challenge FreeCell",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_SKILL,
                      rules_filename='freecell.html'))
registerGame(GameInfo(337, SuperChallengeFreeCell, "Super Challenge FreeCell",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_SKILL))
registerGame(GameInfo(363, Spidercells, "Spidercells",
                      GI.GT_SPIDER | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(364, SevenByFour, "Seven by Four",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_SKILL))
registerGame(GameInfo(365, SevenByFive, "Seven by Five",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_SKILL))
registerGame(GameInfo(383, Bath, "Bath",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_SKILL))
registerGame(GameInfo(394, Clink, "Clink",
                      GI.GT_FREECELL | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(448, Repair, "Repair",
                      GI.GT_FREECELL | GI.GT_OPEN, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(451, Cell11, "Cell 11",
                      GI.GT_FREECELL | GI.GT_OPEN, 3, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(464, FourColours, "Four Colours",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(509, BigCell, "Big Cell",
                      GI.GT_FREECELL | GI.GT_OPEN | GI.GT_ORIGINAL, 3, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(513, OceanTowers, "Ocean Towers",
                      GI.GT_FREECELL | GI.GT_OPEN | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(520, GermanFreeCell, "German FreeCell",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_SKILL))
registerGame(GameInfo(542, KingCell, "KingCell",
                      GI.GT_FREECELL | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(648, Headquarters, "Headquarters",
                      GI.GT_FREECELL | GI.GT_OPEN | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(698, CanCan, "Can Can",
                      GI.GT_RAGLAN | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(746, Limpopo, "Limpopo",
                      GI.GT_FREECELL | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import time

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint, DefaultHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.stack import \
        AC_RowStack, \
        BasicRowStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        OpenStack, \
        OpenTalonStack, \
        RK_FoundationStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        Stack, \
        StackWrapper, \
        TalonStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, ANY_RANK, ANY_SUIT, JACK, KING, NO_RANK, \
        UNLIMITED_ACCEPTS, \
        UNLIMITED_CARDS


class Numerica_Hint(DefaultHint):
    # FIXME: demo is clueless

    # def _getDropCardScore(self, score, color, r, t, ncards):
    # FIXME: implement this method

    def _getMoveWasteScore(self, score, color, r, t, pile, rpile):
        assert r in (self.game.s.waste, self.game.s.talon) and len(pile) == 1
        score = self._computeScore(r, t)
        return score, color

    def _computeScore(self, r, t):
        score = 30000
        if len(t.cards) == 0:
            score = score - (KING - r.cards[0].rank) * 1000
        elif t.cards[-1].rank < r.cards[0].rank:
            # FIXME: add intelligence here
            score = 10000 + t.cards[-1].rank - len(t.cards)
        elif t.cards[-1].rank == r.cards[0].rank:
            score = 20000
        else:
            score = score - (t.cards[-1].rank - r.cards[0].rank) * 1000
        return score


# ************************************************************************
# *
# ************************************************************************

class Numerica_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        # this stack accepts any one card from the Waste pile
        return from_stack is self.game.s.waste and len(cards) == 1

    getBottomImage = Stack._getReserveBottomImage

    def getHelp(self):
        # return _('Tableau. Accepts any one card from the Waste.')
        return _('Tableau. Build regardless of rank and suit.')


# ************************************************************************
# * Numerica
# ************************************************************************

class Numerica(Game):
    Hint_Class = Numerica_Hint
    Foundation_Class = StackWrapper(RK_FoundationStack, suit=ANY_SUIT)
    RowStack_Class = StackWrapper(Numerica_RowStack, max_accept=1)

    #
    # game layout
    #

    def createGame(self, rows=4, reserve=False, max_rounds=1,
                   waste_max_cards=1):
        # create layout
        l, s = Layout(self), self.s
        decks = self.gameinfo.decks
        foundations = 4*decks

        # set window
        # (piles up to 20 cards are playable in default window size)
        h = max(2*l.YS, 20*l.YOFFSET)
        max_rows = max(rows, foundations)
        self.setSize(l.XM+(1.5+max_rows)*l.XS+l.XM, l.YM + l.YS + h)

        # create stacks
        x0 = l.XM + l.XS * 3 // 2
        if decks == 1:
            x = x0 + (rows-4)*l.XS//2
        else:
            x = x0
        y = l.YM
        for i in range(foundations):
            s.foundations.append(self.Foundation_Class(x, y, self, suit=i))
            x = x + l.XS
        x, y = x0, l.YM + l.YS
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self))
            x = x + l.XS
        self.setRegion(s.rows, (x0-l.XS//2, y-l.CH//2, 999999, 999999))
        x, y = l.XM, l.YM+l.YS+l.YS//2*int(reserve)
        s.talon = WasteTalonStack(x, y, self, max_rounds=max_rounds)
        if reserve or waste_max_cards > 1:
            l.createText(s.talon, 'ne')
        else:
            l.createText(s.talon, 'n')
        y = y + l.YS
        s.waste = WasteStack(x, y, self, max_cards=waste_max_cards)
        if waste_max_cards > 1:
            l.createText(s.waste, 'ne')
        if reserve:
            s.reserves.append(self.ReserveStack_Class(l.XM, l.YM, self))

        # define stack-groups
        l.defaultStackGroups()

        return l

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealCards()          # deal first card to WasteStack

    shallHighlightMatch = Game._shallHighlightMatch_SS

    def getHighlightPilesStacks(self):
        return ()


class Numerica2Decks(Numerica):
    def createGame(self):
        Numerica.createGame(self, rows=6)


# ************************************************************************
# * Lady Betty
# * Last Chance
# ************************************************************************

class LadyBetty(Numerica):
    Foundation_Class = SS_FoundationStack

    def createGame(self):
        Numerica.createGame(self, rows=6)


class LastChance_RowStack(Numerica_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return True
        return from_stack is self.game.s.waste and len(cards) == 1


class LastChance_Reserve(OpenStack):
    def canFlipCard(self):
        return (len(self.game.s.talon.cards) == 0 and
                len(self.game.s.waste.cards) == 0 and
                self.cards and not self.cards[0].face_up)


class LastChance(LadyBetty):
    RowStack_Class = StackWrapper(LastChance_RowStack, max_accept=1)
    ReserveStack_Class = LastChance_Reserve

    def createGame(self):
        Numerica.createGame(self, rows=7, reserve=True)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves, flip=False)
        self.s.talon.dealCards()


# ************************************************************************
# * Puss in the Corner
# ************************************************************************

class PussInTheCorner_Talon(OpenTalonStack):
    rightclickHandler = OpenStack.rightclickHandler
    doubleclickHandler = OpenStack.doubleclickHandler

    def canDealCards(self):
        if self.round != self.max_rounds:
            return True
        return False

    def clickHandler(self, event):
        if self.cards:
            return OpenStack.clickHandler(self, event)
        else:
            return TalonStack.clickHandler(self, event)

    def dealCards(self, sound=False):
        ncards = 0
        old_state = self.game.enterState(self.game.S_DEAL)
        if not self.cards and self.round != self.max_rounds:
            self.game.nextRoundMove(self)
            self.game.startDealSample()
            for r in self.game.s.rows:
                while r.cards:
                    self.game.moveMove(1, r, self, frames=4)
                    self.game.flipMove(self)
                    ncards += 1
            self.fillStack()
            self.game.stopSamples()
        self.game.leaveState(old_state)
        return ncards


class PussInTheCorner_Foundation(SS_FoundationStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, base_suit=ANY_SUIT)
        SS_FoundationStack.__init__(self, x, y, game, ANY_SUIT, **cap)

    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if self.cards:
            # check the color
            if cards[0].color != self.cards[-1].color:
                return False
        return True

    def getHelp(self):
        return _('Foundation. Build up by color.')


class PussInTheCorner_RowStack(BasicRowStack):

    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        # this stack accepts any one card from the Talon
        return from_stack is self.game.s.talon and len(cards) == 1

    getBottomImage = Stack._getReserveBottomImage

    def getHelp(self):
        # return _('Tableau. Accepts any one card from the Waste.')
        return _('Tableau. Build regardless of rank and suit.')


class PussInTheCorner(Numerica):

    def createGame(self, rows=4):
        l, s = Layout(self), self.s
        self.setSize(l.XM+5*l.XS, l.YM+4*l.YS)
        for x, y in ((l.XM,        l.YM),
                     (l.XM+4*l.XS, l.YM),
                     (l.XM,        l.YM+3*l.YS),
                     (l.XM+4*l.XS, l.YM+3*l.YS),
                     ):
            stack = PussInTheCorner_RowStack(x, y, self,
                                             max_accept=1, max_move=1)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
            s.rows.append(stack)
        for x, y in ((l.XM+1.5*l.XS, l.YM + l.YS),
                     (l.XM+1.5*l.XS, l.YM + 2*l.YS),
                     (l.XM+2.5*l.XS, l.YM + l.YS),
                     (l.XM+2.5*l.XS, l.YM + 2*l.YS),
                     ):
            s.foundations.append(PussInTheCorner_Foundation(x, y, self,
                                                            max_move=0))
        x, y = l.XM + 2*l.XS, l.YM
        s.waste = s.talon = PussInTheCorner_Talon(x, y, self, max_rounds=2)
        l.createText(s.talon, 'se')
        l.createRoundText(self.s.talon, 'ne')

        # define stack-groups
        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == ACE, c.suit))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.fillStack()

    def _autoDeal(self, sound=True):
        return 0


# ************************************************************************
# * Frog
# * Fly
# * Fanny
# ************************************************************************

class Frog(Game):

    Hint_Class = Numerica_Hint
    # Foundation_Class = SS_FoundationStack
    Foundation_Class = RK_FoundationStack

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 8*l.XS, l.YM + 2*l.YS+16*l.YOFFSET)

        # create stacks
        x, y, = l.XM, l.YM
        for i in range(8):
            if self.Foundation_Class is RK_FoundationStack:
                suit = ANY_SUIT
            else:
                suit = int(i//2)
            s.foundations.append(self.Foundation_Class(x, y, self,
                                 suit=suit, max_move=0))
            x += l.XS
        x, y = l.XM, l.YM+l.YS
        stack = OpenStack(x, y, self, max_accept=0)
        stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, l.YOFFSET
        s.reserves.append(stack)
        x += l.XS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "s")
        x += l.XS
        s.waste = WasteStack(x, y, self, max_cards=1)
        x += l.XS
        for i in range(5):
            stack = Numerica_RowStack(x, y, self, max_accept=UNLIMITED_ACCEPTS)
            # stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, l.YOFFSET
            s.rows.append(stack)
            x = x + l.XS

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        n = 0
        f = 0
        while True:
            c = self.s.talon.cards[-1]
            if c.rank == ACE:
                r = self.s.foundations[f]
                f += 1
                # r = self.s.foundations[c.suit*2]
            else:
                r = self.s.reserves[0]
                n += 1
            self.s.talon.dealRow(rows=[r])
            if n == 13:
                break
        self.s.talon.dealCards()


class Fly(Frog):

    Foundation_Class = RK_FoundationStack

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == ACE, c.suit))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        for i in range(13):
            self.s.talon.dealRow(self.s.reserves)
        self.s.talon.dealCards()


class Fanny(Frog):

    Foundation_Class = RK_FoundationStack

    def startGame(self):
        self.startDealSample()
        for i in range(11):
            self.s.talon.dealRow(self.s.reserves, flip=0)
        self.s.talon.dealRow(self.s.reserves)
        self.s.talon.dealCards()


# ************************************************************************
# * Gnat
# ************************************************************************

class Gnat(Game):

    Hint_Class = Numerica_Hint

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 8*l.XS, l.YM + 2*l.YS+16*l.YOFFSET)

        # create stacks
        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "s")
        x += l.XS
        s.waste = WasteStack(x, y, self, max_cards=1)
        x += l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += l.XS

        x, y = l.XM+2*l.XS, l.YM+l.YS
        for i in range(4):
            s.rows.append(
                Numerica_RowStack(x, y, self, max_accept=UNLIMITED_ACCEPTS))
            x += l.XS
        x = l.XM+6*l.XS
        for i in range(2):
            y = l.YM + l.YS//2
            for j in range(3):
                s.reserves.append(OpenStack(x, y, self, max_accept=0))
                y += l.YS
            x += l.XS

        # define stack-groups
        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == ACE, c.suit))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealCards()


# ************************************************************************
# * Gloaming
# * Chamberlain
# ************************************************************************

class Gloaming_Hint(Numerica_Hint):
    def computeHints(self):
        self.step010(self.game.s.rows, self.game.s.rows)
        self.step060(self.game.sg.reservestacks, self.game.s.rows)

    # try if we should move a card from a ReserveStack to a RowStack
    def step060(self, reservestacks, rows):
        for r in reservestacks:
            if not r.cards:
                continue
            for t in rows:
                if t.cards:
                    score = self._computeScore(r, t)
                    self.addHint(score, 1, r, t)
                else:
                    self.addHint(90000+r.cards[-1].rank, 1, r, t)


class Gloaming_RowStack(Numerica_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        # this stack accepts any one card from reserves
        return from_stack in self.game.s.reserves


class Gloaming(Game):

    Hint_Class = Gloaming_Hint
    Foundation_Class = SS_FoundationStack

    def createGame(self, reserves=3, rows=5):
        # create layout
        l, s = Layout(self), self.s

        # set window
        n = 52//reserves+1
        w, h = l.XM + (reserves+rows+1)*l.XS, l.YM + 2*l.YS+n*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y = l.XM+(reserves+rows+1-4)*l.XS//2, l.YM
        for i in range(4):
            if self.Foundation_Class is RK_FoundationStack:
                suit = ANY_SUIT
            else:
                suit = i
            s.foundations.append(self.Foundation_Class(x, y, self,
                                 suit=suit, max_move=0))
            x += l.XS

        x, y = l.XM, l.YM+l.YS
        for i in range(reserves):
            stack = OpenStack(x, y, self, max_accept=0)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, l.YOFFSET
            s.reserves.append(stack)
            x += l.XS

        x += l.XS
        for i in range(rows):
            s.rows.append(
                Gloaming_RowStack(x, y, self, max_accept=UNLIMITED_ACCEPTS))
            x += l.XS

        s.talon = InitialDealTalonStack(w-l.XS, h-l.YS, self)

        # default
        l.defaultAll()

    def startGame(self):
        n = 52//len(self.s.reserves)+1
        for i in range(n-3):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRowAvail(rows=self.s.reserves)


class Chamberlain(Gloaming):
    Foundation_Class = RK_FoundationStack

    def createGame(self, reserves=3, rows=5):
        Gloaming.createGame(self, reserves=4, rows=3)


# ************************************************************************
# * Toad
# ************************************************************************


class Toad_TalonStack(DealRowTalonStack):
    def canDealCards(self):
        if not DealRowTalonStack.canDealCards(self):
            return False
        for r in self.game.s.reserves:
            if r.cards:
                return False
        return True

    def dealCards(self, sound=False):
        self.dealRow(rows=self.game.s.reserves, sound=sound)


class Toad(Game):
    Hint_Class = Gloaming_Hint

    def createGame(self, reserves=3, rows=5):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+11*l.XS, l.YM+6*l.YS
        self.setSize(w, h)

        # create stacks
        x, y = w-l.XS, h-l.YS
        s.talon = Toad_TalonStack(x, y, self)
        l.createText(s.talon, "n")
        x, y = l.XM, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2))
            x += l.XS
        x, y = l.XM+3*l.XS//2, l.YM+l.YS
        for i in range(5):
            s.rows.append(
                Gloaming_RowStack(x, y, self, max_accept=UNLIMITED_ACCEPTS))
            x += l.XS
        y = l.YM+l.YS//2
        for i in (3, 3, 3, 3, 1):
            x = l.XM+8*l.XS
            for j in range(i):
                s.reserves.append(OpenStack(x, y, self, max_accept=0))
                x += l.XS
            y += l.YS

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)


# ************************************************************************
# * Shifting
# ************************************************************************

class Shifting_Hint(Numerica_Hint):
    shallMovePile = DefaultHint._cautiousShallMovePile


class Shifting_RowStack(Numerica_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack is self.game.s.waste:
            return True
        if not self.cards:
            return cards[0].rank == KING
        if (from_stack in self.game.s.rows and
                self.cards[-1].rank-cards[0].rank == 1):
            return True
        return False


class Shifting(Numerica):
    Hint_Class = Shifting_Hint
    RowStack_Class = StackWrapper(Shifting_RowStack, max_accept=1)


# ************************************************************************
# * Strategerie
# ************************************************************************

class Strategerie_Talon(OpenTalonStack):
    rightclickHandler = OpenStack.rightclickHandler
    doubleclickHandler = OpenStack.doubleclickHandler


class Strategerie_RowStack(BasicRowStack):

    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack is self.game.s.talon or \
                from_stack in self.game.s.reserves:
            return True
        return False

    getBottomImage = Stack._getReserveBottomImage

    def getHelp(self):
        return _('Tableau. Build regardless of rank and suit.')


class Strategerie_ReserveStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack is self.game.s.talon:
            return True
        return False


class Strategerie(Game):
    Hint_Class = Numerica_Hint

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s
        l.freeCellLayout(rows=4, reserves=4, texts=1)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = Strategerie_Talon(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(RK_FoundationStack(r.x, r.y, self))
        for r in l.s.rows:
            s.rows.append(Strategerie_RowStack(r.x, r.y, self,
                                               max_accept=UNLIMITED_ACCEPTS))
        for r in l.s.reserves:
            s.reserves.append(Strategerie_ReserveStack(r.x, r.y, self))
        # default
        l.defaultAll()
        self.sg.dropstacks.append(s.talon)

    def startGame(self):
        self.startDealSample()
        self.s.talon.fillStack()


# ************************************************************************
# * Assembly
# * Anno Domini
# ************************************************************************

class Assembly_RowStack(RK_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return from_stack is self.game.s.waste
        return True


class Assembly(Numerica):
    Hint_Class = CautiousDefaultHint

    Foundation_Class = StackWrapper(RK_FoundationStack, suit=ANY_SUIT)
    RowStack_Class = StackWrapper(Assembly_RowStack, max_move=1)

    def createGame(self):
        Numerica.createGame(self, waste_max_cards=UNLIMITED_CARDS)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_RK


class AnnoDomini_Hint(DefaultHint):
    def step030(self, foundations, rows, dropstacks):
        pass


class AnnoDomini(Numerica):
    Hint_Class = AnnoDomini_Hint

    Foundation_Class = StackWrapper(SS_FoundationStack, suit=ANY_SUIT, mod=13)
    RowStack_Class = StackWrapper(AC_RowStack, mod=13)

    def createGame(self):
        lay = Numerica.createGame(
            self, max_rounds=3, waste_max_cards=UNLIMITED_CARDS)
        year = str(time.localtime()[0])
        i = 0
        for s in self.s.foundations:
            # setup base_rank & base_suit
            s.cap.suit = i
            s.cap.base_suit = i
            d = int(year[i])
            if d == 0:
                d = JACK
            s.cap.base_rank = d
            i += 1
        lay.createRoundText(self.s.talon, 'nn')

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_ACW


# ************************************************************************
# * Circle Nine
# * Measure
# * Double Measure
# ************************************************************************

class CircleNine_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        return from_stack is self.game.s.talon

    def getHelp(self):
        return _('Tableau. Build regardless of rank and suit.')


class CircleNine(Game):
    Hint_Class = Numerica_Hint

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+7*l.XS, l.YM+3*l.YS)

        for i, j in ((1, 0),
                     (2, 0),
                     (3, 0),
                     (4, 0),
                     (5, 1),
                     (3.5, 2),
                     (2.5, 2),
                     (1.5, 2),
                     (0, 1),
                     ):
            x, y = l.XM+(1+i)*l.XS, l.YM+j*l.YS
            stack = CircleNine_RowStack(x, y, self, max_accept=1,
                                        max_move=1, base_rank=NO_RANK)
            s.rows.append(stack)
            stack.CARD_YOFFSET = 0

        x, y = l.XM+3.5*l.XS, l.YM+l.YS
        stack = RK_FoundationStack(x, y, self, suit=ANY_SUIT, max_cards=52,
                                   max_move=0, mod=13, base_rank=ANY_RANK)
        s.foundations.append(stack)
        l.createText(stack, 'ne')
        x, y = l.XM, l.YM
        s.talon = Strategerie_Talon(x, y, self)
        l.createText(s.talon, 'ne')

        l.defaultStackGroups()
        self.sg.dropstacks.append(s.talon)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealRow()
        self.s.talon.fillStack()

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            if self.s.talon.cards:
                old_state = self.enterState(self.S_FILL)
                self.s.talon.moveMove(1, stack)
                self.leaveState(old_state)


class Measure(CircleNine):

    Foundation_Class = StackWrapper(RK_FoundationStack, max_cards=52)

    def createGame(self, rows=8):
        l, s = Layout(self), self.s
        self.setSize(l.XM+rows*l.XS, l.YM+2*l.YS+10*l.YOFFSET)

        x, y = l.XM, l.YM
        s.talon = Strategerie_Talon(x, y, self)
        l.createText(s.talon, 'ne')
        x = self.width-l.XS
        stack = self.Foundation_Class(x, y, self, suit=ANY_SUIT, max_cards=52,
                                      max_move=0, mod=13, base_rank=ANY_RANK)
        s.foundations.append(stack)
        l.createText(stack, 'nw')

        x, y = l.XM, l.YM+l.YS
        for i in range(rows):
            s.rows.append(CircleNine_RowStack(x, y, self, max_accept=1,
                          max_move=1, base_rank=NO_RANK))
            x += l.XS

        l.defaultStackGroups()
        self.sg.dropstacks.append(s.talon)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.fillStack()


class DoubleMeasure(Measure):
    Foundation_Class = StackWrapper(RK_FoundationStack, max_cards=104)

    def createGame(self, rows=8):
        Measure.createGame(self, rows=10)


# ************************************************************************
# * Amphibian
# ************************************************************************

class Amphibian(Game):
    Hint_Class = Gloaming_Hint

    def createGame(self, rows=5, reserves=4, playcards=15):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 8 * l.XS, l.YM + 3*l.YS + playcards*l.YOFFSET)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(4):
            for j in range(2):
                s.foundations.append(RK_FoundationStack(x, y, self,
                                                        suit=ANY_SUIT))
                x += l.XS
        x, y = l.XM+(8-rows)*l.XS//2, l.YM + l.YS
        for i in range(rows):
            s.rows.append(Gloaming_RowStack(x, y, self, max_accept=1))
            x += l.XS

        x, y = l.XM+(8-reserves-1)*l.XS//2, self.height-l.YS
        for i in range(reserves):
            s.reserves.append(OpenStack(x, y, self, max_accept=0))
            x += l.XS

        s.talon = TalonStack(x, y, self)
        l.createText(s.talon, 'n')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)

    def fillStack(self, stack):
        if stack in self.s.reserves:
            for stack in self.s.reserves:
                if stack.cards:
                    return
            old_state = self.enterState(self.S_FILL)
            self.s.talon.dealRow(rows=self.s.reserves, sound=1)
            self.leaveState(old_state)


# ************************************************************************
# * Aglet
# ************************************************************************

class Aglet(Game):

    def createGame(self, playcards=20, rows=8, reserves=1):

        decks = self.gameinfo.decks
        l, s = Layout(self), self.s
        self.setSize(l.XM+(reserves+0.5+rows)*l.XS,
                     l.YM+max(2*l.YS+7*l.YOFFSET, l.YS+playcards*l.YOFFSET))

        x, y = self.width-l.XS, self.height-l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        x, y = l.XM, l.YM
        for i in range(reserves):
            stack = ReserveStack(x, y, self, max_cards=UNLIMITED_CARDS)
            stack.CARD_YOFFSET = l.YOFFSET
            s.reserves.append(stack)
            x += l.XS

        x, y = l.XM + (reserves+0.5+(rows-decks*4)/2.0)*l.XS, l.YM
        for i in range(4):
            s.foundations.append(RK_FoundationStack(x, y, self, suit=ANY_SUIT))
            x += l.XS

        x, y = l.XM+(reserves+0.5)*l.XS, l.YM+l.YS
        for i in range(rows):
            s.rows.append(BasicRowStack(x, y, self, base_rank=NO_RANK))
            x += l.XS

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == ACE, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startDealNumRows(4)
        self.s.talon.dealRowAvail()
        self.s.talon.dealRowAvail()


# register the game
registerGame(GameInfo(257, Numerica, "Numerica",
                      GI.GT_NUMERICA | GI.GT_CONTRIB, 1, 0, GI.SL_BALANCED,
                      altnames=("Sir Tommy",)))
registerGame(GameInfo(171, LadyBetty, "Lady Betty",
                      GI.GT_NUMERICA, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(355, Frog, "Frog",
                      GI.GT_NUMERICA, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(356, Fly, "Fly",
                      GI.GT_NUMERICA, 2, 0, GI.SL_BALANCED,
                      rules_filename='frog.html'))
registerGame(GameInfo(357, Gnat, "Gnat",
                      GI.GT_NUMERICA, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(378, Gloaming, "Gloaming",
                      GI.GT_NUMERICA | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(379, Chamberlain, "Chamberlain",
                      GI.GT_NUMERICA | GI.GT_OPEN | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(402, Toad, "Toad",
                      GI.GT_NUMERICA, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(430, PussInTheCorner, "Puss in the Corner",
                      GI.GT_NUMERICA, 1, 1, GI.SL_BALANCED))
registerGame(GameInfo(435, Shifting, "Shifting",
                      GI.GT_NUMERICA, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(472, Strategerie, "Strategerie",
                      GI.GT_NUMERICA, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(558, Numerica2Decks, "Numerica (2 decks)",
                      GI.GT_NUMERICA, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(589, LastChance, "Last Chance",
                      GI.GT_NUMERICA, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(599, Assembly, "Assembly",
                      GI.GT_NUMERICA, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(600, AnnoDomini, "Anno Domini",
                      GI.GT_NUMERICA, 1, 2, GI.SL_BALANCED))
registerGame(GameInfo(613, Fanny, "Fanny",
                      GI.GT_NUMERICA, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(641, CircleNine, "Circle Nine",
                      GI.GT_NUMERICA, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(643, Measure, "Measure",
                      GI.GT_NUMERICA | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(644, DoubleMeasure, "Double Measure",
                      GI.GT_NUMERICA | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(754, Amphibian, "Amphibian",
                      GI.GT_NUMERICA | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(760, Aglet, "Aglet",
                      GI.GT_1DECK_TYPE | GI.GT_ORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import pysollib.game
from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.hint import FreeCellSolverWrapper
from pysollib.hint import SpiderType_Hint, YukonType_Hint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.stack import \
        AC_FoundationStack, \
        AC_RowStack, \
        AbstractFoundationStack, \
        BasicRowStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        KingAC_RowStack, \
        OpenStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        Spider_AC_Foundation, \
        Spider_SS_Foundation, \
        Spider_SS_RowStack, \
        StackWrapper, \
        SuperMoveStack_StackMethods, \
        TalonStack, \
        UD_SS_RowStack, \
        WasteStack, \
        WasteTalonStack, \
        Yukon_AC_RowStack, \
        Yukon_SS_RowStack, \
        isAlternateColorSequence, \
        isRankSequence, \
        isSameColorSequence, \
        isSameSuitSequence
from pysollib.util import ACE, ANY_RANK, ANY_SUIT, KING, \
        UNLIMITED_ACCEPTS, UNLIMITED_CARDS, UNLIMITED_MOVES


# ************************************************************************
# *
# ************************************************************************

class Spider_Hint(SpiderType_Hint):
    # FIXME: demo is not too clever in this game

    BONUS_SAME_SUIT_MOVE = 400

    def _preferHighRankMoves(self):
        return 1

    def shallMovePile(self, r, t, pile, rpile):
        if not SpiderType_Hint.shallMovePile(self, r, t, pile, rpile):
            return False
        rr = self.ClonedStack(r, stackcards=rpile)
        if rr.acceptsCards(t, pile):
            # the pile we are going to move from r to t
            # could be moved back from t ro r - this is
            # dangerous for as we can create loops...
            if len(t.cards) == 0:
                return True
            if pile[0].suit == t.cards[-1].suit:
                # The pile will get moved onto the correct suit
                if len(rpile) == 0 or pile[0].suit != rpile[-1].suit:
                    return True
            if self.level <= 1 and len(rpile) == 0:
                return True
            return False
        return True


# ************************************************************************
# *
# ************************************************************************

class Spider_RowStack(Spider_SS_RowStack):
    canDropCards = BasicRowStack.spiderCanDropCards


class SuperMoveSpider_RowStack(SuperMoveStack_StackMethods, Spider_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not Spider_RowStack.acceptsCards(self, from_stack, cards):
            return False
        num_seq = self._getNumSSSeq(cards)
        max_move = self._getMaxMove(len(self.cards))
        return num_seq <= max_move

    def canMoveCards(self, cards):
        if not self.basicCanMoveCards(cards):
            return False
        if not isRankSequence(cards, self.cap.mod, self.cap.dir):
            return False
        num_seq = self._getNumSSSeq(cards)
        max_move = self._getMaxMove(1)
        return num_seq <= max_move


# ************************************************************************
# * Relaxed Spider
# ************************************************************************

class RelaxedSpider(Game):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = DealRowTalonStack
    Foundation_Class = Spider_SS_Foundation
    RowStack_Class = Spider_RowStack
    Hint_Class = Spider_Hint

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s
        kwdefault(layout, rows=10, waste=0, texts=1, playcards=23)
        self.Layout_Method(l, **layout)
        # self.__class__.__dict__['Layout_Method'](l, **layout)
        # self.__class__.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        if l.s.waste:
            s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(r.x, r.y, self, suit=ANY_SUIT))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        # default
        l.defaultAll()

    def startGame(self, flip=0):
        for i in range(4):
            self.s.talon.dealRow(flip=flip, frames=0)
        r = self.s.rows
        rows = (r[0], r[3], r[6], r[9])
        self.s.talon.dealRow(rows=rows, flip=flip, frames=0)
        self._startAndDealRow()

    shallHighlightMatch = Game._shallHighlightMatch_RK
    getQuickPlayScore = Game._getSpiderQuickPlayScore


# ************************************************************************
# * Spider
# ************************************************************************

class Spider(RelaxedSpider):
    def canDealCards(self):
        if not RelaxedSpider.canDealCards(self):
            return False
        # no row may be empty
        for r in self.s.rows:
            if not r.cards:
                return False
        return True


class Spider1Suit(Spider):
    pass


class Spider2Suits(Spider):
    pass


class OpenSpider(Spider):
    def startGame(self):
        Spider.startGame(self, flip=1)


# ************************************************************************
# * Black Widow
# ************************************************************************

class BlackWidow_RowStack(RK_RowStack, Spider_RowStack):
    def canDropCards(self, stacks):
        return Spider_RowStack.canDropCards(self, stacks)


class BlackWidow(Spider):
    RowStack_Class = BlackWidow_RowStack


# ************************************************************************
# * Scheidungsgrund (aka Grounds for a Divorce)
# ************************************************************************

class GroundsForADivorce_Talon(TalonStack):
    # A single click deals a new cards to each non-empty row.
    def dealCards(self, sound=True):
        if self.cards:
            rows = [r for r in self.game.s.rows if r.cards]
            if not rows:
                # deal one card to first row if all rows are emtpy
                rows = self.game.s.rows[:1]
            return self.dealRowAvail(rows=rows, sound=sound)
        return 0


class GroundsForADivorce(RelaxedSpider):
    Layout_Method = staticmethod(Layout.harpLayout)
    Talon_Class = GroundsForADivorce_Talon
    Foundation_Class = StackWrapper(
        Spider_SS_Foundation, base_rank=ANY_RANK, mod=13)
    RowStack_Class = StackWrapper(Spider_RowStack, mod=13)

    def createGame(self):
        RelaxedSpider.createGame(self, playcards=22)

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(4)

    shallHighlightMatch = Game._shallHighlightMatch_RKW


# ************************************************************************
# * Grandmother's Game
# ************************************************************************

class GrandmothersGame(RelaxedSpider):
    Layout_Method = staticmethod(Layout.harpLayout)

    def createGame(self):
        RelaxedSpider.createGame(self, playcards=22)

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(5)


# ************************************************************************
# * Spiderette (Spider with one deck and 7 rows)
# ************************************************************************

class Spiderette(Spider):
    def createGame(self):
        Spider.createGame(self, rows=7, playcards=20)

    def startGame(self):
        for i in range(1, len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=0, frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Baby Spiderette
# ************************************************************************

class BabySpiderette(Spiderette):
    RowStack_Class = BlackWidow_RowStack


# ************************************************************************
# * Will o' the Wisp (just like Spiderette)
# ************************************************************************

class WillOTheWisp(Spiderette):
    def startGame(self):
        for i in range(2):
            self.s.talon.dealRow(flip=0, frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Simple Simon
# ************************************************************************

class SimpleSimon(Spider):
    Talon_Class = InitialDealTalonStack
    RowStack_Class = SuperMoveSpider_RowStack
    Solver_Class = FreeCellSolverWrapper(preset='simple_simon', base_rank=0)

    def createGame(self):
        Spider.createGame(self, rows=10, texts=0)

    def startGame(self):
        for i in (9, 8, 7, 6, 5, 4, 3):
            self.s.talon.dealRow(rows=self.s.rows[:i], frames=0)
        self._startAndDealRow()


class SimpleSimonII(SimpleSimon):
    Solver_Class = None
    Foundation_Class = StackWrapper(Spider_SS_Foundation,
                                    base_rank=ANY_RANK, mod=13)
    RowStack_Class = StackWrapper(SuperMoveSpider_RowStack, mod=13)


# ************************************************************************
# * Rachel
# ************************************************************************

class Rachel(pysollib.game.StartDealRowAndCards, RelaxedSpider):
    Talon_Class = StackWrapper(WasteTalonStack, max_rounds=1)
    RowStack_Class = BlackWidow_RowStack

    def createGame(self):
        RelaxedSpider.createGame(self, waste=1, rows=6, texts=1)


# ************************************************************************
# * Scorpion - move cards like in Russian Solitaire
# * Scorpion Tail - building down by alternate color
# ************************************************************************

class Scorpion_RowStack(Yukon_SS_RowStack, Spider_RowStack):
    canDropCards = Spider_RowStack.canDropCards
    canMoveCards = OpenStack.canMoveCards


class Scorpion(RelaxedSpider):

    Hint_Class = YukonType_Hint
    RowStack_Class = StackWrapper(Scorpion_RowStack, base_rank=KING)

    def createGame(self):
        RelaxedSpider.createGame(self, rows=7, playcards=20)

    def startGame(self):
        for i in (4, 4, 4, 0, 0, 0):
            self.s.talon.dealRow(rows=self.s.rows[:i], flip=0, frames=0)
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=1, frames=0)
        self._startAndDealRow()

    shallHighlightMatch = Game._shallHighlightMatch_SS

    def getHighlightPilesStacks(self):
        return ()


class ScorpionTail_RowStack(Yukon_AC_RowStack, Spider_RowStack):
    canDropCards = Spider_RowStack.canDropCards


class ScorpionTail(Scorpion):
    Foundation_Class = Spider_AC_Foundation
    RowStack_Class = StackWrapper(ScorpionTail_RowStack, base_rank=KING)

    shallHighlightMatch = Game._shallHighlightMatch_AC


class DoubleScorpion(Scorpion):
    Talon_Class = InitialDealTalonStack

    def createGame(self):
        RelaxedSpider.createGame(self, rows=10, playcards=26, texts=0)

    def startGame(self):
        for i in (5, 5, 5, 5, 0, 0, 0, 0, 0):
            self.s.talon.dealRow(rows=self.s.rows[:i], flip=0, frames=0)
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=1, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRowAvail()


class TripleScorpion(Scorpion):
    Talon_Class = InitialDealTalonStack

    def createGame(self):
        RelaxedSpider.createGame(self, rows=13, playcards=30, texts=0)

    def startGame(self):
        for i in (5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0):
            self.s.talon.dealRow(rows=self.s.rows[:i], flip=0, frames=0)
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=1, frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Wasp
# ************************************************************************

class Wasp(Scorpion):
    RowStack_Class = Scorpion_RowStack      # anything on an empty space

    def startGame(self):
        for i in (3, 3, 3, 0, 0, 0):
            self.s.talon.dealRow(rows=self.s.rows[:i], flip=0, frames=0)
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=1, frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Three Blind Mice
# * Farmer's Wife
# ************************************************************************

class ThreeBlindMice(Scorpion):

    Talon_Class = InitialDealTalonStack
    ReserveStack_Class = OpenStack

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        # set window
        w, h = l.XM+10*l.XS, l.XM+2*l.XS+15*l.YOFFSET
        self.setSize(w, h)
        # create stacks
        s.talon = self.Talon_Class(w-l.XS, h-l.YS, self)
        x, y = l.XM+6*l.XS, l.YM
        for i in range(4):
            s.foundations.append(
                self.Foundation_Class(x, y, self, suit=ANY_SUIT))
            x += l.XS
        x, y = l.XM, l.YM+l.YS
        for i in range(10):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += l.XS
        x, y = l.XM, l.YM
        for i in range(2):
            s.reserves.append(self.ReserveStack_Class(x, y, self))
            x += l.XS
        # default
        l.defaultAll()

    def startGame(self):
        for i in range(3):
            self.s.talon.dealRow(rows=self.s.rows[:7], flip=1, frames=0)
            self.s.talon.dealRow(rows=self.s.rows[7:], flip=0, frames=0)
        self.s.talon.dealRow(frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)


class FarmersWife(ThreeBlindMice):
    Foundation_Class = Spider_AC_Foundation
    RowStack_Class = StackWrapper(ScorpionTail_RowStack, base_rank=KING)


class HowTheyRun(ThreeBlindMice):
    ReserveStack_Class = ReserveStack


# ************************************************************************
# * Rouge et Noir
# ************************************************************************

class RougeEtNoir_RowStack(KingAC_RowStack):
    def canDropCards(self, stacks):
        if not self.cards:
            return (None, 0)
        for s in stacks:
            for cards in (self.cards[-1:], self.cards[-13:]):
                if s is not self and s.acceptsCards(self, cards):
                    return (s, len(cards))
        return (None, 0)


class RougeEtNoir(Game):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = DealRowTalonStack
    RowStack_Class = RougeEtNoir_RowStack

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s
        kwdefault(layout, rows=10, waste=0, texts=1, playcards=23)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])
        # create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        if l.s.waste:
            s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)
        for i in range(4):
            r = l.s.foundations[i]
            s.foundations.append(
                AC_FoundationStack(r.x, r.y, self, suit=i, max_move=0))
        for i in range(4):
            r = l.s.foundations[i+4]
            s.foundations.append(Spider_AC_Foundation(r.x, r.y, self))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        # default
        l.defaultAll()
        return l

    def startGame(self, flip=0, reverse=1):
        for i in range(3, len(self.s.rows)):
            self.s.talon.dealRow(
                rows=self.s.rows[:-i], flip=flip, frames=0, reverse=reverse)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:-1], reverse=reverse)

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Mrs. Mop
# ************************************************************************

class MrsMop(RelaxedSpider):

    Talon_Class = InitialDealTalonStack
    RowStack_Class = Spider_RowStack

    def createGame(self):
        RelaxedSpider.createGame(self, rows=13, playcards=24, texts=0)

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(7)


# ************************************************************************
# * Cicely
# ************************************************************************

class Cicely_Talon(DealRowTalonStack):
    def dealCards(self, sound=False):
        n = 0
        if sound:
            self.game.startDealSample()
        for i in range(4):
            n += self.dealRow(rows=self.game.s.rows, sound=False)
        if sound:
            self.game.stopSamples()
        return n


class Cicely(Game):

    Hint_Class = CautiousDefaultHint

    def createGame(self, **layout):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+11*l.XS, l.YM+max(5*l.YS, 2*l.YS+16*l.YOFFSET)
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM+l.YS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            y += l.YS
        x, y = l.XM+10*l.XS, l.YM+l.YS
        for i in range(4):
            s.foundations.append(
                SS_FoundationStack(x, y, self, suit=i, base_rank=KING, dir=-1))
            y += l.YS
        x, y = l.XM+1.5*l.XS, l.YM
        for i in range(8):
            s.reserves.append(ReserveStack(x, y, self))
            x += l.XS
        x, y = l.XM+1.5*l.XS, l.YM+l.YS
        for i in range(8):
            s.rows.append(UD_SS_RowStack(x, y, self))
            x += l.XS
        s.talon = Cicely_Talon(l.XM, l.YM, self)
        l.createText(s.talon, "ne")
        l.setRegion(s.rows, (l.XM+1.5*l.XS-l.CW//2, l.YM+l.YS-l.CH//2,
                             w-1.5*l.XS-l.CW//2, 999999))

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self._startDealNumRowsAndDealSingleRow(3)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Trillium
# * Lily
# * Wake-Robin
# ************************************************************************

class Trillium(Game):

    Hint_Class = Spider_Hint
    RowStack_Class = StackWrapper(AC_RowStack, base_rank=ANY_RANK)

    def createGame(self, rows=13):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+rows*l.XS, l.YM+l.YS+24*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += l.XS

        s.talon = DealRowTalonStack(l.XM+(rows-1)*l.XS//2, h-l.YS, self)
        l.createText(s.talon, "se")

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.s.talon.dealRow(frames=0, flip=0)
        self.s.talon.dealRow(frames=0)
        self.s.talon.dealRow(frames=0, flip=0)
        self._startAndDealRow()

    shallHighlightMatch = Game._shallHighlightMatch_AC

    def isGameWon(self):
        for s in self.s.rows:
            if s.cards:
                if len(s.cards) != 13 or not isAlternateColorSequence(s.cards):
                    return False
        return True


class Lily(Trillium):
    RowStack_Class = StackWrapper(AC_RowStack, base_rank=KING)


class WakeRobin(Trillium):
    RowStack_Class = RK_RowStack

    def createGame(self):
        Trillium.createGame(self, rows=9)

    def isGameWon(self):
        for s in self.s.rows:
            if s.cards:
                if len(s.cards) != 13 or not isRankSequence(s.cards):
                    return False
        return True

    shallHighlightMatch = Game._shallHighlightMatch_RK


class TripleWakeRobin(WakeRobin):
    def createGame(self):
        Trillium.createGame(self, rows=13)


# ************************************************************************
# * Chelicera
# ************************************************************************

class Chelicera_RowStack(Yukon_SS_RowStack):
    def fillStack(self):
        if not self.cards:
            sound = self.game.app.opt.sound and self.game.app.opt.animations
            talon = self.game.s.talon
            if sound:
                self.game.startDealSample()
            for i in range(3):
                if talon.cards:
                    talon.dealToStacks([self], flip=1, frames=4)
            if sound:
                self.game.stopSamples()


class Chelicera(Game):

    Hint_Class = YukonType_Hint

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+8*l.XS, l.YM+l.YS+16*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        s.talon = TalonStack(x, y, self)
        l.createText(s.talon, "s")
        x += l.XS
        for i in range(7):
            s.rows.append(Chelicera_RowStack(x, y, self, base_rank=KING))
            x += l.XS

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRows(4)
        for i in range(3):
            self.s.talon.dealRow(rows=self.s.rows[4:])

    def getHighlightPilesStacks(self):
        return ()

    shallHighlightMatch = Game._shallHighlightMatch_SS

    def isGameWon(self):
        for s in self.s.rows:
            if s.cards:
                if len(s.cards) != 13 or not isSameSuitSequence(s.cards):
                    return False
        return True


# ************************************************************************
# * Scorpion Head
# ************************************************************************

class ScorpionHead(Scorpion):

    Layout_Method = staticmethod(Layout.freeCellLayout)

    def createGame(self, **layout):

        # create layout
        l, s = Layout(self), self.s
        kwdefault(layout, rows=7, reserves=4)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # create stacks
        s.talon = InitialDealTalonStack(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(Spider_SS_Foundation(r.x, r.y, self,
                                                      suit=ANY_SUIT))
        for r in l.s.rows:
            s.rows.append(Scorpion_RowStack(r.x, r.y, self,
                                            base_rank=KING))
        for r in l.s.reserves:
            s.reserves.append(ReserveStack(r.x, r.y, self))

        # default
        l.defaultAll()

    def startGame(self):
        rows = self.s.rows
        for i in (3, 3, 3, 3, 7, 7):
            self.s.talon.dealRow(rows=rows[:i], flip=1, frames=0)
            self.s.talon.dealRow(rows=rows[i:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=rows[:3])


# ************************************************************************
# * Spider Web
# ************************************************************************

class SpiderWeb(RelaxedSpider):

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+2*l.YS+16*l.YOFFSET)

        # create stacks
        x, y = l.XM, l.YM
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, "s")
        x += 2*l.XS
        s.reserves.append(ReserveStack(x, y, self))
        x += 2*l.XS
        for i in range(4):
            s.foundations.append(Spider_SS_Foundation(x, y, self,
                                                      suit=ANY_SUIT))
            x += l.XS
        x, y = l.XM+l.XS, l.YM+l.YS
        for i in range(7):
            s.rows.append(Spider_RowStack(x, y, self,
                                          base_rank=ANY_RANK))
            x += l.XS

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRows(2)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.rows[:3])


# ************************************************************************
# * Simon Jester
# ************************************************************************

class SimonJester(Spider):
    Talon_Class = InitialDealTalonStack

    def createGame(self):
        Spider.createGame(self, rows=14, texts=0)

    def startGame(self):
        for i in range(1, 14):
            self.s.talon.dealRow(rows=self.s.rows[:i], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[1:])


# ************************************************************************
# * Applegate
# ************************************************************************

class Applegate(Game):
    Hint_Class = YukonType_Hint

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+max(l.YS+16*l.YOFFSET, 4*l.YS))

        x, y = l.XM, l.YM
        s.talon = InitialDealTalonStack(x, y, self)
        x += l.XS
        for i in range(7):
            s.rows.append(
                Yukon_SS_RowStack(x, y, self, base_rank=KING, mod=13))
            x += l.XS
        x, y = l.XM, l.YM+l.YS
        for i in range(3):
            s.reserves.append(OpenStack(x, y, self, max_accept=0))
            y += l.YS

        # default
        l.defaultAll()

    def startGame(self):
        for i in (6, 6, 0, 0, 0):
            self.s.talon.dealRow(rows=self.s.rows[:7-i], frames=0)
            if i:
                self.s.talon.dealRow(rows=self.s.rows[7-i:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)

    def isGameWon(self):
        for s in self.s.rows:
            if len(s.cards) == 0:
                continue
            if len(s.cards) != 13 or not isSameSuitSequence(s.cards):
                return False
        return True

    def getHighlightPilesStacks(self):
        return ()

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * Big Spider
# * Spider 3x3
# * Big Divorce
# * Spider (4 decks)
# * Very Big Divorce
# * Chinese Spider
# ************************************************************************

class BigSpider(Spider):
    def createGame(self):
        Spider.createGame(self, rows=13, playcards=28)

    def startGame(self):
        for i in range(5):
            self.s.talon.dealRow(frames=0, flip=0)
        self._startAndDealRow()


class BigSpider1Suit(BigSpider):
    pass


class BigSpider2Suits(BigSpider):
    pass


class Spider3x3(BigSpider):
    def startGame(self):
        for i in range(4):
            self.s.talon.dealRow(frames=0, flip=0)
        self._startAndDealRow()


class GroundsForADivorce3Decks(BigSpider):
    Talon_Class = GroundsForADivorce_Talon
    Foundation_Class = StackWrapper(
        Spider_SS_Foundation, base_rank=ANY_RANK, mod=13)
    RowStack_Class = StackWrapper(Spider_RowStack, mod=13)

    def canDealCards(self):
        return Game.canDealCards(self)
    shallHighlightMatch = Game._shallHighlightMatch_RKW


class Spider4Decks(BigSpider):

    def createGame(self, rows=13):

        l, s = Layout(self), self.s
        w, h = l.XM+(rows+2)*l.XS, l.YM+max(l.YS+24*l.YOFFSET, 9*l.YS)
        self.setSize(w, h)

        x, y = l.XM, l.YM
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += l.XS
        l.setRegion(s.rows, (-999, -999, l.XM+rows*l.XS-l.CW//2, 999999))
        x = l.XM+rows*l.XS
        for i in range(2):
            y = l.YM
            for j in range(8):
                s.foundations.append(self.Foundation_Class(x, y, self))
                y += l.YS
            x += l.XS

        x, y = w-1.5*l.XS, h-l.YS
        s.talon = self.Talon_Class(x, y, self)
        l.createText(s.talon, 'sw')

        l.defaultStackGroups()
        l.defaultRegions()


class GroundsForADivorce4Decks(Spider4Decks):
    Talon_Class = GroundsForADivorce_Talon
    Foundation_Class = StackWrapper(
        Spider_SS_Foundation, base_rank=ANY_RANK, mod=13)
    RowStack_Class = StackWrapper(Spider_RowStack, mod=13)

    def createGame(self):
        Spider4Decks.createGame(self, rows=12)

    def canDealCards(self):
        return Game.canDealCards(self)
    shallHighlightMatch = Game._shallHighlightMatch_RKW


class ChineseSpider(Spider):
    def createGame(self):
        Spider.createGame(self, rows=12, playcards=28)

    def startGame(self):
        for i in range(5):
            self.s.talon.dealRow(frames=0, flip=0)
        self._startAndDealRow()


# ************************************************************************
# * York
# ************************************************************************

class York(RelaxedSpider):

    Talon_Class = InitialDealTalonStack
    Foundation_Class = StackWrapper(
        Spider_SS_Foundation, base_rank=ANY_RANK, mod=13)
    RowStack_Class = StackWrapper(Spider_RowStack, mod=13)

    def createGame(self):
        RelaxedSpider.createGame(self, rows=12, playcards=26, texts=0)

    def startGame(self):
        self._startDealNumRows(8)
        self.s.talon.dealRow(rows=self.s.rows[2:-2])

    shallHighlightMatch = Game._shallHighlightMatch_RKW


class BigYork(York):

    def createGame(self):
        RelaxedSpider.createGame(self, rows=14, playcards=26, texts=0)

    def startGame(self):
        self._startDealNumRows(10)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=[self.s.rows[0], self.s.rows[-1]])

# ************************************************************************
# * Spidike
# * Fred's Spider
# ************************************************************************


class Spidike(RelaxedSpider):
    RowStack_Class = StackWrapper(Spider_SS_RowStack, base_rank=KING)

    def createGame(self, rows=7, playcards=18):
        l, s = Layout(self), self.s
        self.Layout_Method(l, rows=rows, waste=0, playcards=playcards)
        self.setSize(l.size[0], l.size[1])
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                SS_FoundationStack(r.x, r.y, self, suit=r.suit))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))
        l.defaultAll()

    def startGame(self):
        for i in range(1, len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i:], frames=0)
        self._startAndDealRow()


class FredsSpider(Spidike):
    RowStack_Class = Spider_SS_RowStack

    def createGame(self):
        Spidike.createGame(self, rows=10, playcards=23)

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(4)


class FredsSpider3Decks(FredsSpider):

    def createGame(self):
        Spidike.createGame(self, rows=13, playcards=26)


# ************************************************************************
# * Long Tail
# * Short Tail
# ************************************************************************

class LongTail(RelaxedSpider):

    def createGame(self, rows=5, playcards=16):
        l, s = Layout(self), self.s

        decks = self.gameinfo.decks
        max_rows = max(2+decks*4, 2+rows)
        w, h = l.XM+max_rows*l.XS, l.YM+l.YS+playcards*l.YOFFSET
        self.setSize(w, h)

        x, y = l.XM, l.YM
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, 'ne')

        x += (max_rows-decks*4)*l.XS
        for i in range(decks*4):
            s.foundations.append(Spider_SS_Foundation(x, y, self))
            x += l.XS

        x, y = l.XM, l.YM+l.YS
        stack = ReserveStack(x, y, self, max_cards=UNLIMITED_CARDS)
        stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, l.YOFFSET
        s.reserves.append(stack)
        l.createText(stack, 'ne')

        x += 2*l.XS
        for i in range(rows):
            s.rows.append(Spider_RowStack(x, y, self))
            x += l.XS

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves*2)

    def getQuickPlayScore(self, ncards, from_stack, to_stack):
        if to_stack in self.s.reserves:
            return 0
        return 1+RelaxedSpider.getQuickPlayScore(
            self, ncards, from_stack, to_stack)


class ShortTail(LongTail):
    def createGame(self):
        LongTail.createGame(self, rows=8, playcards=24)


# ************************************************************************
# * Incompatibility
# ************************************************************************

class Incompatibility(Spidike):
    Talon_Class = GroundsForADivorce_Talon
    RowStack_Class = Spider_SS_RowStack

    def createGame(self):
        Spidike.createGame(self, rows=10)

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(4)


# ************************************************************************
# * Scorpion II
# ************************************************************************

class ScorpionII(Scorpion):

    def startGame(self):
        for i in (3, 3, 3, 0, 0, 0):
            self.s.talon.dealRow(rows=self.s.rows[:i], flip=0, frames=0)
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=1, frames=0)
        self._startAndDealRow()


# ************************************************************************
# * Tarantula
# ************************************************************************

class Tarantula_RowStack(Spider_RowStack):
    def _isSequence(self, cards):
        return isSameColorSequence(cards, self.cap.mod, self.cap.dir)

    def _isAcceptableSequence(self, cards):
        return isRankSequence(cards, self.cap.mod, self.cap.dir)

    def getHelp(self):
        return _('Tableau. Build down regardless of suit. Sequences of cards '
                 'in the same color can be moved as a unit.')


class Tarantula(Spider):
    RowStack_Class = Tarantula_RowStack

    def getQuickPlayScore(self, ncards, from_stack, to_stack):
        if to_stack.cards:
            if from_stack.cards[-1].suit == to_stack.cards[-1].suit:
                # same suit
                return 3
            elif from_stack.cards[-1].color == to_stack.cards[-1].color:
                # same color
                return 2
            return 1
        return 0


# ************************************************************************
# * Fechter's Game
# ************************************************************************

class FechtersGame_Talon(TalonStack):
    def dealCards(self, sound=True):
        if self.cards:
            rows = []
            for r in self.game.s.rows:
                king_seq = False
                for i in range(len(r.cards)):
                    if isAlternateColorSequence(r.cards[-i-1:]):
                        if r.cards[-i-1].rank == KING:
                            king_seq = True
                            break
                    else:
                        break
                if not king_seq:
                    rows.append(r)
            return self.dealRowAvail(rows=rows, sound=sound)
        return 0


class FechtersGame_RowStack(AC_RowStack):
    def canDropCards(self, stacks):
        if len(self.cards) < 13:
            return (None, 0)
        cards = self.cards[-13:]
        for s in stacks:
            if s is not self and s.acceptsCards(self, cards):
                return (s, 13)
        return (None, 0)


class FechtersGame(RelaxedSpider):
    Talon_Class = FechtersGame_Talon
    Foundation_Class = StackWrapper(
        Spider_AC_Foundation, base_rank=KING, mod=13)
    RowStack_Class = StackWrapper(FechtersGame_RowStack, base_rank=KING)

    def createGame(self):
        RelaxedSpider.createGame(self, rows=12)

    def startGame(self):
        self.s.talon.dealRow(flip=0, frames=0)
        self.s.talon.dealRow(flip=1, frames=0)
        self.s.talon.dealRow(flip=0, frames=0)
        self._startAndDealRow()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Bebop
# ************************************************************************

class Bebop(Game):

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+10*l.XS, l.YM+2*l.YS+18*l.YOFFSET)

        x, y = l.XM+2*l.XS, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2))
            x += l.XS
        x, y = l.XM+l.XS, l.YM+l.YS
        for i in range(8):
            s.rows.append(RK_RowStack(x, y, self))
            x += l.XS
        x, y = l.XM, l.YM
        s.talon = TalonStack(x, y, self)
        l.createText(s.talon, 'ne')

        l.defaultStackGroups()

    def startGame(self):
        for i in range(len(self.s.rows)-1):
            self.s.talon.dealRow(frames=0, flip=0)
        self._startAndDealRow()

    def fillStack(self, stack):
        if stack in self.s.rows:
            if len(stack.cards) == len(self.s.rows)-1:
                for c in stack.cards:
                    if c.face_up:
                        return
                old_state = self.enterState(self.S_FILL)
                for s in self.s.rows:
                    if s is stack:
                        continue
                    stack.flipMove()
                    stack.moveMove(1, s, frames=4)
                for i in range(len(self.s.rows)-1):
                    if self.s.talon.cards:
                        self.s.talon.dealRow(rows=[stack], frames=4, flip=0)
                if self.s.talon.cards:
                    self.s.talon.dealRow(rows=[stack])
                self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * The Jolly Roger
# ************************************************************************

class TheJollyRoger_Foundation(AbstractFoundationStack):

    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        return isSameColorSequence(cards, self.cap.mod, self.cap.dir)

    def getBottomImage(self):
        return self.game.app.images.getLetter(ACE)


class TheJollyRoger_RowStack(BasicRowStack):

    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return True
        c1, c2 = self.cards[-1], cards[0]
        if c2.rank == ACE:
            return c1.rank == ACE
        return c1.rank == c2.rank+2

    def canMoveCards(self, cards):
        if cards[0].rank == ACE:
            return isSameColorSequence(cards, dir=0)
        elif cards[-1].rank == ACE:
            return False                # 5-3-ace
        return isSameSuitSequence(cards, dir=-2)

    def canDropCards(self, stacks):
        cards = self.cards
        if not cards:
            return (None, 0)
        dcards = None
        if cards[-1].rank == ACE:
            if len(cards) < 4:
                return (None, 0)
            if isSameColorSequence(cards[-4:], dir=0):
                dcards = cards[-4:]
        else:
            if len(cards) < 6:
                return (None, 0)
            if isSameSuitSequence(cards, dir=-2):
                dcards = cards[-6:]
        if not dcards:
            return (None, 0)
        for s in stacks:
            if s is not self and s.acceptsCards(self, dcards):
                return (s, len(dcards))
        return (None, 0)


class TheJollyRoger(Game):
    Hint_Class = Spider_Hint

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+13*l.XS, l.YM+3*l.YS+12*l.YOFFSET)

        # create stacks
        y = l.YM
        for i in range(2):
            x = l.XM+2*l.XS
            for j in range(8):
                s.foundations.append(Spider_SS_Foundation(x, y, self,
                                     dir=-2, base_rank=ANY_RANK,
                                     min_accept=6, max_cards=6, max_move=0))
                x += l.XS
            s.foundations.append(TheJollyRoger_Foundation(x, y, self,
                                 suit=ANY_SUIT, dir=0,
                                 min_accept=4, max_accept=4,
                                 max_cards=4, max_move=0))
            y += l.YS

        x, y = l.XM, l.YM+2*l.YS
        for i in range(13):
            s.rows.append(
                TheJollyRoger_RowStack(
                    x, y, self, dir=2,
                    max_move=UNLIMITED_MOVES, max_accept=UNLIMITED_ACCEPTS))
            x += l.XS
        s.talon = DealRowTalonStack(l.XM, l.YM, self)
        l.createText(s.talon, 's')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(2)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        if card1.rank != ACE and card2.rank != ACE:
            # by rank
            return abs(card1.rank-card2.rank) == 2
        return card1.rank == ACE and card2.rank == ACE

    getQuickPlayScore = Game._getSpiderQuickPlayScore


# register the game
registerGame(GameInfo(10, RelaxedSpider, "Relaxed Spider",
                      GI.GT_SPIDER | GI.GT_RELAXED, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(11, Spider, "Spider",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(49, BlackWidow, "Black Widow",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL,
                      altnames=("Scarab",)))
registerGame(GameInfo(14, GroundsForADivorce, "Grounds for a Divorce",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL,
                      altnames=('Scheidungsgrund',)))
registerGame(GameInfo(114, GrandmothersGame, "Grandmother's Game",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(24, Spiderette, "Spiderette",
                      GI.GT_SPIDER, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(47, BabySpiderette, "Baby Spiderette",
                      GI.GT_SPIDER, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(48, WillOTheWisp, "Will o' the Wisp",
                      GI.GT_SPIDER, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(50, SimpleSimon, "Simple Simon",
                      GI.GT_SPIDER | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(194, Rachel, "Rachel",
                      GI.GT_SPIDER | GI.GT_XORIGINAL, 1, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(29, Scorpion, "Scorpion",
                      GI.GT_SPIDER, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(185, Wasp, "Wasp",
                      GI.GT_SPIDER, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(220, RougeEtNoir, "Rouge et Noir",
                      GI.GT_GYPSY, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(269, Spider1Suit, "Spider (1 suit)",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL,
                      suits=(0, 0, 0, 0),
                      rules_filename="spider.html"))
registerGame(GameInfo(270, Spider2Suits, "Spider (2 suits)",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL,
                      suits=(0, 0, 2, 2),
                      rules_filename="spider.html"))
registerGame(GameInfo(305, ThreeBlindMice, "Three Blind Mice",
                      GI.GT_SPIDER, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(309, MrsMop, "Mrs. Mop",
                      GI.GT_SPIDER | GI.GT_OPEN, 2, 0, GI.SL_SKILL))
registerGame(GameInfo(341, Cicely, "Cicely",
                      GI.GT_SPIDER, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(342, Trillium, "Trillium",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(343, Lily, "Lily",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(344, Chelicera, "Chelicera",
                      GI.GT_SPIDER, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(345, ScorpionHead, "Scorpion Head",
                      GI.GT_SPIDER, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(346, ScorpionTail, "Scorpion Tail",
                      GI.GT_SPIDER, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(359, SpiderWeb, "Spider Web",
                      GI.GT_SPIDER, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(366, SimonJester, "Simon Jester",
                      GI.GT_SPIDER | GI.GT_OPEN, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(382, Applegate, "Applegate",
                      GI.GT_SPIDER, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(384, BigSpider, "Big Spider",
                      GI.GT_SPIDER, 3, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(401, GroundsForADivorce3Decks, "Big Divorce",
                      GI.GT_SPIDER, 3, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(441, York, "York",
                      GI.GT_SPIDER | GI.GT_OPEN | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_SKILL))
registerGame(GameInfo(444, BigYork, "Big York",
                      GI.GT_SPIDER | GI.GT_OPEN | GI.GT_ORIGINAL, 3, 0,
                      GI.SL_SKILL))
registerGame(GameInfo(445, BigSpider1Suit, "Big Spider (1 suit)",
                      GI.GT_SPIDER, 3, 0, GI.SL_MOSTLY_SKILL,
                      suits=(0, 0, 0, 0),
                      rules_filename="bigspider.html"))
registerGame(GameInfo(446, BigSpider2Suits, "Big Spider (2 suits)",
                      GI.GT_SPIDER, 3, 0, GI.SL_MOSTLY_SKILL,
                      suits=(0, 0, 2, 2),
                      rules_filename="bigspider.html"))
registerGame(GameInfo(449, Spider3x3, "Spider 3x3",
                      GI.GT_SPIDER | GI.GT_ORIGINAL, 3, 0, GI.SL_MOSTLY_SKILL,
                      suits=(0, 1, 2),
                      rules_filename="bigspider.html"))
registerGame(GameInfo(454, Spider4Decks, "Spider (4 decks)",
                      GI.GT_SPIDER, 4, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(455, GroundsForADivorce4Decks, "Very Big Divorce",
                      GI.GT_SPIDER, 4, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(458, Spidike, "Spidike",
                      GI.GT_SPIDER, 1, 0, GI.SL_BALANCED))  # GT_GYPSY ?
registerGame(GameInfo(459, FredsSpider, "Fred's Spider",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(460, FredsSpider3Decks, "Fred's Spider (3 decks)",
                      GI.GT_SPIDER, 3, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(461, OpenSpider, "Open Spider",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL,
                      altnames=('Beetle',)))
registerGame(GameInfo(501, WakeRobin, "Wake-Robin",
                      GI.GT_SPIDER | GI.GT_ORIGINAL, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(502, TripleWakeRobin, "Wake-Robin (3 decks)",
                      GI.GT_SPIDER | GI.GT_ORIGINAL, 3, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(511, DoubleScorpion, "Double Scorpion",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(512, TripleScorpion, "Triple Scorpion",
                      GI.GT_SPIDER, 3, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(543, FarmersWife, "Farmer's Wife",
                      GI.GT_SPIDER, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(544, HowTheyRun, "How They Run",
                      GI.GT_SPIDER, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(570, LongTail, "Long Tail",
                      GI.GT_SPIDER, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(571, ShortTail, "Short Tail",
                      GI.GT_SPIDER | GI.GT_ORIGINAL, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(670, ChineseSpider, "Chinese Spider",
                      GI.GT_SPIDER, 4, 0, GI.SL_MOSTLY_SKILL,
                      suits=(0, 1, 2),))
registerGame(GameInfo(671, Incompatibility, "Incompatibility",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(672, ScorpionII, "Scorpion II",
                      GI.GT_SPIDER, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(680, Tarantula, "Tarantula",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(685, FechtersGame, "Fechter's Game",
                      GI.GT_SPIDER, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(710, Bebop, "Bebop",
                      GI.GT_2DECK_TYPE | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
# registerGame(GameInfo(000, SimpleSimonII, "Simple Simon II",
#                      GI.GT_SPIDER | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(711, TheJollyRoger, "The Jolly Roger",
                      GI.GT_SPIDER | GI.GT_ORIGINAL, 2, 0, GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint, FreeCellType_Hint
from pysollib.hint import FreeCellSolverWrapper
from pysollib.layout import Layout
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AC_RowStack, \
        AbstractFoundationStack, \
        FreeCell_AC_RowStack, \
        InitialDealTalonStack, \
        OpenStack, \
        RK_FoundationStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        StackWrapper, \
        TalonStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, ANY_RANK, ANY_SUIT, KING, NO_RANK, \
        QUEEN, RANKS, UNLIMITED_ACCEPTS


class DerKatzenschwanz_Hint(FreeCellType_Hint):
    def _getMovePileScore(self, score, color, r, t, pile, rpile):
        if len(rpile) == 0:
            # don't create empty row
            return -1, color
        return FreeCellType_Hint._getMovePileScore(
            self, score, color, r, t, pile, rpile)


# ************************************************************************
# *
# ************************************************************************

class DerKatzenschwanz(Game):
    RowStack_Class = StackWrapper(AC_RowStack, base_rank=NO_RANK)
    Hint_Class = DerKatzenschwanz_Hint
    Solver_Class = FreeCellSolverWrapper(esf='none', sm='unlimited')

    #
    # game layout
    #

    def createGame(self, rows=9, reserves=8):
        # create layout
        l, s = Layout(self), self.s

        # set size
        maxrows = max(rows, reserves)
        self.setSize(l.XM + (maxrows+2)*l.XS, l.YM + 6*l.YS)

        #
        playcards = 4*l.YS // l.YOFFSET
        xoffset, yoffset = [], []
        for i in range(playcards):
            xoffset.append(0)
            yoffset.append(l.YOFFSET)
        for i in range(104-playcards):
            xoffset.append(l.XOFFSET)
            yoffset.append(0)

        # create stacks
        x, y = l.XM + (maxrows-reserves)*l.XS//2, l.YM
        for i in range(reserves):
            s.reserves.append(ReserveStack(x, y, self))
            x = x + l.XS
        x, y = l.XM + (maxrows-rows)*l.XS//2, l.YM + l.YS
        self.setRegion(s.reserves, (-999, -999, 999999, y - l.CH // 2))
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self)
            stack.CARD_XOFFSET = xoffset
            stack.CARD_YOFFSET = yoffset
            s.rows.append(stack)
            x = x + l.XS
        x, y = l.XM + maxrows*l.XS, l.YM
        for suit in range(4):
            for i in range(2):
                s.foundations.append(
                    SS_FoundationStack(x+i*l.XS, y, self, suit=suit))
            y = y + l.YS
        self.setRegion(
            self.s.foundations, (x - l.CW // 2, -999, 999999, y), priority=1)
        s.talon = InitialDealTalonStack(
            self.width-3*l.XS//2, self.height-l.YS, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        i = 0
        while self.s.talon.cards:
            if self.s.talon.cards[-1].rank == KING:
                if self.s.rows[i].cards:
                    i = i + 1
            self.s.talon.dealRow(rows=[self.s.rows[i]], frames=4)

    shallHighlightMatch = Game._shallHighlightMatch_AC

    # must look at cards
    def _getClosestStack(self, cx, cy, stacks, dragstack):
        closest, cdist = None, 999999999
        for stack in stacks:
            if stack.cards and stack is not dragstack:
                dist = (stack.cards[-1].x - cx)**2 + \
                    (stack.cards[-1].y - cy)**2
            else:
                dist = (stack.x - cx)**2 + (stack.y - cy)**2
            if dist < cdist:
                closest, cdist = stack, dist
        return closest


# ************************************************************************
# *
# ************************************************************************

class DieSchlange(DerKatzenschwanz):

    RowStack_Class = StackWrapper(FreeCell_AC_RowStack, base_rank=NO_RANK)
    Solver_Class = FreeCellSolverWrapper(esf='none')

    def createGame(self):
        DerKatzenschwanz.createGame(self, rows=9, reserves=7)

    def startGame(self):
        self.startDealSample()
        i = 0
        while self.s.talon.cards:
            c = self.s.talon.cards[-1]
            if c.rank == ACE:
                to_stack = self.s.foundations[c.suit*2]
                if to_stack.cards:
                    to_stack = self.s.foundations[c.suit*2+1]
            else:
                if c.rank == KING and self.s.rows[i].cards:
                    i = i + 1
                to_stack = self.s.rows[i]
            self.s.talon.dealRow(rows=(to_stack,), frames=4)


# ************************************************************************
# * Kings
# ************************************************************************

class Kings(DerKatzenschwanz):

    RowStack_Class = StackWrapper(AC_RowStack, base_rank=NO_RANK)
    Solver_Class = FreeCellSolverWrapper(esf='none', sm='unlimited')

    def createGame(self):
        return DerKatzenschwanz.createGame(self, rows=8, reserves=8)

    def _shuffleHook(self, cards):
        for c in cards[:]:
            if c.rank == KING:
                cards.remove(c)
                break
        cards.append(c)
        return cards


# ************************************************************************
# * Retinue
# ************************************************************************

class Retinue(DieSchlange, Kings):

    RowStack_Class = StackWrapper(FreeCell_AC_RowStack, base_rank=NO_RANK)
    Solver_Class = FreeCellSolverWrapper(esf='none')

    def createGame(self):
        return DerKatzenschwanz.createGame(self, rows=8, reserves=8)

    def _shuffleHook(self, cards):
        return Kings._shuffleHook(self, cards)

    def startGame(self):
        return DieSchlange.startGame(self)


# ************************************************************************
# * Salic Law
# ************************************************************************

class SalicLaw_Hint(CautiousDefaultHint):

    # Score for dropping ncards from stack r to stack t.
    def _getDropCardScore(self, score, color, r, t, ncards):
        return score+len(r.cards), color


class SalicLaw_Talon(TalonStack):

    def dealCards(self, sound=False):
        if len(self.cards) == 0:
            return 0
        base_rank = self.game.ROW_BASE_RANK
        self.game.enterState(self.game.S_DEAL)
        rows = self.game.s.rows
        c = self.cards[-1]
        ri = len([r for r in rows if r.cards])
        if c.rank == base_rank:
            to_stack = rows[ri]
        else:
            to_stack = rows[ri-1]
        if sound and not self.game.demo:
            self.game.startDealSample()
        self.dealToStacks(stacks=[to_stack])
        if sound and not self.game.demo:
            self.game.stopSamples()
        return 1


# all Aces go to the Foundations
class SalicLaw_Talon_2(SalicLaw_Talon):
    def dealCards(self, sound=False):
        if len(self.cards) == 0:
            return 0
        if self.cards[-1].rank == ACE:
            for f in self.game.s.foundations:
                if not f.cards:
                    break
            if sound and not self.game.demo:
                self.game.startDealSample()
            self.dealToStacks(stacks=[f])
            if sound and not self.game.demo:
                self.game.stopSamples()
            return 1
        else:
            return SalicLaw_Talon.dealCards(self, sound=sound)


class SalicLaw_RowStack(OpenStack):
    def acceptsCards(self, from_stack, cards):
        if len(self.cards) == 1:
            return True
        return False
        return OpenStack.acceptsCards(self, from_stack, cards)


class SalicLaw_Foundation(RK_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack not in self.game.s.rows:
            return False
        row_id = self.id + 8
        return len(self.game.allstacks[row_id].cards) > 0


class SalicLaw(DerKatzenschwanz):

    Hint_Class = SalicLaw_Hint
    Solver_Class = None

    Talon_Class = SalicLaw_Talon_2
    Foundation_Classes = [
        StackWrapper(AbstractFoundationStack, max_cards=1, base_rank=QUEEN),
        StackWrapper(SalicLaw_Foundation, max_cards=11, base_rank=ACE),
        ]
    RowStack_Class = StackWrapper(SalicLaw_RowStack, min_cards=1,
                                  max_accept=UNLIMITED_ACCEPTS)

    ROW_BASE_RANK = KING

    #
    # game layout
    #

    def createGame(self):  # , rows=9, reserves=8):
        # create layout
        l, s = Layout(self), self.s

        # set size
        self.setSize(l.XM+10*l.XS, l.YM+(5+len(self.Foundation_Classes))*l.YS)

        #
        playcards = 4*l.YS // l.YOFFSET
        xoffset, yoffset = [], []
        for i in range(playcards):
            xoffset.append(0)
            yoffset.append(l.YOFFSET)
        for i in range(104-playcards):
            xoffset.append(l.XOFFSET)
            yoffset.append(0)

        # create stacks
        y = l.YM
        for found_class in self.Foundation_Classes:
            x = l.XM
            for i in range(8):
                s.foundations.append(found_class(x, y, self,
                                                 suit=ANY_SUIT, max_move=0))
                x += l.XS
            y += l.YS

        x, y = l.XM, l.YM+l.YS*len(self.Foundation_Classes)
        self.setRegion(s.foundations, (-999, -999, 999999, y - l.XM // 2))
        for i in range(8):
            stack = self.RowStack_Class(x, y, self, max_move=1)
            stack.CARD_XOFFSET = xoffset
            stack.CARD_YOFFSET = yoffset
            s.rows.append(stack)
            x += l.XS
        s.talon = self.Talon_Class(l.XM+9*l.XS, l.YM, self)
        l.createText(s.talon, "s")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        for c in cards[:]:
            if c.rank == KING:
                cards.remove(c)
                break
        cards.append(c)
        cards = self._shuffleHookMoveToTop(cards,
                                           lambda c: (c.rank == QUEEN, None))
        return cards

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(self.s.foundations[:8])  # deal Queens
        self.s.talon.dealRow(self.s.rows[:1])  # deal King

    def isGameWon(self):
        for s in self.s.foundations[8:]:
            if len(s.cards) != 11:
                return False
        return True


# ************************************************************************
# * Deep
# ************************************************************************

class Deep(DerKatzenschwanz):
    RowStack_Class = StackWrapper(AC_RowStack, base_rank=ANY_RANK)
    Solver_Class = FreeCellSolverWrapper(sm='unlimited')

    def createGame(self):
        return DerKatzenschwanz.createGame(self, rows=8, reserves=8)

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(12)


# ************************************************************************
# * Faerie Queen
# ************************************************************************

class FaerieQueen_RowStack(RK_RowStack):
    def acceptsCards(self, from_stack, cards):
        if self.game.s.talon.cards:
            return False
        if len(self.cards) == 1:
            return True
        return RK_RowStack.acceptsCards(self, from_stack, cards)


class FaerieQueen(SalicLaw):

    Talon_Class = SalicLaw_Talon
    Foundation_Classes = [
        StackWrapper(RK_FoundationStack, max_move=0, max_cards=12)
        ]
    RowStack_Class = StackWrapper(
        FaerieQueen_RowStack, min_cards=1, max_move=1)

    def _shuffleHook(self, cards):
        for c in cards[:]:
            if c.rank == KING:
                cards.remove(c)
                break
        cards.append(c)
        return cards

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(self.s.rows[:1])  # deal King

    def isGameWon(self):
        if self.s.talon.cards:
            return False
        for s in self.s.foundations:
            if len(s.cards) != 12:
                return False
        return True

    def getQuickPlayScore(self, ncards, from_stack, to_stack):
        return int(len(to_stack.cards) > 1)

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Intrigue
# * Laggard Lady
# * Glencoe
# ************************************************************************

class Intrigue_RowStack(OpenStack):
    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return False
        return len(self.game.s.talon.cards) == 0 and len(self.cards) == 1


class Intrigue(SalicLaw):

    Talon_Class = SalicLaw_Talon
    Foundation_Classes = [
        StackWrapper(RK_FoundationStack, base_rank=5, max_cards=6),
        StackWrapper(
            RK_FoundationStack, base_rank=4, max_cards=6, dir=-1, mod=13),
        ]
    RowStack_Class = StackWrapper(Intrigue_RowStack, max_accept=1, min_cards=1)

    ROW_BASE_RANK = QUEEN

    def _shuffleHook(self, cards):
        for c in cards[:]:
            if c.rank == QUEEN:
                cards.remove(c)
                break
        cards.append(c)
        return cards

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(self.s.rows[:1])  # deal King

    def isGameWon(self):
        if self.s.talon.cards:
            return False
        for s in self.s.foundations:
            if len(s.cards) != 6:
                return False
        return True


class LaggardLady_Foundation(RK_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        c = cards[0]
        if c.rank in (4, 5):
            i = list(self.game.s.foundations).index(self) % 8
            r = self.game.s.rows[i]
            if not r.cards:
                return False
        return True


class LaggardLady(Intrigue):
    Foundation_Classes = [
        StackWrapper(LaggardLady_Foundation, base_rank=5, max_cards=6),
        StackWrapper(
            LaggardLady_Foundation, base_rank=4, max_cards=6, dir=-1, mod=13),
        ]


class Glencoe_Foundation(RK_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        c = cards[0]
        if c.rank in (4, 5):
            i = list(self.game.s.foundations).index(self) % 8
            r = self.game.s.rows[i]
            if not r.cards:
                return False
            return c.suit == r.cards[0].suit
        return True


class Glencoe(Intrigue):
    Foundation_Classes = [
        StackWrapper(Glencoe_Foundation, base_rank=5, max_cards=6),
        StackWrapper(
            Glencoe_Foundation, base_rank=4, max_cards=6, dir=-1, mod=13),
        ]


# ************************************************************************
# * Step-Up
# ************************************************************************

class StepUp_Foundation(SS_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack in self.game.s.reserves:
            return True
        for r in self.game.s.reserves:
            if not r.cards:
                return True
        return False


class StepUp_Talon(WasteTalonStack):
    def canDealCards(self):
        if not WasteTalonStack.canDealCards(self):
            return False
        for r in self.game.s.reserves:
            if not r.cards:
                return False
        return True


class StepUp_RowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if (from_stack in self.game.s.reserves or
                from_stack in self.game.s.foundations):
            return False
        return True


class StepUp(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+13*l.XS, l.YM+7*l.YS)
        self.base_rank = ANY_RANK

        x, y = l.XM+2.5*l.XS, l.YM
        for i in range(8):
            s.foundations.append(StepUp_Foundation(x, y, self,
                                 suit=i % 4, mod=13, base_rank=ANY_RANK))
            x += l.XS
        tx, ty, ta, tf = l.getTextAttr(s.foundations[0], "sw")
        font = self.app.getFont("canvas_default")
        self.texts.info = MfxCanvasText(self.canvas, tx, ty,
                                        anchor=ta, font=font)

        x, y = l.XM, l.YM+l.YS
        for i in range(13):
            s.reserves.append(ReserveStack(x, y, self))
            x += l.XS
        x, y = l.XM+2*l.XS, l.YM+2*l.YS
        for i in range(9):
            s.rows.append(StepUp_RowStack(x, y, self, max_move=1, mod=13))
            x += l.XS

        x, y = l.XM, l.YM+2.5*l.YS
        s.talon = StepUp_Talon(x, y, self, max_rounds=1)
        l.createText(s.talon, 'se')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'se')

        l.defaultStackGroups()

    def startGame(self):
        c = self.s.talon.cards[-1]
        self.base_rank = c.rank
        self.s.talon.flipMove()
        self.s.talon.moveMove(1, self.s.foundations[c.suit], frames=0)
        for s in self.s.foundations:
            s.cap.base_rank = c.rank
        self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def updateText(self):
        if self.preview > 1:
            return
        base_rank = self.base_rank
        if base_rank == ANY_RANK:
            t = ''
        else:
            t = RANKS[base_rank]
        self.texts.info.config(text=t)

    def _restoreGameHook(self, game):
        self.base_rank = game.loadinfo.base_rank
        for s in self.s.foundations:
            s.cap.base_rank = self.base_rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_rank=None)    # register extra load var.
        self.loadinfo.base_rank = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_rank)

    shallHighlightMatch = Game._shallHighlightMatch_ACW


# ************************************************************************
# * Kentish
# ************************************************************************

class Kentish(Kings):
    Solver_Class = FreeCellSolverWrapper(sbb='rank', sm='unlimited')

    def createGame(self, rows=8):
        # create layout
        l, s = Layout(self), self.s

        # set size
        self.setSize(l.XM + (rows+2)*l.XS, l.YM + 5*l.YS)

        #
        playcards = 4*l.YS // l.YOFFSET
        xoffset, yoffset = [], []
        for i in range(playcards):
            xoffset.append(0)
            yoffset.append(l.YOFFSET)
        for i in range(104-playcards):
            xoffset.append(l.XOFFSET)
            yoffset.append(0)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(rows):
            stack = RK_RowStack(x, y, self)
            stack.CARD_XOFFSET = xoffset
            stack.CARD_YOFFSET = yoffset
            s.rows.append(stack)
            x += l.XS
        x, y = l.XM + rows*l.XS, l.YM
        for suit in range(4):
            for i in range(2):
                s.foundations.append(RK_FoundationStack(x+i*l.XS, y, self,
                                                        suit=suit))
            y += l.YS
        self.setRegion(self.s.foundations,
                       (x - l.CW // 2, -999, 999999, y), priority=1)
        x, y = self.width-3*l.XS//2, self.height-l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # define stack-groups
        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        for c in cards[:]:
            if c.rank == ACE:
                cards.remove(c)
                break
        cards.insert(0, c)
        return cards

    def startGame(self):
        self.startDealSample()
        i = 0
        while self.s.talon.cards:
            r = self.s.talon.cards[-1].rank
            self.s.talon.dealRow(rows=[self.s.rows[i]], frames=4)
            if r == ACE:
                i += 1

    shallHighlightMatch = Game._shallHighlightMatch_RK


# register the game
registerGame(GameInfo(141, DerKatzenschwanz, "Cat's Tail",
                      GI.GT_FREECELL | GI.GT_OPEN, 2, 0, GI.SL_MOSTLY_SKILL,
                      altnames=("Der Katzenschwanz",)))
registerGame(GameInfo(142, DieSchlange, "Snake",
                      GI.GT_FREECELL | GI.GT_OPEN, 2, 0, GI.SL_MOSTLY_SKILL,
                      altnames=("Die Schlange",)))
registerGame(GameInfo(279, Kings, "Kings",
                      GI.GT_FREECELL | GI.GT_OPEN, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(286, Retinue, "Retinue",
                      GI.GT_FREECELL | GI.GT_OPEN | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(299, SalicLaw, "Salic Law",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(442, Deep, "Deep",
                      GI.GT_FREECELL | GI.GT_OPEN | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(523, Intrigue, "Intrigue",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(611, FaerieQueen, "Faerie Queen",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(612, Glencoe, "Glencoe",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED,
                      rules_filename="intrigue.html"))
registerGame(GameInfo(616, LaggardLady, "Laggard Lady",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED,
                      rules_filename="intrigue.html"))
registerGame(GameInfo(624, StepUp, "Step-Up",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(766, Kentish, "Kentish",
                      GI.GT_2DECK_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import AbstractHint
from pysollib.layout import Layout
from pysollib.stack import \
        AbstractFoundationStack, \
        DealRowTalonStack, \
        ReserveStack, \
        Stack
from pysollib.util import ANY_RANK, ANY_SUIT


class PushPin_Hint(AbstractHint):

    def computeHints(self):
        game = self.game
        rows = game.s.rows
        for i in range(len(rows)-3):
            r = rows[i+1]
            if not rows[i+2].cards:
                break
            if r._checkPair(i, i+2):
                self.addHint(5000, 1, r, game.s.foundations[0])
            if not rows[i+3].cards:
                break
            if r._checkPair(i, i+3):
                self.addHint(5000, 1, r, rows[i+2])


class PushPin_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        return True


class PushPin_Talon(DealRowTalonStack):
    def dealCards(self, sound=False):
        for r in self.game.s.rows:
            if not r.cards:
                return self.dealRowAvail(rows=[r], sound=sound)
        return self.dealRowAvail(rows=[self.game.s.rows[0]], sound=sound)
    getBottomImage = Stack._getNoneBottomImage


class PushPin_RowStack(ReserveStack):

    def _checkPair(self, ps, ns):
        if ps < 0 or ns > 51:
            return False
        rows = self.game.allstacks
        pc, nc = rows[ps].cards, rows[ns].cards
        if pc and nc:
            if pc[0].suit == nc[0].suit or pc[0].rank == nc[0].rank:
                return True
        return False

    def clickHandler(self, event):
        ps, ns = self.id - 1, self.id + 1
        if self._checkPair(ps, ns):
            if not self.game.demo:
                self.game.playSample("autodrop", priority=20)
            self.playMoveMove(1, self.game.s.foundations[0], sound=False)
            return True
        return False

    def acceptsCards(self, from_stack, cards):
        if not self.cards:
            return False
        if abs(self.id - from_stack.id) != 1:
            return False
        ps = min(self.id, from_stack.id)-1
        ns = ps + 3
        return self._checkPair(ps, ns)

    def fillStack(self):
        self.game.fillEmptyStacks()

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        if to_stack is not self.game.s.foundations[0]:
            self._dropPairMove(ncards, to_stack, frames=-1, shadow=shadow)
        else:
            ReserveStack.moveMove(
                self, ncards, to_stack, frames=frames, shadow=shadow)

    def _dropPairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        old_state = game.enterState(game.S_FILL)
        f = game.s.foundations[0]
        game.updateStackMove(game.s.talon, 2 | 16)            # for undo
        if not game.demo:
            game.playSample("droppair", priority=200)
        game.moveMove(n, self, f, frames=frames, shadow=shadow)
        game.moveMove(n, other_stack, f, frames=frames, shadow=shadow)
        self.fillStack()
        game.updateStackMove(game.s.talon, 1 | 16)            # for redo
        game.leaveState(old_state)

    getBottomImage = Stack._getBlankBottomImage


class PushPin(Game):

    Hint_Class = PushPin_Hint
    RowStack_Class = PushPin_RowStack

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        xx, yy = 9, 6
        w, h = l.XM+xx*l.XS, l.YM+yy*l.YS
        self.setSize(w, h)

        # create stacks
        for i in range(yy):
            for j in range(xx):
                n = j+xx*i
                if n < 1:
                    continue
                if n > 52:
                    break
                k = j
                if i % 2:
                    k = xx-j-1
                x, y = l.XM + k*l.XS, l.YM + i*l.YS
                s.rows.append(self.RowStack_Class(x, y, self))
        s.talon = PushPin_Talon(l.XM, l.YM, self)
        s.foundations.append(PushPin_Foundation(l.XM, h-l.YS, self,
                             suit=ANY_SUIT, dir=0, base_rank=ANY_RANK,
                             max_accept=0, max_move=0, max_cards=52))

        # define stack-groups
        l.defaultStackGroups()
        return l

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:3])

    def isGameWon(self):
        return len(self.s.foundations[0].cards) == 50

    def _fillOne(self):
        rows = self.s.rows
        i = 0
        for r in rows:
            if not r.cards:
                break
            i += 1
        j = i
        for r in rows[i:]:
            if r.cards:
                break
            j += 1
        else:
            return 0
        self.moveMove(1, rows[j], rows[i], frames=2, shadow=0)
        return 1

    def fillEmptyStacks(self):
        if not self.demo:
            self.startDealSample()
        old_state = self.enterState(self.S_FILL)
        while True:
            if not self._fillOne():
                break
        self.leaveState(old_state)
        if not self.demo:
            self.stopSamples()

    def getAutoStacks(self, event=None):
        return ((), (), ())


class RoyalMarriage(PushPin):
    def _shuffleHook(self, cards):
        qi, ki = -1, -1
        for i in range(len(cards)):
            c = cards[i]
            if c.suit == 2 and c.rank == 11:
                qi = i
            if c.suit == 2 and c.rank == 12:
                ki = i
            if qi >= 0 and ki >= 0:
                break
        q, k = cards[qi], cards[ki]
        del cards[max(qi, ki)]
        del cards[min(qi, ki)]
        cards.insert(0, k)
        cards.append(q)
        return cards


class Queens(PushPin):
    def startGame(self):
        self._startAndDealRow()


# ************************************************************************
# * Bayan (ex. Accordion)
# ************************************************************************

class Accordion_Hint(AbstractHint):

    def computeHints(self):
        game = self.game
        rows = game.s.rows
        for i in range(len(rows)-3):
            r1, r2 = rows[i], rows[i+1]
            if r1.cards and r2.cards:
                c1, c2 = r1.cards[0], r2.cards[0]
                if c1.rank == c2.rank or c1.suit == c2.suit:
                    if r2.acceptsCards(r1, [c1]):
                        self.addHint(5000, 1, r1, r2)
                    if r1.acceptsCards(r2, [c2]):
                        self.addHint(5000, 1, r2, r1)
            r1, r2 = rows[i], rows[i+3]
            if r1.cards and r2.cards:
                c1, c2 = r1.cards[0], r2.cards[0]
                if c1.rank == c2.rank or c1.suit == c2.suit:
                    if r2.acceptsCards(r1, [c1]):
                        self.addHint(6000, 1, r1, r2)
                    if r1.acceptsCards(r2, [c2]):
                        self.addHint(6000, 1, r2, r1)


class Accordion_RowStack(PushPin_RowStack):

    def acceptsCards(self, from_stack, cards):
        if not self.cards:
            return False
        if abs(self.id - from_stack.id) not in (1, 3):
            return False
        c1, c2 = self.cards[-1], cards[0]
        if c1.rank == c2.rank:
            return True
        return c1.suit == c2.suit

    clickHandler = ReserveStack.clickHandler


class Accordion(PushPin):
    Hint_Class = Accordion_Hint
    RowStack_Class = Accordion_RowStack

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:2])

    def isGameWon(self):
        return len(self.s.foundations[0].cards) == 52

# ************************************************************************
# * Accordion (fixed)
# ************************************************************************


class Accordion2_RowStack(Accordion_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not Accordion_RowStack.acceptsCards(self, from_stack, cards):
            return False
        # accepts only from right stack
        return self.id < from_stack.id

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        game = self.game
        old_state = game.enterState(game.S_FILL)
        f = game.s.foundations[0]
        game.updateStackMove(game.s.talon, 2 | 16)            # for undo

        game.moveMove(ncards, to_stack, f, frames=frames, shadow=shadow)
        game.moveMove(ncards, self, to_stack, frames=frames, shadow=shadow)
        self.fillStack()

        game.updateStackMove(game.s.talon, 1 | 16)            # for redo
        game.leaveState(old_state)


class Accordion2(Accordion):
    RowStack_Class = Accordion2_RowStack

    def isGameWon(self):
        return len(self.s.foundations[0].cards) == 51

# ************************************************************************
# * Relaxed Accordion
# ************************************************************************


class RelaxedAccordion_RowStack(Accordion2_RowStack):
    acceptsCards = Accordion_RowStack.acceptsCards


class RelaxedAccordion(Accordion2):
    RowStack_Class = RelaxedAccordion_RowStack


registerGame(GameInfo(287, PushPin, "Push Pin",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(288, RoyalMarriage, "Royal Marriage",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
#  registerGame(GameInfo(303, Queens, "Queens",
#                        GI.GT_1DECK_TYPE | GI.GT_OPEN, 1, 0))
registerGame(GameInfo(656, Accordion, "Bayan",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(772, Accordion2, "Accordion",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_BALANCED,
                      altnames=('Idle Year', 'Methuselah', 'Tower of Babel')))
registerGame(GameInfo(773, RelaxedAccordion, "Relaxed Accordion",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.gypsy import Gypsy
from pysollib.hint import Yukon_Hint
from pysollib.layout import Layout
from pysollib.stack import \
        SS_FoundationStack, \
        StackWrapper, \
        WasteTalonStack, \
        Yukon_AC_RowStack

# ************************************************************************
# * Sanibel
# *   play similar to Yukon
# ************************************************************************


class Sanibel(Gypsy):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = StackWrapper(WasteTalonStack, max_rounds=1)
    Foundation_Class = StackWrapper(SS_FoundationStack, max_move=0)
    RowStack_Class = Yukon_AC_RowStack
    Hint_Class = Yukon_Hint

    def createGame(self):
        Gypsy.createGame(self, rows=10, waste=1, playcards=23)

    def startGame(self):
        for i in range(3):
            self.s.talon.dealRow(flip=0, frames=0)
        self._startDealNumRows(6)
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack

    def getHighlightPilesStacks(self):
        return ()


registerGame(GameInfo(201, Sanibel, "Sanibel",
                      GI.GT_YUKON | GI.GT_CONTRIB | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import pysollib.game
from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.layout import Layout
from pysollib.stack import \
        OpenStack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack

# ************************************************************************
# * Eiffel Tower
# ************************************************************************


class EiffelTower_RowStack(OpenStack):
    def __init__(self, x, y, game):
        OpenStack.__init__(self, x, y, game, max_move=0, max_accept=1)
        self.CARD_YOFFSET = 1

    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return False
        return self.cards[-1].rank + cards[0].rank == 12


class EiffelTower(pysollib.game.StartDealRowAndCards, Game):
    Talon_Class = WasteTalonStack
    Waste_Class = WasteStack

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 8.5*l.XS, l.YM + 6*l.YS)

        # create stacks
        y = l.YM
        for d in ((1, 2.5), (2, 2), (3, 1.5), (4, 1), (5, 0.5), (5, 0.5)):
            x = l.XM + d[1] * l.XS
            for i in range(d[0]):
                s.rows.append(EiffelTower_RowStack(x, y, self))
                x = x + l.XS
            y = y + l.YS
        x = l.XM + 6 * l.XS
        y = l.YM + 5 * l.YS // 2
        s.waste = self.Waste_Class(x, y, self)
        l.createText(s.waste, "s")
        x = x + l.XS
        s.talon = self.Talon_Class(x, y, self, max_rounds=1)
        l.createText(s.talon, "s")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def isGameWon(self):
        return len(self.s.talon.cards) == 0 and len(self.s.waste.cards) == 0

    def getAutoStacks(self, event=None):
        return ((), (), ())

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank + card2.rank == 12


# ************************************************************************
# * Strict Eiffel Tower
# ************************************************************************

class StrictEiffelTower(EiffelTower):
    Waste_Class = StackWrapper(WasteStack, max_cards=2)


# register the game
registerGame(GameInfo(16, EiffelTower, "Eiffel Tower",
                      GI.GT_PAIRING_TYPE, 2, 0, GI.SL_MOSTLY_LUCK))
# registerGame(GameInfo(801, StrictEiffelTower, "Strict Eiffel Tower",
#                       GI.GT_PAIRING_TYPE, 2, 0))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.gypsy import DieRussische_Foundation
from pysollib.hint import CautiousDefaultHint, DefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        AC_FoundationStack, \
        AC_RowStack, \
        BO_RowStack, \
        RK_FoundationStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        Spider_SS_RowStack, \
        Stack, \
        StackWrapper, \
        TalonStack, \
        UD_AC_RowStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, ANY_RANK, ANY_SUIT, KING, NO_RANK, \
        UNLIMITED_MOVES, UNLIMITED_REDEALS


class FortyThieves_Hint(CautiousDefaultHint):
    # FIXME: demo is not too clever in this game
    pass


# ************************************************************************
# * Forty Thieves
# *   rows build down by suit
# ************************************************************************

class FortyThieves(Game):
    Foundation_Class = SS_FoundationStack
    RowStack_Class = SS_RowStack
    Hint_Class = FortyThieves_Hint

    FOUNDATION_MAX_MOVE = 1
    ROW_MAX_MOVE = 1
    DEAL = (0, 4)
    FILL_EMPTY_ROWS = 0

    #
    # game layout
    #

    def createGame(self, max_rounds=1, num_deal=1, rows=10,
                   playcards=12, XCARDS=64, XOFFSET=None):
        # create layout
        if XOFFSET is None:
            l, s = Layout(self), self.s
        else:
            l, s = Layout(self, XOFFSET=XOFFSET), self.s

        # set window
        # (compute best XOFFSET - up to 64/72 cards can be in the Waste)
        decks = self.gameinfo.decks
        maxrows = max(rows, 4*decks)
        if maxrows <= 12:
            maxrows += 1
        w1, w2 = maxrows*l.XS+l.XM, 2*l.XS
        if w2 + XCARDS * l.XOFFSET > w1:
            l.XOFFSET = int((w1 - w2) / XCARDS)
        # (piles up to 12 cards are playable without overlap
        #   in default window size)
        h = max(2*l.YS, l.YS+(playcards-1)*l.YOFFSET)
        self.setSize(w1, l.YM + l.YS + h + l.YS + l.TEXT_HEIGHT)

        # create stacks
        # foundations
        x = l.XM + (maxrows - 4*decks) * l.XS // 2
        y = l.YM
        for i in range(4*decks):
            s.foundations.append(
                self.Foundation_Class(
                    x, y, self,
                    suit=i//decks, max_move=self.FOUNDATION_MAX_MOVE))
            x = x + l.XS
        # rows
        x = l.XM + (maxrows - rows) * l.XS // 2
        y = l.YM + l.YS
        for i in range(rows):
            s.rows.append(self.RowStack_Class(x, y, self,
                                              max_move=self.ROW_MAX_MOVE))
            x = x + l.XS
        # talon, waste
        x = self.width - l.XS
        y = self.height - l.YS
        s.talon = WasteTalonStack(x, y, self,
                                  max_rounds=max_rounds, num_deal=num_deal)
        l.createText(s.talon, "n")
        if max_rounds > 1:
            l.createRoundText(s.talon, 'nnn')
        x -= l.XS
        s.waste = WasteStack(x, y, self)
        s.waste.CARD_XOFFSET = -l.XOFFSET
        l.createText(s.waste, "n")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        for i in range(self.DEAL[0]):
            self.s.talon.dealRow(flip=0, frames=0)
        for i in range(self.DEAL[1] - 1):
            self.s.talon.dealRow(frames=0)
        self._startAndDealRowAndCards()

    def fillStack(self, stack):
        if self.FILL_EMPTY_ROWS and stack in self.s.rows and not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if self.s.waste.cards:
                self.s.waste.moveMove(1, stack)
            elif self.s.talon.canDealCards():
                self.s.talon.dealCards()
                self.s.waste.moveMove(1, stack)
            self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Busy Aces
# * Limited
# * Courtyard
# * Waning Moon
# * Lucas
# * Napoleon's Square
# * Carre Napoleon
# * Josephine
# * Marie Rose
# * Big Courtyard
# * San Juan Hill
# * Famous Fifty
# *   rows build down by suit
# ************************************************************************

class BusyAces(FortyThieves):
    DEAL = (0, 1)

    def createGame(self):
        FortyThieves.createGame(self, rows=12)


class Limited(BusyAces):
    DEAL = (0, 3)


class Courtyard(BusyAces):
    ROW_MAX_MOVE = UNLIMITED_MOVES
    FILL_EMPTY_ROWS = 1


class WaningMoon(FortyThieves):
    def createGame(self):
        FortyThieves.createGame(self, rows=13)


class Lucas(WaningMoon):
    ROW_MAX_MOVE = UNLIMITED_MOVES


class NapoleonsSquare(FortyThieves):
    ROW_MAX_MOVE = UNLIMITED_MOVES

    def createGame(self):
        FortyThieves.createGame(self, rows=12)


class CarreNapoleon(FortyThieves):
    RowStack_Class = StackWrapper(SS_RowStack, base_rank=KING)

    def createGame(self):
        FortyThieves.createGame(self, rows=12)

    def _fillOne(self):
        for r in self.s.rows:
            if r.cards:
                c = r.cards[-1]
                for f in self.s.foundations:
                    if f.acceptsCards(r, [c]):
                        self.moveMove(1, r, f, frames=4, shadow=0)
                        return 1
        return 0

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self.startDealSample()
        for i in range(4):
            self.s.talon.dealRow()
            while True:
                if not self._fillOne():
                    break
        self.s.talon.dealCards()

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(cards,
                                          lambda c: (c.rank == 0, c.suit))


class Josephine(FortyThieves):
    ROW_MAX_MOVE = UNLIMITED_MOVES


class MarieRose(Josephine):
    DEAL = (0, 5)

    def createGame(self):
        FortyThieves.createGame(self, rows=12, playcards=16, XCARDS=96)


class BigCourtyard(Courtyard):
    def createGame(self):
        FortyThieves.createGame(self, rows=12, playcards=16, XCARDS=96)


class Express(Limited):
    def createGame(self):
        FortyThieves.createGame(self, rows=14, playcards=16, XCARDS=96)


class Carnation(Limited):
    def createGame(self):
        FortyThieves.createGame(self, rows=16, playcards=20, XCARDS=120)


class SanJuanHill(FortyThieves):

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(cards,
                                          lambda c: (c.rank == ACE, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        FortyThieves.startGame(self)


class FamousFifty(FortyThieves):
    DEAL = (0, 5)


# ************************************************************************
# * Deuces
# ************************************************************************

class Deuces(FortyThieves):
    Foundation_Class = StackWrapper(SS_FoundationStack, mod=13, base_rank=1)
    RowStack_Class = StackWrapper(SS_RowStack, mod=13)

    DEAL = (0, 1)

    def _shuffleHook(self, cards):
        # move Twos to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 1, c.suit))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        FortyThieves.startGame(self)

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * Corona
# * Quadrangle
# ************************************************************************

class Corona(FortyThieves):
    FOUNDATION_MAX_MOVE = 0
    DEAL = (0, 3)
    FILL_EMPTY_ROWS = 1

    def createGame(self):
        FortyThieves.createGame(self, rows=12)


class Quadrangle(Corona):
    Foundation_Class = StackWrapper(
        SS_FoundationStack, mod=13, base_rank=NO_RANK)
    RowStack_Class = StackWrapper(SS_RowStack, mod=13)

    def startGame(self):
        FortyThieves.startGame(self)
        self.s.talon.dealSingleBaseCard()

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * Forty and Eight
# ************************************************************************

class FortyAndEight(FortyThieves):
    def createGame(self):
        FortyThieves.createGame(self, max_rounds=2, rows=8, XCARDS=72)


# ************************************************************************
# * Little Forty
# ************************************************************************

class LittleForty(FortyThieves):
    RowStack_Class = Spider_SS_RowStack

    ROW_MAX_MOVE = UNLIMITED_MOVES
    FILL_EMPTY_ROWS = 1

    def createGame(self):
        FortyThieves.createGame(self, max_rounds=4, num_deal=3, XOFFSET=0)

    shallHighlightMatch = Game._shallHighlightMatch_RK
    getQuickPlayScore = Game._getSpiderQuickPlayScore


# ************************************************************************
# * Streets
# * Maria
# * Number Ten
# * Rank and File
# * Emperor
# * Triple Line
# * Big Streets
# * Number Twelve
# * Roosevelt
# *   rows build down by alternate color
# ************************************************************************

class Streets(FortyThieves):
    RowStack_Class = AC_RowStack

    shallHighlightMatch = Game._shallHighlightMatch_AC


class Maria(Streets):
    def createGame(self):
        Streets.createGame(self, rows=9)


class NumberTen(Streets):
    ROW_MAX_MOVE = UNLIMITED_MOVES
    DEAL = (2, 2)


class RankAndFile(Streets):
    ROW_MAX_MOVE = UNLIMITED_MOVES
    DEAL = (3, 1)


class Emperor(Streets):
    DEAL = (3, 1)


class TripleLine(Streets):
    GAME_VERSION = 2

    FOUNDATION_MAX_MOVE = 0
    ROW_MAX_MOVE = UNLIMITED_MOVES
    DEAL = (0, 3)
    FILL_EMPTY_ROWS = 1

    def createGame(self):
        Streets.createGame(self, max_rounds=2, rows=12)


class BigStreets(Streets):
    def createGame(self):
        FortyThieves.createGame(self, rows=12, XCARDS=96)


class NumberTwelve(NumberTen):
    def createGame(self):
        FortyThieves.createGame(self, rows=12, XCARDS=96)


class Roosevelt(Streets):
    DEAL = (0, 4)

    def createGame(self):
        Streets.createGame(self, rows=7)


# ************************************************************************
# * Red and Black
# * Zebra
# *   rows build down by alternate color, foundations up by alternate color
# ************************************************************************

class RedAndBlack(Streets):
    Foundation_Class = AC_FoundationStack

    ROW_MAX_MOVE = UNLIMITED_MOVES
    DEAL = (0, 1)

    def createGame(self):
        FortyThieves.createGame(self, rows=8)

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        Streets.startGame(self)


class Zebra(RedAndBlack):
    FOUNDATION_MAX_MOVE = 0
    ROW_MAX_MOVE = 1
    FILL_EMPTY_ROWS = 1

    def createGame(self):
        FortyThieves.createGame(self, max_rounds=2, rows=8, XOFFSET=0)


# ************************************************************************
# * Indian
# * Midshipman
# * Mumbai
# *   rows build down by any suit but own
# ************************************************************************

class Indian(FortyThieves):
    RowStack_Class = BO_RowStack
    DEAL = (1, 2)

    def createGame(self):
        FortyThieves.createGame(self, XCARDS=74)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit != card2.suit and
                (card1.rank + 1 == card2.rank or
                 card2.rank + 1 == card1.rank))


class Midshipman(Indian):
    DEAL = (2, 2)

    def createGame(self):
        FortyThieves.createGame(self, rows=9)


class Mumbai(Indian):
    def createGame(self):
        FortyThieves.createGame(self, XCARDS=84, rows=13)


# ************************************************************************
# * Napoleon's Exile
# * Double Rail
# * Single Rail (1 deck)
# * Final Battle
# *   rows build down by rank
# ************************************************************************

class NapoleonsExile(FortyThieves):
    RowStack_Class = RK_RowStack

    DEAL = (0, 4)

    shallHighlightMatch = Game._shallHighlightMatch_RK


class DoubleRail(NapoleonsExile):
    ROW_MAX_MOVE = UNLIMITED_MOVES
    DEAL = (0, 1)

    def createGame(self):
        FortyThieves.createGame(self, rows=5)


class SingleRail(DoubleRail):
    def createGame(self):
        FortyThieves.createGame(self, rows=4, XCARDS=48)


class FinalBattle(DoubleRail):
    def createGame(self):
        FortyThieves.createGame(self, rows=6)


# ************************************************************************
# * Octave
# ************************************************************************

class Octave_Talon(WasteTalonStack):

    def dealCards(self, sound=False):
        if self.round == self.max_rounds:
            return 0
        if self.cards:
            return WasteTalonStack.dealCards(self, sound)
        # last round
        num_cards = WasteTalonStack.dealCards(self, sound)
        wastes = [self.waste]+list(self.game.s.reserves)
        old_state = self.game.enterState(self.game.S_DEAL)
        if self.cards:
            if sound and not self.game.demo:
                self.game.startDealSample()
            num_cards = min(len(self.cards), 8)
            for i in range(num_cards):
                if not self.cards[-1].face_up:
                    self.game.flipMove(self)
                self.game.moveMove(1, self, wastes[i], frames=4, shadow=0)
            if sound and not self.game.demo:
                self.game.stopSamples()
        self.game.leaveState(old_state)
        return num_cards


class Octave_Waste(WasteStack):
    def updateText(self):
        if self.game.preview > 1 or self.texts.ncards is None:
            return
        if self.game.s.talon.round == self.game.s.talon.max_rounds:
            t = ''
        else:
            t = str(len(self.cards))
        self.texts.ncards.config(text=t)


class Octave(Game):
    Hint_Class = CautiousDefaultHint

    #
    # game layout
    #

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+9*l.XS, l.YM+3*l.YS+12*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y = l.XM+l.XS//2, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self,
                                 suit=int(i//2), max_cards=10))
            x += l.XS

        x, y = l.XM+l.XS//2, l.YM+l.YS
        for i in range(8):
            s.rows.append(AC_RowStack(x, y, self,
                                      base_rank=ANY_RANK, max_move=1))
            x += l.XS

        x, y = l.XM, h-l.YS
        s.talon = Octave_Talon(x, y, self, max_rounds=2)
        l.createText(s.talon, "n")
        x += l.XS
        s.waste = Octave_Waste(x, y, self)
        l.createText(s.waste, 'n')
        x += l.XS
        for i in range(7):
            stack = WasteStack(x, y, self, max_accept=0)
            s.reserves.append(stack)
            x += l.XS

        # define stack-groups
        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(cards,
                                          lambda c: (c.rank == ACE, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startDealNumRows(2)
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack

    def isGameWon(self):
        for s in self.s.foundations:
            if len(s.cards) != 10:
                return False
        for s in self.s.reserves:
            if s.cards:
                return False
        return not self.s.waste.cards

    shallHighlightMatch = Game._shallHighlightMatch_AC

    def _autoDeal(self, sound=True):
        ncards = len(self.s.waste.cards) + sum(
            [len(i.cards) for i in self.s.reserves])
        if ncards == 0:
            return self.dealCards(sound=sound)
        return 0

    def fillStack(self, stack):
        if self.s.talon.round == self.s.talon.max_rounds:
            # last round
            if not stack.cards and self.s.talon.cards:
                if stack is self.s.waste or stack in self.s.reserves:
                    old_state = self.enterState(self.S_FILL)
                    self.flipMove(self.s.talon)
                    self.moveMove(1, self.s.talon, stack, frames=4, shadow=0)
                    self.leaveState(old_state)


# ************************************************************************
# * Fortune's Favor
# ************************************************************************

class FortunesFavor(Game):

    def createGame(self):

        l, s = Layout(self), self.s

        w, h = l.XM+8*l.XS, 2*l.YM+3*l.YS
        self.setSize(w, h)

        x, y = l.XM+3*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += l.XS
        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'se')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'se')
        y = 2*l.YM+l.YS
        for i in range(2):
            x = l.XM+2*l.XS
            for j in range(6):
                stack = SS_RowStack(x, y, self, max_move=1)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
                s.rows.append(stack)
                x += l.XS
            y += l.YS

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(cards,
                                          lambda c: (c.rank == ACE, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRowAndCards()

    def fillStack(self, stack):
        if len(stack.cards) == 0:
            if stack is self.s.waste and self.s.talon.cards:
                self.s.talon.dealCards()
            elif stack in self.s.rows and self.s.waste.cards:
                self.s.waste.moveMove(1, stack)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Octagon
# ************************************************************************

class Octagon(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):

        l, s = Layout(self), self.s

        w1 = l.XS+12*l.XOFFSET
        w, h = l.XM+2*l.XS+2*w1, l.YM+4*l.YS
        self.setSize(w, h)

        for x, y in ((l.XM,                l.YM),
                     (l.XM+w1+2*l.XS+l.XM, l.YM),
                     (l.XM,                l.YM+3*l.YS),
                     (l.XM+w1+2*l.XS+l.XM, l.YM+3*l.YS),):
            stack = SS_RowStack(x, y, self, max_move=1)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
            s.rows.append(stack)
        i = 0
        for x, y in ((l.XM+w1,                    l.YM),
                     (l.XM+w1+l.XS,               l.YM),
                     (l.XM+w1-2*l.XS-l.XS//2-l.XM, l.YM+1.5*l.YS),
                     (l.XM+w1-l.XS-l.XS//2-l.XM,   l.YM+1.5*l.YS),
                     (l.XM+w1+2*l.XS+l.XS//2+l.XM, l.YM+1.5*l.YS),
                     (l.XM+w1+3*l.XS+l.XS//2+l.XM, l.YM+1.5*l.YS),
                     (l.XM+w1,                    l.YM+3*l.YS),
                     (l.XM+w1+l.XS,               l.YM+3*l.YS),):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i % 4))
            i += 1
        x, y = l.XM+w1, l.YM+1.5*l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=4)
        l.createText(s.talon, 's')
        l.createRoundText(s.talon, 'nn')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 's')

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == ACE, (c.deck, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self.startDealSample()
        for i in range(5):
            self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            if not self.s.waste.cards:
                self.s.talon.dealCards()
            if self.s.waste.cards:
                self.s.waste.moveMove(1, stack)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Squadron
# ************************************************************************

class Squadron(FortyThieves):

    def createGame(self):
        l, s = Layout(self), self.s

        self.setSize(l.XM+12*l.XS, l.YM+max(4.5*l.YS, 2*l.YS+12*l.YOFFSET))

        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 's')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 's')
        x += 2*l.XS
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2))
            x += l.XS
        x, y = l.XM, l.YM+l.YS*3//2
        for i in range(3):
            s.reserves.append(ReserveStack(x, y, self))
            y += l.YS
        x, y = l.XM+2*l.XS, l.YM+l.YS
        for i in range(10):
            s.rows.append(SS_RowStack(x, y, self, max_move=1))
            x += l.XS

        l.defaultStackGroups()

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self._startDealNumRows(3)
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack


# ************************************************************************
# * Waterloo
# ************************************************************************

class Waterloo(FortyThieves):

    RowStack_Class = Spider_SS_RowStack

    ROW_MAX_MOVE = UNLIMITED_MOVES
    DEAL = (0, 1)

    def createGame(self):
        FortyThieves.createGame(self, rows=6)

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == ACE, (c.deck, c.suit)))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack

    getQuickPlayScore = Game._getSpiderQuickPlayScore
    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Junction
# * Crossroads
# ************************************************************************

class Junction(Game):
    Foundation_Class = StackWrapper(DieRussische_Foundation, max_cards=8)

    def createGame(self, rows=7):

        l, s = Layout(self), self.s

        self.setSize(l.XM+10*l.XS, l.YM+3*l.YS+12*l.YOFFSET)

        y = l.YM
        for i in range(2):
            x = l.XM+2*l.XS
            for j in range(8):
                s.foundations.append(self.Foundation_Class(x, y, self,
                                                           suit=j % 4))
                x += l.XS
            y += l.YS

        x, y = l.XM+(10-rows)*l.XS//2, l.YM+2*l.YS
        for i in range(rows):
            s.rows.append(AC_RowStack(x, y, self))
            x += l.XS

        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'ne')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'ne')

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_AC


class Crossroads(Junction):
    Foundation_Class = StackWrapper(SS_FoundationStack, max_cards=13)

    def startGame(self):
        for i in range(3):
            self.s.talon.dealRow(frames=0)
            self.s.talon.dealRow(flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()


# ************************************************************************
# * The Spark
# ************************************************************************

class TheSpark_Talon(TalonStack):

    def canDealCards(self):
        return len(self.cards) > 0

    def dealCards(self, sound=False):
        old_state = self.game.enterState(self.game.S_DEAL)
        num_cards = 0
        if self.cards:
            if sound and not self.game.demo:
                self.game.playSample("dealwaste")
            for i in range(self.num_deal):
                for r in self.game.s.reserves:
                    if not self.cards:
                        break
                    self.game.flipMove(self)
                    self.game.moveMove(1, self, r, frames=4, shadow=0)
                    num_cards += 1
        self.game.leaveState(old_state)
        return num_cards


class TheSpark(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):

        l, s = Layout(self), self.s

        w, h = l.XM+8*l.XS, l.YM+4*l.YS
        self.setSize(w, h)

        x, y = l.XM, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self,
                                 suit=i//2, base_rank=KING, mod=13))
            x += l.XS
        x, y = l.XM, l.YM+l.YS
        s.talon = TheSpark_Talon(x, y, self, max_rounds=1, num_deal=3)
        l.createText(s.talon, 'se')
        y += l.YS
        for i in (0, 1):
            stack = WasteStack(x, y, self)
            s.reserves.append(stack)
            l.createText(stack, 'se')
            y += l.YS
        y = l.YM+l.YS*3//2
        for i in range(2):
            x = l.XM+2*l.XS
            for j in range(6):
                stack = SS_RowStack(x, y, self, max_move=1)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
                s.rows.append(stack)
                x += l.XS
            y += l.YS

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(cards,
                                          lambda c: (c.rank == KING, c.suit))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRowAndCards()

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Double Gold Mine
# ************************************************************************

class DoubleGoldMine_RowStack(AC_RowStack):
    getBottomImage = Stack._getReserveBottomImage


class DoubleGoldMine(Streets):

    RowStack_Class = DoubleGoldMine_RowStack

    ROW_MAX_MOVE = UNLIMITED_MOVES

    def createGame(self):
        Streets.createGame(self, rows=9, num_deal=3)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealCards()


# ************************************************************************
# * Interchange
# * Unlimited
# * Breakwater
# * Forty Nine
# * Alternation
# * Triple Interchange
# ************************************************************************

class Interchange(FortyThieves):

    RowStack_Class = StackWrapper(SS_RowStack, base_rank=KING)

    ROW_MAX_MOVE = UNLIMITED_MOVES

    def createGame(self):
        FortyThieves.createGame(self, rows=7)

    def startGame(self):
        for i in (0, 1, 2):
            self.s.talon.dealRow(frames=0)
            self.s.talon.dealRow(flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()


class Unlimited(Interchange):
    def createGame(self):
        FortyThieves.createGame(self, rows=7, XOFFSET=0,
                                max_rounds=UNLIMITED_REDEALS)


class Breakwater(Interchange):
    RowStack_Class = RK_RowStack
    shallHighlightMatch = Game._shallHighlightMatch_RK


class FortyNine_RowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if self.cards:
            return len(cards) == 1
        return True


class FortyNine(Interchange):
    RowStack_Class = FortyNine_RowStack

    def startGame(self):
        self._startDealNumRowsAndDealRowAndCards(6)

    shallHighlightMatch = Game._shallHighlightMatch_AC


class Alternation(Interchange):
    RowStack_Class = AC_RowStack
    shallHighlightMatch = Game._shallHighlightMatch_AC


class TripleInterchange(Interchange):
    RowStack_Class = SS_RowStack

    def createGame(self):
        FortyThieves.createGame(self, rows=9, XOFFSET=0,
                                max_rounds=UNLIMITED_REDEALS)

    def startGame(self):
        for i in (0, 1, 2, 3):
            self.s.talon.dealRow(frames=0)
            self.s.talon.dealRow(flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()


# ************************************************************************
# * Indian Patience
# ************************************************************************

class IndianPatience_RowStack(BO_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not BO_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.game.s.talon.cards:
            return True
        if self.cards:
            if from_stack in self.game.s.rows and len(from_stack.cards) == 1:
                return False
            return len(self.cards) != 1
        return True


class IndianPatience(Indian):
    RowStack_Class = IndianPatience_RowStack

    def fillStack(self, stack):
        if stack in self.s.rows and not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if self.s.talon.cards:
                if len(self.s.talon.cards) == 1:
                    self.s.talon.flipMove()
                self.s.talon.moveMove(1, stack)
            if self.s.talon.cards:
                self.s.talon.flipMove()
                self.s.talon.moveMove(1, stack)
            if self.s.talon.cards:
                self.s.talon.flipMove()
                self.s.talon.moveMove(1, stack)
            self.leaveState(old_state)


# ************************************************************************
# * Floradora
# ************************************************************************

class Floradora(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):

        l, s = Layout(self), self.s

        self.setSize(l.XM+10*l.XS, l.YM+2*l.YS+12*l.YOFFSET+l.TEXT_HEIGHT)

        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 's')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 's')
        x += l.XS
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i % 4,
                                                    max_cards=12))
            x += l.XS
        x, y = l.XM, l.YM+l.YS+l.TEXT_HEIGHT
        s.foundations.append(RK_FoundationStack(x, y, self, suit=ANY_SUIT,
                             base_rank=KING, dir=0, max_cards=8))
        x += 3*l.XS
        for i in range(6):
            s.rows.append(RK_RowStack(x, y, self, max_move=1))
            x += l.XS

        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealRowAndCards(5)

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Blind Patience
# ************************************************************************

class BlindPatience_Hint(DefaultHint):
    SCORE_FLIP = 80000

    def shallMovePile(self, from_stack, to_stack, pile, rpile):
        if from_stack is to_stack or \
                not to_stack.acceptsCards(from_stack, pile):
            return False
        #
        if len(rpile) == 0:
            return True
        # now check for loops
        rr = self.ClonedStack(from_stack, stackcards=rpile)
        if self.level < 2:
            # hint
            if to_stack.cards and not to_stack.cards[-1].face_up:
                if rr.cards and not rr.cards[-1].face_up:
                    return True
            if rr.cards and not rr.cards[-1].face_up:
                return True
            if not to_stack.cards:
                return True
        else:
            # demo mode
            if rr.cards and not rr.cards[-1].face_up:
                if len(rr.cards) < len(to_stack.cards):
                    return True
        if rr.acceptsCards(to_stack, pile):
            # the pile we are going to move could be moved back -
            # this is dangerous as we can create endless loops...
            return False
        return True


class BlindPatience_RowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if self.cards and not self.cards[-1].face_up:
            return True
        return AC_RowStack.acceptsCards(self, from_stack, cards)


class BlindPatience(FortyThieves):
    Hint_Class = BlindPatience_Hint
    RowStack_Class = BlindPatience_RowStack

    def startGame(self):
        for i in range(3):
            self.s.talon.dealRow(flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(flip=0)
        self.s.talon.dealCards()        # deal first card to WasteStack

    def getAutoStacks(self, event=None):
        if event is None:
            # do not auto flip
            return ([], self.sg.dropstacks, self.sg.dropstacks)
        return (self.sg.dropstacks, self.sg.dropstacks, self.sg.dropstacks)

    def getQuickPlayScore(self, ncards, from_stack, to_stack):
        if to_stack in self.s.rows:
            if to_stack.cards:
                if to_stack.cards[-1].face_up:
                    # top card is face up
                    return 1001
                else:
                    return 1000
            else:
                return 999
        # prefer non-empty piles in to_stack
        return 1001 + int(len(to_stack.cards) != 0)

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Foothold
# ************************************************************************

class Foothold(FortyThieves):
    RowStack_Class = UD_AC_RowStack
    DEAL = (0, 5)

    def createGame(self):
        FortyThieves.createGame(self, rows=8, playcards=16)
    shallHighlightMatch = Game._shallHighlightMatch_AC


# register the game
registerGame(GameInfo(13, FortyThieves, "Forty Thieves",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL,
                      altnames=("Napoleon at St.Helena",
                                "Le Cadran")))
registerGame(GameInfo(80, BusyAces, "Busy Aces",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(228, Limited, "Limited",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(79, WaningMoon, "Waning Moon",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(125, Lucas, "Lucas",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(109, Deuces, "Deuces",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(196, Corona, "Corona",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(195, Quadrangle, "Quadrangle",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(110, Courtyard, "Courtyard",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(23, FortyAndEight, "Forty and Eight",
                      GI.GT_FORTY_THIEVES, 2, 1, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(115, LittleForty, "Little Forty",         # was: 72
                      GI.GT_FORTY_THIEVES, 2, 3, GI.SL_BALANCED))
registerGame(GameInfo(76, Streets, "Streets",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(73, Maria, "Maria",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED,
                      altnames=("Maria Luisa",)))
registerGame(GameInfo(70, NumberTen, "Number Ten",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(71, RankAndFile, "Rank and File",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED,
                      altnames=("Dress Parade")))
registerGame(GameInfo(197, TripleLine, "Triple Line",
                      GI.GT_FORTY_THIEVES | GI.GT_XORIGINAL, 2, 1,
                      GI.SL_BALANCED))
registerGame(GameInfo(126, RedAndBlack, "Red and Black",        # was: 75
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(113, Zebra, "Zebra",
                      GI.GT_FORTY_THIEVES, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(69, Indian, "Indian",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(74, Midshipman, "Midshipman",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(198, NapoleonsExile, "Napoleon's Exile",
                      GI.GT_FORTY_THIEVES | GI.GT_XORIGINAL, 2, 0,
                      GI.SL_BALANCED))
registerGame(GameInfo(131, DoubleRail, "Double Rail",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(199, SingleRail, "Single Rail",
                      GI.GT_FORTY_THIEVES, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(295, NapoleonsSquare, "Napoleon's Square",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(310, Emperor, "Emperor",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(323, Octave, "Octave",
                      GI.GT_FORTY_THIEVES, 2, 1, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(332, Mumbai, "Mumbai",
                      GI.GT_FORTY_THIEVES, 3, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(411, CarreNapoleon, "Carre Napoleon",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(416, FortunesFavor, "Fortune's Favor",
                      GI.GT_FORTY_THIEVES, 1, 0, GI.SL_LUCK))
registerGame(GameInfo(426, Octagon, "Octagon",
                      GI.GT_FORTY_THIEVES, 2, 3, GI.SL_BALANCED))
registerGame(GameInfo(440, Squadron, "Squadron",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(462, Josephine, "Josephine",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(493, MarieRose, "Marie Rose",
                      GI.GT_FORTY_THIEVES, 3, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(503, BigStreets, "Big Streets",
                      GI.GT_FORTY_THIEVES | GI.GT_ORIGINAL, 3, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(504, NumberTwelve, "Number Twelve",
                      GI.GT_FORTY_THIEVES | GI.GT_ORIGINAL, 3, 0,
                      GI.SL_BALANCED))
registerGame(GameInfo(505, BigCourtyard, "Big Courtyard",
                      GI.GT_FORTY_THIEVES | GI.GT_ORIGINAL, 3, 0,
                      GI.SL_BALANCED))
registerGame(GameInfo(506, Express, "Express",
                      GI.GT_FORTY_THIEVES | GI.GT_ORIGINAL, 3, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(514, Carnation, "Carnation",
                      GI.GT_FORTY_THIEVES | GI.GT_ORIGINAL, 4, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(528, FinalBattle, "Final Battle",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(529, SanJuanHill, "San Juan Hill",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(540, Waterloo, "Waterloo",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(556, Junction, "Junction",
                      GI.GT_FORTY_THIEVES, 4, 0, GI.SL_MOSTLY_SKILL,
                      ranks=(0, 6, 7, 8, 9, 10, 11, 12)))
registerGame(GameInfo(564, TheSpark, "The Spark",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(573, DoubleGoldMine, "Double Gold Mine",
                      GI.GT_NUMERICA | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(574, Interchange, "Interchange",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(575, Unlimited, "Unlimited",
                      GI.GT_FORTY_THIEVES, 2, -1, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(576, Breakwater, "Breakwater",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(577, FortyNine, "Forty Nine",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(578, IndianPatience, "Indian Patience",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(588, Roosevelt, "Roosevelt",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(628, Crossroads, "Crossroads",
                      GI.GT_FORTY_THIEVES, 4, 0, GI.SL_BALANCED))
registerGame(GameInfo(631, Alternation, "Alternation",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(632, Floradora, "Floradora",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(679, TripleInterchange, "Triple Interchange",
                      GI.GT_FORTY_THIEVES, 3, -1, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(683, FamousFifty, "Famous Fifty",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(751, BlindPatience, "Blind Patience",
                      GI.GT_FORTY_THIEVES, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(765, Foothold, "Foothold",
                      GI.GT_FORTY_THIEVES | GI.GT_ORIGINAL, 2, 0,
                      GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.unionsquare import UnionSquare_Foundation
from pysollib.hint import CautiousDefaultHint, DefaultHint
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.stack import \
        AC_FoundationStack, \
        AC_RowStack, \
        AbstractFoundationStack, \
        BasicRowStack, \
        DealRowTalonStack, \
        OpenStack, \
        OpenTalonStack, \
        RK_FoundationStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        Stack, \
        StackWrapper, \
        UD_RK_RowStack, \
        UD_SS_RowStack, \
        WasteStack, \
        WasteTalonStack, \
        isSameSuitSequence
from pysollib.util import ACE, ANY_RANK, ANY_SUIT, JACK, KING, NO_RANK

# ************************************************************************
# * Royal Cotillion
# ************************************************************************


class RoyalCotillion_Foundation(SS_FoundationStack):
    def getBottomImage(self):
        if self.cap.base_rank == 1:
            return self.game.app.images.getLetter(1)
        return self.game.app.images.getSuitBottom(self.cap.base_suit)


class RoyalCotillion(Game):
    Foundation_Class = RoyalCotillion_Foundation

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 10*l.XS, l.YM + 4*l.YS)

        # create stacks
        for i in range(4):
            x, y, = l.XM + i*l.XS, l.YM
            s.rows.append(BasicRowStack(x, y, self, max_accept=0))
        for i in range(4):
            x, y, = l.XM + 4*l.XS, l.YM + i*l.YS
            s.foundations.append(
                self.Foundation_Class(x, y, self, i, dir=2, mod=13))
            x += l.XS
            s.foundations.append(
                self.Foundation_Class(
                    x, y, self, i, dir=2, mod=13, base_rank=1))
        for i in range(4):
            for j in range(4):
                x, y, = l.XM + (j+6)*l.XS, l.YM + i*l.YS
                s.reserves.append(ReserveStack(x, y, self, max_accept=0))
        x, y = l.XM + l.XS, self.height - l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "sw")
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "se")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        for i in range(3):
            self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack

    def fillStack(self, stack):
        if not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if stack is self.s.waste and self.s.talon.cards:
                self.s.talon.dealCards()
            elif stack in self.s.reserves and self.s.waste.cards:
                self.s.waste.moveMove(1, stack)
            self.leaveState(old_state)

    def getHighlightPilesStacks(self):
        return ()

    def getAutoStacks(self, event=None):
        if event is None:
            # disable auto drop - this would ruin the whole gameplay
            return (self.sg.dropstacks, (), self.sg.dropstacks)
        else:
            # rightclickHandler
            return (self.sg.dropstacks, self.sg.dropstacks, self.sg.dropstacks)


# ************************************************************************
# * Odd and Even
# ************************************************************************

class OddAndEven(RoyalCotillion):
    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 8*l.XS, l.YM + 4*l.YS)

        # create stacks
        x, y, = l.XM, l.YM
        for i in range(4):
            s.foundations.append(
                self.Foundation_Class(x, y, self, i, dir=2, mod=13))
            x += l.XS
        for i in range(4):
            s.foundations.append(
                self.Foundation_Class(
                    x, y, self, i, dir=2, mod=13, base_rank=1))
            x += l.XS
        for i in range(2):
            x, y, = l.XM + ((4, 3)[i])*l.XS, l.YM + (i+1)*l.YS
            for j in range((4, 5)[i]):
                s.reserves.append(ReserveStack(x, y, self, max_accept=0))
                x += l.XS
        x, y = l.XM, self.height - l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=2)
        l.createText(s.talon, "n")
        l.createRoundText(s.talon, 'nnn')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "n")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealCards()          # deal first card to WasteStack


# ************************************************************************
# * Kingdom
# ************************************************************************

class Kingdom(RoyalCotillion):
    Foundation_Class = RK_FoundationStack

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 8*l.XS, l.YM + 4*l.YS)

        # create stacks
        x, y, = l.XM, l.YM
        for i in range(8):
            s.foundations.append(self.Foundation_Class(x, y, self, ANY_SUIT))
            x += l.XS
        x, y, = l.XM, y + l.YS
        for i in range(8):
            s.reserves.append(ReserveStack(x, y, self, max_accept=0))
            x += l.XS
        x, y = l.XM + 3*l.XS, l.YM + 3*l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "sw")
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "se")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        # move one Ace to top of the Talon (i.e. first card to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 0, c.suit), 1)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=(self.s.foundations[0],))
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealCards()          # deal first card to WasteStack


# ************************************************************************
# * Alhambra
# * Granada
# * Reserves
# * Grant's Reinforcement
# ************************************************************************

class Alhambra_Hint(CautiousDefaultHint):
    def _getDropCardScore(self, score, color, r, t, ncards):
        return 93000, color


class Alhambra_RowStack(UD_SS_RowStack):
    getBottomImage = Stack._getReserveBottomImage

    def getHelp(self):
        return _('Waste. Build up or down by suit.')


class Alhambra_Talon(DealRowTalonStack):
    def canDealCards(self):
        r_cards = sum([len(r.cards) for r in self.game.s.rows])
        if self.cards:
            return True
        elif r_cards and self.round != self.max_rounds:
            return True
        return False

    def _deal(self):
        num_cards = 0
        for r in self.game.s.rows:
            if self.cards:
                self.game.flipAndMoveMove(self, r)
                num_cards += 1

    def dealCards(self, sound=False):
        old_state = self.game.enterState(self.game.S_DEAL)
        num_cards = 0
        rows = self.game.s.rows
        r_cards = sum([len(r.cards) for r in self.game.s.rows])
        if self.cards:
            if sound and not self.game.demo:
                self.game.playSample("dealwaste")
            if len(self.game.s.rows) > 1:
                num_cards = self.dealRowAvail(sound=False, frames=4)
            else:
                num_cards = self._deal()
        elif r_cards and self.round != self.max_rounds:
            if sound:
                self.game.playSample("turnwaste", priority=20)
            for r in rows:
                for i in range(len(r.cards)):
                    self.game.moveMove(1, r, self, frames=0)
                    self.game.flipMove(self)
            if len(self.game.s.rows) > 1:
                num_cards = self.dealRowAvail(sound=False, frames=4)
            else:
                num_cards = self._deal()
            self.game.nextRoundMove(self)
        self.game.leaveState(old_state)
        return num_cards


class Alhambra(Game):
    Hint_Class = Alhambra_Hint

    RowStack_Class = StackWrapper(Alhambra_RowStack, base_rank=ANY_RANK)

    def createGame(self, rows=1, reserves=8, playcards=3):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+8*l.XS, l.YM+3.5*l.YS+playcards*l.YOFFSET
        h += l.TEXT_HEIGHT
        self.setSize(w, h)

        # create stacks
        x, y, = l.XM, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                    max_move=0))
            x += l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                 max_move=0, base_rank=KING, dir=-1))
            x += l.XS
        x, y, = l.XM+(8-reserves)*l.XS//2, y+l.YS
        for i in range(reserves):
            stack = OpenStack(x, y, self, max_accept=0)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, l.YOFFSET
            s.reserves.append(stack)
            x += l.XS
        x, y = l.XM+(8-1-rows)*l.XS//2, self.height-l.YS
        s.talon = Alhambra_Talon(x, y, self, max_rounds=3)
        if rows == 1:
            l.createText(s.talon, 'sw')
        else:
            l.createText(s.talon, 'n')
        anchor = 'nn'
        if rows > 1:
            anchor = 'nnn'
        l.createRoundText(s.talon, anchor)

        x += l.XS
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self, mod=13, max_accept=1)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
            s.rows.append(stack)
            x += l.XS
            if rows == 1:
                l.createText(stack, 'se')
            else:
                l.createText(stack, 'n')

        # define stack-groups (non default)
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        # move one Aces and Kings of first deck to top of the Talon (i.e. first
        # card to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.deck == 0 and
                              c.rank in (ACE, KING), (c.rank, c.suit)), 8)

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        for i in range(3):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_SSW


class Granada(Alhambra):
    def createGame(self):
        Alhambra.createGame(self, rows=4)


class Reserves_RowStack(UD_RK_RowStack):
    getBottomImage = Stack._getReserveBottomImage

    def getHelp(self):
        return _('Waste. Build up or down regardless of suit.')


class Reserves(Alhambra):
    RowStack_Class = StackWrapper(Reserves_RowStack, base_rank=NO_RANK)

    def createGame(self):
        Alhambra.createGame(self, reserves=4, playcards=11)

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        for i in range(11):
            self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_RKW


class GrantsReinforcement(Reserves):
    RowStack_Class = StackWrapper(Alhambra_RowStack, base_rank=NO_RANK)

    def fillStack(self, stack):
        for r in self.s.reserves:
            if r.cards:
                continue
            if self.s.talon.cards:
                old_state = self.enterState(self.S_FILL)
                self.s.talon.flipMove()
                self.s.talon.moveMove(1, r)
                self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * Carpet
# ************************************************************************

class Carpet(Game):
    Foundation_Class = SS_FoundationStack

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 9*l.XS, l.YM + 4*l.YS)

        # create stacks
        for i in range(4):
            for j in range(5):
                x, y = l.XM + (j+3)*l.XS, l.YM + i*l.YS
                s.rows.append(ReserveStack(x, y, self))
        for i in range(4):
            dx, dy = ((2, 1), (8, 1), (2, 2), (8, 2))[i]
            x, y = l.XM + dx*l.XS, l.YM + dy*l.YS
            s.foundations.append(self.Foundation_Class(x, y, self, i))
        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "se")
        y = y + l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "se")

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealRow()
        self.s.talon.dealCards()          # deal first card to WasteStack


# ************************************************************************
# * British Constitution
# ************************************************************************

class BritishConstitution_RowStackMethods:
    def acceptsCards(self, from_stack, cards):
        if self in self.game.s.rows[:8] and \
                from_stack in self.game.s.rows[8:16]:
            return True
        if self in self.game.s.rows[8:16] and \
                from_stack in self.game.s.rows[16:24]:
            return True
        if self in self.game.s.rows[16:24] and \
                from_stack in self.game.s.rows[24:]:
            return True
        if self in self.game.s.rows[24:] and from_stack is self.game.s.waste:
            return True
        return False


class BritishConstitution_RowStack(BritishConstitution_RowStackMethods,
                                   AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        return BritishConstitution_RowStackMethods.acceptsCards(
            self, from_stack, cards)


class NewBritishConstitution_RowStack(BritishConstitution_RowStackMethods,
                                      RK_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not RK_RowStack.acceptsCards(self, from_stack, cards):
            return False
        return BritishConstitution_RowStackMethods.acceptsCards(
            self, from_stack, cards)


class BritishConstitution_Foundation(SS_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack in self.game.s.rows[:8]:
            return True
        return False


class BritishConstitution(Game):
    RowStack_Class = BritishConstitution_RowStack

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 9*l.XS, l.YM + 5*l.YS)

        # create stacks
        x, y = l.XM+l.XS, l.YM
        for i in range(8):
            s.foundations.append(BritishConstitution_Foundation(x, y, self,
                                 suit=int(i//2), max_cards=11))
            x += l.XS

        y = l.YM+l.YS
        for i in range(4):
            x = l.XM+l.XS
            for j in range(8):
                stack = self.RowStack_Class(x, y, self, max_move=1)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = 0, 0
                s.rows.append(stack)
                x += l.XS
            y += l.YS

        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "s")
        y += l.YS+l.TEXT_HEIGHT
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRowAndCards()

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == ACE, c.suit))

    def fillStack(self, stack):
        if not stack.cards:
            if stack in self.s.rows[:24]:
                return
            old_state = self.enterState(self.S_FILL)
            if stack is self.s.waste and self.s.talon.cards:
                self.s.talon.dealCards()
            elif stack in self.s.rows[24:] and self.s.waste.cards:
                self.s.waste.moveMove(1, stack)
            self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_AC


class NewBritishConstitution(BritishConstitution):
    RowStack_Class = StackWrapper(
        NewBritishConstitution_RowStack, base_rank=JACK)

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Twenty
# ************************************************************************

class Twenty_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return False
        return len(self.cards) == 0

    def getHelp(self):
        return _('Tableau. Empty piles can be filled with any card.')


class Twenty(Game):
    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+10*l.XS, l.YM+3*l.YS+10*l.YOFFSET)

        # create stacks
        x, y = l.XM, l.YM
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, 'se')
        x += 2*l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                 base_rank=KING, dir=-1))
            x += l.XS

        for y in (l.YM+l.YS, l.YM+2*l.YS+5*l.YOFFSET):
            x = l.XM
            for i in range(10):
                s.rows.append(Twenty_RowStack(x, y, self,
                              base_rank=ANY_RANK, max_accept=1))
                x += l.XS

        # define stack-groups
        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (ACE, KING) and c.deck == 1,
                       (c.rank, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRow()

    def fillStack(self, stack):
        if not stack.cards and stack in self.s.rows and self.s.talon.cards:
            old_state = self.enterState(self.S_FILL)
            self.flipMove(self.s.talon)
            self.s.talon.moveMove(1, stack)
            self.leaveState(old_state)


# ************************************************************************
# * Three Pirates
# ************************************************************************

class ThreePirates_Talon(DealRowTalonStack):
    def dealCards(self, sound=False):
        num_cards = 0
        old_state = self.game.enterState(self.game.S_DEAL)
        if self.cards:
            if sound and not self.game.demo:
                self.game.playSample("dealwaste")
            num_cards = self.dealRowAvail(rows=self.game.s.reserves,
                                          sound=False, frames=4)
        self.game.leaveState(old_state)
        return num_cards


class ThreePirates(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):
        l, s = Layout(self), self.s

        self.setSize(l.XM+10*l.XS, l.YM+3*l.YS+16*l.YOFFSET)

        x, y, = l.XM+l.XS, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2))
            x += l.XS

        x, y, = l.XM, l.YM+l.YS
        for i in range(10):
            s.rows.append(SS_RowStack(x, y, self, max_move=1))
            x += l.XS

        x, y = l.XM, self.height-l.YS
        s.talon = ThreePirates_Talon(x, y, self)
        l.createText(s.talon, 'n')
        x += l.XS
        for i in (0, 1, 2):
            stack = WasteStack(x, y, self)
            s.reserves.append(stack)
            l.createText(stack, 'n')
            x += l.XS

        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealRowAndCards(3)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Frames
# ************************************************************************

class Frames_Hint(CautiousDefaultHint):
    def computeHints(self):
        CautiousDefaultHint.computeHints(self)
        if self.hints:
            return
        if not self.game.s.talon.cards:
            return
        for s in self.game.s.reserves:
            if s.cards:
                for r in self.game.s.rows:
                    if r.acceptsCards(s, s.cards):
                        self.addHint(5000, 1, s, r)


class Frames_Foundation(UnionSquare_Foundation):
    def acceptsCards(self, from_stack, cards):
        if not UnionSquare_Foundation.acceptsCards(self, from_stack, cards):
            return False
        return from_stack in self.game.s.rows


class Frames_RowStack(UD_SS_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not UD_SS_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not (from_stack in self.game.s.reserves or
                from_stack in self.game.s.rows):
            return False
        if len(self.cards) > 1:
            cs = self.cards+cards
            if not (isSameSuitSequence(cs, dir=1) or
                    isSameSuitSequence(cs, dir=-1)):
                return False
        if from_stack in self.game.s.reserves:
            if hasattr(self.cap, 'column') and \
                   self.cap.column != from_stack.cap.column:
                return False
            if hasattr(self.cap, 'row') and \
                    self.cap.row != from_stack.cap.row:
                return False
        return True


class Frames(Game):
    Hint_Class = Frames_Hint  # CautiousDefaultHint

    def createGame(self):
        l, s = Layout(self), self.s

        self.setSize(l.XM+8*l.XS, l.YM+5*l.YS)

        x0, y0 = l.XM+2*l.XS, l.YM
        # foundations (corners)
        suit = 0
        for i,  j in ((0, 0), (5, 0), (0, 4), (5, 4)):
            x, y = x0+i*l.XS, y0+j*l.YS
            s.foundations.append(Frames_Foundation(x, y, self,
                                 suit=suit, dir=0, max_cards=26))
            suit += 1
        # rows (frame)
        for i in (1, 2, 3, 4):
            for j in (0, 4):
                x, y = x0+i*l.XS, y0+j*l.YS
                stack = Frames_RowStack(x, y, self)
                s.rows.append(stack)
                stack.cap.addattr(column=i)
                stack.CARD_YOFFSET = 0
        for i in (0, 5):
            for j in (1, 2, 3):
                x, y = x0+i*l.XS, y0+j*l.YS
                stack = Frames_RowStack(x, y, self)
                s.rows.append(stack)
                stack.cap.addattr(row=j)
                stack.CARD_YOFFSET = 0
        # reserves (picture)
        for j in (1, 2, 3):
            for i in (1, 2, 3, 4):
                x, y = x0+i*l.XS, y0+j*l.YS
                stack = OpenStack(x, y, self)
                s.reserves.append(stack)
                stack.cap.addattr(column=i)
                stack.cap.addattr(row=j)
        # talon & waste
        x, y, = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'ne')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'ne')

        l.defaultStackGroups()

    def startGame(self):
        self.s.talon.dealRow(frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if not stack.cards and stack in self.s.reserves:
            if not self.s.waste.cards:
                self.s.talon.dealCards()
            if self.s.waste.cards:
                old_state = self.enterState(self.S_FILL)
                self.s.waste.moveMove(1, stack)
                self.leaveState(old_state)

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Royal Rendezvous
# ************************************************************************

class RoyalRendezvous(Game):

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+9.5*l.XS, l.YM+4.5*l.YS)

        y = l.YM
        # kings
        suit = 0
        for i in (0, 1, 6, 7):
            x = l.XM+(1.5+i)*l.XS
            s.foundations.append(SS_FoundationStack(x, y, self, suit=suit,
                                 base_rank=KING, max_cards=1))
            suit += 1
        # aces
        suit = 0
        for i in (2, 3, 4, 5):
            x = l.XM+(1.5+i)*l.XS
            s.foundations.append(SS_FoundationStack(x, y, self, suit=suit))
            suit += 1
        y += l.YS
        # twos
        suit = 0
        for i in (0, 1, 6, 7):
            x = l.XM+(1.5+i)*l.XS
            s.foundations.append(SS_FoundationStack(x, y, self, suit=suit,
                                 base_rank=1, dir=2, max_cards=6))
            suit += 1
        # aces
        suit = 0
        for i in (2, 3, 4, 5):
            x = l.XM+(1.5+i)*l.XS
            s.foundations.append(SS_FoundationStack(x, y, self, suit=suit,
                                 dir=2, max_cards=6))
            suit += 1

        y += 1.5*l.YS
        for i in (0, 1):
            x = l.XM+1.5*l.XS
            for j in range(8):
                s.rows.append(OpenStack(x, y, self, max_accept=0))
                x += l.XS
            y += l.YS

        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'ne')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'ne')

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        # move twos to top
        cards = self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank == 1 and c.deck == 0, c.suit))
        # move aces to top
        cards = self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank == ACE, (c.deck, c.suit)))
        return cards

    def startGame(self):
        # deal aces
        self.s.talon.dealRow(rows=self.s.foundations[4:8], frames=0)
        self.s.talon.dealRow(rows=self.s.foundations[12:16], frames=0)
        # deal twos
        self.s.talon.dealRow(rows=self.s.foundations[8:12], frames=0)
        #
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if not stack.cards and stack in self.s.rows:
            if not self.s.waste.cards:
                self.s.talon.dealCards()
            if self.s.waste.cards:
                old_state = self.enterState(self.S_FILL)
                self.s.waste.moveMove(1, stack)
                self.leaveState(old_state)


# ************************************************************************
# * Shady Lanes
# ************************************************************************

class ShadyLanes_Hint(CautiousDefaultHint):
    def computeHints(self):
        CautiousDefaultHint.computeHints(self)
        if self.hints:
            return
        for r in self.game.s.rows:
            if not r.cards:
                for s in self.game.s.reserves:
                    if s.cards:
                        self.addHint(5000-s.cards[0].rank, 1, s, r)


class ShadyLanes_Foundation(AbstractFoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if self.cards:
            # check the rank
            if self.cards[-1].rank+1 != cards[0].rank:
                return False
        return True

    def getHelp(self):
        return _('Foundation. Build up by color.')


class ShadyLanes_RowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if not self.cards:
            return from_stack in self.game.s.reserves
        return True


class ShadyLanes(Game):
    Hint_Class = ShadyLanes_Hint

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+5*l.YS)

        x, y = l.XM, l.YM
        for i in range(8):
            suit = i//2
            color = suit//2
            s.foundations.append(
                ShadyLanes_Foundation(
                    x, y, self,
                    base_suit=suit, suit=ANY_SUIT, color=color))
            x += l.XS
        x, y = l.XM, l.YM+l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'ne')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'ne')
        x, y = l.XM+2*l.XS, l.YM+l.YS
        for i in range(4):
            s.rows.append(ShadyLanes_RowStack(x, y, self, max_move=1))
            x += l.XS

        x, y = self.width-l.XS, l.YM+l.YS
        for i in range(4):
            s.reserves.append(OpenStack(x, y, self, max_accept=0))
            y += l.YS

        l.defaultStackGroups()

    def fillStack(self, stack):
        if not stack.cards and stack in self.s.reserves:
            if not self.s.waste.cards:
                self.s.talon.dealCards()
            if self.s.waste.cards:
                old_state = self.enterState(self.S_FILL)
                self.s.waste.moveMove(1, stack)
                self.leaveState(old_state)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Four Winds
# * Boxing the Compass
# ************************************************************************

class FourWinds(Game):

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+9*l.XS, l.YM+6*l.YS)

        # vertical rows
        x = l.XM+l.XS
        for i in (0, 1):
            y = l.YM+l.YS
            for j in range(4):
                stack = ReserveStack(x, y, self, base_suit=i)
                stack.getBottomImage = stack._getSuitBottomImage
                s.rows.append(stack)
                y += l.YS
            x += 6*l.XS
        # horizontal rows
        y = l.YM+l.YS
        for i in (2, 3):
            x = l.XM+2.5*l.XS
            for j in range(4):
                stack = ReserveStack(x, y, self, base_suit=i)
                stack.getBottomImage = stack._getSuitBottomImage
                s.rows.append(stack)
                x += l.XS
            y += 3*l.YS
        # foundations
        decks = self.gameinfo.decks
        for k in range(decks):
            suit = 0
            for i, j in ((0, 3-decks*0.5+k),
                         (8, 3-decks*0.5+k),
                         (4.5-decks*0.5+k, 0),
                         (4.5-decks*0.5+k, 5)):
                x, y = l.XM+i*l.XS, l.YM+j*l.YS
                s.foundations.append(SS_FoundationStack(x, y, self,
                                     suit=suit, max_move=0))
                suit += 1
        # talon & waste
        x, y = l.XM+3.5*l.XS, l.YM+2.5*l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=2)
        l.createText(s.talon, 's')
        l.createRoundText(self.s.talon, 'nn')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 's')

        l.defaultStackGroups()

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank == ACE, (c.deck, c.suit)))


class BoxingTheCompass(FourWinds):
    pass


# ************************************************************************
# * Colonel
# ************************************************************************

class Colonel_Hint(DefaultHint):
    def _getMoveCardBonus(self, r, t, pile, rpile):
        if r in self.game.s.rows and t in self.game.s.rows:
            if rpile:
                return 0
        return DefaultHint._getMoveCardBonus(self, r, t, pile, rpile)


class Colonel_RowStack(SS_RowStack):

    def _getStackIndex(self, stack):
        index = list(self.game.s.rows).index(stack)
        if index < 12:
            row = 0
        elif 12 <= index < 24:
            row = 1
        else:
            row = 2
        return index, row

    def acceptsCards(self, from_stack, cards):
        if not SS_RowStack.acceptsCards(self, from_stack, cards):
            return False

        self_index, self_row = self._getStackIndex(self)

        if self_row in (1, 2):
            above_stack = self.game.s.rows[self_index-12]
            if not above_stack.cards:
                return False

        below_stack = None
        if self_row in (0, 1):
            below_stack = self.game.s.rows[self_index+12]

        # from_stack is waste
        if from_stack is self.game.s.waste:
            if below_stack is None or not below_stack.cards:
                return True
            else:
                return False

        #  from_stack in rows
        from_index, from_row = self._getStackIndex(from_stack)
        if below_stack and below_stack.cards:
            return from_stack is below_stack
        return from_row > self_row

    def canMoveCards(self, cards):
        self_index, self_row = self._getStackIndex(self)
        if self_row in (0, 1):
            below_stack = self.game.s.rows[self_index+12]
            if below_stack.cards:
                return False
        return SS_RowStack.canMoveCards(self, cards)

    getBottomImage = Stack._getReserveBottomImage


class Colonel(Game):
    Hint_Class = Colonel_Hint

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+12*l.XS, l.YM+5*l.YS)

        x, y = l.XM+2*l.XS, l.YM
        for i in range(8):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2,
                                                    max_move=0))
            x += l.XS

        y = l.YM+l.YS
        for i in range(3):
            x = l.XM
            for j in range(12):
                stack = Colonel_RowStack(x, y, self, max_move=1)
                stack.CARD_YOFFSET = 0
                s.rows.append(stack)
                x += l.XS
            y += l.YS

        x, y = l.XM+5*l.XS, l.YM+4*l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'sw')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'se')

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(frames=4)
        self.s.talon.dealCards()

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * The Red and the Black
# ************************************************************************


class TheRedAndTheBlack_Foundation(AC_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack is self.game.s.waste or from_stack in self.game.s.rows:
            return True
        return False


class TheRedAndTheBlack_Reserve(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack is self.game.s.waste:
            return True
        return False


class TheRedAndTheBlack(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM + 8*l.XS, l.YM + 4.5*l.YS)

        x, y = l.XM, l.YM
        for i in range(8):
            s.foundations.append(TheRedAndTheBlack_Foundation(x, y, self,
                                                              suit=i//2))
            x += l.XS
        x, y = l.XM+2*l.XS, l.YM+l.YS
        for i in range(4):
            stack = AC_RowStack(x, y, self, max_move=1)
            stack.getBottomImage = stack._getReserveBottomImage
            stack.CARD_YOFFSET = 0
            s.rows.append(stack)
            x += l.XS
        x, y = l.XM+2*l.XS, l.YM+2*l.YS
        for i in range(4):
            s.reserves.append(TheRedAndTheBlack_Reserve(x, y, self))
            x += l.XS
        x, y = l.XM+3*l.XS, l.YM+3.5*l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, "sw")
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "se")

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealCards()       # deal first card to WasteStack

    def _shuffleHook(self, cards):
        # move Aces to top of the Talon (i.e. first cards to be dealt)
        return self._shuffleHookMoveToTop(
            cards, lambda c: (c.rank == ACE, c.suit))

    shallHighlightMatch = Game._shallHighlightMatch_AC


# ************************************************************************
# * Twilight Zone
# ************************************************************************

class TwilightZone_Foundation(AC_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_FoundationStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack is self.game.s.waste or \
                from_stack in self.game.s.reserves:
            return False
        return True


class TwilightZone_Talon(OpenTalonStack, WasteTalonStack):
    rightclickHandler = OpenStack.rightclickHandler
    doubleclickHandler = OpenStack.doubleclickHandler

    def prepareStack(self):
        OpenTalonStack.prepareStack(self)
        self.waste = self.game.s.waste

    canDealCards = WasteTalonStack.canDealCards
    dealCards = WasteTalonStack.dealCards


class TwilightZone_RowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not AC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if from_stack is self.game.s.waste:
            return False
        return True


class TwilightZone_Waste(WasteStack):
    def acceptsCards(self, from_stack, cards):
        if not WasteStack.acceptsCards(self, from_stack, cards):
            return False
        return from_stack is self.game.s.talon


class TwilightZone(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):

        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM+7*l.XS, l.YM+5*l.YS)

        # create stacks
        y = l.YM
        for i in range(2):
            x = l.XM+3*l.XS
            for j in range(4):
                s.foundations.append(TwilightZone_Foundation(x, y, self,
                                                             suit=j))
                x += l.XS
            y += l.YS

        x, y = l.XM+3*l.XS, l.YM+2*l.YS
        for i in range(4):
            stack = TwilightZone_RowStack(x, y, self, max_move=1)
            stack.CARD_YOFFSET = 0
            s.rows.append(stack)
            x += l.XS

        x, y = l.XM+3*l.XS, l.YM+4*l.YS
        for i in range(4):
            s.reserves.append(OpenStack(x, y, self))
            x += l.XS

        x, y = l.XM, l.YM+l.YS//2
        s.talon = TwilightZone_Talon(x, y, self, max_move=1, max_rounds=2)
        l.createText(s.talon, 's')
        l.createRoundText(s.talon, 'nn')
        x += l.XS
        s.waste = TwilightZone_Waste(x, y, self, max_accept=1)
        l.createText(s.waste, 's')

        # define stack-groups
        l.defaultStackGroups()
        self.sg.dropstacks.append(s.talon)
        self.sg.openstacks.append(s.waste)

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.fillStack()

    def fillStack(self, stack):
        if not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if stack in self.s.rows:
                i = list(self.s.rows).index(stack)
                from_stack = self.s.reserves[i]
                if from_stack.cards:
                    from_stack.moveMove(1, stack)
            elif stack in self.s.reserves:
                from_stack = self.s.waste
                if not from_stack.cards:
                    from_stack = self.s.talon
                if from_stack.cards:
                    from_stack.moveMove(1, stack)
            self.leaveState(old_state)

    def _autoDeal(self, sound=True):
        return 0

    shallHighlightMatch = Game._shallHighlightMatch_AC


# register the game
registerGame(GameInfo(54, RoyalCotillion, "Royal Cotillion",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_LUCK))
registerGame(GameInfo(55, OddAndEven, "Odd and Even",
                      GI.GT_2DECK_TYPE, 2, 1, GI.SL_LUCK))
registerGame(GameInfo(143, Kingdom, "Kingdom",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(234, Alhambra, "Alhambra",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(97, Carpet, "Carpet",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(391, BritishConstitution, "British Constitution",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED,
                      ranks=list(range(11)),  # without Queens and Kings
                      altnames=("Constitution",)))
registerGame(GameInfo(392, NewBritishConstitution, "New British Constitution",
                      GI.GT_2DECK_TYPE | GI.GT_ORIGINAL, 2, 0, GI.SL_BALANCED,
                      ranks=list(range(11))  # without Queens and Kings
                      ))
registerGame(GameInfo(443, Twenty, "Twenty",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(465, Granada, "Granada",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(579, ThreePirates, "Three Pirates",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(608, Frames, "Frames",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(609, GrantsReinforcement, "Grant's Reinforcement",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_BALANCED))
registerGame(GameInfo(638, RoyalRendezvous, "Royal Rendezvous",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(639, ShadyLanes, "Shady Lanes",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(675, FourWinds, "Four Winds",
                      GI.GT_1DECK_TYPE, 1, 1, GI.SL_BALANCED))
registerGame(GameInfo(676, BoxingTheCompass, "Boxing the Compass",
                      GI.GT_2DECK_TYPE, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(693, Colonel, "Colonel",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(695, TheRedAndTheBlack, "The Red and the Black",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(748, TwilightZone, "Twilight Zone",
                      GI.GT_2DECK_TYPE, 2, 1, GI.SL_BALANCED))
registerGame(GameInfo(752, Reserves, "Reserves",
                      GI.GT_2DECK_TYPE, 2, 2, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.layout import Layout
from pysollib.stack import \
        BasicRowStack, \
        InitialDealTalonStack, \
        ReserveStack, \
        SS_FoundationStack
from pysollib.util import KING

# ************************************************************************
# * Buffalo Bill
# * Little Billie
# ************************************************************************


class BuffaloBill(Game):

    #
    # game layout
    #

    def createGame(self, rows=(7, 7, 7, 5)):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+max(
            max(rows)*(l.XS+3*l.XOFFSET), 9*l.XS), l.YM+(len(rows)+2)*l.YS
        self.setSize(w, h)

        # create stacks
        x, y = l.XM+(w-l.XM-8*l.XS)//2, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += l.XS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self,
                                 base_rank=KING, suit=i, dir=-1))
            x += l.XS
        n = 0
        y = l.YM+l.YS
        for i in rows:
            x = l.XM
            for j in range(i):
                stack = BasicRowStack(x, y, self, max_move=1, max_accept=0)
                stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
                s.rows.append(stack)
                x += l.XS+3*l.XOFFSET
                n += 1
            y += l.YS

        x, y = l.XM+(w-l.XM-8*l.XS)//2, h-l.YS
        for i in range(8):
            s.reserves.append(ReserveStack(x, y, self))
            x += l.XS
        s.talon = InitialDealTalonStack(w-l.XS, h-l.YS, self)

        # default
        l.defaultAll()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRowsAndDealSingleRow(3)


class LittleBillie(BuffaloBill):
    def createGame(self):
        # BuffaloBill.createGame(self, rows=(8, 8, 8))
        BuffaloBill.createGame(self, rows=(6, 6, 6, 6))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.reserves, frames=0)
        BuffaloBill.startGame(self)


# register the game
registerGame(GameInfo(338, BuffaloBill, "Buffalo Bill",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(421, LittleBillie, "Little Billie",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_MOSTLY_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.layout import Layout
from pysollib.stack import \
        BasicRowStack, \
        DealRowTalonStack, \
        SS_FoundationStack
from pysollib.util import ACE, KING

# ************************************************************************
# * Parallels
# * British Blockade
# ************************************************************************


class Parallels_RowStack(BasicRowStack):
    def basicIsBlocked(self):
        index = self.index
        rows = self.game.s.rows
        if index < 10:
            return False
        if not rows[index-10].cards:
            return False
        if index >= 60:  # last row
            return False
        if not rows[index+10].cards:
            return False
        return True


class Parallels_TalonStack(DealRowTalonStack):
    def dealCards(self, sound=False):
        return self.dealRow(sound=sound)

    def dealRow(self, rows=None, flip=1, reverse=0, frames=-1, sound=False):
        if rows is not None:
            return DealRowTalonStack.dealRowAvail(
                self, rows=rows, flip=flip,
                reverse=reverse, frames=frames, sound=sound)
        rows = self.game.s.rows
        for r in rows[:10]:
            if not r.cards:
                return self._fillRow(frames=frames, sound=sound)
        column_ncards = []
        for i in range(10):
            column = [r for r in rows[i::10] if r.cards]
            column_ncards.append(len(column))
        max_col = max(column_ncards)
        if max(column_ncards) != min(column_ncards):
            return self._fillRow(frames=frames, sound=sound)
        r = rows[max_col*10:max_col*10+10]
        return DealRowTalonStack.dealRowAvail(
            self, rows=r, flip=flip,
            reverse=reverse, frames=frames, sound=sound)

    def _fillRow(self, frames=-1, sound=False):
        rows = self.game.s.rows
        column_ncards = []
        for i in range(10):
            column = [r for r in rows[i::10] if r.cards]
            column_ncards.append(len(column))
        max_col = max(column_ncards)
        max_col = max(max_col, 1)
        n = 0
        rr = self.game.s.rows[:max_col*10]
        while True:
            filled = False
            for i in range(10):
                prev_s = None
                for s in rr[i::10]:
                    if not self.cards:
                        filled = False
                        break
                    if s.cards:
                        if prev_s:
                            DealRowTalonStack.dealRow(
                                self, rows=[prev_s],
                                frames=frames, sound=sound)
                            n += 1
                            filled = True
                        break
                    prev_s = s
            if not filled:
                break
        while True:
            filled = False
            for i in range(10):
                for s in rr[i::10]:
                    if not self.cards:
                        filled = False
                        break
                    if not s.cards:
                        DealRowTalonStack.dealRow(
                            self, rows=[s],
                            frames=frames, sound=sound)
                        n += 1
                        filled = True
                        break
            if not filled:
                break

        return n


class Parallels(Game):

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        # set window
        self.setSize(l.XM+12*l.XS, l.YM+7*l.YS)
        # create stacks
        s.talon = Parallels_TalonStack(l.XM, l.YM, self)
        l.createText(s.talon, 's')
        n = 0
        y = l.YM
        for i in range(7):
            x = l.XM+l.XS
            for j in range(10):
                stack = Parallels_RowStack(x, y, self, max_accept=0)
                stack.index = n
                s.rows.append(stack)
                n += 1
                x += l.XS
            y += l.YS
        x, y = l.XM, l.YM+l.YS+l.YS//2
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            y += l.YS
        x, y = l.XM+11*l.XS, l.YM+l.YS+l.YS//2
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                    base_rank=KING, dir=-1))
            y += l.YS

        # define stack-groups
        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToTop(
            cards,
            lambda c: (c.rank in (ACE, KING) and c.deck == 0,
                       (c.rank, c.suit)))

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:10])


class BritishBlockade(Parallels):

    def fillStack(self, stack):
        if not stack.cards and stack in self.s.rows:
            if self.s.talon.cards:
                old_state = self.enterState(self.S_FILL)
                self.s.talon.flipMove()
                self.s.talon.moveMove(1, stack)
                self.leaveState(old_state)


# register the game
registerGame(GameInfo(428, Parallels, "Parallels",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(615, BritishBlockade, "British Blockade",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint, DefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        AC_FoundationStack, \
        BasicRowStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        InvisibleStack, \
        RK_RowStack, \
        SC_RowStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, ANY_SUIT, JACK, KING, QUEEN


class GrandfathersClock_Hint(CautiousDefaultHint):
    # FIXME: demo is not too clever in this game

    def _getDropCardScore(self, score, color, r, t, ncards):
        # drop all cards immediately
        return 92000, color


# ************************************************************************
# * Grandfather's Clock
# ************************************************************************

class GrandfathersClock(Game):
    Hint_Class = GrandfathersClock_Hint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (piles up to 9 cards are fully playable in default window size)
        dh = max(3*l.YS//2+l.CH, l.YS+(9-1)*l.YOFFSET)
        self.setSize(10*l.XS+l.XM, l.YM+2*dh)

        # create stacks
        for i in range(2):
            x, y = l.XM, l.YM + i*dh
            for j in range(4):
                s.rows.append(
                    RK_RowStack(x, y, self, max_move=1, max_accept=1))
                x = x + l.XS
        y = l.YM + dh - l.CH // 2
        self.setRegion(s.rows[:4], (-999, -999, x - l.XM // 2, y))
        self.setRegion(s.rows[4:], (-999,    y, x - l.XM // 2, 999999))
        d = [(0, 0), (1, 0.15), (2, 0.5), (2.5, 1.5), (2, 2.5), (1, 2.85)]
        for i in range(len(d)):
            d.append((0 - d[i][0], 3 - d[i][1]))
        x0, y0 = l.XM, l.YM + dh - l.CH
        for i in range(12):
            j = (i + 5) % 12
            x = int(round(x0 + (6.5+d[j][0]) * l.XS))
            y = int(round(y0 + (-1.5+d[j][1]) * l.YS))
            suit = (1, 2, 0, 3)[i % 4]
            s.foundations.append(SS_FoundationStack(x, y, self, suit,
                                                    base_rank=i+1, mod=13,
                                                    max_move=0))
        s.talon = InitialDealTalonStack(
            self.width-l.XS, self.height-l.YS, self)

        # define stack-groups
        self.sg.openstacks = s.foundations + s.rows
        self.sg.talonstacks = [s.talon]
        self.sg.dropstacks = s.rows

    #
    # game overrides
    #
    def _shuffleHook(self, cards):
        # move clock cards to bottom of the Talon (i.e. last cards to be dealt)
        C, S, H, D = 0*13, 1*13, 2*13, 3*13
        ids = (1+S, 2+H, 3+C, 4+D, 5+S, 6+H, 7+C, 8+D, 9+S, 10+H, 11+C, 12+D)
        clocks = []
        for c in cards[:]:
            if c.id in ids:
                clocks.append(c)
                cards.remove(c)
        # sort clocks reverse by rank
        clocks.sort(key=lambda x: -x.rank)
        return clocks + cards

    def startGame(self):
        self.playSample("grandfathersclock", loop=1)
        self._dealNumRows(4)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.foundations)

    shallHighlightMatch = Game._shallHighlightMatch_RK

    def getHighlightPilesStacks(self):
        return ()

    def getAutoStacks(self, event=None):
        # disable auto drop - this would ruin the whole gameplay
        return ((), (), ())


# ************************************************************************
# * Dial
# ************************************************************************

class Dial(Game):

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+8*l.XS, l.YM+4*l.YS)

        x0, y0 = l.XM+2*l.XS, l.YM
        rank = 0
        for xx, yy in ((3.5, 0.15),
                       (4.5, 0.5),
                       (5,   1.5),
                       (4.5, 2.5),
                       (3.5, 2.85),
                       (2.5, 3),
                       (1.5, 2.85),
                       (0.5, 2.5),
                       (0,   1.5),
                       (0.5, 0.5),
                       (1.5, 0.15),
                       (2.5, 0),
                       (2.5, 1.5),
                       ):
            x = int(x0 + xx*l.XS)
            y = int(y0 + yy*l.YS)
            s.foundations.append(
                AC_FoundationStack(
                    x, y, self, suit=ANY_SUIT,
                    dir=0, max_cards=4, base_rank=rank, max_move=0))
            rank += 1

        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=2)
        l.createText(s.talon, 's')
        l.createRoundText(s.talon, 'sss')
        x += l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 's')

        l.defaultStackGroups()

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealCards()          # deal first card to WasteStack


# ************************************************************************
# * Hemispheres
# ************************************************************************

BLACK, RED = 0, 1


class Hemispheres_Hint(DefaultHint):
    def shallMovePile(self, from_stack, to_stack, pile, rpile):
        if not self._defaultShallMovePile(from_stack, to_stack, pile, rpile):
            return False
        if from_stack in self.game.s.rows and to_stack in self.game.s.rows:
            # check for loops
            return len(from_stack.cards) == 1
        return True


class Hemispheres_RowStack(SC_RowStack):

    def _canSwapPair(self, from_stack):
        if from_stack not in self.game.s.rows[4:]:
            return False
        if len(self.cards) != 1 or len(from_stack.cards) != 1:
            return False
        if self in self.game.s.rows[4:10]:
            alt_rows = self.game.s.rows[10:]
            color = RED
        else:
            alt_rows = self.game.s.rows[4:10]
            color = BLACK
        if from_stack not in alt_rows:
            return False
        c0, c1 = from_stack.cards[0], self.cards[0]
        return c0.color == color and c1.color != color

    def acceptsCards(self, from_stack, cards):
        if self._canSwapPair(from_stack):
            return True
        if not SC_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if self in self.game.s.rows[4:10]:
            if cards[0].color == BLACK:
                return False
            return (from_stack in self.game.s.rows[4:10] or
                    from_stack is self.game.s.waste)
        if self in self.game.s.rows[10:]:
            if cards[0].color == RED:
                return False
            return (from_stack in self.game.s.rows[10:] or
                    from_stack is self.game.s.waste)
        return False

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        if self._canSwapPair(to_stack):
            self._swapPairMove(ncards, to_stack, frames=-1, shadow=0)
        else:
            SC_RowStack.moveMove(self, ncards, to_stack,
                                 frames=frames, shadow=shadow)

    def _swapPairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        old_state = game.enterState(game.S_FILL)
        swap = game.s.internals[0]
        game.moveMove(n, self, swap, frames=0)
        game.moveMove(n, other_stack, self, frames=frames, shadow=shadow)
        game.moveMove(n, swap, other_stack, frames=0)
        game.leaveState(old_state)


class Hemispheres(Game):
    Hint_Class = Hemispheres_Hint

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+9.5*l.XS, l.YM+5*l.YS)

        # internal stack (for swap)
        s.internals.append(InvisibleStack(self))

        x0, y0 = l.XM+1.5*l.XS, l.YM
        # barriers
        for xx, yy in ((0,   2),
                       (7,   2),
                       (3.5, 0),
                       (3.5, 4),
                       ):
            x, y = x0+xx*l.XS, y0+yy*l.YS
            s.rows.append(BasicRowStack(x, y, self, max_accept=0))

        # northern hemisphere (red)
        for xx, yy in ((0.5, 1),
                       (1.5, 0.5),
                       (2.5, 0.3),
                       (4.5, 0.3),
                       (5.5, 0.5),
                       (6.5, 1),
                       ):
            x, y = x0+xx*l.XS, y0+yy*l.YS
            stack = Hemispheres_RowStack(x, y, self,
                                         base_color=RED, max_move=1)
            stack.CARD_YOFFSET = 0
            s.rows.append(stack)

        # southern hemisphere (black)
        for xx, yy in ((6.5, 3),
                       (5.5, 3.5),
                       (4.5, 3.8),
                       (2.5, 3.8),
                       (1.5, 3.5),
                       (0.5, 3),
                       ):
            x, y = x0+xx*l.XS, y0+yy*l.YS
            stack = Hemispheres_RowStack(x, y, self,
                                         base_color=BLACK, max_move=1, dir=1)
            stack.CARD_YOFFSET = 0
            s.rows.append(stack)

        # foundations
        x, y = x0+2*l.XS, y0+1.5*l.YS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=2+i//2,
                                                    max_move=0))
            x += l.XS
        x, y = x0+2*l.XS, y+l.YS
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i//2,
                                 max_move=0, base_rank=KING, dir=-1))
            x += l.XS

        # talon & waste
        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'ne')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'ne')

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        founds_cards = []               # foundations
        rows_cards = []                 # rows
        for c in cards[:]:
            if c.rank in (ACE, KING):
                cond = ((c.rank == ACE and c.color == RED) or
                        (c.rank == KING and c.color == BLACK))
                if cond:
                    cards.remove(c)
                    founds_cards.append(c)
                elif c.deck == 0:
                    cards.remove(c)
                    rows_cards.append(c)
        founds_cards.sort(key=lambda x: (-x.rank, -x.suit))
        rows_cards.sort(key=lambda x: (x.rank, x.suit))
        return cards+rows_cards+founds_cards

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.foundations, frames=0)
        self._startAndDealRowAndCards()

    def fillStack(self, stack):
        if stack in self.s.rows[4:] and not stack.cards:
            old_state = self.enterState(self.S_FILL)
            if not self.s.waste.cards:
                self.s.talon.dealCards()
            if self.s.waste.cards:
                self.s.waste.moveMove(1, stack)
            self.leaveState(old_state)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        # by color
        return card1.color == card2.color and abs(card1.rank-card2.rank) == 1


# ************************************************************************
# * Big Ben
# ************************************************************************

class BigBen_Talon(DealRowTalonStack):

    def dealCards(self, sound=False):
        if not self.cards:
            return 0
        rows = [s for s in self.game.s.rows if len(s.cards) < 3]
        if not rows:
            # deal to the waste
            if sound and not self.game.demo:
                self.game.playSample("dealwaste")
            self.game.flipAndMoveMove(self, self.game.s.waste)
            return 1
        # deal to the rows
        if sound and self.game.app.opt.animations:
            self.game.startDealSample()
        ncards = 0
        while rows:
            n = self.dealRowAvail(rows=rows, sound=False)
            if not n:
                break
            ncards += n
            rows = [s for s in self.game.s.rows if len(s.cards) < 3]
        if sound:
            self.game.stopSamples()
        return ncards


class BigBen_RowStack(SS_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not SS_RowStack.acceptsCards(self, from_stack, cards):
            return False
        if len(self.cards) < 3:
            return False
        return True


class BigBen(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+12*l.XS, l.YM+5.5*l.YS)

        y = l.YM
        for i in range(2):
            x = l.XM
            for j in range(6):
                s.rows.append(BigBen_RowStack(x, y, self, max_move=1, mod=13))
                x += l.XS
            y += 2.75*l.YS

        x0, y0 = l.XM+6*l.XS, l.YM
        rank = 1
        for xx, yy in (
            (0,   1.5),
            (0.5, 0.5),
            (1.5, 0.15),
            (2.5, 0),
            (3.5, 0.15),
            (4.5, 0.5),
            (5,   1.5),
            (4.5, 2.5),
            (3.5, 2.85),
            (2.5, 3),
            (1.5, 2.85),
            (0.5, 2.5),
                ):
            x = int(x0 + xx*l.XS)
            y = int(y0 + yy*l.YS)
            suit = (3, 0, 2, 1)[rank % 4]
            max_cards = rank <= 4 and 8 or 9
            s.foundations.append(SS_FoundationStack(x, y, self, suit=suit,
                                 max_cards=max_cards, base_rank=rank,
                                 mod=13, max_move=0))
            rank += 1

        x, y = self.width-l.XS, self.height-l.YS
        s.talon = BigBen_Talon(x, y, self, max_rounds=1)
        l.createText(s.talon, 'n')
        x -= l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'n')

        l.defaultStackGroups()

    def _shuffleHook(self, cards):
        # move clock cards to top of the Talon (i.e. first cards to be dealt)
        C, S, H, D = list(range(4))           # suits
        t = [(1, C), (2, H), (3, S), (4, D), (5, C), (6, H),
             (7, S), (8, D), (9, C), (JACK, H), (QUEEN, S), (KING, D)]
        clocks = []
        for c in cards[:]:
            if (c.rank, c.suit) in t:
                t.remove((c.rank, c.suit))
                cards.remove(c)
                clocks.append(c)
            if not t:
                break
        # sort clocks reverse by rank
        clocks.sort(key=lambda x: -x.rank)
        return cards+clocks

    def startGame(self):
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations, frames=4)
        for i in range(3):
            self.s.talon.dealRow(frames=4)

    def _autoDeal(self, sound=True):
        # don't deal a card to the waste if the waste is empty
        return 0

    shallHighlightMatch = Game._shallHighlightMatch_SSW


# ************************************************************************
# * Clock
# ************************************************************************

class Clock_RowStack(RK_RowStack):

    def _numFaceDown(self):
        ncards = 0
        for c in self.cards:
            if not c.face_up:
                ncards += 1
        return ncards

    def acceptsCards(self, from_stack, cards):
        return cards[0].rank == self.id

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        self._swapPairMove(ncards, to_stack, frames=-1, shadow=0)

    def _swapPairMove(self, n, other_stack, frames=-1, shadow=-1):
        is_king = other_stack.cards[-1].rank == KING
        game = self.game
        old_state = game.enterState(game.S_FILL)
        swap = game.s.internals[0]
        ncards = other_stack._numFaceDown()
        for i in range(ncards):
            game.moveMove(n, other_stack, swap, frames=0)
        game.moveMove(n, self, other_stack, frames=0)
        for i in range(ncards):
            game.moveMove(n, swap, other_stack, frames=0)
        game.flipMove(other_stack)
        game.moveMove(n, other_stack, self)
        if is_king:
            self._moveKingToBottom()
        game.leaveState(old_state)

    def _moveKingToBottom(self):
        # move king to bottom of stack
        game = self.game
        swap, swap2 = game.s.internals
        game.moveMove(1, self, swap2, frames=0)
        ncards = self._numFaceDown()
        for i in range(ncards):
            game.moveMove(1, self, swap, frames=0)
        game.moveMove(1, swap2, self, frames=0)
        for i in range(ncards):
            game.moveMove(1, swap, self, frames=0)
        if not self.cards[-1].face_up:
            game.flipMove(self)
        self._fillStack()

    def _fillStack(self):
        c = self.cards[-1]
        n = self._numFaceDown()
        if n == 0:
            return
        if c.face_up and c.rank == KING:
            self._moveKingToBottom()

    def canFlipCard(self):
        return False


class Clock(Game):

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        dx = l.XS + 3*l.XOFFSET
        w = max(5.25*dx + l.XS, 5.5*dx)
        self.setSize(l.XM + w, l.YM + 4*l.YS)

        # create stacks
        for xx, yy in (
            (3.25, 0.15),
            (4.25, 0.5),
            (4.5,  1.5),
            (4.25, 2.5),
            (3.25, 2.85),
            (2.25, 3),
            (1.25, 2.85),
            (0.25, 2.5),
            (0,    1.5),
            (0.25, 0.5),
            (1.25, 0.15),
            (2.25, 0),
                ):
            x = l.XM + xx*dx
            y = l.YM + yy*l.YS
            stack = Clock_RowStack(x, y, self, max_move=0)
            stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
            stack.SHRINK_FACTOR = 1
            s.rows.append(stack)

        x, y = l.XM + 2.25*dx, l.YM + 1.5*l.YS
        stack = Clock_RowStack(x, y, self, max_move=1)
        stack.CARD_XOFFSET, stack.CARD_YOFFSET = l.XOFFSET, 0
        stack.SHRINK_FACTOR = 1
        s.rows.append(stack)

        x, y = self.width - l.XS, self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)

        # create an invisible stacks
        s.internals.append(InvisibleStack(self))
        s.internals.append(InvisibleStack(self))

        # default
        l.defaultAll()

    def startGame(self):
        for i in range(3):
            self.s.talon.dealRow(frames=0, flip=False)
        self.startDealSample()
        self.s.talon.dealRow(flip=False)
        self.flipMove(self.s.rows[-1])
        self.s.rows[-1]._fillStack()

    def isGameWon(self):
        for r in self.s.rows:
            if not r.cards[-1].face_up:
                return False
        return True

    def getHighlightPilesStacks(self):
        return ()

    def getAutoStacks(self, event=None):
        return (), (), ()


# register the game
registerGame(GameInfo(261, GrandfathersClock, "Grandfather's Clock",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN, 1, 0, GI.SL_BALANCED))
registerGame(GameInfo(682, Dial, "Dial",
                      GI.GT_1DECK_TYPE, 1, 1, GI.SL_LUCK))
registerGame(GameInfo(690, Hemispheres, "Hemispheres",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED,
                      altnames=("The Four Continents",)))
registerGame(GameInfo(697, BigBen, "Big Ben",
                      GI.GT_2DECK_TYPE, 2, 0, GI.SL_BALANCED))
registerGame(GameInfo(737, Clock, "Clock",
                      GI.GT_1DECK_TYPE, 1, 0, GI.SL_LUCK,
                      altnames=("Travellers",)))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AC_RowStack, \
        BasicRowStack, \
        InitialDealTalonStack, \
        ReserveStack, \
        SS_FoundationStack, \
        StackWrapper, \
        UD_AC_RowStack, \
        UD_RK_RowStack, \
        UD_SS_RowStack, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ACE, KING, NO_RANK, RANKS, UNLIMITED_REDEALS


# ************************************************************************
# * Bisley
# ************************************************************************

class Bisley(Game):

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = 2*l.XM+8*l.XS, max(2*(l.YM+l.YS+8*l.YOFFSET), l.YM+5*l.YS)
        self.setSize(w, h)

        # create stacks
        x, y = l.XM, l.YM
        for i in range(6):
            s.rows.append(UD_SS_RowStack(x, y, self, base_rank=NO_RANK))
            x += l.XS
        x, y = l.XM, l.YM+l.YS+8*l.YOFFSET
        for i in range(6):
            s.rows.append(UD_SS_RowStack(x, y, self, base_rank=NO_RANK))
            x += l.XS
        y = l.YM
        for i in range(4):
            x = l.XM+6*l.XS+l.XM
            s.foundations.append(SS_FoundationStack(x, y, self, i, max_move=0))
            x += l.XS
            s.foundations.append(SS_FoundationStack(x, y, self, i,
                                 base_rank=KING, max_move=0, dir=-1))
            y += l.YS

        s.talon = InitialDealTalonStack(w-l.XS, h-l.YS, self)

        # default
        l.defaultAll()

    #
    # game overrides
    #

    def startGame(self):
        self._startDealNumRows(3)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.foundations[::2])

    def _shuffleHook(self, cards):
        # move Aces to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == ACE, c.suit))

    shallHighlightMatch = Game._shallHighlightMatch_SS


# ************************************************************************
# * Double Bisley
# ************************************************************************

class DoubleBisley(Bisley):

    Hint_Class = CautiousDefaultHint

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+(8+2)*l.XS, l.YM+max(3*(l.YS+8*l.YOFFSET), 8*l.YS)
        self.setSize(w, h)

        # create stacks
        y = l.YM
        for i in range(3):
            x = l.XM
            for j in range(8):
                s.rows.append(UD_SS_RowStack(x, y, self, base_rank=NO_RANK))
                x += l.XS
            y += l.YS+8*l.YOFFSET

        y = l.YM
        for j in range(2):
            for i in range(4):
                x = l.XM+8*l.XS
                s.foundations.append(SS_FoundationStack(x, y, self,
                                     suit=j*2+i//2, max_move=0))
                x += l.XS
                s.foundations.append(
                    SS_FoundationStack(
                        x, y, self,
                        suit=j*2+i//2, base_rank=KING, max_move=0, dir=-1))
                y += l.YS

        s.talon = InitialDealTalonStack(l.XM, h-l.YS, self)

        # default
        l.defaultAll()


# ************************************************************************
# * Gloria
# ************************************************************************

class Gloria(Game):

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = l.XM+12*l.XS, l.YM+2*l.YS+2*(l.YS+5*l.YOFFSET)
        self.setSize(w, h)

        # create stacks
        y = l.YM+2*l.YS
        for i in range(2):
            x = l.XM
            for j in range(12):
                s.rows.append(BasicRowStack(x, y, self, max_accept=0))
                x += l.XS
            y += l.YS+5*l.YOFFSET

        x = l.XM+2*l.XS
        for j in range(2):
            for i in range(4):
                y = l.YM
                s.foundations.append(
                    SS_FoundationStack(x, y, self, suit=j*2+i//2))
                y += l.YS
                s.foundations.append(SS_FoundationStack(x, y, self,
                                     suit=j*2+i//2, base_rank=KING, dir=-1))
                x += l.XS

        s.reserves.append(ReserveStack(l.XM, l.YM, self))
        s.reserves.append(ReserveStack(w-l.XS, l.YM, self))

        s.talon = InitialDealTalonStack(l.XM, l.YM+l.YS, self)

        # default
        l.defaultAll()

    def startGame(self):
        self._startDealNumRows(3)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.foundations[1::2])

    def _shuffleHook(self, cards):
        # move Kings to bottom of the Talon (i.e. last cards to be dealt)
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == KING, c.suit))


# ************************************************************************
# * Realm
# * Mancunian
# ************************************************************************

class Realm(Game):

    Hint_Class = CautiousDefaultHint
    RowStack_Class = StackWrapper(UD_AC_RowStack, base_rank=NO_RANK)

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        w, h = 3*l.XM+8*l.XS, l.YM+2*l.YS+15*l.YOFFSET
        self.setSize(w, h)

        # create stacks
        x, y = 2*l.XM, l.YM+l.YS
        for i in range(8):
            s.rows.append(self.RowStack_Class(x, y, self))
            x += l.XS
        y = l.YM
        for i in range(4):
            x = l.XM+i*l.XS
            s.foundations.append(SS_FoundationStack(x, y, self, i, max_move=0))
            x += 2*l.XM+4*l.XS
            s.foundations.append(SS_FoundationStack(x, y, self, i,
                                 base_rank=KING, max_move=0, dir=-1))

        s.talon = InitialDealTalonStack(w-l.XS, h-l.YS, self)

        # default
        l.defaultAll()

    def startGame(self):
        self._startDealNumRows(5)
        self.s.talon.dealRow()
        self.s.talon.dealRowAvail()

    shallHighlightMatch = Game._shallHighlightMatch_AC


class Mancunian(Realm):
    RowStack_Class = StackWrapper(UD_RK_RowStack, base_rank=NO_RANK)

    shallHighlightMatch = Game._shallHighlightMatch_RK


# ************************************************************************
# * Hospital Patience
# ************************************************************************

class HospitalPatience(Game):

    def createGame(self):
        l, s = Layout(self), self.s
        self.setSize(l.XM+6*l.XS, l.YM+2*l.YS)

        x, y = l.XM, l.YM
        s.talon = WasteTalonStack(x, y, self,
                                  max_rounds=UNLIMITED_REDEALS, num_deal=3)
        l.createText(s.talon, 'ne')
        y += l.YS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'ne')

        x = l.XM+2*l.XS
        for i in range(4):
            y = l.YM
            s.foundations.append(SS_FoundationStack(x, y, self, i, max_move=0))
            y += l.YS
            s.foundations.append(SS_FoundationStack(x, y, self, i,
                                 base_rank=KING, max_move=0, dir=-1))
            x += l.XS

        l.defaultStackGroups()

    def startGame(self, flip=0, reverse=1):
        self.startDealSample()
        self.s.talon.dealCards()      # deal first card to WasteStack


# ************************************************************************
# * Board Patience
# ************************************************************************

class BoardPatience(Game):
    Hint_Class = CautiousDefaultHint

    def createGame(self):

        l, s = Layout(self), self.s
        self.setSize(l.XM+10*l.XS, l.YM+2*l.YS+12*l.YOFFSET)

        # extra settings
        self.base_card = None

        # create stacks
        x, y = l.XM+3*l.XS, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self,
                                 suit=i, mod=13))
            x = x + l.XS
        tx, ty, ta, tf = l.getTextAttr(s.foundations[-1], "ne")
        font = self.app.getFont("canvas_default")
        self.texts.info = MfxCanvasText(self.canvas, tx, ty,
                                        anchor=ta, font=font)
        x, y = l.XM, l.YM+l.YS
        for i in range(10):
            s.rows.append(UD_AC_RowStack(x, y, self, mod=13))
            x += l.XS

        x, y = l.XM, l.YM
        s.talon = InitialDealTalonStack(x, y, self)

        # default
        l.defaultAll()

    def updateText(self):
        if self.preview > 1:
            return
        if not self.texts.info:
            return
        if not self.base_card:
            t = ""
        else:
            t = RANKS[self.base_card.rank]
        self.texts.info.config(text=t)

    def startGame(self):
        # deal base_card to Foundations, update foundations cap.base_rank
        self.base_card = self.s.talon.getCard()
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        n = self.base_card.suit
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, self.s.foundations[n], frames=0)
        # deal to rows
        self._startDealNumRows(4)
        self.s.talon.dealRow()
        self.s.talon.dealRowAvail()

    shallHighlightMatch = Game._shallHighlightMatch_ACW

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)


# ************************************************************************
# * Cringle
# ************************************************************************

class Cringle(Game):

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        self.setSize(l.XM + 8.5*l.XS, l.YM + 3*l.YS + 14*l.XOFFSET)

        # create stacks
        x, y, = l.XM, l.YM
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i))
            x += l.XS
        x += l.XS//2
        for i in range(4):
            s.foundations.append(SS_FoundationStack(x, y, self, suit=i,
                                                    base_rank=KING, dir=-1))
            x += l.XS

        x, y = l.XM, l.YM+l.YS
        for j in range(4):
            s.rows.append(AC_RowStack(x, y, self))
            x += l.XS
        x += l.XS//2
        for j in range(4):
            s.rows.append(AC_RowStack(x, y, self, dir=1))
            x += l.XS

        x, y = self.width-l.XS, self.height-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=1)
        l.createText(s.talon, 'n')
        x -= l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, 'n')

        # define stack-groups
        l.defaultStackGroups()

    def startGame(self):
        self._startDealNumRowsAndDealRowAndCards(4)

    shallHighlightMatch = Game._shallHighlightMatch_AC


# register the game
registerGame(GameInfo(290, Bisley, "Bisley",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(372, DoubleBisley, "Double Bisley",
                      GI.GT_2DECK_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL,
                      2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(373, Gloria, "Gloria",
                      GI.GT_2DECK_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL,
                      2, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(374, Realm, "Realm",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL,
                      1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(375, Mancunian, "Mancunian",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN | GI.GT_ORIGINAL,
                      1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(686, HospitalPatience, "Hospital Patience",
                      GI.GT_1DECK_TYPE, 1, -1, GI.SL_MOSTLY_LUCK))
registerGame(GameInfo(692, BoardPatience, "Board Patience",
                      GI.GT_1DECK_TYPE | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL))
registerGame(GameInfo(747, Cringle, "Cringle",
                      GI.GT_2DECK_TYPE | GI.GT_ORIGINAL, 2, 0, GI.SL_BALANCED))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.stack import \
        BasicRowStack, \
        InitialDealTalonStack, \
        isRankSequence

# ************************************************************************
# * Tower of Hanoy
# ************************************************************************


class TowerOfHanoy_Hint(CautiousDefaultHint):
    # FIXME: demo is completely clueless
    pass


class TowerOfHanoy_RowStack(BasicRowStack):
    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return 0
        if not self.cards:
            return 1
        return self.cards[-1].rank > cards[0].rank

    def getBottomImage(self):
        return self.game.app.images.getReserveBottom()


class TowerOfHanoy(Game):
    RowStack_Class = TowerOfHanoy_RowStack
    Hint_Class = TowerOfHanoy_Hint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (piles up to XX cards are fully playable in default window size)
        h = max(2*l.YS, l.YS + (len(self.cards)-1)*l.YOFFSET + l.YM)
        self.setSize(l.XM + 5*l.XS, l.YM + l.YS + h)

        # create stacks
        for i in range(3):
            x, y, = l.XM + (i+1)*l.XS, l.YM
            s.rows.append(
                self.RowStack_Class(x, y, self, max_accept=1, max_move=1))
        s.talon = InitialDealTalonStack(l.XM, self.height-l.YS, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        for i in range(3):
            self.s.talon.dealRow()

    def isGameWon(self):
        for s in self.s.rows:
            if len(s.cards) == len(self.cards):
                return 1
        return 0

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank

    def getAutoStacks(self, event=None):
        return ((), (), self.sg.dropstacks)


# ************************************************************************
# * Hanoi Puzzle
# ************************************************************************

class HanoiPuzzle_RowStack(TowerOfHanoy_RowStack):
    def getBottomImage(self):
        if self.id == len(self.game.s.rows) - 1:
            return self.game.app.images.getSuitBottom()
        return self.game.app.images.getReserveBottom()


class HanoiPuzzle4(TowerOfHanoy):
    RowStack_Class = HanoiPuzzle_RowStack

    def _shuffleHook(self, cards):
        # no shuffling
        return self._shuffleHookMoveToTop(cards, lambda c: (1, -c.id))

    def startGame(self):
        self.startDealSample()
        for i in range(len(self.cards)):
            self.s.talon.dealRow(rows=self.s.rows[:1])

    def isGameWon(self):
        return len(self.s.rows[-1].cards) == len(self.cards)


class HanoiPuzzle5(HanoiPuzzle4):
    pass


class HanoiPuzzle6(HanoiPuzzle4):
    pass


# ************************************************************************
# * Hanoi Sequence
# ************************************************************************

class HanoiSequence(TowerOfHanoy):
    def isGameWon(self):
        for s in self.s.rows:
            if len(s.cards) == len(self.cards) and isRankSequence(s.cards):
                return 1
        return 0


# register the game
registerGame(GameInfo(124, TowerOfHanoy, "Tower of Hanoy",
                      GI.GT_PUZZLE_TYPE, 1, 0, GI.SL_SKILL,
                      suits=(2,), ranks=list(range(9))))
registerGame(GameInfo(207, HanoiPuzzle4, "Hanoi Puzzle 4",
                      GI.GT_PUZZLE_TYPE, 1, 0, GI.SL_SKILL,
                      suits=(2,), ranks=list(range(4)),
                      rules_filename="hanoipuzzle.html"))
registerGame(GameInfo(208, HanoiPuzzle5, "Hanoi Puzzle 5",
                      GI.GT_PUZZLE_TYPE, 1, 0, GI.SL_SKILL,
                      suits=(2,), ranks=list(range(5)),
                      rules_filename="hanoipuzzle.html"))
registerGame(GameInfo(209, HanoiPuzzle6, "Hanoi Puzzle 6",
                      GI.GT_PUZZLE_TYPE, 1, 0, GI.SL_SKILL,
                      suits=(2,), ranks=list(range(6)),
                      rules_filename="hanoipuzzle.html"))
registerGame(GameInfo(769, HanoiSequence, "Hanoi Sequence",
                      GI.GT_PUZZLE_TYPE, 1, 0, GI.SL_SKILL,
                      suits=(2,), ranks=list(range(9))))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.bakersdozen import Cruel_Talon
from pysollib.games.braid import Braid, Braid_ReserveStack, Braid_RowStack
from pysollib.games.braid import Braid_BraidStack, Braid_Foundation
from pysollib.hint import CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        InitialDealTalonStack, \
        OpenStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ANY_RANK, NO_RANK, UNLIMITED_ACCEPTS, UNLIMITED_MOVES

# ************************************************************************
# * Tarock Talon Stacks
# ************************************************************************


class Wicked_Talon(Cruel_Talon):
    pass


# ************************************************************************
# * Tarock Foundation Stacks
# ************************************************************************

class ImperialTrump_Foundation(SS_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not SS_FoundationStack.acceptsCards(self, from_stack, cards):
            return 0
        return cards[-1].rank < len(self.game.s.foundations[4].cards)


class Ponytail_Foundation(Braid_Foundation):
    pass


# ************************************************************************
# * Tarock Row Stacks
# ************************************************************************

class Tarock_OpenStack(OpenStack):
    def __init__(self, x, y, game, yoffset=-1, **cap):
        kwdefault(cap, max_move=UNLIMITED_MOVES, max_accept=UNLIMITED_ACCEPTS)
        OpenStack.__init__(self, x, y, game, **cap)
        if yoffset < 0:
            yoffset = game.app.images.CARD_YOFFSET
        self.CARD_YOFFSET = yoffset


class Tarock_AC_RowStack(Tarock_OpenStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        if not self.cards:
            return 1
        if cards[0].rank != self.cards[-1].rank - 1:
            return 0
        elif cards[0].color == 2 or self.cards[-1].color == 2:
            return 1
        else:
            return cards[0].color != self.cards[-1].color


class Skiz_RowStack(RK_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        if not self.cards:
            if cards[0].suit == len(self.game.gameinfo.suits):
                return cards[0].rank == len(self.game.gameinfo.trumps) - 1
            else:
                return cards[0].rank == len(self.game.gameinfo.ranks) - 1
        return self.cards[-1].suit == cards[0].suit and \
            self.cards[-1].rank - 1 == cards[0].rank


class Pagat_RowStack(RK_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        if not self.cards:
            return 1
        return self.cards[-1].suit == cards[0].suit and \
            self.cards[-1].rank - 1 == cards[0].rank


class TrumpWild_RowStack(Tarock_OpenStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        if not self.cards:
            if cards[0].suit == len(self.game.gameinfo.suits):
                return cards[0].rank == len(self.game.gameinfo.trumps) - 1
            else:
                return cards[0].rank == len(self.game.gameinfo.ranks) - 1
        if cards[0].rank != self.cards[-1].rank - 1:
            return 0
        elif cards[0].color == 2 or self.cards[-1].color == 2:
            return 1
        else:
            return cards[0].color != self.cards[-1].color


class TrumpOnly_RowStack(Tarock_OpenStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        if not self.cards:
            return cards[0].suit == len(self.game.gameinfo.suits)
        return cards[0].color == 2 and cards[0].rank == self.cards[-1].rank - 1

    def getBottomImage(self):
        return self.game.app.images.getReserveBottom()


class Excuse_RowStack(Tarock_OpenStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        if not self.cards:
            return 0
        return cards[0].rank == self.cards[-1].rank - 1


class WheelOfFortune_RowStack(Tarock_OpenStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        if not self.cards:
            return 1
        return ((cards[0].suit == self.cards[-1].suit) and
                (cards[0].rank == self.cards[-1].rank - 1))

    def getBottomImage(self):
        return self.game.app.images.getReserveBottom()


class Ponytail_PonytailStack(Braid_BraidStack):
    pass


class Ponytail_RowStack(Braid_RowStack):
    pass


class Ponytail_ReserveStack(Braid_ReserveStack):
    pass


class Cavalier_RowStack(Tarock_AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not Tarock_AC_RowStack.acceptsCards(self, from_stack, cards):
            return 0
        return self.cards or len(cards) == 1

    def canMoveCards(self, cards):
        for i in range(len(cards) - 1):
            if not cards[i].suit == 4:
                if cards[i].color == cards[i + 1].color:
                    return 0
            if cards[i].rank - 1 != cards[i + 1].rank:
                return 0
        return 1


class Nasty_RowStack(SS_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        if self.cards:
            return (cards[0].rank == self.cards[-1].rank - 1 and
                    cards[0].suit == self.cards[-1].suit)
        return cards[0].rank == 13 + 8 * (cards[0].suit == 4)


# ************************************************************************
# *
# ************************************************************************

class Tarock_GameMethods:
    SUITS = (_("Wand"), _("Sword"), _("Cup"), _("Coin"), _("Trump"))
    RANKS = (_("Ace"), "2", "3", "4", "5", "6", "7", "8", "9", "10",
             _("Page"), _("Valet"), _("Queen"), _("King"))

    def getCardFaceImage(self, deck, suit, rank):
        return self.app.images.getFace(deck, suit, rank)


class AbstractTarockGame(Tarock_GameMethods, Game):
    pass


# ************************************************************************
# * Wheel of Fortune
# ************************************************************************

class WheelOfFortune(AbstractTarockGame):
    Hint_Class = CautiousDefaultHint

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        self.setSize(l.XM + l.XS * 11.5, l.YM + l.YS * 5.5)

        # Create wheel
        xoffset = (1, 2, 3, 3.9, 3, 2, 1, 0, -1, -2, -3,
                   -3.9, -3, -2, -1, 0, -2, -1, 0, 1, 2)
        yoffset = (0.2, 0.5, 1.1, 2.2, 3.3, 3.9, 4.2, 4.4,
                   4.2, 3.9, 3.3, 2.2, 1.1, 0.5, 0.2, 0,
                   1.8, 2.1, 2.2, 2.4, 2.6)
        x = l.XM + l.XS * 4
        y = l.YM
        for i in range(21):
            x0 = x + xoffset[i] * l.XS
            y0 = y + yoffset[i] * l.YS
            s.rows.append(WheelOfFortune_RowStack(x0, y0, self,
                          yoffset=l.CH//4,
                          max_cards=2, max_move=1, max_accept=1))
        self.setRegion(s.rows, (-999, -999, l.XS * 9, 999999))

        # Create foundations
        x = self.width - l.XS * 2
        y = l.YM
        s.foundations.append(SS_FoundationStack(x, y, self, 0, max_cards=14))
        x = x + l.XS
        s.foundations.append(SS_FoundationStack(x, y, self, 1, max_cards=14))
        y = y + l.YS
        s.foundations.append(SS_FoundationStack(x, y, self, 3, max_cards=14))
        x = x - l.XS
        s.foundations.append(SS_FoundationStack(x, y, self, 2, max_cards=14))
        x = x + l.XS * 0.5
        y = y + l.YS
        s.foundations.append(SS_FoundationStack(x, y, self, 4, max_cards=22))

        # Create talon
        x = self.width - l.XS
        y = self.height - l.YS * 1.5
        s.talon = WasteTalonStack(x, y, self, num_deal=2, max_rounds=1)
        l.createText(s.talon, "n")
        x = x - l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "n")

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 78
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[-5:])
        self.s.talon.dealRow(rows=self.s.rows[4:-5])
        self.s.talon.dealRow(rows=self.s.rows[:4])
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return 0


# ************************************************************************
# * Imperial Trumps
# ************************************************************************

class ImperialTrumps(AbstractTarockGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        self.setSize(l.XM + l.XS * 8, l.YM + l.YS * 5)

        # Create foundations
        x = l.XM + l.XS * 3
        y = l.YM
        for i in range(4):
            s.foundations.append(
                ImperialTrump_Foundation(x, y, self, i, max_cards=14))
            x = x + l.XS
        s.foundations.append(SS_FoundationStack(x, y, self, 4, max_cards=22))

        # Create talon
        x = l.XM
        s.talon = WasteTalonStack(x, y, self, num_deal=1, max_rounds=-1)
        l.createText(s.talon, "s")
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")

        # Create rows
        x = l.XM
        y = l.YM + l.YS + l.TEXT_HEIGHT
        for i in range(8):
            s.rows.append(TrumpWild_RowStack(x, y, self))
            x = x + l.XS
        self.setRegion(s.rows, (-999, y, 999999, 999999))

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self, reverse=1):
        assert len(self.s.talon.cards) == 78
        for i in range(1, len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(reverse=reverse)
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return 0


# ************************************************************************
# * Pagat
# ************************************************************************

class Pagat(AbstractTarockGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        h = max(3 * l.YS, 20 * l.YOFFSET)
        self.setSize(l.XM + 12 * l.XS, l.YM + l.YS + h)

        # Create foundations
        x = l.XM + l.XS * 3.5
        y = l.YM
        s.foundations.append(SS_FoundationStack(x, y, self, 0, max_cards=14))
        x = x + l.XS
        s.foundations.append(SS_FoundationStack(x, y, self, 1, max_cards=14))
        x = x + l.XS
        s.foundations.append(SS_FoundationStack(x, y, self, 4, max_cards=22))
        x = x + l.XS
        s.foundations.append(SS_FoundationStack(x, y, self, 2, max_cards=14))
        x = x + l.XS
        s.foundations.append(SS_FoundationStack(x, y, self, 3, max_cards=14))

        # Create reserves
        x = l.XM
        for i in range(3):
            s.reserves.append(ReserveStack(x, y, self))
            x = x + l.XS
        x = x + l.XS * 6
        for i in range(3):
            s.reserves.append(ReserveStack(x, y, self))
            x = x + l.XS

        # Create rows
        x = l.XM
        y = l.YM + l.YS * 1.1
        for i in range(12):
            s.rows.append(Pagat_RowStack(x, y, self))
            x = x + l.XS
        self.setRegion(s.rows, (-999, int(y), 999999, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(l.XM, self.height-l.YS, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 78
        self._startDealNumRows(6)
        self.s.talon.dealRow(rows=self.s.rows[3:9])

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Skiz
# ************************************************************************

class Skiz(AbstractTarockGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        h = max(3 * l.YS, 20 * l.YOFFSET)
        self.setSize(l.XM + 12 * l.XS, l.YM + l.YS + h)

        # Create foundations
        x = l.XM + l.XS * 3.5
        y = l.YM
        s.foundations.append(SS_FoundationStack(x, y, self, 0, max_cards=14))
        x = x + l.XS
        s.foundations.append(SS_FoundationStack(x, y, self, 1, max_cards=14))
        x = x + l.XS
        s.foundations.append(SS_FoundationStack(x, y, self, 4, max_cards=22))
        x = x + l.XS
        s.foundations.append(SS_FoundationStack(x, y, self, 2, max_cards=14))
        x = x + l.XS
        s.foundations.append(SS_FoundationStack(x, y, self, 3, max_cards=14))

        # Create reserves
        x = l.XM
        for i in range(3):
            s.reserves.append(ReserveStack(x, y, self))
            x = x + l.XS
        x = x + l.XS * 6
        for i in range(3):
            s.reserves.append(ReserveStack(x, y, self))
            x = x + l.XS

        # Create rows
        x = l.XM
        y = l.YM + l.YS * 1.1
        for i in range(12):
            s.rows.append(Skiz_RowStack(x, y, self))
            x = x + l.XS
        self.setRegion(s.rows, (-999, int(y), 999999, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(l.XM, self.height-l.YS, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 78
        self._startDealNumRows(6)
        self.s.talon.dealRow(rows=self.s.rows[3:9])

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Fifteen Plus
# ************************************************************************

class FifteenPlus(AbstractTarockGame):
    Hint_Class = CautiousDefaultHint

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        h = max(5 * l.YS, 20 * l.YOFFSET)
        self.setSize(l.XM + 9 * l.XS, l.YM + l.YS + h)

        # Create foundations
        x = self.width - l.XS
        y = l.YM
        s.foundations.append(SS_FoundationStack(x, y, self, 4, max_cards=22))
        y = y + l.YS
        for i in range(4):
            s.foundations.append(
                SS_FoundationStack(x, y, self, i, max_cards=14))
            y = y + l.YS

        # Create rows
        x = l.XM
        y = l.YM
        for j in range(2):
            for i in range(8):
                s.rows.append(
                    Tarock_AC_RowStack(x, y, self, max_move=1, max_accept=1))
                x = x + l.XS
            x = l.XM
            y = y + l.YS * 3
        self.setRegion(s.rows, (-999, -999, l.XM + l.XS * 8, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(l.XM, self.height-l.YS, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 78
        for i in range(2):
            self.s.talon.dealRow(flip=0, frames=0)
        for i in range(2):
            self.s.talon.dealRow(rows=self.s.rows[:15], flip=0, frames=0)
        self._startAndDealRow()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Excuse
# ************************************************************************

class Excuse(AbstractTarockGame):
    Hint_Class = CautiousDefaultHint
    GAME_VERSION = 2

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        h = max(5 * l.YS, 20 * l.YOFFSET)
        self.setSize(l.XM + 9 * l.XS, l.YM + l.YS + h)

        # Create foundations
        x = self.width - l.XS
        y = l.YM
        s.foundations.append(SS_FoundationStack(x, y, self, 4, max_cards=22))
        y = y + l.YS
        for i in range(4):
            s.foundations.append(
                SS_FoundationStack(x, y, self, i, max_cards=14))
            y = y + l.YS

        # Create rows
        x = l.XM
        y = l.YM
        for j in range(2):
            for i in range(8):
                s.rows.append(Excuse_RowStack(x, y, self,
                              max_move=1, max_accept=1, base_rank=NO_RANK))
                x = x + l.XS
            x = l.XM
            y = y + l.YS * 3
        self.setRegion(s.rows, (-999, -999, l.XM + l.XS * 8, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(l.XM, self.height-l.YS, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def _shuffleHook(self, cards):
        # move Kings to bottom of each stack (see Baker's Dozen)
        def isKing(c):
            return ((c.suit < 4 and c.rank == 13) or
                    (c.suit == 4 and c.rank == 21))
        i, n = 0, len(self.s.rows)
        kings = []
        for c in cards:
            if isKing(c):
                kings.append(i)
            i = i + 1
        for i in kings:
            j = i % n
            while j < i:
                if not isKing(cards[j]):
                    cards[i], cards[j] = cards[j], cards[i]
                    break
                j = j + n
        cards.reverse()
        return cards

    def startGame(self):
        assert len(self.s.talon.cards) == 78
        self._dealNumRows(3)
        self.s.talon.dealRow(rows=self.s.rows[:15], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:15])

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.rank + 1 == card2.rank or card1.rank - 1 == card2.rank)


# ************************************************************************
# * Grasshopper
# * Double Grasshopper
# ************************************************************************

class Grasshopper(AbstractTarockGame):
    GAME_VERSION = 2
    MAX_ROUNDS = 2

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        decks = self.gameinfo.decks
        self.setSize(2*l.XM + (2 + 5*decks)*l.XS, 3*l.YM + 5*l.YS)
        yoffset = min(l.YOFFSET, max(10, l.YOFFSET // 2))

        # Create talon
        x = l.XM
        y = l.YM
        s.talon = WasteTalonStack(
            x, y, self, num_deal=1, max_rounds=self.MAX_ROUNDS)
        l.createText(s.talon, "s")
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")

        # Create foundations
        x = x + l.XM + l.XS
        for j in range(4):
            for i in range(decks):
                s.foundations.append(
                    SS_FoundationStack(x, y, self, j, max_cards=14))
                x = x + l.XS
        for i in range(decks):
            s.foundations.append(
                SS_FoundationStack(x, y, self, 4, max_cards=22))
            x = x + l.XS

        # Create reserve
        x = l.XM
        y = l.YM + l.YS + l.TEXT_HEIGHT
        s.reserves.append(OpenStack(x, y, self))
        s.reserves[0].CARD_YOFFSET = (l.YOFFSET, yoffset)[decks == 2]

        # Create rows
        x = x + l.XM + l.XS
        for i in range(decks):
            s.rows.append(TrumpOnly_RowStack(x, y, self, yoffset=yoffset))
            x = x + l.XS
        for i in range(4*decks+1):
            s.rows.append(Tarock_AC_RowStack(x, y, self))
            x = x + l.XS
        self.setRegion(s.rows, (-999, y - l.YS, 999999, 999999))

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        decks = self.gameinfo.decks
        assert len(self.s.talon.cards) == 78 * decks
        self.startDealSample()
        for i in range(14 * decks):
            self.s.talon.dealRow(rows=self.s.reserves, flip=0, frames=4)
        self.s.reserves[0].flipMove()
        self.s.talon.dealRow(rows=self.s.rows[decks:])
        self.s.talon.dealCards()          # deal first card to WasteStack

    def fillStack(self, stack):
        r = self.s.reserves[0]
        if not stack.cards and stack in self.s.rows:
            if r.cards and stack.acceptsCards(r, r.cards[-1:]):
                r.moveMove(1, stack)
        if r.canFlipCard():
            r.flipMove()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return ((card1.rank + 1 == card2.rank or
                card1.rank - 1 == card2.rank) and
                card1.color != card2.color)


class DoubleGrasshopper(Grasshopper):
    pass


# ************************************************************************
# * Ponytail
# ************************************************************************

class Ponytail(Tarock_GameMethods, Braid):

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (piles up to 20 cards are playable -
        #       needed for Ponytail_PonytailStack)
        h = max(5*l.YS + l.TEXT_HEIGHT, l.YS+(self.BRAID_CARDS-1)*l.YOFFSET)
        self.setSize(10*l.XS+l.XM, l.YM + h)

        # extra settings
        self.base_card = None

        # create stacks
        s.addattr(braid=None)      # register extra stack variable
        x, y = l.XM, l.YM
        for i in range(2):
            s.rows.append(Ponytail_RowStack(x + 0.5 * l.XS, y, self))
            s.rows.append(Ponytail_RowStack(x + 4.5 * l.XS, y, self))
            s.rows.append(Ponytail_RowStack(x + 5.5 * l.XS, y, self))
            s.rows.append(Ponytail_RowStack(x + 6.5 * l.XS, y, self))
            y = y + 4 * l.YS
        y = l.YM + l.YS
        for i in range(2):
            s.rows.append(Ponytail_ReserveStack(x, y, self))
            s.rows.append(Ponytail_ReserveStack(x + l.XS, y, self))
            s.rows.append(Ponytail_ReserveStack(x, y + l.YS, self))
            s.rows.append(Ponytail_ReserveStack(x + l.XS, y + l.YS, self))
            s.rows.append(Ponytail_ReserveStack(x, y + 2 * l.YS, self))
            s.rows.append(Ponytail_ReserveStack(x + l.XS, y + 2 * l.YS, self))
            x = x + 4 * l.XS
        x = l.XM + 5*l.XS//2
        y = l.YM
        s.braid = Ponytail_PonytailStack(x, y, self, sine=1)
        x = l.XM + 7 * l.XS
        y = l.YM + 2*l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "s")
        s.talon.texts.rounds = MfxCanvasText(
            self.canvas,
            x + l.CW // 2, y - l.YM,
            anchor="s",
            font=self.app.getFont("canvas_default"))
        x = x - l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")
        x = l.XM + 8 * l.XS
        y = l.YM
        for i in range(4):
            s.foundations.append(
                Ponytail_Foundation(x, y, self, i, mod=14, max_cards=14))
            s.foundations.append(
                Ponytail_Foundation(
                    x + l.XS, y, self, i, mod=14, max_cards=14))
            y = y + l.YS
        s.foundations.append(
            Ponytail_Foundation(x, y, self, 4, mod=22, max_cards=22))
        s.foundations.append(
            Ponytail_Foundation(x + l.XS, y, self, 4, mod=22, max_cards=22))
        # ???
        self.texts.info = MfxCanvasText(
            self.canvas,
            x + l.CW + l.XM // 2, y + l.YS,
            anchor="n",
            font=self.app.getFont("canvas_default"))

        # define stack-groups
        self.sg.openstacks = s.foundations + s.rows
        self.sg.talonstacks = [s.talon] + [s.waste]
        self.sg.dropstacks = [s.braid] + s.rows + [s.waste]


# ************************************************************************
# * Cavalier
# * Five Aces
# * Wicked
# * Nasty
# ************************************************************************

class Cavalier(AbstractTarockGame):
    Layout_Method = staticmethod(Layout.bakersDozenLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = Cavalier_RowStack

    #
    # Game layout
    #

    def createGame(self, **layout):
        # Create layout
        l, s = Layout(self), self.s
        kwdefault(layout, rows=18, playcards=19)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create foundations
        for r in l.s.foundations:
            n = 14 + 8 * (r.suit == 4)
            s.foundations.append(self.Foundation_Class(r.x, r.y, self, r.suit,
                                 mod=n, max_cards=n))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self))

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self, flip=(0, 1, 0), foundations=0):
        assert len(self.s.talon.cards) == 78
        for f in flip:
            self.s.talon.dealRow(flip=f, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        if foundations:
            self.s.talon.dealRow(rows=self.s.rows[0:1])
            self.s.talon.dealRow(rows=self.s.foundations)
        else:
            self.s.talon.dealRow(rows=self.s.rows[:6])

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return ((card1.rank + 1 == card2.rank or
                 card1.rank - 1 == card2.rank) and
                ((card1.suit == 4 or card2.suit == 4) or
                 card1.color != card2.color))


class FiveAces(Cavalier):
    def _shuffleHook(self, cards):
        return self._shuffleHookMoveToBottom(
            cards, lambda c: (c.rank == 0, c.suit))

    def startGame(self):
        Cavalier.startGame(self, foundations=1)


class Wicked(FiveAces):
    Talon_Class = StackWrapper(Wicked_Talon, max_rounds=-1)
    RowStack_Class = StackWrapper(
        SS_RowStack, max_move=1, max_accept=1, base_rank=NO_RANK)
    Hint_Class = CautiousDefaultHint

    def startGame(self):
        Cavalier.startGame(self, flip=(1, 1, 1), foundations=1)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return ((card1.rank + 1 == card2.rank or
                 card1.rank - 1 == card2.rank) and
                card1.suit == card2.suit)


class Nasty(Wicked):
    RowStack_Class = StackWrapper(
        Nasty_RowStack, max_move=1, max_accept=1, base_rank=ANY_RANK)


# ************************************************************************
# * register the games
# ************************************************************************

def r(id, gameclass, name, game_type, decks, redeals, skill_level):
    game_type = game_type | GI.GT_TAROCK | GI.GT_CONTRIB | GI.GT_ORIGINAL
    gi = GameInfo(id, gameclass, name, game_type, decks, redeals, skill_level,
                  ranks=list(range(14)), trumps=list(range(22)))
    registerGame(gi)
    return gi


r(157, WheelOfFortune, "Wheel of Fortune", GI.GT_TAROCK, 1, 0, GI.SL_BALANCED)
r(158, ImperialTrumps, "Imperial Trumps", GI.GT_TAROCK, 1, -1, GI.SL_BALANCED)
r(159, Pagat, "Pagat", GI.GT_TAROCK | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL)
r(160, Skiz, "Skiz", GI.GT_TAROCK | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL)
r(161, FifteenPlus, "Fifteen plus", GI.GT_TAROCK, 1, 0, GI.SL_BALANCED)
r(162, Excuse, "Excuse", GI.GT_TAROCK | GI.GT_OPEN, 1, 0, GI.SL_BALANCED)
r(163, Grasshopper, "Grasshopper", GI.GT_TAROCK, 1, 1, GI.SL_MOSTLY_SKILL)
r(164, DoubleGrasshopper, "Double Grasshopper", GI.GT_TAROCK, 2, 1,
  GI.SL_MOSTLY_SKILL)
r(179, Ponytail, "Ponytail", GI.GT_TAROCK, 2, 2, GI.SL_MOSTLY_SKILL)
r(202, Cavalier, "Cavalier", GI.GT_TAROCK, 1, 0, GI.SL_MOSTLY_SKILL)
r(203, FiveAces, "Five Aces", GI.GT_TAROCK, 1, 0, GI.SL_MOSTLY_SKILL)
r(204, Wicked, "Wicked", GI.GT_TAROCK | GI.GT_OPEN, 1, -1, GI.SL_BALANCED)
r(205, Nasty, "Nasty", GI.GT_TAROCK | GI.GT_OPEN, 1, -1, GI.SL_BALANCED)

del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        InitialDealTalonStack, \
        InvisibleStack, \
        OpenTalonStack, \
        ReserveStack, \
        StackWrapper

# ************************************************************************
# * Poker Square
# ************************************************************************


class PokerSquare_RowStack(ReserveStack):
    def clickHandler(self, event):
        if not self.cards:
            self.game.s.talon.playMoveMove(1, self)
            return 1
        return ReserveStack.clickHandler(self, event)

    rightclickHandler = clickHandler


class PokerSquare(Game):
    Talon_Class = OpenTalonStack
    RowStack_Class = StackWrapper(PokerSquare_RowStack, max_move=0)
    Hint_Class = None

    WIN_SCORE = 100

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # create texts 1)
        ta = "ss"
        x, y = l.XM, l.YM + 2*l.YS
        if self.preview <= 1:
            t = MfxCanvasText(self.canvas, x, y, anchor="nw",
                              font=self.app.getFont("canvas_default"),
                              text=_('''\
Royal Flush
Straight Flush
Four of a Kind
Full House
Flush
Straight
Three of a Kind
Two Pair
One Pair'''))
            self.texts.list.append(t)
            bb = t.bbox()
            x = bb[1][0] + 16
            h = bb[1][1] - bb[0][1]
            if h >= 2*l.YS:
                ta = "e"
                t.move(0, -l.YS)
                y = y - l.YS
            t = MfxCanvasText(self.canvas, x, y, anchor="nw",
                              font=self.app.getFont("canvas_default"),
                              text="100\n75\n50\n25\n20\n15\n10\n5\n2")
            self.texts.list.append(t)
            x = t.bbox()[1][0] + 16
            self.texts.misc = MfxCanvasText(
                self.canvas, x, y, anchor="nw",
                font=self.app.getFont("canvas_default"),
                text="0\n"*8+"0")
            x = self.texts.misc.bbox()[1][0] + 32

        # set window
        w = max(2*l.XS, x)
        self.setSize(l.XM + w + 5*l.XS + 50, l.YM + 5*l.YS + 30)

        # create stacks
        for i in range(5):
            for j in range(5):
                x, y = l.XM + w + j*l.XS, l.YM + i*l.YS
                s.rows.append(self.RowStack_Class(x, y, self))
        x, y = l.XM, l.YM
        s.talon = self.Talon_Class(x, y, self)
        l.createText(s.talon, anchor=ta)
        s.internals.append(InvisibleStack(self))    # for _swapPairMove()

        # create texts 2)
        if self.preview <= 1:
            for i in (4, 9, 14, 19, 24):
                tx, ty, ta, tf = l.getTextAttr(s.rows[i], anchor="e")
                t = MfxCanvasText(self.canvas, tx+8, ty,
                                  anchor=ta,
                                  font=self.app.getFont("canvas_default"))
                self.texts.list.append(t)
            for i in range(20, 25):
                tx, ty, ta, tf = l.getTextAttr(s.rows[i], anchor="ss")
                t = MfxCanvasText(self.canvas, tx, ty, anchor=ta,
                                  font=self.app.getFont("canvas_default"))
                self.texts.list.append(t)
            self.texts.score = MfxCanvasText(
                self.canvas, l.XM, 5*l.YS, anchor="sw",
                font=self.app.getFont("canvas_large"))

        # define hands for scoring
        r = s.rows
        self.poker_hands = [
            r[0:5],  r[5:10], r[10:15], r[15:20], r[20:25],
            (r[0], r[0+5], r[0+10], r[0+15], r[0+20]),
            (r[1], r[1+5], r[1+10], r[1+15], r[1+20]),
            (r[2], r[2+5], r[2+10], r[2+15], r[2+20]),
            (r[3], r[3+5], r[3+10], r[3+15], r[3+20]),
            (r[4], r[4+5], r[4+10], r[4+15], r[4+20]),
        ]
        self.poker_hands = list(map(tuple, self.poker_hands))

        # define stack-groups
        l.defaultStackGroups()
        return l

    #
    # game overrides
    #

    def startGame(self):
        self.moveMove(27, self.s.talon, self.s.internals[0], frames=0)
        self.s.talon.fillStack()

    def isGameWon(self):
        return len(self.s.talon.cards) == 0 and \
            self.getGameScore() >= self.WIN_SCORE

    def getAutoStacks(self, event=None):
        return ((), (), ())

    #
    # scoring
    #

    def updateText(self):
        if self.preview > 1:
            return
        score = 0
        count = [0] * 9
        for i in range(10):
            type, value = self.getHandScore(self.poker_hands[i])
            if 0 <= type <= 8:
                count[type] = count[type] + 1
            self.texts.list[i+2].config(text=str(value))
            score = score + value
        t = '\n'.join(map(str, count))
        self.texts.misc.config(text=t)
        #
        t = ""
        if score >= self.WIN_SCORE:
            t = _("WON\n\n")
        if self.s.talon.cards:
            t = t + _("Points: %d") % score
        else:
            t = t + _("Total: %d") % score
        self.texts.score.config(text=t)

    def getGameScore(self):
        score = 0
        for hand in self.poker_hands:
            type, value = self.getHandScore(hand)
            score = score + value
        return score

    def getHandScore(self, hand):
        same_rank = [0] * 13
        same_suit = [0] * 4
        ranks = []
        for s in hand:
            if s.cards:
                rank, suit = s.cards[0].rank, s.cards[0].suit
                same_rank[rank] = same_rank[rank] + 1
                same_suit[suit] = same_suit[suit] + 1
                ranks.append(rank)
        #
        straight = 0
        if same_rank.count(1) == 5:
            d = max(ranks) - min(ranks)
            if d == 4:
                straight = 1                # normal straight
            elif d == 12 and same_rank[-4:].count(1) == 4:
                straight = 2                # straight with Ace ranked high
        #
        if max(same_suit) == 5:
            if straight:
                if straight == 2:
                    return 0, 100           # Royal Flush
                return 1, 75                # Straight Flush
            return 4, 20                    # Flush
        #
        if straight:
            return 5, 15                    # Straight
        #
        if max(same_rank) >= 2:
            same_rank.sort()
            if same_rank[-1] == 4:
                return 2, 50                # Four of a Kind
            if same_rank[-1] == 3:
                if same_rank[-2] == 2:
                    return 3, 25            # Full House
                return 6, 10                # Three of a Kind
            if same_rank[-2] == 2:
                return 7, 5                 # Two Pairs
            return 8, 2                     # Pair
        #
        return -1, 0


# ************************************************************************
# * Poker Shuffle
# ************************************************************************

class PokerShuffle_RowStack(ReserveStack):
    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        assert ncards == 1 and to_stack in self.game.s.rows
        assert len(to_stack.cards) == 1
        self._swapPairMove(ncards, to_stack, frames=-1, shadow=0)

    def _swapPairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        old_state = game.enterState(game.S_FILL)
        swap = game.s.internals[0]
        game.moveMove(n, self, swap, frames=0)
        game.moveMove(n, other_stack, self, frames=frames, shadow=shadow)
        game.moveMove(n, swap, other_stack, frames=0)
        game.leaveState(old_state)


class PokerShuffle(PokerSquare):
    Talon_Class = InitialDealTalonStack
    RowStack_Class = StackWrapper(
        PokerShuffle_RowStack, max_accept=1, max_cards=2)

    WIN_SCORE = 200

    def createGame(self):
        PokerSquare.createGame(self)
        if self.s.talon.texts.ncards:
            self.s.talon.texts.ncards.text_format = "%D"

    def startGame(self):
        self.moveMove(27, self.s.talon, self.s.internals[0], frames=0)
        self._startAndDealRow()

    def checkForWin(self):
        return 0


# register the game
registerGame(GameInfo(139, PokerSquare, "Poker Square",
                      GI.GT_POKER_TYPE | GI.GT_SCORE, 1, 0, GI.SL_MOSTLY_SKILL,
                      si={"ncards": 25}))
registerGame(GameInfo(140, PokerShuffle, "Poker Shuffle",
                      GI.GT_POKER_TYPE | GI.GT_SCORE | GI.GT_OPEN, 1, 0,
                      GI.SL_MOSTLY_SKILL,
                      si={"ncards": 25}))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import AbstractHint
from pysollib.layout import Layout
from pysollib.stack import \
        AbstractFoundationStack, \
        InitialDealTalonStack, \
        InvisibleStack, \
        ReserveStack
from pysollib.util import ANY_SUIT


class Pegged_Hint(AbstractHint):
    # FIXME: no intelligence whatsoever is implemented here
    def computeHints(self):
        game = self.game
        # get free stacks
        stacks = [r for r in game.s.rows if not r.cards]
        #
        for t in stacks:
            for dx, dy in game.STEPS:
                r = game.map.get((t.pos[0] + dx, t.pos[1] + dy))
                if not r or not r.cards or not t.acceptsCards(r, r.cards):
                    continue
                # braindead scoring...
                score = 10000 + game.app.miscrandom.randint(0, 9999)
                self.addHint(score, 1, r, t)


# ************************************************************************
# *
# ************************************************************************

class Pegged_RowStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return 0
        return self._getMiddleStack(from_stack) is not None

    def canDropCards(self, stacks):
        return (None, 0)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        other_stack = to_stack._getMiddleStack(self)
        old_state = self.game.enterState(self.game.S_FILL)
        f = self.game.s.foundations[0]
        self.game.moveMove(ncards, self, to_stack, frames=0)
        self.game.playSample("drop", priority=200)
        self.game.moveMove(ncards, other_stack, f, frames=-1, shadow=shadow)
        self.game.leaveState(old_state)
        self.fillStack()
        other_stack.fillStack()

    def _getMiddleStack(self, from_stack):
        dx, dy = from_stack.pos[0] - self.pos[0], \
            from_stack.pos[1] - self.pos[1]
        if not self.game.STEP_MAP.get((dx, dy)):
            return None
        s = self.game.map.get((self.pos[0] + dx//2, self.pos[1] + dy//2))
        if not s or not s.cards:
            return None
        return s

    def copyModel(self, clone):
        ReserveStack.copyModel(self, clone)
        clone.pos = self.pos


# ************************************************************************
# * Pegged
# ************************************************************************

class Pegged(Game):
    Hint_Class = Pegged_Hint

    STEPS = ((-4, 0), (4, 0), (0, -4), (0, 4))
    ROWS = (3, 5, 7, 7, 7, 5, 3)
    EMPTY_STACK_ID = -1

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        n = m = max(self.ROWS)
        if self.ROWS[0] == m or self.ROWS[-1] == m:
            n = n + 1
        self.setSize(l.XM + n*l.XS, l.YM + len(self.ROWS)*l.YS)

        # game extras 1)
        self.map = {}

        # create stacks
        for i in range(len(self.ROWS)):
            r = self.ROWS[i]
            for j in range(r):
                d = m - r + 2*j
                x, y = l.XM + d*l.XS//2, l.YM + i*l.YS
                stack = Pegged_RowStack(x, y, self)
                stack.pos = (d, 2*i)
                # print stack.id, stack.pos
                s.rows.append(stack)
                self.map[stack.pos] = stack
        x, y = self.width - l.XS, l.YM
        s.foundations.append(
            AbstractFoundationStack(
                x, y, self, ANY_SUIT, max_move=0, max_accept=0,
                max_cards=self.gameinfo.ncards))
        l.createText(s.foundations[0], "s")
        y = self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)
        s.internals.append(InvisibleStack(self))

        # game extras 2)
        self.STEP_MAP = {}
        for step in self.STEPS:
            self.STEP_MAP[step] = 1
        if self.EMPTY_STACK_ID < 0:
            self.EMPTY_STACK_ID = len(s.rows) // 2

        # Define stack groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def shuffle(self):
        cards = list(self.cards)
        cards.reverse()
        for card in cards:
            self.s.talon.addCard(card, update=0)
            card.showBack(unhide=0)

    def startGame(self):
        n = len(self.cards) - len(self.s.rows) + 1
        if n > 0:
            self.moveMove(n, self.s.talon, self.s.internals[0], frames=0)
        self.startDealSample()
        rows = list(self.s.rows[:])
        rows.remove(rows[self.EMPTY_STACK_ID])
        self.s.talon.dealRow(rows=rows, frames=4)
        assert len(self.s.talon.cards) == 0

    def isGameWon(self):
        c = 0
        for s in self.s.foundations:
            c = c + len(s.cards)
        return c + 1 == self.gameinfo.si.ncards

    def getAutoStacks(self, event=None):
        return ((), (), ())

    # Pegged special: check for a perfect game
    def getWinStatus(self):
        won, status, updated = Game.getWinStatus(self)
        if status == 2:
            stacks = [r for r in self.s.rows if r.cards]
            assert len(stacks) == 1
            if stacks[0].id != self.EMPTY_STACK_ID:
                # not perfect
                return won, 1, self.U_WON
        return won, status, updated

    # Pegged special: highlight all moveable cards
    def getHighlightPilesStacks(self):
        rows = []
        for r in self.s.rows:
            if not r.cards:
                continue
            rx, ry = r.pos
            for dx, dy in self.STEPS:
                s = self.map.get((rx + dx, ry + dy))
                if s and not s.cards:
                    m = self.map.get((rx + dx//2, ry + dy//2))
                    if m and m.cards:
                        rows.append(r)
        return ((rows, 1),)


class PeggedCross1(Pegged):
    ROWS = (3, 3, 7, 7, 7, 3, 3)


class PeggedCross2(Pegged):
    ROWS = (3, 3, 3, 9, 9, 9, 3, 3, 3)


class Pegged6x6(Pegged):
    EMPTY_STACK_ID = 14
    ROWS = (6, 6, 6, 6, 6, 6)


class Pegged7x7(Pegged):
    ROWS = (7, 7, 7, 7, 7, 7, 7)


# ************************************************************************
# * Pegged Triangle
# ************************************************************************

class PeggedTriangle1(Pegged):
    STEPS = ((-2, -4), (-2, 4), (-4, 0), (4, 0), (2, -4), (2, 4))
    ROWS = (1, 2, 3, 4, 5)
    EMPTY_STACK_ID = 4


class PeggedTriangle2(PeggedTriangle1):
    ROWS = (1, 2, 3, 4, 5, 6)


# ************************************************************************
# * register the games
# ************************************************************************

def r(id, gameclass, name):
    ncards = 0
    for n in gameclass.ROWS:
        ncards += n
    ncards -= 1
    gi = GameInfo(id, gameclass, name,
                  GI.GT_PUZZLE_TYPE, 1, 0, GI.SL_SKILL,
                  category=GI.GC_TRUMP_ONLY,
                  suits=(), ranks=(), trumps=list(range(ncards)),
                  si={"decks": 1, "ncards": ncards},
                  rules_filename="pegged.html")
    registerGame(gi)
    return gi


r(180, Pegged, "Pegged")
r(181, PeggedCross1, "Pegged Cross 1")
r(182, PeggedCross2, "Pegged Cross 2")
r(183, Pegged6x6, "Pegged 6x6")
r(184, Pegged7x7, "Pegged 7x7")
r(210, PeggedTriangle1, "Pegged Triangle 1")
r(211, PeggedTriangle2, "Pegged Triangle 2")

del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
from . import hanoi  # noqa: F401
from . import memory  # noqa: F401
from . import pegged  # noqa: F401
from . import poker  # noqa: F401
from . import tarock  # noqa: F401


def no_use():
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.layout import Layout
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        InitialDealTalonStack, \
        InvisibleStack, \
        OpenStack

# ************************************************************************
# *
# ************************************************************************


class Memory_RowStack(OpenStack):
    def clickHandler(self, event):
        game = self.game
        if len(self.cards) != 1 or self.cards[-1].face_up:
            return 1
        if game.other_stack is None:
            game.playSample("flip", priority=5)
            self.flipMove()
            game.other_stack = self
        else:
            assert len(game.other_stack.cards) == 1 and \
                game.other_stack.cards[-1].face_up
            c1, c2 = self.cards[-1], game.other_stack.cards[0]
            self.flipMove()
            if self.game.cardsMatch(c1, c2):
                self._dropPairMove(1, game.other_stack)
            else:
                game.playSample("flip", priority=5)
                game.score = game.score - 1
                game.updateStatus(moves=game.moves.index+1)  # update moves now
                game.updateText()
                game.canvas.update_idletasks()
                game.sleep(0.5)
                game.other_stack.flipMove()
                game.canvas.update_idletasks()
                game.sleep(0.2)
                self.flipMove()
            game.other_stack = None
        self.game.finishMove()
        self.game.checkForWin()
        return 1

    def _dropPairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        game.playSample("droppair", priority=200)
        game.closed_cards = game.closed_cards - 2
        game.score = game.score + 5

    rightclickHandler = clickHandler
    doubleclickHandler = clickHandler

    def controlclickHandler(self, event):
        return 0

    def shiftclickHandler(self, event):
        return 0


# ************************************************************************
# * Memory
# ************************************************************************

class Memory24(Game):
    Hint_Class = None

    COLUMNS = 6
    ROWS = 4
    WIN_SCORE = 40
    PERFECT_SCORE = 60       # 5 * (6*4)/2

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # game extras
        self.other_stack = None
        self.closed_cards = -1
        self.score = 0

        # create text
        x, y = l.XM, self.ROWS*l.YS
        if self.preview <= 1:
            self.texts.score = MfxCanvasText(
                self.canvas, x, y, anchor="sw",
                font=self.app.getFont("canvas_large"))
            x = self.texts.score.bbox()[1][0] + 16

        # set window
        w = max(2*l.XS, x)
        self.setSize(l.XM + w + self.COLUMNS*l.XS, l.YM + self.ROWS*l.YS)

        # create stacks
        for i in range(self.ROWS):
            for j in range(self.COLUMNS):
                x, y = l.XM + w + j*l.XS, l.YM + i*l.YS
                s.rows.append(Memory_RowStack(x, y, self,
                              max_move=0, max_accept=0, max_cards=1))
        x, y = l.XM, l.YM
        s.talon = InitialDealTalonStack(x, y, self)
        l.createText(s.talon, anchor="n", text_format="%D")
        s.internals.append(InvisibleStack(self))

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        n = self.COLUMNS * self.ROWS
        assert len(self.s.talon.cards) == n
        self.other_stack = None
        self.closed_cards = n
        self.score = 0
        self.updateText()
        n = n - self.COLUMNS
        self.s.talon.dealRow(rows=self.s.rows[:n], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[n:], flip=0)
        assert len(self.s.talon.cards) == 0

    def isGameWon(self):
        return self.closed_cards == 0 and self.score >= self.WIN_SCORE

    def getAutoStacks(self, event=None):
        return ((), (), ())

    #
    # scoring
    #

    def updateText(self):
        if self.preview > 1 or not self.texts.score:
            return
        t = ""
        if self.closed_cards:
            t = _("Points: %d") % self.score
        else:
            if self.score >= self.WIN_SCORE:
                t = _("WON\n\n")
            t = t + _("Total: %d") % self.score
        self.texts.score.config(text=t)

    def getGameScore(self):
        return self.score

    # Memory special: check score for a perfect game
    def getWinStatus(self):
        won, status, updated = Game.getWinStatus(self)
        if status == 2 and self.score < self.PERFECT_SCORE:
            return won, 1, self.U_WON
        return won, status, updated

    #
    # game extras
    #

    def cardsMatch(self, card1, card2):
        return card1.suit == card2.suit and card1.rank == card2.rank

    def canSaveGame(self):
        return 0

    def canUndo(self):
        return 0

    def _restoreGameHook(self, game):
        if game.loadinfo.other_stack_id >= 0:
            self.other_stack = self.allstacks[game.loadinfo.other_stack_id]
        else:
            self.other_stack = None
        self.closed_cards = game.loadinfo.closed_cards
        self.score = game.loadinfo.score

    def _loadGameHook(self, p):
        self.loadinfo.addattr(other_stack_id=p.load())
        self.loadinfo.addattr(closed_cards=p.load())
        self.loadinfo.addattr(score=p.load())

    def _saveGameHook(self, p):
        if self.other_stack:
            p.dump(self.other_stack.id)
        else:
            p.dump(-1)
        p.dump(self.closed_cards)
        p.dump(self.score)


class Memory30(Memory24):
    COLUMNS = 6
    ROWS = 5
    WIN_SCORE = 45
    PERFECT_SCORE = 75      # 5 * (6*5)/2


class Memory40(Memory24):
    COLUMNS = 8
    ROWS = 5
    WIN_SCORE = 50
    PERFECT_SCORE = 100     # 5 * (8*5)/2


# ************************************************************************
# * Concentration
# ************************************************************************

class Concentration_RowStack(Memory_RowStack):
    def _dropPairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        game.playSample("droppair", priority=200)
        game.closed_cards = game.closed_cards - 2
        game.score = game.score + 5
        #
        old_state = game.enterState(game.S_FILL)
        f = game.s.talon
        game.moveMove(n, self, f, frames=frames, shadow=shadow)
        game.moveMove(n, other_stack, f, frames=frames, shadow=shadow)
        game.leaveState(old_state)


class Concentration(Memory24):
    COLUMNS = 13
    ROWS = 4
    WIN_SCORE = 50
    PERFECT_SCORE = 130     # 5 * (13*4)/2

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self, card_x_space=4), self.s

        # game extras
        self.other_stack = None
        self.closed_cards = -1
        self.score = 0

        # set window
        self.setSize(l.XM + self.COLUMNS*l.XS, l.YM + (self.ROWS+1)*l.YS)

        # create stacks
        for i in range(self.ROWS):
            for j in range(self.COLUMNS):
                x, y = l.XM + j*l.XS, l.YM + i*l.YS
                s.rows.append(Concentration_RowStack(x, y, self,
                              max_move=0, max_accept=0, max_cards=1))
        x, y = l.XM + self.COLUMNS*l.XS//2, self.height - l.YS
        s.talon = InitialDealTalonStack(x, y, self)
        l.createText(s.talon, dx=-10, anchor="sw", text_format="%D")

        # create text
        x, y = l.XM, self.height - l.YM
        if self.preview <= 1:
            self.texts.score = MfxCanvasText(
                self.canvas, x, y,
                anchor="sw",
                font=self.app.getFont("canvas_large"))

        # define stack-groups
        l.defaultStackGroups()

    #
    # game extras
    #

    def cardsMatch(self, card1, card2):
        return card1.rank == card2.rank


# register the game
registerGame(GameInfo(176, Memory24, "Memory 24",
                      GI.GT_MEMORY | GI.GT_SCORE, 2, 0, GI.SL_SKILL,
                      suits=(0, 2), ranks=(0, 8, 9, 10, 11, 12)))
registerGame(GameInfo(219, Memory30, "Memory 30",
                      GI.GT_MEMORY | GI.GT_SCORE, 2, 0, GI.SL_SKILL,
                      suits=(0, 2, 3), ranks=(0, 9, 10, 11, 12)))
registerGame(GameInfo(177, Memory40, "Memory 40",
                      GI.GT_MEMORY | GI.GT_SCORE, 2, 0, GI.SL_SKILL,
                      suits=(0, 2), ranks=(0, 4, 5, 6, 7, 8, 9, 10, 11, 12)))
registerGame(GameInfo(178, Concentration, "Concentration",
                      GI.GT_MEMORY | GI.GT_SCORE, 1, 0, GI.SL_SKILL))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.special.tarock import AbstractTarockGame, Grasshopper
from pysollib.games.threepeaks import ThreePeaksNoScore
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.stack import \
        InitialDealTalonStack, \
        OpenStack, \
        ReserveStack, \
        SS_FoundationStack, \
        StackWrapper
from pysollib.util import ANY_RANK, NO_RANK, UNLIMITED_ACCEPTS, UNLIMITED_MOVES


class Tarock_OpenStack(OpenStack):

    def __init__(self, x, y, game, yoffset=-1, **cap):
        kwdefault(
            cap, max_move=UNLIMITED_MOVES,
            max_accept=UNLIMITED_ACCEPTS, dir=-1)
        OpenStack.__init__(self, x, y, game, **cap)
        if yoffset < 0:
            yoffset = game.app.images.CARD_YOFFSET
        self.CARD_YOFFSET = yoffset

    def isRankSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        for c2 in cards[1:]:
            if not c1.rank + dir == c2.rank:
                return 0
            c1 = c2
        return 1

    def isAlternateColorSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        for c2 in cards[1:]:
            if (c1.color < 2 and c1.color == c2.color or
                    not c1.rank + dir == c2.rank):
                return 0
            c1 = c2
        return 1

    def isSuitSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        for c2 in cards[1:]:
            if not (c1.suit == c2.suit and c1.rank + dir == c2.rank):
                return 0
            c1 = c2
        return 1

    def isHighRankCard(self, card):
        maxcard = ([self.game.gameinfo.ranks[-1],
                    self.game.gameinfo.trumps[-1]]
                   [(card.suit == len(self.game.gameinfo.suits))])
        return card.rank == maxcard or self.cap.base_rank == ANY_RANK


class Tarock_RK_RowStack(Tarock_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if (not self.basicAcceptsCards(from_stack, cards) or
                not self.isRankSequence(cards)):
            return 0
        if not self.cards:
            return self.isHighRankCard(cards[0])
        return self.isRankSequence([self.cards[-1], cards[0]])

    def canMoveCards(self, cards):
        return (self.basicCanMoveCards(cards) and self.isRankSequence(cards))


class Tarock_SS_RowStack(Tarock_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if (not self.basicAcceptsCards(from_stack, cards) or
                not self.isSuitSequence(cards)):
            return 0
        if not self.cards:
            return self.isHighRankCard(cards[0])
        return self.isSuitSequence([self.cards[-1], cards[0]])

    def canMoveCards(self, cards):
        return (self.basicCanMoveCards(cards) and self.isSuitSequence(cards))


class Tarock_AC_RowStack(Tarock_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards) \
               or not self.isAlternateColorSequence(cards):
            return 0
        if not self.cards:
            return self.isHighRankCard(cards[0])
        return self.isAlternateColorSequence([self.cards[-1], cards[0]])

    def canMoveCards(self, cards):
        return (self.basicCanMoveCards(cards) and
                self.isAlternateColorSequence(cards))

# ************************************************************************
# *
# ************************************************************************


class Cockroach(Grasshopper):
    MAX_ROUNDS = 1


class DoubleCockroach(Grasshopper):
    MAX_ROUNDS = 1

# ************************************************************************
# *
# ************************************************************************


class Corkscrew(AbstractTarockGame):
    RowStack_Class = StackWrapper(Tarock_RK_RowStack, base_rank=NO_RANK)

    #
    # game layout
    #

    def createGame(self, rows=11, reserves=10):
        # create layout
        l, s = Layout(self), self.s

        # set size
        maxrows = max(rows, reserves)
        self.setSize(l.XM + (maxrows + 2) * l.XS, l.YM + 6 * l.YS)

        #
        playcards = 4 * l.YS // l.YOFFSET
        xoffset, yoffset = [], []
        for i in range(playcards):
            xoffset.append(0)
            yoffset.append(l.YOFFSET)
        for i in range(78 * self.gameinfo.decks - playcards):
            xoffset.append(l.XOFFSET)
            yoffset.append(0)

        # create stacks
        x, y = l.XM + (maxrows - reserves) * l.XS // 2, l.YM
        for i in range(reserves):
            s.reserves.append(ReserveStack(x, y, self))
            x = x + l.XS
        x, y = l.XM + (maxrows - rows) * l.XS // 2, l.YM + l.YS
        self.setRegion(s.reserves, (-999, -999, 999999, y - l.YM // 2))
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self, yoffset=l.YOFFSET)
            stack.CARD_XOFFSET = xoffset
            stack.CARD_YOFFSET = yoffset
            s.rows.append(stack)
            x = x + l.XS
        x, y = l.XM + maxrows * l.XS, l.YM
        for i in range(2):
            for suit in range(5):
                s.foundations.append(
                    SS_FoundationStack(
                        x, y, self, suit=suit,
                        max_cards=14 + 8 * (suit == 4)))
                y = y + l.YS
            x, y = x + l.XS, l.YM
        self.setRegion(
            self.s.foundations,
            (x - l.XS * 2, -999, 999999,
             self.height - (l.YS + l.YM)), priority=1)
        s.talon = InitialDealTalonStack(
            self.width - 3 * l.XS // 2, self.height - l.YS, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        i = 0
        while self.s.talon.cards:
            card = self.s.talon.cards[-1]
            if card.rank == 13 + 8 * (card.suit == 4):
                if self.s.rows[i].cards:
                    i = i + 1
            self.s.talon.dealRow(rows=[self.s.rows[i]], frames=4)

    # must look at cards
    def _getClosestStack(self, cx, cy, stacks, dragstack):
        closest, cdist = None, 999999999
        for stack in stacks:
            if stack.cards and stack is not dragstack:
                dist = (stack.cards[-1].x - cx)**2 + \
                    (stack.cards[-1].y - cy)**2
            else:
                dist = (stack.x - cx)**2 + (stack.y - cy)**2
            if dist < cdist:
                closest, cdist = stack, dist
        return closest

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isRankSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))

# ************************************************************************
# *
# ************************************************************************


class Serpent(Corkscrew):
    RowStack_Class = StackWrapper(Tarock_AC_RowStack, base_rank=NO_RANK)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isAlternateColorSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))

# ************************************************************************
# *
# ************************************************************************


class Rambling(Corkscrew):
    RowStack_Class = StackWrapper(Tarock_SS_RowStack, base_rank=NO_RANK)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isSuitSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))

# ************************************************************************
# * Le Grande Teton
# ************************************************************************


class LeGrandeTeton(ThreePeaksNoScore):
    pass


# ************************************************************************
# * register the games
# ************************************************************************

def r(id, gameclass, name, game_type, decks, redeals, skill_level):
    game_type = game_type | GI.GT_TAROCK | GI.GT_CONTRIB | GI.GT_ORIGINAL
    gi = GameInfo(id, gameclass, name, game_type, decks, redeals, skill_level,
                  ranks=list(range(14)), trumps=list(range(22)))
    registerGame(gi)
    return gi


r(13163, Cockroach, 'Cockroach', GI.GT_TAROCK, 1, 0, GI.SL_MOSTLY_SKILL)
r(13164, DoubleCockroach, 'Double Cockroach', GI.GT_TAROCK, 2, 0,
  GI.SL_MOSTLY_SKILL)
r(13165, Corkscrew, 'Corkscrew', GI.GT_TAROCK, 2, 0, GI.SL_MOSTLY_SKILL)
r(13166, Serpent, 'Serpent', GI.GT_TAROCK, 2, 0, GI.SL_MOSTLY_SKILL)
r(13167, Rambling, 'Rambling', GI.GT_TAROCK, 2, 0, GI.SL_MOSTLY_SKILL)
r(22232, LeGrandeTeton, 'Le Grande Teton', GI.GT_TAROCK, 1, 0, GI.SL_BALANCED)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.larasgame import LarasGame, LarasGame_Reserve
from pysollib.games.larasgame import LarasGame_Talon
from pysollib.stack import OpenStack


class DojoujisGame_Talon(LarasGame_Talon):
    def getActiveRow(self):
        card = self.getCard()
        return card.rank + card.deck * 4


class DoubleKalisGame_Talon(LarasGame_Talon):
    def getActiveRow(self):
        card = self.getCard()
        return card.rank + card.deck * 12


class BridgetsGame_Reserve(OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return 0
        if not self.cards:
            return from_stack in self.game.s.foundations and cards[0].suit == 4
        return from_stack in self.game.s.rows

    def getBottomImage(self):
        return self.game.app.images.getReserveBottom()


# ************************************************************************
# * Katrina's Game
# ************************************************************************

class KatrinasGame(LarasGame):
    DEAL_TO_TALON = 3
    MAX_ROUNDS = 2
    ROW_LENGTH = 5
    MAX_ROW = 22

    #
    # Game extras
    #

    def Max_Cards(self, i):
        return 14 + 8 * (i == 4)

    def Mod(self, i):
        return 14 + 8 * (i == 4)

    def Base_Rank(self, i, j):
        return (13 + 8 * (i == 4)) * (not j)

    def Deal_Rows(self, i):
        return 14 + 8 * (i % 2)

    def Base_Suit(self, i, j):
        return i

    #
    # Game overrides
    #

    def getCardFaceImage(self, deck, suit, rank):
        return self.app.images.getFace(deck, suit, rank)


# ************************************************************************
# * Relaxed Katrina's Game
# ************************************************************************

class RelaxedKatrinasGame(KatrinasGame):
    Reserve_Class = LarasGame_Reserve
    Reserve_Cards = 2


# ************************************************************************
# * Double Katrina's Game
# ************************************************************************

class DoubleKatrinasGame(RelaxedKatrinasGame):
    Reserve_Cards = 3
    MAX_ROUNDS = 3

    def Max_Cards(self, i):
        return 28 + 16 * (i == 4)


# ************************************************************************
# * Bridget's Game
# * In memory of Bridget Bishop
# * Hanged as a witch on June 10, 1692
# * Salem Massachusetts, U. S. A.
# * and the nineteen other women
# * and men who followed her
# ************************************************************************

class BridgetsGame(LarasGame):
    Reserve_Class = BridgetsGame_Reserve
    Reserve_Cards = 2
    MAX_ROUNDS = 2
    ROW_LENGTH = 5
    MAX_ROW = 16

    def Max_Cards(self, i):
        return 16 - 12 * (i == 4)

    def Mod(self, i):
        return 16 - 12 * (i == 4)

    def Base_Rank(self, i, j):
        return (15 - 12 * (i == 4)) * (not j)

    def Deal_Rows(self, i):
        return 16

    def Base_Suit(self, i, j):
        return i


# ************************************************************************
# * Double Bridget's Game
# ************************************************************************

class DoubleBridgetsGame(BridgetsGame):
    Reserve_Cards = 3
    MAX_ROUNDS = 3

    def Max_Cards(self, i):
        return 32 - 24 * (i == 4)


# ************************************************************************
# * Fatimeh's Game
# ************************************************************************

class FatimehsGame(LarasGame):
    DEAL_TO_TALON = 5
    MAX_ROUNDS = 3
    MAX_ROW = 12
    DIR = (1, 1)

    def Max_Cards(self, i):
        return 12

    def Mod(self, i):
        return 12

    def Base_Rank(self, i, j):
        return 0

    def Deal_Rows(self, i):
        return 12

    def Base_Suit(self, i, j):
        return i + j * 4


# ************************************************************************
# * Relaxed Fatimeh's Game
# ************************************************************************

class RelaxedFatimehsGame(FatimehsGame):
    Reserve_Class = LarasGame_Reserve
    Reserve_Cards = 2


# ************************************************************************
# * Kali's Game
# ************************************************************************

class KalisGame(FatimehsGame):
    DEAL_TO_TALON = 6
    ROW_LENGTH = 5

    def Base_Suit(self, i, j):
        return i + j * 5


# ************************************************************************
# * Relaxed Kali's Game
# ************************************************************************

class RelaxedKalisGame(KalisGame):
    Reserve_Class = LarasGame_Reserve
    Reserve_Cards = 2


# ************************************************************************
# * Double Kali's Game
# ************************************************************************

class DoubleKalisGame(RelaxedKalisGame):
    Talon_Class = DoubleKalisGame_Talon
    Reserve_Cards = 4
    MAX_ROUNDS = 4
    MAX_ROW = 24

    def Max_Cards(self, i):
        return 24

    def Deal_Rows(self, i):
        return 24


# ************************************************************************
# * Dojouji's Game
# ************************************************************************

class DojoujisGame(LarasGame):
    Talon_Class = DojoujisGame_Talon
    ROW_LENGTH = 6
    MAX_ROW = 8
    DIR = (-1, -1)

    def Max_Cards(self, i):
        return 8

    def Mod(self, i):
        return 4

    def Base_Rank(self, i, j):
        return 3

    def Deal_Rows(self, i):
        return 8

    def Base_Suit(self, i, j):
        return i + j * 6


# ************************************************************************
# * Double Dojouji's Game
# ************************************************************************

class DoubleDojoujisGame(DojoujisGame):
    MAX_ROW = 16

    def Max_Cards(self, i):
        return 16

    def Deal_Rows(self, i):
        return 16


# register the game
registerGame(GameInfo(13001, KatrinasGame, "Katrina's Game",
                      GI.GT_TAROCK, 2, 1, GI.SL_BALANCED,
                      ranks=list(range(14)), trumps=list(range(22))))
registerGame(GameInfo(13002, BridgetsGame, "Bridget's Game",
                      GI.GT_HEXADECK, 2, 1, GI.SL_BALANCED,
                      ranks=list(range(16)), trumps=list(range(4))))
registerGame(GameInfo(13003, FatimehsGame, "Fatimeh's Game",
                      GI.GT_MUGHAL_GANJIFA, 1, 2, GI.SL_BALANCED,
                      suits=list(range(8)), ranks=list(range(12))))
registerGame(GameInfo(13004, KalisGame, "Kali's Game",
                      GI.GT_DASHAVATARA_GANJIFA, 1, 2, GI.SL_BALANCED,
                      suits=list(range(10)), ranks=list(range(12))))
registerGame(GameInfo(13005, DojoujisGame, "Dojouji's Game",
                      GI.GT_HANAFUDA, 2, 0, GI.SL_BALANCED,
                      suits=list(range(12)), ranks=list(range(4))))
registerGame(GameInfo(13008, RelaxedKatrinasGame, "Katrina's Game Relaxed",
                      GI.GT_TAROCK, 2, 1, GI.SL_BALANCED,
                      ranks=list(range(14)), trumps=list(range(22))))
registerGame(GameInfo(13009, DoubleKatrinasGame, "Katrina's Game Doubled",
                      GI.GT_TAROCK, 4, 2, GI.SL_BALANCED,
                      ranks=list(range(14)), trumps=list(range(22))))
registerGame(GameInfo(13010, DoubleBridgetsGame, "Bridget's Game Doubled",
                      GI.GT_HEXADECK, 4, 2, GI.SL_BALANCED,
                      ranks=list(range(16)), trumps=list(range(4))))
registerGame(GameInfo(13011, RelaxedKalisGame, "Kali's Game Relaxed",
                      GI.GT_DASHAVATARA_GANJIFA, 1, 2, GI.SL_BALANCED,
                      suits=list(range(10)), ranks=list(range(12))))
registerGame(GameInfo(13012, DoubleKalisGame, "Kali's Game Doubled",
                      GI.GT_DASHAVATARA_GANJIFA, 2, 3, GI.SL_BALANCED,
                      suits=list(range(10)), ranks=list(range(12))))
registerGame(GameInfo(13013, RelaxedFatimehsGame, "Fatimeh's Game Relaxed",
                      GI.GT_MUGHAL_GANJIFA, 1, 2, GI.SL_BALANCED,
                      suits=list(range(8)), ranks=list(range(12))))
registerGame(GameInfo(13014, DoubleDojoujisGame, "Dojouji's Game Doubled",
                      GI.GT_HANAFUDA, 4, 0, GI.SL_BALANCED,
                      suits=list(range(12)), ranks=list(range(4))))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import math
import time

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import AbstractHint, CautiousDefaultHint, DefaultHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AC_RowStack, \
        AbstractFoundationStack, \
        BasicRowStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        OpenStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack, \
        isSameSuitSequence
from pysollib.util import ANY_RANK, ANY_SUIT, NO_RANK, \
        UNLIMITED_ACCEPTS, \
        UNLIMITED_CARDS, \
        UNLIMITED_MOVES

# ************************************************************************
#  * Dashavatara Foundation Stacks
#  ***********************************************************************/


class Dashavatara_FoundationStack(AbstractFoundationStack):

    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, max_move=0, max_cards=12)
        SS_FoundationStack.__init__(self, x, y, game, suit, **cap)

    def updateText(self):
        AbstractFoundationStack.updateText(self)
        self.game.updateText()


class Journey_Foundation(AbstractFoundationStack):

    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, mod=12, dir=0, base_rank=NO_RANK, max_move=0)
        AbstractFoundationStack.__init__(self, x, y, game, suit, **cap)

    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return 0
        if not self.cards:
            return 1
        stack_dir = self.game.getFoundationDir()
        if stack_dir == 0:
            card_dir = (cards[0].rank - self.cards[-1].rank) % self.cap.mod
            return card_dir in (1, 11)
        else:
            return (self.cards[-1].rank + stack_dir) % \
                    self.cap.mod == cards[0].rank


class AppachansWaterfall_Foundation(AbstractFoundationStack):

    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, base_suit=0, mod=12, max_cards=120, max_move=0)
        AbstractFoundationStack.__init__(self, x, y, game, suit, **cap)

    def acceptsCards(self, from_stack, cards):
        if not (from_stack in self.game.s.rows and
                AbstractFoundationStack.acceptsCards(self, from_stack, cards)):
            return 0
        pile, rank, suit = from_stack.getPile(), 0, 0
        if self.cards:
            rank = (self.cards[-1].rank + 1) % 12
            suit = self.cards[-1].suit + (rank == 0)
        if (not pile or len(pile) <= 11 - rank or
                not isSameSuitSequence(pile[-(12 - rank):])):
            return 0
        return cards[0].suit == suit and cards[0].rank == rank


# ************************************************************************
#  * Dashavatara Row Stacks
#  ***********************************************************************/

class Dashavatara_OpenStack(OpenStack):

    def __init__(self, x, y, game, yoffset, **cap):
        kwdefault(cap, max_move=UNLIMITED_MOVES, max_cards=UNLIMITED_CARDS,
                  max_accept=UNLIMITED_ACCEPTS, base_rank=0, dir=-1)
        OpenStack.__init__(self, x, y, game, **cap)
        self.CARD_YOFFSET = yoffset

    def currentForce(self, card):
        force = self._getForce(card)
        hour = time.localtime(time.time())[3]
        if not (hour >= 7 and hour <= 19):
            force = not force
        return force

    def _getForce(self, card):
        return int(card.suit >= 5)

    def isRankSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        for c2 in cards[1:]:
            if not c1.rank + dir == c2.rank:
                return 0
            c1 = c2
        return 1

    def isAlternateColorSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        for c2 in cards[1:]:
            if not ((c1.suit + c2.suit) % 2 and
                    c1.rank + dir == c2.rank):
                return 0
            c1 = c2
        return 1

    def isAlternateForceSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        f1 = self._getForce(c1)
        for c2 in cards[1:]:
            f2 = self._getForce(c2)
            if f1 == f2 or c1.rank + dir != c2.rank:
                return 0
            c1 = c2
            f1 = f2
        return 1

    def isSuitSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        for c2 in cards[1:]:
            if not (c1.suit == c2.suit and c1.rank + dir == c2.rank):
                return 0
            c1 = c2
        return 1


class Dashavatara_AC_RowStack(Dashavatara_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards) \
                or not self.isAlternateColorSequence(cards):
            return 0
        stackcards = self.cards
        if not len(stackcards):
            return cards[0].rank == 11 or self.cap.base_rank == ANY_RANK
        return self.isAlternateColorSequence([stackcards[-1], cards[0]])


class Dashavatara_AF_RowStack(Dashavatara_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards) \
                or not self.isAlternateForceSequence(cards):
            return 0
        stackcards = self.cards
        if not len(stackcards):
            return cards[0].rank == 11 or self.cap.base_rank == ANY_RANK
        return self.isAlternateForceSequence([stackcards[-1], cards[0]])


class Dashavatara_RK_RowStack(Dashavatara_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards) \
                or not self.isRankSequence(cards):
            return 0
        stackcards = self.cards
        if not len(stackcards):
            return cards[0].rank == 11 or self.cap.base_rank == ANY_RANK
        return self.isRankSequence([stackcards[-1], cards[0]])


class Dashavatara_SS_RowStack(Dashavatara_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards) \
                or not self.isSuitSequence(cards):
            return 0
        stackcards = self.cards
        if not len(stackcards):
            return cards[0].rank == 11 or self.cap.base_rank == ANY_RANK
        return self.isSuitSequence([stackcards[-1], cards[0]])


class Circles_RowStack(SS_RowStack):

    def __init__(self, x, y, game, base_rank):
        SS_RowStack.__init__(self, x, y, game, base_rank=base_rank,
                             max_accept=1, max_move=1)
        self.CARD_YOFFSET = 1


class Journey_BraidStack(OpenStack):

    def __init__(self, x, y, game, xoffset, yoffset):
        OpenStack.__init__(self, x, y, game)
        self.CARD_YOFFSET = int(self.game.app.images.CARD_YOFFSET * yoffset)
        # use a sine wave for the x offsets
        self.CARD_XOFFSET = []
        j = 1
        for i in range(30):
            self.CARD_XOFFSET.append(int(math.sin(j) * xoffset))
            j = j + .9


class Journey_StrongStack(ReserveStack):

    def fillStack(self):
        if not self.cards:
            if self.game.s.braidstrong.cards:
                self.game.moveMove(1, self.game.s.braidstrong, self)
            elif self.game.s.braidweak.cards:
                self.game.moveMove(1, self.game.s.braidweak, self)

    def getBottomImage(self):
        return self.game.app.images.getBraidBottom()


class Journey_WeakStack(ReserveStack):

    def fillStack(self):
        if not self.cards:
            if self.game.s.braidweak.cards:
                self.game.moveMove(1, self.game.s.braidweak, self)
            elif self.game.s.braidstrong.cards:
                self.game.moveMove(1, self.game.s.braidstrong, self)

    def getBottomImage(self):
        return self.game.app.images.getBraidBottom()


class Journey_ReserveStack(ReserveStack):

    def acceptsCards(self, from_stack, cards):
        if (from_stack is self.game.s.braidstrong or
                from_stack is self.game.s.braidweak or
                from_stack in self.game.s.rows):
            return 0
        return ReserveStack.acceptsCards(self, from_stack, cards)

    def getBottomImage(self):
        return self.game.app.images.getTalonBottom()


class AppachansWaterfall_RowStack(RK_RowStack):

    def canDropCards(self, stacks):
        pile, stack, rank = self.getPile(), stacks[0], 0
        if stack.cards:
            rank = (stack.cards[-1].rank + 1) % 12
        if (not pile or len(pile) <= 11 - rank or
                not isSameSuitSequence(pile[-(12 - rank):]) or
                not stack.acceptsCards(self, pile[-1:])):
            return (None, 0)
        return (stack, 1)


# ************************************************************************
# * Dashavatara Game Stacks
# ************************************************************************

class Dashavatara_TableauStack(Dashavatara_OpenStack):

    def __init__(self, x, y, game, base_rank, yoffset, **cap):
        kwdefault(cap, dir=3, max_move=99, max_cards=4, max_accept=1,
                  base_rank=base_rank)
        OpenStack.__init__(self, x, y, game, **cap)
        self.CARD_YOFFSET = yoffset

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        # check that the base card is correct
        if self.cards and self.cards[0].rank != self.cap.base_rank:
            return 0
        if not self.cards:
            return cards[0].rank == self.cap.base_rank
        return (self.cards[-1].suit == cards[0].suit and
                self.cards[-1].rank + self.cap.dir == cards[0].rank)

    def getBottomImage(self):
        return self.game.app.images.getLetter(self.cap.base_rank)


class Dashavatara_ReserveStack(ReserveStack):

    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_cards=1, max_accept=1, base_rank=ANY_RANK)
        OpenStack.__init__(self, x, y, game, **cap)

    def acceptsCards(self, from_stack, cards):
        return (ReserveStack.acceptsCards(self, from_stack, cards) and
                self.game.s.talon.cards)


class Dashavatara_RowStack(BasicRowStack):

    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return 0
        # check
        return not (self.cards or self.game.s.talon.cards)

    def canMoveCards(self, cards):
        return 1

    def getBottomImage(self):
        return self.game.app.images.getTalonBottom()


# ************************************************************************
#  *
#  ***********************************************************************/

class AbstractDashavataraGame(Game):

    SUITS = (_("Fish"), _("Tortoise"), _("Boar"), _("Lion"), _("Dwarf"),
             _("Axe"), _("Arrow"), _("Plow"), _("Lotus"), _("Horse"))
    RANKS = (_("Ace"), "2", "3", "4", "5", "6", "7", "8", "9", "10",
             _("Pradhan"), _("Raja"))
    COLORS = (_("Black"), _("Red"), _("Yellow"), _("Green"), _("Brown"),
              _("Orange"), _("Grey"), _("White"), _("Olive"), _("Crimson"))
    FORCE = (_("Strong"), _("Weak"))

    def updateText(self):
        pass

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                (card1.rank + 1 == card2.rank or card1.rank - 1 == card2.rank))


class Journey_Hint(DefaultHint):
    # FIXME: demo is not too clever in this game
    pass


# ************************************************************************
#  * Dashavatara Circles
#  ***********************************************************************/

class DashavataraCircles(AbstractDashavataraGame):
    Hint_Class = CautiousDefaultHint

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        w, h = l.XM + l.XS * 9, l.YM + l.YS * 7
        self.setSize(w, h)

        # Create row stacks
        x = w // 2 - l.CW // 2
        y = h // 2 - l.YS // 2
        x0 = (-.7, .3, .7, -.3,
              -1.7, -1.5, -.6, .6, 1.5, 1.7, 1.5, .6, -.6, -1.5,
              -2.7, -2.5, -1.9, -1, 0, 1, 1.9, 2.5, 2.7, 2.5, 1.9,
              1, 0, -1, -1.9, -2.5)
        y0 = (-.3, -.45, .3, .45,
              0, -.8, -1.25, -1.25, -.8, 0, .8, 1.25, 1.25, .8,
              0, -.9, -1.6, -2, -2.2, -2, -1.6, -.9, 0, .9, 1.6,
              2, 2.2, 2, 1.6, .9)
        for i in range(30):
            # FIXME:
            _x, _y = x+l.XS*x0[i], y+l.YS*y0[i]+l.YM*y0[i]*2
            if _x < 0:
                _x = 0
            if _y < 0:
                _y = 0
            s.rows.append(Circles_RowStack(_x, _y, self, base_rank=ANY_RANK))

        # Create reserve stacks
        s.reserves.append(ReserveStack(l.XM, h - l.YS, self))
        s.reserves.append(ReserveStack(w - l.XS, h - l.YS, self))

        # Create foundations
        x, y = l.XM, l.YM
        for j in range(2):
            for i in range(5):
                s.foundations.append(
                    SS_FoundationStack(x, y, self, i + j * 5, mod=12,
                                       max_move=0, max_cards=12))
                y = y + l.YS
            x, y = w - l.XS, l.YM
        #        from pprint import pprint
        #        pprint(s.rows)
        #        print (l.XM + l.XS, 0, w - l.XS - l.XM, 999999)
        self.setRegion(s.rows, (l.XM + l.XS, 0, w - l.XS - l.XM, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(l.XM + l.XS, l.YM, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 120
        for i in range(3):
            self.s.talon.dealRow(rows=self.s.rows, flip=1, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows, flip=1, frames=3)
        self.s.talon.dealCards()


# ************************************************************************
#  * Ten Avatars
#  ***********************************************************************/

class TenAvatars(AbstractDashavataraGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        self.setSize(l.XM * 3 + l.XS * 11, l.YM + l.YS * 6)

        # Create row stacks
        x = l.XM
        y = l.YM
        for i in range(10):
            s.rows.append(RK_RowStack(x, y, self, base_rank=11,
                                      max_move=12, max_cards=99))
            x = x + l.XS

        # Create reserve stacks
        x = self.width - l.XS
        y = l.YM
        for i in range(6):
            s.reserves.append(ReserveStack(x, y, self))
            y = y + l.YS
        y = y - l.YS
        for i in range(6):
            x = x - l.XS
            s.reserves.append(ReserveStack(x, y, self))

        self.setRegion(s.rows, (0, 0, l.XM + l.XS * 10, l.YS * 5))

        # Create talon
        s.talon = DealRowTalonStack(l.XM, self.height - l.YS, self)
        l.createText(s.talon, "n")

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 120
        for i in range(4):
            self.s.talon.dealRow(flip=1, frames=0)
        self.startDealSample()
        self.s.talon.dealCards()

    def isGameWon(self):
        if len(self.s.talon.cards):
            return 0
        for s in self.s.rows:
            if len(s.cards) != 12 or not isSameSuitSequence(s.cards):
                return 0
        return 1


# ************************************************************************
#  * Balarama
#  ***********************************************************************/

class Balarama(AbstractDashavataraGame):
    Layout_Method = staticmethod(Layout.ghulamLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = Dashavatara_AC_RowStack
    BASE_RANK = ANY_RANK

    #
    # Game layout
    #

    def createGame(self, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=16, reserves=4, texts=0)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(self.Foundation_Class(r.x, r.y, self,
                                 r.suit, mod=12, max_cards=12))

        # Create reserve stacks
        for r in l.s.reserves:
            s.reserves.append(ReserveStack(r.x, r.y, self, ))

        # Create row stacks
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self, l.YOFFSET,
                          suit=ANY_SUIT, base_rank=self.BASE_RANK,
                          max_cards=12))

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 120
        for i in range(6):
            self.s.talon.dealRow(rows=self.s.rows, flip=1, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows, flip=1, frames=3)
        self.s.talon.dealRow(rows=self.s.rows[:8], flip=1, frames=3)
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color % 2 != card2.color % 2 and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
#  * Hayagriva
#  ***********************************************************************/

class Hayagriva(Balarama):
    Layout_Method = staticmethod(Layout.ghulamLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = Dashavatara_RK_RowStack
    BASE_RANK = 11

    #
    # Game layout
    #

    def createGame(self, **layout):
        Balarama.createGame(self)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank)


# ************************************************************************
#  * Shanka
#  ***********************************************************************/

class Shanka(Balarama):
    Layout_Method = staticmethod(Layout.ghulamLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = Dashavatara_RK_RowStack
    BASE_RANK = 11

    #
    # Game layout
    #

    def createGame(self, **layout):
        Balarama.createGame(self, reserves=0)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        if stack1 in self.s.foundations:
            return (card1.suit == card2.suit and
                    (card1.rank + 1 == card2.rank or
                     card2.rank + 1 == card1.rank))
        return (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank)


# ************************************************************************
#  * Surukh
#  ***********************************************************************/

class Surukh(Balarama):
    Layout_Method = staticmethod(Layout.ghulamLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = Dashavatara_AF_RowStack
    BASE_RANK = ANY_RANK

    #
    # Game layout
    #

    def createGame(self, **layout):
        Balarama.createGame(self, reserves=4)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        if card1.suit <= 4:
            force0 = 0
        else:
            force0 = 1
        if card2.suit <= 4:
            force1 = 0
        else:
            force1 = 1
        return (force0 != force1 and
                (card1.rank + 1 == card2.rank or
                 card2.rank + 1 == card1.rank))


# ************************************************************************
#  * Matsya
#  ***********************************************************************/

class Matsya(AbstractDashavataraGame):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = RK_RowStack
    BASE_RANK = 11

    #
    # Game layout
    #

    def createGame(self, max_rounds=1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=10, waste=1)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(self.Foundation_Class(r.x, r.y, self,
                                 r.suit, mod=12, max_cards=12, max_move=0))

        # Create row stacks
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                          suit=ANY_SUIT, base_rank=self.BASE_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 120
        for i in range(10):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank)


# ************************************************************************
#  * Kurma
#  ***********************************************************************/

class Kurma(Matsya):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = SS_RowStack
    BASE_RANK = ANY_RANK

    #
    # Game layout
    #

    def createGame(self, **layout):
        Matsya.createGame(self, max_rounds=-1)


# ************************************************************************
#  * Varaha
#  ***********************************************************************/

class Varaha(Matsya):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = SS_RowStack
    BASE_RANK = ANY_RANK

    #
    # Game layout
    #

    def createGame(self, **layout):
        Matsya.createGame(self, max_rounds=-1, num_deal=3)


# ************************************************************************
#  * Narasimha
#  ***********************************************************************/

class Narasimha(Matsya):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack
    BASE_RANK = 11

    #
    # Game layout
    #

    def createGame(self, **layout):
        Matsya.createGame(self, max_rounds=1, num_deal=1)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color % 2 != card2.color % 2 and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
#  * Vamana
#  ***********************************************************************/

class Vamana(Matsya):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack
    BASE_RANK = 11

    #
    # Game layout
    #

    def createGame(self, **layout):
        Matsya.createGame(self, max_rounds=-1, num_deal=3)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color % 2 != card2.color % 2 and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
#  * Parashurama
#  ***********************************************************************/

class Parashurama(Matsya):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = RK_RowStack
    BASE_RANK = 11

    #
    # Game layout
    #

    def createGame(self, **layout):
        Matsya.createGame(self, max_rounds=2, num_deal=3)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank)


# ************************************************************************
# * Journey to Cuddapah
# ************************************************************************

class Journey(AbstractDashavataraGame):
    Hint_Class = Journey_Hint

    BRAID_CARDS = 15
    BRAID_OFFSET = 1

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (piles up to 20 cards are playable - needed for Braid_BraidStack)
        decks = self.gameinfo.decks
        h = max(5 * l.YS + 35, 2*l.YM + 2*l.YS +
                (self.BRAID_CARDS - 1) * l.YOFFSET*self.BRAID_OFFSET)
        self.setSize(l.XM + l.XS * (7 + decks * 2), l.YM + h)

        # extra settings
        self.base_card = None

        # Create foundations, rows, reserves
        s.addattr(braidstrong=None)      # register extra stack variable
        s.addattr(braidweak=None)      # register extra stack variable
        x, y = l.XM, l.YM
        for j in range(5):
            for i in range(decks):
                s.foundations.append(Journey_Foundation(x + l.XS * i, y, self,
                                     j, mod=12, max_cards=12))
            s.rows.append(Journey_StrongStack(x + l.XS * decks, y, self))
            s.rows.append(
                Journey_ReserveStack(x + l.XS * (1 + decks), y, self))
            y = y + l.YS
        x, y = x + l.XS * (5 + decks), l.YM
        for j in range(5):
            s.rows.append(Journey_ReserveStack(x, y, self))
            s.rows.append(Journey_WeakStack(x + l.XS, y, self))
            for i in range(decks, 0, -1):
                s.foundations.append(
                    Journey_Foundation(x + l.XS * (1 + i), y, self,
                                       j + 5, mod=12, max_cards=12))
            y = y + l.YS
        self.texts.info = MfxCanvasText(
            self.canvas,
            self.width // 2, h - l.YM // 2,
            anchor="center",
            font=self.app.getFont("canvas_default"))

        # Create braids
        x, y = l.XM + l.XS * 2.15 + l.XS * decks, l.YM
        s.braidstrong = Journey_BraidStack(
            x, y, self, xoffset=12, yoffset=self.BRAID_OFFSET)
        x = x + l.XS * 1.7
        s.braidweak = Journey_BraidStack(
            x, y, self, xoffset=-12, yoffset=self.BRAID_OFFSET)

        # Create talon
        x, y = l.XM + l.XS * 2 + l.XS * decks, h - l.YS - l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "s")
        s.talon.texts.rounds = MfxCanvasText(
            self.canvas,
            self.width // 2, h - l.YM * 2.5,
            anchor="center",
            font=self.app.getFont("canvas_default"))
        x = x + l.XS * 2
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")

        # define stack-groups
        self.sg.talonstacks = [s.talon] + [s.waste]
        self.sg.openstacks = s.foundations + s.rows
        self.sg.dropstacks = [s.braidstrong] + [s.braidweak] + s.rows \
            + [s.waste]

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        self.base_card = None
        self.updateText()
        for i in range(self.BRAID_CARDS):
            self.s.talon.dealRow(rows=[self.s.braidstrong])
        for i in range(self.BRAID_CARDS):
            self.s.talon.dealRow(rows=[self.s.braidweak])
        self.s.talon.dealRow()
        # deal base_card to foundations, update cap.base_rank
        self.base_card = self.s.talon.getCard()
        to_stack = self.s.foundations[
            self.base_card.suit * self.gameinfo.decks]
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, to_stack)
        self.updateText()
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        # deal first card to WasteStack
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                ((card1.rank + 1) % 12 == card2.rank or
                 (card2.rank + 1) % 12 == card1.rank))

    def getHighlightPilesStacks(self):
        return ()

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)

    #
    # game extras
    #

    def updateText(self):
        if self.preview > 1 or not self.texts.info:
            return
        if not self.base_card:
            t = ""
        else:
            t = self.RANKS[self.base_card.rank]
            dir = self.getFoundationDir() % 12
            if dir == 1:
                t = t + _(" Ascending")
            elif dir == 11:
                t = t + _(" Descending")
        self.texts.info.config(text=t)


# ************************************************************************
# * Long Journey to Cuddapah
# ************************************************************************

class LongJourney(Journey):

    BRAID_CARDS = 20
    BRAID_OFFSET = .7


# ************************************************************************
#  * Appachan's Waterfall
#  ***********************************************************************/

class AppachansWaterfall(AbstractDashavataraGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        w, h = l.XM + l.XS * 10, l.YM + l.YS * 6
        self.setSize(w, h)

        # Create row stacks
        x, y = l.XM, l.YM
        for i in range(10):
            s.rows.append(AppachansWaterfall_RowStack(x, y, self,
                                                      base_rank=ANY_RANK,
                                                      max_move=12,
                                                      max_cards=99))
            x = x + l.XS
        self.setRegion(s.rows, (-999, -999, 999999, l.YM + l.YS * 5))

        # Create foundation
        x, y = w // 2 - l.CW // 2, h - l.YS
        s.foundations.append(AppachansWaterfall_Foundation(x, y, self, -1))

        # Create reserves
        s.reserves.append(ReserveStack(x - l.XS * 2, y, self))
        s.reserves.append(ReserveStack(x + l.XS * 2, y, self))

        # Create talon
        s.talon = DealRowTalonStack(l.XM, y, self)
        l.createText(s.talon, "n")

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 120
        for i in range(4):
            self.s.talon.dealRow(flip=1, frames=0)
        self.startDealSample()
        self.s.talon.dealCards()

    def isGameWon(self):
        return len(self.s.foundations[0].cards) == 120


# ************************************************************************
# * Hiranyaksha
# ************************************************************************

class Hiranyaksha(AbstractDashavataraGame):
    RowStack_Class = StackWrapper(Dashavatara_RK_RowStack, base_rank=NO_RANK)

    #
    # game layout
    #

    def createGame(self, rows=11, reserves=10):
        # create layout
        l, s = Layout(self), self.s

        # set size
        maxrows = max(rows, reserves)
        self.setSize(l.XM + (maxrows + 2) * l.XS, l.YM + 6 * l.YS)

        #
        playcards = 4 * l.YS // l.YOFFSET
        xoffset, yoffset = [], []
        for i in range(playcards):
            xoffset.append(0)
            yoffset.append(l.YOFFSET)
        for i in range(96 * self.gameinfo.decks - playcards):
            xoffset.append(l.XOFFSET)
            yoffset.append(0)

        # create stacks
        x, y = l.XM + (maxrows - reserves) * l.XS // 2, l.YM
        for i in range(reserves):
            s.reserves.append(ReserveStack(x, y, self))
            x = x + l.XS
        x, y = l.XM + (maxrows - rows) * l.XS // 2, l.YM + l.YS
        self.setRegion(s.reserves, (-999, -999, 999999, y - l.YM // 2))
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self, yoffset=l.YOFFSET)
            stack.CARD_XOFFSET = xoffset
            stack.CARD_YOFFSET = yoffset
            s.rows.append(stack)
            x = x + l.XS
        x, y = l.XM + maxrows * l.XS, l.YM
        for i in range(2):
            for suit in range(5):
                s.foundations.append(SS_FoundationStack(x, y, self,
                                                        suit=suit + (5 * i)))
                y = y + l.YS
            x, y = x + l.XS, l.YM
        self.setRegion(self.s.foundations, (x - l.XS * 2, -999, 999999,
                       self.height - (l.YS + l.YM)), priority=1)
        s.talon = InitialDealTalonStack(
            self.width - 3 * l.XS // 2, self.height - l.YS, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        i = 0
        while self.s.talon.cards:
            if self.s.talon.cards[-1].rank == 11:
                if self.s.rows[i].cards:
                    i = i + 1
            self.s.talon.dealRow(rows=[self.s.rows[i]], frames=4)

    # must look at cards
    def _getClosestStack(self, cx, cy, stacks, dragstack):
        closest, cdist = None, 999999999
        for stack in stacks:
            if stack.cards and stack is not dragstack:
                dist = (stack.cards[-1].x - cx)**2 + \
                    (stack.cards[-1].y - cy)**2
            else:
                dist = (stack.x - cx)**2 + (stack.y - cy)**2
            if dist < cdist:
                closest, cdist = stack, dist
        return closest

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isRankSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# * Dashavatara Hint
# ************************************************************************

class Dashavatara_Hint(AbstractHint):
    def computeHints(self):
        game = self.game

        # 2)See if we can move a card to the tableaux
        if not self.hints:
            for r in game.sg.dropstacks:
                pile = r.getPile()
                if not pile or len(pile) != 1:
                    continue
                if r in game.s.tableaux:
                    rr = self.ClonedStack(r, stackcards=r.cards[:-1])
                    if rr.acceptsCards(None, pile):
                        # do not move a card that is already in correct place
                        continue
                    base_score = 80000 + (4 - r.cap.base_suit)
                else:
                    base_score = 80000
                # find a stack that would accept this card
                for t in game.s.tableaux:
                    if t is not r and t.acceptsCards(r, pile):
                        score = base_score + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 3)See if we can move a card from the tableaux
        #    to a row stack. This can only happen if there are
        #    no more cards to deal.
        if not self.hints:
            for r in game.s.tableaux:
                pile = r.getPile()
                if not pile or len(pile) != 1:
                    continue
                rr = self.ClonedStack(r, stackcards=r.cards[:-1])
                if rr.acceptsCards(None, pile):
                    # do not move a card that is already in correct place
                    continue
                # find a stack that would accept this card
                for t in game.s.rows:
                    if t is not r and t.acceptsCards(r, pile):
                        score = 70000 + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 4)See if we can move a card within the row stacks
        if not self.hints:
            for r in game.s.rows:
                pile = r.getPile()
                if not pile or len(pile) != 1 or len(pile) == len(r.cards):
                    continue
                base_score = 60000
                # find a stack that would accept this card
                for t in game.s.rows:
                    if t is not r and t.acceptsCards(r, pile):
                        score = base_score + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 5)See if we can deal cards
        if self.level >= 2:
            if game.canDealCards():
                self.addHint(self.SCORE_DEAL, 0, game.s.talon, None)


# ************************************************************************
# * Dashavatara
# ************************************************************************

class Dashavatara(Game):
    Hint_Class = Dashavatara_Hint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        TABLEAU_YOFFSET = min(9, max(3, l.YOFFSET // 3))

        # set window
        th = l.YS + 3 * TABLEAU_YOFFSET
        # (set piles so that at least 2/3 of a card is visible with 10 cards)
        h = 10 * l.YOFFSET + l.CH * 2//3
        self.setSize(11 * l.XS + l.XM * 2, l.YM + 3 * th + l.YM + h)

        # create stacks
        s.addattr(tableaux=[])     # register extra stack variable
        x = l.XM + 8 * l.XS + l.XS // 2
        y = l.YM
        for i in range(3, 0, -1):
            x = l.XM
            for j in range(10):
                s.tableaux.append(
                    Dashavatara_TableauStack(
                        x, y, self, i - 1, TABLEAU_YOFFSET))
                x = x + l.XS
            x = x + l.XM
            s.reserves.append(Dashavatara_ReserveStack(x, y, self))
            y = y + th
        x, y = l.XM, y + l.YM
        for i in range(10):
            s.rows.append(Dashavatara_RowStack(x, y, self, max_accept=1))
            x = x + l.XS
        x = self.width - l.XS
        y = self.height - l.YS
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, "sw")

        # define stack-groups
        self.sg.openstacks = s.tableaux + s.rows + s.reserves
        self.sg.talonstacks = [s.talon]
        self.sg.dropstacks = s.tableaux + s.rows

    #
    # game overrides
    #

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.tableaux, frames=0)
        self._startAndDealRow()

    def isGameWon(self):
        for stack in self.s.tableaux:
            if len(stack.cards) != 4:
                return 0
        return 1

    def fillStack(self, stack):
        if self.s.talon.cards:
            if stack in self.s.rows and len(stack.cards) == 0:
                self.s.talon.dealRow(rows=[stack])

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                (card1.rank + 3 == card2.rank or card2.rank + 3 == card1.rank))

    def getHighlightPilesStacks(self):
        return ()


# ************************************************************************
#  *
#  ***********************************************************************/

def r(id, gameclass, name, game_type, decks, redeals, skill_level):
    game_type = game_type | GI.GT_DASHAVATARA_GANJIFA
    gi = GameInfo(id, gameclass, name, game_type, decks, redeals, skill_level,
                  suits=list(range(10)), ranks=list(range(12)))
    registerGame(gi)
    return gi


r(15406, Matsya, "Matsya", GI.GT_DASHAVATARA_GANJIFA, 1, 0, GI.SL_BALANCED)
r(15407, Kurma, "Kurma", GI.GT_DASHAVATARA_GANJIFA, 1, -1, GI.SL_BALANCED)
r(15408, Varaha, "Varaha", GI.GT_DASHAVATARA_GANJIFA, 1, -1, GI.SL_BALANCED)
r(15409, Narasimha, "Narasimha", GI.GT_DASHAVATARA_GANJIFA, 1, 0,
  GI.SL_BALANCED)
r(15410, Vamana, "Vamana", GI.GT_DASHAVATARA_GANJIFA, 1, -1, GI.SL_BALANCED)
r(15411, Parashurama, "Parashurama", GI.GT_DASHAVATARA_GANJIFA, 1, 1,
  GI.SL_BALANCED)
r(15412, TenAvatars, "Ten Avatars", GI.GT_DASHAVATARA_GANJIFA, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(15413, DashavataraCircles, "Dashavatara Circles", GI.GT_DASHAVATARA_GANJIFA,
  1, 0, GI.SL_MOSTLY_SKILL)
r(15414, Balarama, "Balarama", GI.GT_DASHAVATARA_GANJIFA, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(15415, Hayagriva, "Hayagriva", GI.GT_DASHAVATARA_GANJIFA, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(15416, Shanka, "Shanka", GI.GT_DASHAVATARA_GANJIFA, 1, 0, GI.SL_MOSTLY_SKILL)
r(15417, Journey, "Journey to Cuddapah", GI.GT_DASHAVATARA_GANJIFA, 1, 2,
  GI.SL_BALANCED)
r(15418, LongJourney, "Long Journey to Cuddapah", GI.GT_DASHAVATARA_GANJIFA,
  2, 2, GI.SL_BALANCED)
r(15419, Surukh, "Surukh", GI.GT_DASHAVATARA_GANJIFA, 1, 0, GI.SL_BALANCED)
r(15420, AppachansWaterfall, "Appachan's Waterfall", GI.GT_DASHAVATARA_GANJIFA,
  1, 0, GI.SL_MOSTLY_SKILL)
r(15421, Hiranyaksha, 'Hiranyaksha', GI.GT_DASHAVATARA_GANJIFA, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(15422, Dashavatara, 'Dashavatara', GI.GT_DASHAVATARA_GANJIFA, 1, 0,
  GI.SL_BALANCED)

del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import math

from pysollib.game import Game
from pysollib.hint import DefaultHint
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.stack import \
        AbstractFoundationStack, \
        OpenStack, \
        ReserveStack, \
        cardsFaceUp, \
        isRankSequence
from pysollib.util import ANY_RANK, ANY_SUIT


class AbstractFlowerGame(Game):
    SUITS = (_("Pine"), _("Plum"), _("Cherry"), _("Wisteria"),
             _("Iris"), _("Peony"), _("Bush Clover"), _("Eularia"),
             _("Chrysanthemum"), _("Maple"), _("Willow"), _("Paulownia"))

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return ((card1.suit == card2.suit) and
                ((card1.rank + 1 == card2.rank) or
                 (card1.rank - 1 == card2.rank)))


class Queue_Hint(DefaultHint):
    pass


# ************************************************************************
#  * Flower Foundation Stacks
#  ***********************************************************************/


class Flower_FoundationStack(AbstractFoundationStack):

    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, max_cards=12, max_move=0, base_rank=ANY_RANK,
                  base_suit=ANY_SUIT)
        AbstractFoundationStack.__init__(self, x, y, game, suit, **cap)

    def updateText(self):
        AbstractFoundationStack.updateText(self)
        self.game.updateText()

    def isHanafudaSequence(self, s, strictness=1):
        for i in range(len(s) - 1):
            if s[i].suit != s[i + 1].suit:
                return 0
            if s[i].suit == 10 or strictness:
                a, b = s[i].rank, s[i + 1].rank
            else:
                a, b = self.swapTrashCards(s[i], s[i + 1])
            if a + 1 != b:
                return 0
        return cardsFaceUp(s)

    def swapTrashCards(self, carda, cardb):
        a, b = carda.rank, cardb.rank
        if a == 3 and b == 2:
            a, b = 2, 3
        elif a == 1 and b == 3:
            b = 2
        return a, b

    def getBaseCard(self):
        return ''                       # FIXME

    def getHelp(self):
        return ''                       # FIXME


class Hanafuda_SS_FoundationStack(Flower_FoundationStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if not stackcards:
            return cards[0].rank == 3
        return self.isHanafudaSequence([cards[0], stackcards[-1]])

    def getBottomImage(self):
        return self.game.app.images.getSuitBottom(self.cap.suit)


class FlowerClock_Foundation(Flower_FoundationStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if not stackcards:
            return cards[0].rank == 3
        if not stackcards[-1].suit == cards[0].suit:
            return 0
        return stackcards[-1].rank == cards[0].rank + 1


class Gaji_Foundation(Flower_FoundationStack):

    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, max_move=1, min_cards=1, max_accept=1,
                  base_suit=ANY_SUIT)
        Flower_FoundationStack.__init__(self, x, y, game, suit, **cap)
        self.CARD_YOFFSET = self.game.app.images.CARD_YOFFSET

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        return ((((stackcards[-1].suit + 1) % 12) == cards[0].suit) and
                (stackcards[-1].rank == cards[0].rank))

    def getBottomImage(self):
        return self.game.app.images.getLetter(self.cap.base_rank)


class Pagoda_Foundation(Flower_FoundationStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if not stackcards:
            return cards[0].rank == 3
        a, b = stackcards[-1].rank, cards[0].rank
        if len(stackcards) < 4:
            return a - 1 == b
        elif len(stackcards) > 4:
            return a + 1 == b
        else:
            return a == b

    def getBottomImage(self):
        return self.game.app.images.getSuitBottom(self.cap.suit)


class MatsuKiri_Foundation(Flower_FoundationStack):

    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, max_move=0, max_cards=48, max_accept=4, min_accept=4)
        AbstractFoundationStack.__init__(self, x, y, game, suit, **cap)
        self.CARD_YOFFSET = self.game.app.images.CARDH // 10

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        if not self.isHanafudaSequence(cards, 0):
            return 0
        stackcards = self.cards
        if not stackcards:
            return cards[0].suit == 0
        return stackcards[-1].suit + 1 == cards[0].suit

    #     def getBottomImage(self):
    #         return self.game.app.images.getBraidBottom()


class GreatWall_FoundationStack(Flower_FoundationStack):

    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, max_cards=48, max_move=1, min_accept=1, max_accept=1)
        Flower_FoundationStack.__init__(self, x, y, game, suit, **cap)
        self.CARD_YOFFSET = self.game.app.images.CARDH // 20

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if stackcards:
            return ((stackcards[-1].suit + 1) % 12 == cards[0].suit and
                    cards[0].rank == self.cap.base_rank)
        else:
            return cards[0].suit == 0

    def getBottomImage(self):
        return self.game.app.images.getLetter(self.cap.base_rank)


class FourWinds_Foundation(Flower_FoundationStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if not (cards[0].rank == self.cap.base_rank):
            return 0
        if not stackcards:
            return (cards[0].suit == 0)
        else:
            return (cards[0].suit == stackcards[-1].suit + 1)

    #      def getBottomImage(self):
    #          return self.game.app.images.getLetter(self.cap.base_rank)


class Queue_Foundation(AbstractFoundationStack):
    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, mod=12, dir=0, base_suit=ANY_SUIT, max_move=0)
        AbstractFoundationStack.__init__(self, x, y, game, suit, **cap)

    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return 0
        if not self.cards:
            return cards[0].suit == self.game.base_card.suit
        stack_dir = self.game.getFoundationDir()
        if stack_dir == 0:
            card_dir = (cards[0].suit - self.cards[-1].suit) % 12
            return card_dir in (1, 11)
        else:
            return (self.cards[-1].suit + stack_dir) % 12 == cards[0].suit

    def getBottomImage(self):
        return self.game.app.images.getLetter(self.cap.base_rank)


# ************************************************************************
#  * Flower Row Stacks
#  ***********************************************************************/

class Flower_OpenStack(OpenStack):

    def __init__(self, x, y, game, yoffset, **cap):
        kwdefault(cap, max_move=99, max_cards=99, max_accept=99, base_rank=0,
                  dir=1)
        OpenStack.__init__(self, x, y, game, **cap)
        self.CARD_YOFFSET = yoffset

    def isHanafudaSequence(self, cards, strictness=1):
        c1 = cards[0]
        for c2 in cards[1:]:
            if c1.suit != c2.suit:
                return 0
            if c1.suit == 10 or strictness:
                a, b = c1.rank, c2.rank
            else:
                a, b = self.swapTrashCards(c1, c2)
            if a + self.cap.dir != b:
                return 0
            c1 = c2
        return 1

    def swapTrashCards(self, carda, cardb):
        a, b = carda.rank, cardb.rank
        if a == 3 and b == 2:
            a, b = 2, 3
        elif a == 1 and b == 3:
            b = 2
        return a, b


class Hanafuda_SequenceStack(Flower_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards) \
               or not self.isHanafudaSequence(cards):
            return 0
        stackcards = self.cards
        if not len(stackcards):
            return cards[0].rank == 0 or self.cap.base_rank == ANY_RANK
        return self.isHanafudaSequence([stackcards[-1], cards[0]])

    def canMoveCards(self, cards):
        return self.basicCanMoveCards(cards) and self.isHanafudaSequence(cards)


class Oonsoo_SequenceStack(Flower_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards) \
                or not self.isHanafudaSequence(cards, 0):
            return 0
        stackcards = self.cards
        if not len(stackcards):
            return cards[0].rank == 0 or self.cap.base_rank == ANY_RANK
        return self.isHanafudaSequence([stackcards[-1], cards[0]], 0)

    def canMoveCards(self, cards):
        return (self.basicCanMoveCards(cards) and
                self.isHanafudaSequence(cards, 0))


class FlowerClock_RowStack(Flower_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if not len(stackcards):
            return 1
        return stackcards[-1].rank + 1 == cards[0].rank


class Gaji_RowStack(Flower_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if ((not len(stackcards)) or
                ((stackcards[-1].suit == 10) and (stackcards[-1].rank == 3)) or
                ((cards[0].suit == 10) and (cards[0].rank == 3))):
            return 1
        elif stackcards[-1].suit != cards[0].suit:
            return 0
        a, b = self.swapTrashCards(stackcards[-1], cards[0])
        return a + 1 == b


class Matsukiri_RowStack(Flower_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if not stackcards:
            return cards[0].rank == 0
        if cards[0].suit != stackcards[-1].suit:
            return 0
        if stackcards[-1].suit == 10 or self.game.Strictness:
            a, b = stackcards[-1].rank, cards[0].rank
        else:
            a, b = self.swapTrashCards(stackcards[-1], cards[0])
        return a + 1 == b

    def canDropCards(self, stacks):
        pile = self.getPile()
        if not pile or len(pile) <= 3:
            return (None, 0)
        f = self.game.s.foundations[0]
        if not f.cards:
            suit = 0
        else:
            suit = f.cards[-1].suit + 1
        if not pile[-1].suit == suit or \
                not self.isHanafudaSequence(pile[-4:], 0):
            return (None, 0)
        return (f, 4)


class Samuri_RowStack(Flower_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if not stackcards:
            return cards[0].rank == 0
        return stackcards[-1].suit == cards[0].suit and \
            stackcards[-1].rank + 1 == cards[0].rank


class GreatWall_RowStack(Flower_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if not stackcards:
            return cards[0].rank == 0
        if cards[0].rank == stackcards[-1].rank:
            return stackcards[-1].suit == (cards[0].suit + 1) % 12
        a, b = self.swapTrashCards(stackcards[-1], cards[0])
        return a + 1 == b


class FourWinds_RowStack(Flower_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if len(cards) - 1 or len(stackcards) >= 3:
            return 0
        if not stackcards:
            return 1
        return ((cards[0].rank == stackcards[-1].rank) and
                (cards[0].suit == stackcards[-1].suit - 1))

    def getBottomImage(self):
        return self.game.app.images.getReserveBottom()


class Queue_BraidStack(OpenStack):

    def __init__(self, x, y, game, yoffset):
        OpenStack.__init__(self, x, y, game)
        self.CARD_YOFFSET = int(self.game.app.images.CARD_YOFFSET * yoffset)
        # use a sine wave for the x offsets
        # compensate for card width
        offset = self.game.app.images.CARDW / 1.7
        self.CARD_XOFFSET = []
        j = 1
        for i in range(20):
            self.CARD_XOFFSET.append(int(math.sin(j) * offset))
            j = j + .9


class Queue_RowStack(ReserveStack):

    def fillStack(self):
        if not self.cards and self.game.s.braid.cards:
            self.game.moveMove(1, self.game.s.braid, self)

    def getBottomImage(self):
        return self.game.app.images.getBraidBottom()


class Queue_ReserveStack(ReserveStack):

    def acceptsCards(self, from_stack, cards):
        if from_stack is self.game.s.braid or from_stack in self.game.s.rows:
            return 0
        return ReserveStack.acceptsCards(self, from_stack, cards)

    def getBottomImage(self):
        return self.game.app.images.getTalonBottom()


class JapaneseGarden_RowStack(Flower_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if (not self.basicAcceptsCards(from_stack, cards) or
                from_stack not in self.game.s.rows):
            return 0
        stackcards = self.cards
        if not len(stackcards):
            return 1
        return stackcards[-1].rank + 1 == cards[0].rank


class HanafudaRK_RowStack(Flower_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if (not self.basicAcceptsCards(from_stack, cards) or
                not isRankSequence(cards, dir=1)):
            return 0
        stackcards = self.cards
        if not len(stackcards):
            return 1
        return stackcards[-1].rank + 1 == cards[0].rank
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.ultra.hanafuda_common import \
        AbstractFlowerGame, \
        FlowerClock_Foundation, \
        FlowerClock_RowStack, \
        FourWinds_Foundation, \
        FourWinds_RowStack, \
        Gaji_Foundation, \
        Gaji_RowStack, \
        GreatWall_FoundationStack, \
        GreatWall_RowStack, \
        Hanafuda_SS_FoundationStack, \
        Hanafuda_SequenceStack, \
        MatsuKiri_Foundation, \
        Matsukiri_RowStack, \
        Oonsoo_SequenceStack, \
        Pagoda_Foundation
from pysollib.hint import FreeCellType_Hint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        ReserveStack, \
        WasteStack, \
        WasteTalonStack, \
        cardsFaceUp
from pysollib.util import ANY_RANK, ANY_SUIT

# ************************************************************************
#  * Flower Clock
#  ***********************************************************************/


class FlowerClock(AbstractFlowerGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s
        font = self.app.getFont("canvas_default")

        # Set window size
        self.setSize(l.XM + l.XS * 10.5, l.YM + l.YS * 5.5)

        # Create clock
        xoffset = (1, 2, 2.5, 2, 1, 0, -1, -2, -2.5, -2, -1, 0)
        yoffset = (0.25, 0.75, 1.9, 3, 3.5, 3.75, 3.5, 3, 1.9, 0.75, 0.25, 0)
        x = l.XM + l.XS * 7
        y = l.CH // 3
        for i in range(12):
            x0 = x + xoffset[i] * l.XS
            y0 = y + yoffset[i] * l.YS
            stack = FlowerClock_Foundation(x0, y0, self, ANY_SUIT, base_rank=3)
            s.foundations.append(stack)
            t = MfxCanvasText(self.canvas, x0 + l.CW // 2, y0 + l.YS,
                              anchor="center", font=font,
                              text=self.SUITS[i])
            stack.texts.misc = t

        # Create row stacks
        for j in range(2):
            x, y = l.XM, l.YM + l.YS * j * 2.7
            for i in range(4):
                s.rows.append(FlowerClock_RowStack(x, y, self,
                                                   yoffset=l.CH//4,
                                                   max_cards=8, max_accept=8))
                x = x + l.XS
        self.setRegion(s.rows, (0, 0, l.XS * 4, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(
            self.width - l.XS, self.height - l.YS, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48
        self._startDealNumRows(5)
        self.s.talon.dealRow()
        assert len(self.s.talon.cards) == 0

    def isGameWon(self):
        for i in self.s.foundations:
            if len(i.cards) != 4:
                return 0
            if i.cards[0].suit != i.id:
                return 0
        return 1

    def getAutoStacks(self, event=None):
        if event is None:
            return (self.sg.dropstacks, (), self.sg.dropstacks)
        else:
            return (self.sg.dropstacks, self.sg.dropstacks, self.sg.dropstacks)


# ************************************************************************
#  * Gaji
#  ***********************************************************************/

class Gaji(AbstractFlowerGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        self.setSize(l.XM + l.XS * 13, l.YM * 2 + l.YS * 6)

        # Create left foundations
        x = l.XM
        y = l.YM
        s.foundations.append(Gaji_Foundation(x, y, self, -1, base_rank=0))
        x += l.XS
        s.foundations.append(Gaji_Foundation(x, y, self, -1, base_rank=1))

        # Create right foundations
        x = self.width - l.XS * 2
        s.foundations.append(Gaji_Foundation(x, y, self, -1, base_rank=2))
        x += l.XS
        s.foundations.append(Gaji_Foundation(x, y, self, -1, base_rank=3))

        # Create row stacks
        x = l.XS * 2.5 + l.XM
        for i in range(8):
            s.rows.append(Gaji_RowStack(x, y, self, yoffset=l.CH//2,
                                        max_cards=12, max_accept=12))
            x += l.XS
        self.setRegion(
            s.rows, (l.XM + l.XS * 2, -999, l.XM + l.XS * 10, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(
            self.width - l.XS, self.height - l.YS, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def _shuffleHook(self, cards):
        topcards = [None, None, None, None]
        for c in cards[:]:
            if not topcards[c.rank]:
                if not ((c.suit == 10) and (c.rank == 3)):
                    topcards[c.rank] = c
                    cards.remove(c)
        return topcards + cards

    def startGame(self):
        assert len(self.s.talon.cards) == 48
        self._startDealNumRows(4)
        r = self.s.rows
        self.s.talon.dealRow(rows=(r[0], r[1], r[2], r[5], r[6], r[7]))
        self.s.talon.dealRow(rows=(r[0], r[1], r[6], r[7]))
        self.s.talon.dealRow(rows=(r[0], r[7]))
        r = self.s.foundations
        self.s.talon.dealRow(rows=(r[3], r[2], r[1], r[0]))
        assert len(self.s.talon.cards) == 0

    def fillStack(self, stack):
        if stack in self.s.rows:
            if stack.cards and not stack.cards[-1].face_up:
                self.flipMove(stack)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        if stack1 in self.s.foundations:
            return (card1.rank == card2.rank and
                    ((((card1.suit + 1) % 12) == card2.suit) or
                     (((card1.suit - 1) % 12) == card2.suit)))
        else:
            return ((card1.suit == card2.suit) and
                    ((card1.rank + 1 == card2.rank) or
                     (card1.rank - 1 == card2.rank)))


# ************************************************************************
#  * Oonsoo
#  ***********************************************************************/

class Oonsoo(AbstractFlowerGame):
    Layout_Method = staticmethod(Layout.oonsooLayout)
    Talon_Class = DealRowTalonStack
    RowStack_Class = Oonsoo_SequenceStack
    Rows = 12
    Suit = ANY_SUIT
    BaseRank = 0
    Reserves = 0
    Strictness = 0

    #
    # Game layout
    #

    def createGame(self, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=self.Rows, reserves=self.Reserves,
                  texts=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self, suit=self.Suit,
                                              base_rank=self.BaseRank,
                                              yoffset=l.YOFFSET))
        for r in l.s.reserves:
            s.reserves.append(ReserveStack(r.x, r.y, self))
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * self.gameinfo.decks
        self.startDealSample()
        self.s.talon.dealRow(flip=0)
        self.s.talon.dealCards()

    def isGameWon(self):
        if len(self.s.talon.cards):
            return 0
        for s in self.s.rows:
            if (len(s.cards) != 4 or not cardsFaceUp(s.cards) or
                    not s.isHanafudaSequence(s.cards, self.Strictness)):
                return 0
        return 1


# ************************************************************************
# * Oonsoo Too
# ************************************************************************

class OonsooToo(Oonsoo):
    Reserves = 1


# ************************************************************************
# * Oonsoo Strict
# ************************************************************************

class OonsooStrict(Oonsoo):
    RowStack_Class = Hanafuda_SequenceStack
    Reserves = 2
    Strictness = 1


# ************************************************************************
# * Oonsoo Open
# ************************************************************************

class OonsooOpen(Oonsoo):
    BaseRank = ANY_RANK


# ************************************************************************
# * Oonsoo Times Two
# ************************************************************************

class OonsooTimesTwo(Oonsoo):
    Rows = 24
    Reserves = 1


# ************************************************************************
#  * Pagoda
#  ***********************************************************************/

class Pagoda(AbstractFlowerGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s
        font = self.app.getFont("canvas_default")

        # Set window size
        self.setSize(l.XM + l.XS * 11, l.YS * 6)

        # Create foundations
        id = 0
        for j in range(4):
            x, y = l.XM + l.XS * 8, l.YM * 3 + l.YS * j * 1.5
            for i in range(3):
                stack = Pagoda_Foundation(x, y, self, id)
                s.foundations.append(stack)
                t = MfxCanvasText(self.canvas, x + l.CW // 2, y - 12,
                                  anchor="center", font=font)
                stack.texts.misc = t
                x = x + l.XS
                id = id + 1

        # Build pagoda
        x, y = l.XM + l.XS, l.YM
        d = (0.4, 0.25, 0, 0.25, 0.4)
        for i in range(5):
            s.reserves.append(
                ReserveStack(x + l.XS * i, y + l.YS * d[i], self))

        x, y = l.XM + l.XS * 2, y + l.YS * 1.1
        d = (0.25, 0, 0.25)
        for i in range(3):
            s.reserves.append(
                ReserveStack(x + l.XS * i, y + l.YS * d[i], self))

        x, y = l.XM, y + l.YS * 1.1
        d = (0.5, 0.4, 0.25, 0, 0.25, 0.4, 0.5)
        for i in range(7):
            s.reserves.append(
                ReserveStack(x + l.XS * i, y + l.YS * d[i], self))

        x, y = l.XM + l.XS, y + l.YS * 1.5
        for i in range(5):
            s.reserves.append(ReserveStack(x + l.XS * i, y, self))

        # Create talon
        x = l.XM + l.XS * 2.5
        y = l.YM + l.YS * 4.9
        s.talon = WasteTalonStack(x, y, self, num_deal=4, max_rounds=1)
        l.createText(s.talon, "sw")
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "se")

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game extras
    #

    def updateText(self):
        if self.preview > 1:
            return
        for i in range(12):
            s = self.s.foundations[i]
            if not len(s.cards) or len(s.cards) == 8:
                text = self.SUITS[i]
            elif len(s.cards) < 5:
                text = _("Rising")
            else:
                text = _("Setting")
            s.texts.misc.config(text=text)

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * 2
        self.updateText()
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.reserves, reverse=1)
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if not stack.cards and stack is self.s.waste:
            if self.canDealCards():
                self.dealCards()


# ************************************************************************
#  * Matsukiri
#  ***********************************************************************/

class MatsuKiri(AbstractFlowerGame):
    Strictness = 0

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        self.setSize(l.XM * 3 + l.XS * 9, l.YM + l.YS * 6)

        # Create row stacks
        x = l.XM
        y = l.YM
        for i in range(8):
            s.rows.append(Matsukiri_RowStack(x, y, self, yoffset=l.CH//2,
                                             max_cards=12, max_accept=12))
            x = x + l.XS
        self.setRegion(s.rows, (-999, -999, l.XM + (l.XS * 8) + 10, 999999))

        # Create foundation
        x = x + l.XM * 2
        s.foundations.append(MatsuKiri_Foundation(x, y, self, ANY_SUIT))
        self.setRegion(
            s.foundations, (l.XM + (l.XS * 8) + 10, -999, 999999, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(
            self.width - l.XS, self.height - l.YS, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48
        self._startDealNumRows(5)
        self.s.talon.dealRow()
        assert len(self.s.talon.cards) == 0

    def fillStack(self, stack):
        if stack in self.s.rows:
            if len(stack.cards) > 0 and not stack.cards[-1].face_up:
                self.flipMove(stack)


class MatsuKiriStrict(MatsuKiri):
    Strictness = 1


# ************************************************************************
#  * Great Wall
#  ***********************************************************************/

class GreatWall(AbstractFlowerGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s
        font = self.app.getFont("canvas_default")

        # Set window size
        w, h = l.XM + l.XS * 15, l.YM + l.YS * 6.2
        self.setSize(w, h)

        # Create foundations
        x, y = (l.XM, l.XM, w - l.XS, w - l.XS), (l.YM, h // 2, l.YM, h // 2)
        for i in range(4):
            stack = GreatWall_FoundationStack(x[i], y[i] + l.YM, self, -1,
                                              base_rank=i)
            s.foundations.append(stack)
            stack.texts.misc = MfxCanvasText(self.canvas,
                                             x[i] + l.CW // 2, y[i],
                                             anchor="center", font=font)

        # Create row stacks
        x = l.XM + l.XS * 1.5
        y = l.YM
        for i in range(12):
            s.rows.append(GreatWall_RowStack(x, y, self, yoffset=l.CH//4,
                                             max_cards=26, max_accept=26))
            x = x + l.XS
        self.setRegion(
            s.rows, (l.XM + l.XS * 1.25, -999, self.width - l.XS * 1.25,
                     999999))

        # Create talon
        x = self.width // 2 - l.CW // 2
        y = self.height - l.YS * 1.2
        s.talon = InitialDealTalonStack(x, y, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game extras
    #

    def updateText(self):
        if self.preview > 1:
            return
        for i in range(4):
            stack = self.s.foundations[i]
            mylen = len(stack.cards) // 12
            if mylen == 0:
                text = ""
            elif mylen == 4:
                text = _("Filled")
            else:
                text = str(mylen) + \
                    (_("st"), _("nd"), _("rd"), _("th"))[mylen - 1] \
                    + _(" Deck")
            stack.texts.misc.config(text=text)

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * 4
        self.updateText()
        for i in range(15):
            self.s.talon.dealRow(flip=0, frames=0)
        self._startAndDealRow()
        assert len(self.s.talon.cards) == 0

    def fillStack(self, stack):
        if stack in self.s.rows:
            if len(stack.cards) > 0 and not stack.cards[-1].face_up:
                self.flipMove(stack)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        if stack1 in self.s.foundations:
            return (card1.rank == card2.rank and
                    ((((card1.suit + 1) % 12) == card2.suit) or
                     (((card1.suit - 1) % 12) == card2.suit)))
        else:
            return (card1.rank + 1 == card2.rank or
                    card1.rank - 1 == card2.rank)


# ************************************************************************
# * Four Winds
# ************************************************************************

class FourWinds(AbstractFlowerGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s
        font = self.app.getFont("canvas_default")

        # Set window size
        self.setSize(7 * l.XS, 5 * l.YS + 3 * l.YM)

        # Four winds
        TEXTS = (_("North"), _("East"), _("South"), _("West"),
                 _("NW"), _("NE"), _("SE"), _("SW"))

        # Create foundations
        x = l.XM * 3
        y = l.YM
        xoffset = (2.5, 5, 2.5, 0)
        yoffset = (0, 2, 4, 2)
        for i in range(4):
            x0 = x + (xoffset[i] * l.XS)
            y0 = y + (yoffset[i] * l.YS)
            stack = FourWinds_Foundation(x0, y0, self, -1,
                                         max_cards=12, max_accept=1,
                                         base_rank=i)
            s.foundations.append(stack)
            t = MfxCanvasText(self.canvas, x0 + l.CW // 2, y0 + l.YS + 5,
                              anchor="center", font=font,
                              text=TEXTS[i])
            stack.texts.misc = t

        # Create rows
        xoffset = (1.25, 3.75, 3.75, 1.25)
        yoffset = (0.75, 0.75, 3, 3)
        for i in range(4):
            x0 = x + (xoffset[i] * l.XS)
            y0 = y + (yoffset[i] * l.YS)
            stack = FourWinds_RowStack(x0, y0, self, yoffset=10,
                                       max_cards=3, max_accept=1,
                                       base_rank=ANY_RANK)
            s.rows.append(stack)
            t = MfxCanvasText(self.canvas, x0 + l.CW // 2, y0 + l.YS + 5,
                              anchor="center", font=font,
                              text=TEXTS[i+4])
            stack.texts.misc = t
        self.setRegion(s.rows, (x + l.XS, y + l.YS * 0.65, x + l.XS * 4 + 5,
                                y + l.YS * 3 + 5))

        # Create talon
        x = x + 2 * l.XS
        y = y + 2 * l.YS
        s.talon = WasteTalonStack(x, y, self, num_deal=1, max_rounds=2)
        l.createText(s.talon, "s")
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")

        # Define stack-groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48
        self.startDealSample()
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if not stack.cards and stack is self.s.waste:
            if self.canDealCards():
                self.dealCards()


# ************************************************************************
# * Sumo
# ************************************************************************

class Sumo(AbstractFlowerGame):
    Layout_Method = staticmethod(Layout.sumoLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = Hanafuda_SS_FoundationStack
    RowStack_Class = Hanafuda_SequenceStack
    Hint_Class = FreeCellType_Hint

    #
    # Game layout
    #

    def createGame(self, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, reserves=2, texts=0, playcards=16)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    suit=r.suit, base_rank=3))
        for r in l.s.rows:
            s.rows.append(
                self.RowStack_Class(r.x, r.y, self, yoffset=l.YOFFSET))
        for r in l.s.reserves:
            s.reserves.append(ReserveStack(r.x, r.y, self))
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48
        self._startDealNumRowsAndDealRowAndCards(5)


# ************************************************************************
# * Big Sumo
# ************************************************************************

class BigSumo(AbstractFlowerGame):
    Layout_Method = staticmethod(Layout.sumoLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = Hanafuda_SS_FoundationStack
    RowStack_Class = Hanafuda_SequenceStack

    #
    # Game layout
    #

    def createGame(self, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=10, reserves=4, texts=0, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(r.x, r.y, self,
                                      suit=r.suit, base_rank=3))
        for r in l.s.rows:
            s.rows.append(
                self.RowStack_Class(r.x, r.y, self, yoffset=l.YOFFSET))
        for r in l.s.reserves:
            s.reserves.append(ReserveStack(r.x, r.y, self))
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * 2
        self._startDealNumRows(9)
        self.s.talon.dealRow(rows=self.s.rows[2:8])
        self.s.talon.dealCards()


# ************************************************************************
# * Samuri
# ************************************************************************

class Samuri(AbstractFlowerGame):
    Layout_Method = staticmethod(Layout.samuriLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = Hanafuda_SS_FoundationStack
    RowStack_Class = Hanafuda_SequenceStack
    Rows = 7

    #
    # Game layout
    #

    def createGame(self, max_rounds=1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=self.Rows, waste=1, texts=1, playcards=21)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(self.Foundation_Class(r.x, r.y, self,
                                 suit=r.suit, base_rank=3))

        # Create row stacks
        for r in l.s.rows:
            s.rows.append(
                self.RowStack_Class(r.x, r.y, self, yoffset=l.YOFFSET))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        decks = self.gameinfo.decks
        assert len(self.s.talon.cards) == 48 * decks
        for i in range(1 + (decks > 1)):
            self.s.talon.dealRow(flip=0, frames=0)
        max_row = len(self.s.rows)
        for i in range(max_row):
            self.s.talon.dealRow(
                rows=self.s.rows[i:max_row-i], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if not stack.cards and stack is self.s.waste:
            if self.canDealCards():
                self.dealCards()


# ************************************************************************
#  * Double Samuri
#  ***********************************************************************/

class DoubleSamuri(Samuri):
    Rows = 11


# ************************************************************************
#  * Super Samuri
#  ***********************************************************************/

class SuperSamuri(DoubleSamuri):
    pass


# ************************************************************************
# * Little Easy
# ************************************************************************

class LittleEasy(AbstractFlowerGame):
    Layout_Method = staticmethod(Layout.easyLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = FourWinds_Foundation
    RowStack_Class = Hanafuda_SequenceStack
    Rows = 7
    PlayCards = 10

    #
    # Game layout
    #

    def createGame(self, max_rounds=-1, num_deal=3, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=self.Rows, waste=1, texts=1,
                  playcards=self.PlayCards)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)
        for r in l.s.foundations:
            s.foundations.append(self.Foundation_Class(r.x, r.y, self,
                                 suit=ANY_SUIT, base_rank=r.suit))
        for r in l.s.rows:
            s.rows.append(
                self.RowStack_Class(r.x, r.y, self, yoffset=l.YOFFSET))
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * self.gameinfo.decks
        self.s.talon.dealRow(flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def fillStack(self, stack):
        if not stack.cards and stack is self.s.waste:
            if self.canDealCards():
                self.dealCards()


# ************************************************************************
# * Easy x One
# ************************************************************************

class EasyX1(LittleEasy):

    def createGame(self, **layout):
        LittleEasy.createGame(self, max_rounds=2, num_deal=1)


# ************************************************************************
# * Relax
# ************************************************************************

class Relax(EasyX1):
    RowStack_Class = Oonsoo_SequenceStack


# ************************************************************************
# * Big Easy
# ************************************************************************

class BigEasy(LittleEasy):
    Rows = 11


# ************************************************************************
# * Easy Supreme
# ************************************************************************

class EasySupreme(LittleEasy):
    Rows = 11
    PlayCards = 14


# ************************************************************************
# * Just For Fun
# ************************************************************************

class JustForFun(AbstractFlowerGame):
    Layout_Method = staticmethod(Layout.funLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = FourWinds_Foundation
    RowStack_Class = Hanafuda_SequenceStack
    Rows = 12
    Reserves = 2
    BaseRank = 0

    #
    # Game layout
    #

    def createGame(self, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=self.Rows, reserves=self.Reserves, texts=0,
                  playcards=22)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create stacks
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)
        for r in l.s.foundations:
            s.foundations.append(self.Foundation_Class(r.x, r.y, self,
                                 suit=ANY_SUIT, base_rank=r.suit))
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                          base_rank=self.BaseRank, yoffset=l.YOFFSET))
        for r in l.s.reserves:
            s.reserves.append(ReserveStack(r.x, r.y, self))
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        decks = self.gameinfo.decks
        assert len(self.s.talon.cards) == 48 * decks
        for i in range((decks * 2) + 1):
            self.s.talon.dealRow(flip=1, frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:len(self.s.talon.cards)])
        self.s.talon.dealCards()


# ************************************************************************
# * Double Your Fun
# ************************************************************************

class DoubleYourFun(JustForFun):
    Rows = 18
    Reserves = 4


# ************************************************************************
# * Firecracker
# ************************************************************************

class Firecracker(JustForFun):
    RowStack_Class = Oonsoo_SequenceStack
    Reserves = 0
    BaseRank = ANY_RANK


# ************************************************************************
# * Cherry Bomb
# ************************************************************************

class CherryBomb(Firecracker):
    Rows = 18


# ************************************************************************
# * Paulownia
# ************************************************************************

class Paulownia(AbstractFlowerGame):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = Hanafuda_SS_FoundationStack
    RowStack_Class = Hanafuda_SequenceStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=-1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(self.Foundation_Class(r.x, r.y, self,
                                                       suit=r.suit,
                                                       base_rank=3))

        # Create row stacks
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                          base_rank=0, yoffset=l.YOFFSET))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48
        for i in range(8):
            self.s.talon.dealRow(rows=self.s.rows[i + 1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()


# ************************************************************************
# *  Register the games
# ************************************************************************

def r(id, gameclass, name, game_type, decks, redeals, skill_level):
    game_type = game_type | GI.GT_HANAFUDA
    gi = GameInfo(id, gameclass, name, game_type, decks, redeals, skill_level,
                  suits=list(range(12)), ranks=list(range(4)))
    registerGame(gi)
    return gi


r(12345, Oonsoo, "Oonsoo", GI.GT_HANAFUDA, 1, 0, GI.SL_MOSTLY_SKILL)
r(12346, MatsuKiri, "MatsuKiri", GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(12372, MatsuKiriStrict, 'MatsuKiri Strict', GI.GT_HANAFUDA | GI.GT_OPEN, 1,
  0, GI.SL_MOSTLY_SKILL)
r(12347, Gaji, "Gaji", GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL)
r(12348, FlowerClock, "Flower Clock", GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(12349, Pagoda, "Pagoda", GI.GT_HANAFUDA, 2, 0, GI.SL_BALANCED)
r(12350, Samuri, "Samuri", GI.GT_HANAFUDA, 1, 0, GI.SL_BALANCED)
r(12351, GreatWall, "Great Wall", GI.GT_HANAFUDA, 4, 0, GI.SL_MOSTLY_SKILL)
r(12352, FourWinds, "Hanafuda Four Winds", GI.GT_HANAFUDA, 1, 1,
  GI.SL_MOSTLY_SKILL)
r(12353, Sumo, "Sumo", GI.GT_HANAFUDA, 1, 0, GI.SL_MOSTLY_SKILL)
r(12354, BigSumo, "Big Sumo", GI.GT_HANAFUDA, 2, 0, GI.SL_MOSTLY_SKILL)
r(12355, LittleEasy, "Little Easy", GI.GT_HANAFUDA, 1, -1, GI.SL_BALANCED)
r(12356, BigEasy, "Big Easy", GI.GT_HANAFUDA, 2, -1, GI.SL_BALANCED)
r(12357, EasySupreme, "Easy Supreme", GI.GT_HANAFUDA, 4, -1, GI.SL_BALANCED)
r(12358, JustForFun, "Just For Fun", GI.GT_HANAFUDA, 1, 0, GI.SL_MOSTLY_SKILL)
r(12359, Firecracker, "Firecracker", GI.GT_HANAFUDA, 1, 0, GI.SL_BALANCED)
r(12360, EasyX1, "Easy x One", GI.GT_HANAFUDA, 1, 1, GI.SL_BALANCED)
r(12361, Relax, "Relax", GI.GT_HANAFUDA, 1, 1, GI.SL_BALANCED)
r(12362, DoubleSamuri, "Double Samuri", GI.GT_HANAFUDA, 2, 0, GI.SL_BALANCED)
r(12363, SuperSamuri, "Super Samuri", GI.GT_HANAFUDA, 4, 0, GI.SL_BALANCED)
r(12364, DoubleYourFun, "Double Your Fun", GI.GT_HANAFUDA, 2, 0,
  GI.SL_MOSTLY_SKILL)
r(12365, CherryBomb, "Cherry Bomb", GI.GT_HANAFUDA, 2, 0, GI.SL_BALANCED)
r(12366, OonsooToo, "Oonsoo Too", GI.GT_HANAFUDA, 1, 0, GI.SL_MOSTLY_SKILL)
r(12367, OonsooStrict, "Oonsoo Strict", GI.GT_HANAFUDA, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(12368, OonsooOpen, "Oonsoo Open", GI.GT_HANAFUDA, 1, 0, GI.SL_MOSTLY_SKILL)
r(12379, OonsooTimesTwo, "Oonsoo Times Two", GI.GT_HANAFUDA, 2, 0,
  GI.SL_MOSTLY_SKILL)

del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import math

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import AbstractHint, DefaultHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AC_RowStack, \
        AbstractFoundationStack, \
        BasicRowStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        OpenStack, \
        RK_RowStack, \
        ReserveStack, \
        SS_FoundationStack, \
        SS_RowStack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack, \
        isSameSuitSequence
from pysollib.util import ANY_RANK, ANY_SUIT, NO_RANK, UNLIMITED_ACCEPTS, \
        UNLIMITED_CARDS,  UNLIMITED_MOVES


# ************************************************************************
#  * Mughal Foundation Stacks
#  ***********************************************************************/


class Mughal_FoundationStack(AbstractFoundationStack):

    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, max_move=0)
        SS_FoundationStack.__init__(self, x, y, game, suit, **cap)

    def updateText(self):
        AbstractFoundationStack.updateText(self)
        self.game.updateText()


class Triumph_Foundation(AbstractFoundationStack):

    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, mod=12, dir=0, base_rank=NO_RANK, max_move=0)
        AbstractFoundationStack.__init__(self, x, y, game, suit, **cap)

    def acceptsCards(self, from_stack, cards):

        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return 0
        if not self.cards:
            return 1
        stack_dir = self.game.getFoundationDir()
        if stack_dir == 0:
            card_dir = (cards[0].rank - self.cards[-1].rank) % self.cap.mod
            return card_dir in (1, 11)
        else:
            return (self.cards[-1].rank + stack_dir) % self.cap.mod \
                == cards[0].rank


# ************************************************************************
#  * Mughal Row Stacks
#  ***********************************************************************/

class Mughal_OpenStack(OpenStack):

    def __init__(self, x, y, game, yoffset, **cap):
        kwdefault(cap, max_move=UNLIMITED_MOVES, max_cards=UNLIMITED_CARDS,
                  max_accept=UNLIMITED_ACCEPTS, base_rank=0, dir=-1)
        OpenStack.__init__(self, x, y, game, **cap)
        self.CARD_YOFFSET = yoffset

    def isRankSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        for c2 in cards[1:]:
            if not c1.rank + dir == c2.rank:
                return 0
            c1 = c2
        return 1

    def isAlternateColorSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        for c2 in cards[1:]:
            if not ((c1.suit + c2.suit) % 2 and c1.rank + dir == c2.rank):
                return 0
            c1 = c2
        return 1

    def isAlternateForceSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        for c2 in cards[1:]:
            if not ((c1.suit < 4 and c2.suit > 3 or
                     c1.suit > 3 and c2.suit < 4) and
                    c1.rank + dir == c2.rank):
                return 0
            c1 = c2
        return 1

    def isSuitSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        for c2 in cards[1:]:
            if not (c1.suit == c2.suit and c1.rank + dir == c2.rank):
                return 0
            c1 = c2
        return 1


class Mughal_AC_RowStack(Mughal_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if (not self.basicAcceptsCards(from_stack, cards) or
                not self.isAlternateColorSequence(cards)):
            return 0
        stackcards = self.cards
        if not len(stackcards):
            return cards[0].rank == 11 or self.cap.base_rank == ANY_RANK
        return self.isAlternateColorSequence([stackcards[-1], cards[0]])


class Mughal_AF_RowStack(Mughal_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if (not self.basicAcceptsCards(from_stack, cards) or
                not self.isAlternateForceSequence(cards)):
            return 0
        stackcards = self.cards
        if not len(stackcards):
            return cards[0].rank == 11 or self.cap.base_rank == ANY_RANK
        return self.isAlternateForceSequence([stackcards[-1], cards[0]])


class Mughal_RK_RowStack(Mughal_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if (not self.basicAcceptsCards(from_stack, cards) or
                not self.isRankSequence(cards)):
            return 0
        stackcards = self.cards
        if not len(stackcards):
            return cards[0].rank == 11 or self.cap.base_rank == ANY_RANK
        return self.isRankSequence([stackcards[-1], cards[0]])


class Mughal_SS_RowStack(Mughal_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if (not self.basicAcceptsCards(from_stack, cards) or
                not self.isSuitSequence(cards)):
            return 0
        stackcards = self.cards
        if not len(stackcards):
            return cards[0].rank == 11 or self.cap.base_rank == ANY_RANK
        return self.isSuitSequence([stackcards[-1], cards[0]])


class Circles_RowStack(SS_RowStack):

    def __init__(self, x, y, game, base_rank, yoffset):
        SS_RowStack.__init__(
            self, x, y, game, base_rank=base_rank,
            max_accept=1, max_move=1)
        self.CARD_YOFFSET = 1


class Triumph_BraidStack(OpenStack):

    def __init__(self, x, y, game, xoffset, yoffset):
        OpenStack.__init__(self, x, y, game)
        self.CARD_YOFFSET = int(self.game.app.images.CARD_YOFFSET * yoffset)
        # use a sine wave for the x offsets
        self.CARD_XOFFSET = []
        j = 1
        for i in range(30):
            self.CARD_XOFFSET.append(int(math.cos(j) * xoffset))
            j = j + .9


class Triumph_StrongStack(ReserveStack):

    def fillStack(self):
        if not self.cards:
            if self.game.s.braidstrong.cards:
                self.game.moveMove(1, self.game.s.braidstrong, self)
            elif self.game.s.braidweak.cards:
                self.game.moveMove(1, self.game.s.braidweak, self)

    def getBottomImage(self):
        return self.game.app.images.getBraidBottom()


class Triumph_WeakStack(ReserveStack):

    def fillStack(self):
        if not self.cards:
            if self.game.s.braidweak.cards:
                self.game.moveMove(1, self.game.s.braidweak, self)
            elif self.game.s.braidstrong.cards:
                self.game.moveMove(1, self.game.s.braidstrong, self)

    def getBottomImage(self):
        return self.game.app.images.getBraidBottom()


class Triumph_ReserveStack(ReserveStack):

    def acceptsCards(self, from_stack, cards):
        if (from_stack is self.game.s.braidstrong or
                from_stack is self.game.s.braidweak or
                from_stack in self.game.s.rows):
            return 0
        return ReserveStack.acceptsCards(self, from_stack, cards)

    def getBottomImage(self):
        return self.game.app.images.getTalonBottom()


# ************************************************************************
#  *
#  ***********************************************************************/

class AbstractMughalGame(Game):

    SUITS = (_("Crown"), _("Silver"), _("Saber"), _("Servant"),
             _("Harp"), _("Gold"), _("Document"), _("Stores"))
    RANKS = (_("Ace"), "2", "3", "4", "5", "6", "7", "8", "9", "10",
             _("Pradhan"), _("Raja"))
    COLORS = (_("Brown"), _("Black"), _("Red"), _("Yellow"),
              _("Green"), _("Grey"), _("Orange"), _("Tan"))
    FORCE = (_("Strong"), _("Weak"))

    def updateText(self):
        pass

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank)


class Triumph_Hint(DefaultHint):
    # FIXME: demo is not too clever in this game
    pass


# ************************************************************************
#  * Mughal Circles
#  ***********************************************************************/

class MughalCircles(AbstractMughalGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        w, h = l.XM + l.XS * 9, l.YM + l.YS * 7
        self.setSize(w, h)

        # Create row stacks
        x = w // 2 - l.CW // 2
        y = h // 2 - l.YS // 2
        x0 = (-1, -.8, 0, .8, 1, .8, 0, -.8,
              -2, -1.9, -1.5, -.8, 0, .8, 1.5, 1.9, 2, 1.9, 1.5, .8,
              0, -.8, -1.5, -1.9)
        y0 = (0, -.8, -1, -.8, 0, .8, 1, .8,
              0, -.8, -1.5, -1.9, -2, -1.9, -1.5, -.8,
              0, .8, 1.5, 1.9, 2, 1.9, 1.5, .8)
        for i in range(24):
            # FIXME:
            _x, _y = x+l.XS*x0[i]+l.XM*x0[i]*2, y+l.YS*y0[i]+l.YM*y0[i]*2
            if _x < 0:
                _x = 0
            if _y < 0:
                _y = 0
            s.rows.append(
                Circles_RowStack(_x, _y, self, base_rank=ANY_RANK, yoffset=0))

        # Create reserve stacks
        s.reserves.append(ReserveStack(l.XM, h - l.YS, self))
        s.reserves.append(ReserveStack(w - l.XS, h - l.YS, self))

        # Create foundations
        x = l.XM
        y = l.YM
        for i in range(4):
            s.foundations.append(
                SS_FoundationStack(
                    x, y, self, i, mod=12,
                    max_move=0, max_cards=12))
            y = y + l.YS
        x = self.width - l.XS
        y = l.YM
        for i in range(4):
            s.foundations.append(
                SS_FoundationStack(
                    x, y, self, i + 4, mod=12,
                    max_move=0, max_cards=12))
            y = y + l.YS
        # FIXME:
        _x1, _x2 = l.XM + l.XS, w - l.XS - l.XM
        for i in s.rows:
            if i.x < _x1:
                i.x = _x1
            elif i.x > _x2:
                i.x = _x2
        self.setRegion(s.rows, (_x1, 0, _x2, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(l.XM + l.XS, l.YM, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 96
        self._startDealNumRowsAndDealRowAndCards(3)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return ((card1.suit == card2.suit) and
                ((card1.rank + 1 == card2.rank) or
                 (card1.rank - 1 == card2.rank)))


# ************************************************************************
#  * Eight Legions
#  ***********************************************************************/

class EightLegions(AbstractMughalGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        self.setSize(l.XM * 3 + l.XS * 9, l.YM + l.YS * 6)

        # Create row stacks
        x = l.XM
        y = l.YM
        for i in range(8):
            s.rows.append(RK_RowStack(x, y, self, base_rank=11,
                                      max_move=12, max_cards=99))
            x = x + l.XS

        # Create reserve stacks
        x = self.width - l.XS
        y = l.YM
        for i in range(6):
            s.reserves.append(ReserveStack(x, y, self))
            y = y + l.YS
        y = y - l.YS
        for i in range(4):
            x = x - l.XS
            s.reserves.append(ReserveStack(x, y, self))

        self.setRegion(s.rows, (0, 0, l.XM + l.XS * 8, l.YS * 5))

        # Create talon
        s.talon = DealRowTalonStack(l.XM, self.height - l.YS, self)
        l.createText(s.talon, "n")

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 96
        self._startDealNumRows(4)
        self.s.talon.dealCards()

    def isGameWon(self):
        if len(self.s.talon.cards):
            return 0
        for s in self.s.rows:
            if len(s.cards) != 12 or not isSameSuitSequence(s.cards):
                return 0
        return 1


# ************************************************************************
#  * Shamsher
#  ***********************************************************************/

class Shamsher(AbstractMughalGame):
    Layout_Method = staticmethod(Layout.ghulamLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = RK_RowStack
    BASE_RANK = ANY_RANK

    #
    # Game layout
    #

    def createGame(self, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=14, reserves=4, texts=0)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=12, max_cards=12))

        # Create reserve stacks
        for r in l.s.reserves:
            s.reserves.append(ReserveStack(r.x, r.y, self, ))

        # Create row stacks
        for r in l.s.rows:
            s.rows.append(
                self.RowStack_Class(
                    r.x, r.y, self, max_cards=12,
                    suit=ANY_SUIT, base_rank=self.BASE_RANK))

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self)

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 96
        self._startDealNumRows(6)
        self.s.talon.dealRow(rows=self.s.rows[:12])
        self.s.talon.dealCards()


# ************************************************************************
#  * Ashrafi
#  ***********************************************************************/

class Ashrafi(Shamsher):
    Layout_Method = staticmethod(Layout.ghulamLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = RK_RowStack
    BASE_RANK = 11

    #
    # Game layout
    #

    def createGame(self, **layout):
        Shamsher.createGame(self)


# ************************************************************************
#  * Ghulam
#  ***********************************************************************/

class Ghulam(Shamsher):
    Layout_Method = staticmethod(Layout.ghulamLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = SS_RowStack
    BASE_RANK = ANY_RANK

    #
    # Game layout
    #

    def createGame(self, **layout):
        Shamsher.createGame(self)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return ((card1.suit == card2.suit) and
                ((card1.rank + 1 == card2.rank) or
                 (card1.rank - 1 == card2.rank)))


# ************************************************************************
#  * Tipati
#  ***********************************************************************/

class Tipati(AbstractMughalGame):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = RK_RowStack
    BASE_RANK = 11
    MAX_MOVE = 0

    #
    # Game layout
    #

    def createGame(self, max_rounds=1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(
            l.s.talon.x, l.s.talon.y, self,
            max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=12, max_cards=12, max_move=self.MAX_MOVE))

        # Create row stacks
        for r in l.s.rows:
            s.rows.append(
                self.RowStack_Class(
                    r.x, r.y, self,
                    suit=ANY_SUIT, base_rank=self.BASE_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 96
        for i in range(8):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()


# ************************************************************************
#  * Ashwapati
#  ***********************************************************************/

class Ashwapati(Tipati):
    RowStack_Class = SS_RowStack
    BASE_RANK = ANY_RANK
    MAX_MOVE = 1

    #
    # Game layout
    #

    def createGame(self, **layout):
        Tipati.createGame(self, max_rounds=-1, num_deal=1)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return ((card1.suit == card2.suit) and
                ((card1.rank + 1 == card2.rank) or
                 (card1.rank - 1 == card2.rank)))


# ************************************************************************
#  * Gajapati
#  ***********************************************************************/

class Gajapati(Tipati):
    RowStack_Class = SS_RowStack
    BASE_RANK = ANY_RANK
    MAX_MOVE = 1

    #
    # Game layout
    #

    def createGame(self, **layout):
        Tipati.createGame(self, max_rounds=-1, num_deal=3)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return ((card1.suit == card2.suit) and
                ((card1.rank + 1 == card2.rank) or
                 (card1.rank - 1 == card2.rank)))


# ************************************************************************
#  * Narpati
#  ***********************************************************************/

class Narpati(Tipati):
    RowStack_Class = AC_RowStack
    MAX_MOVE = 1

    #
    # Game layout
    #

    def createGame(self, **layout):
        Tipati.createGame(self, max_rounds=1, num_deal=1)


# ************************************************************************
#  * Garhpati
#  ***********************************************************************/

class Garhpati(Tipati):
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, **layout):
        Tipati.createGame(self, max_rounds=-1, num_deal=3)


# ************************************************************************
#  * Dhanpati
#  ***********************************************************************/

class Dhanpati(Tipati):

    #
    # Game layout
    #

    def createGame(self, **layout):
        Tipati.createGame(self, max_rounds=2, num_deal=3)


# ************************************************************************
# * Akbar's Triumph
# ************************************************************************

class AkbarsTriumph(AbstractMughalGame):
    Hint_Class = Triumph_Hint

    BRAID_CARDS = 12
    BRAID_OFFSET = 1.1

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (piles up to 20 cards are playable - needed for Braid_BraidStack)
        decks = self.gameinfo.decks
        h = max(5 * l.YS + 35, l.YS + (self.BRAID_CARDS - 1) * l.YOFFSET)
        self.setSize(l.XM + l.XS * (7 + decks * 2), l.YM + h)

        # extra settings
        self.base_card = None

        # Create foundations, rows, reserves
        s.addattr(braidstrong=None)      # register extra stack variable
        s.addattr(braidweak=None)      # register extra stack variable
        x, y = l.XM, l.YM
        for j in range(4):
            for i in range(decks):
                s.foundations.append(
                    Triumph_Foundation(
                        x + l.XS * i, y, self,
                        j, mod=12, max_cards=12))
            s.rows.append(Triumph_StrongStack(x + l.XS * decks, y, self))
            s.rows.append(Triumph_ReserveStack(
                x + l.XS * (1 + decks), y, self))
            y = y + l.YS
        x, y = x + l.XS * (5 + decks), l.YM
        for j in range(4):
            s.rows.append(Triumph_ReserveStack(x, y, self))
            s.rows.append(Triumph_WeakStack(x + l.XS, y, self))
            for i in range(decks, 0, -1):
                s.foundations.append(Triumph_Foundation(
                    x + l.XS * (1 + i), y, self,
                    j + 4, mod=12, max_cards=12))
            y = y + l.YS
        self.texts.info = MfxCanvasText(
            self.canvas,
            self.width // 2, h - l.YM // 2,
            anchor="center",
            font=self.app.getFont("canvas_default"))

        # Create braids
        x, y = l.XM + l.XS * 2.3 + l.XS * decks, l.YM
        s.braidstrong = Triumph_BraidStack(
            x, y, self, xoffset=12, yoffset=self.BRAID_OFFSET)
        x += l.XS * 1.4
        s.braidweak = Triumph_BraidStack(
            x, y, self, xoffset=-12, yoffset=self.BRAID_OFFSET)

        # Create talon
        x, y = l.XM + l.XS * 2 + l.XS * decks, h - l.YS - l.YM
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "s")
        s.talon.texts.rounds = MfxCanvasText(
            self.canvas,
            self.width // 2, h - l.YM * 2.5,
            anchor="center",
            font=self.app.getFont("canvas_default"))
        x += l.XS * 2
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")

        # define stack-groups
        self.sg.talonstacks = [s.talon] + [s.waste]
        self.sg.openstacks = s.foundations + s.rows
        self.sg.dropstacks = [s.braidstrong] + [s.braidweak] + s.rows \
            + [s.waste]

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        self.base_card = None
        self.updateText()
        for i in range(self.BRAID_CARDS):
            self.s.talon.dealRow(rows=[self.s.braidstrong])
        for i in range(self.BRAID_CARDS):
            self.s.talon.dealRow(rows=[self.s.braidweak])
        self.s.talon.dealRow()
        # deal base_card to foundations, update cap.base_rank
        self.base_card = self.s.talon.getCard()
        to_stack = self.s.foundations[
            self.base_card.suit * self.gameinfo.decks]
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, to_stack)
        self.updateText()
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        # deal first card to WasteStack
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                ((card1.rank + 1) % 12 == card2.rank or
                 (card2.rank + 1) % 12 == card1.rank))

    def getHighlightPilesStacks(self):
        return ()

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)

    #
    # game extras
    #

    def updateText(self):
        if self.preview > 1 or not self.texts.info:
            return
        if not self.base_card:
            t = ""
        else:
            t = self.RANKS[self.base_card.rank]
            dir = self.getFoundationDir() % 12
            if dir == 1:
                t = t + _(" Ascending")
            elif dir == 11:
                t = t + _(" Descending")
        self.texts.info.config(text=t)


# ************************************************************************
# * Akbar's Conquest
# ************************************************************************

class AkbarsConquest(AkbarsTriumph):

    BRAID_CARDS = 16
    BRAID_OFFSET = .9


# ************************************************************************
# *
# ************************************************************************

class Vajra(AbstractMughalGame):
    RowStack_Class = StackWrapper(Mughal_RK_RowStack, base_rank=NO_RANK)

    #
    # game layout
    #

    def createGame(self, rows=9, reserves=8):
        # create layout
        l, s = Layout(self), self.s

        # set size
        maxrows = max(rows, reserves)
        self.setSize(l.XM + (maxrows + 2) * l.XS, l.YM + 6 * l.YS)

        #
        playcards = 4 * l.YS // l.YOFFSET
        xoffset, yoffset = [], []
        for i in range(playcards):
            xoffset.append(0)
            yoffset.append(l.YOFFSET)
        for i in range(96 * self.gameinfo.decks - playcards):
            xoffset.append(l.XOFFSET)
            yoffset.append(0)

        # create stacks
        x, y = l.XM + (maxrows - reserves) * l.XS // 2, l.YM
        for i in range(reserves):
            s.reserves.append(ReserveStack(x, y, self))
            x = x + l.XS
        x, y = l.XM + (maxrows - rows) * l.XS // 2, l.YM + l.YS
        self.setRegion(s.reserves, (-999, -999, 999999, y - l.YM // 2))
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self, yoffset=l.YOFFSET)
            stack.CARD_XOFFSET = xoffset
            stack.CARD_YOFFSET = yoffset
            s.rows.append(stack)
            x = x + l.XS
        x, y = l.XM + maxrows * l.XS, l.YM
        for i in range(2):
            for suit in range(4):
                s.foundations.append(
                    SS_FoundationStack(x, y, self, suit=suit+(4 * i)))
                y = y + l.YS
            x, y = x + l.XS, l.YM
        self.setRegion(self.s.foundations, (x - l.XS * 2, -999, 999999,
                       self.height - (l.YS + l.YM)), priority=1)
        s.talon = InitialDealTalonStack(
            self.width - 3 * l.XS // 2, self.height - l.YS, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        i = 0
        while self.s.talon.cards:
            if self.s.talon.cards[-1].rank == 11:
                if self.s.rows[i].cards:
                    i = i + 1
            self.s.talon.dealRow(rows=[self.s.rows[i]], frames=4)

    # must look at cards
    def _getClosestStack(self, cx, cy, stacks, dragstack):
        closest, cdist = None, 999999999
        for stack in stacks:
            if stack.cards and stack is not dragstack:
                dist = (stack.cards[-1].x - cx)**2 + \
                    (stack.cards[-1].y - cy)**2
            else:
                dist = (stack.x - cx)**2 + (stack.y - cy)**2
            if dist < cdist:
                closest, cdist = stack, dist
        return closest

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isRankSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# *
# ************************************************************************

class Danda(Vajra):
    RowStack_Class = StackWrapper(Mughal_AF_RowStack, base_rank=NO_RANK)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isAlternateForceSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# *
# ************************************************************************

class Khadga(Vajra):
    RowStack_Class = StackWrapper(Mughal_AC_RowStack, base_rank=NO_RANK)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isAlternateColorSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# *
# ************************************************************************

class Makara(Vajra):
    RowStack_Class = StackWrapper(Mughal_SS_RowStack, base_rank=NO_RANK)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isSuitSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# * Ashta Dikapala Game Stacks
# ************************************************************************

class Dikapala_TableauStack(Mughal_OpenStack):

    def __init__(self, x, y, game, base_rank, yoffset, **cap):
        kwdefault(cap, dir=3, max_move=99, max_cards=4, max_accept=1,
                  base_rank=base_rank)
        OpenStack.__init__(self, x, y, game, **cap)
        self.CARD_YOFFSET = yoffset

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        # check that the base card is correct
        if self.cards and self.cards[0].rank != self.cap.base_rank:
            return 0
        if not self.cards:
            return cards[0].rank == self.cap.base_rank
        return (self.cards[-1].suit == cards[0].suit and
                self.cards[-1].rank + self.cap.dir == cards[0].rank)

    def getBottomImage(self):
        return self.game.app.images.getLetter(self.cap.base_rank)


class Dikapala_ReserveStack(ReserveStack):

    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_cards=1, max_accept=1, base_rank=ANY_RANK)
        OpenStack.__init__(self, x, y, game, **cap)

    def acceptsCards(self, from_stack, cards):
        return (ReserveStack.acceptsCards(self, from_stack, cards) and
                self.game.s.talon.cards)


class Dikapala_RowStack(BasicRowStack):

    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return 0
        # check
        return not (self.cards or self.game.s.talon.cards)

    def canMoveCards(self, cards):
        return 1

    def getBottomImage(self):
        return self.game.app.images.getTalonBottom()


# ************************************************************************
# * Dikapala Hint
# ************************************************************************

class Dikapala_Hint(AbstractHint):
    def computeHints(self):
        game = self.game

        # 2)See if we can move a card to the tableaux
        if not self.hints:
            for r in game.sg.dropstacks:
                pile = r.getPile()
                if not pile or len(pile) != 1:
                    continue
                if r in game.s.tableaux:
                    rr = self.ClonedStack(r, stackcards=r.cards[:-1])
                    if rr.acceptsCards(None, pile):
                        # do not move a card that is already in correct place
                        continue
                    base_score = 80000 + (4 - r.cap.base_suit)
                else:
                    base_score = 80000
                # find a stack that would accept this card
                for t in game.s.tableaux:
                    if t is not r and t.acceptsCards(r, pile):
                        score = base_score + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 3)See if we can move a card from the tableaux
        #    to a row stack. This can only happen if there are
        #    no more cards to deal.
        if not self.hints:
            for r in game.s.tableaux:
                pile = r.getPile()
                if not pile or len(pile) != 1:
                    continue
                rr = self.ClonedStack(r, stackcards=r.cards[:-1])
                if rr.acceptsCards(None, pile):
                    # do not move a card that is already in correct place
                    continue
                # find a stack that would accept this card
                for t in game.s.rows:
                    if t is not r and t.acceptsCards(r, pile):
                        score = 70000 + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 4)See if we can move a card within the row stacks
        if not self.hints:
            for r in game.s.rows:
                pile = r.getPile()
                if not pile or len(pile) != 1 or len(pile) == len(r.cards):
                    continue
                base_score = 60000
                # find a stack that would accept this card
                for t in game.s.rows:
                    if t is not r and t.acceptsCards(r, pile):
                        score = base_score + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 5)See if we can deal cards
        if self.level >= 2:
            if game.canDealCards():
                self.addHint(self.SCORE_DEAL, 0, game.s.talon, None)


# ************************************************************************
# * Ashta Dikapala
# ************************************************************************

class AshtaDikapala(Game):
    Hint_Class = Dikapala_Hint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        TABLEAU_YOFFSET = min(9, max(3, l.YOFFSET // 3))

        # set window
        th = l.YS + 3 * TABLEAU_YOFFSET
        # (set piles so that at least 2/3 of a card is visible with 10 cards)
        h = 8 * l.YOFFSET + l.CH * 2//3
        self.setSize(9 * l.XS + l.XM * 2, l.YM + 3 * th + l.YM + h)

        # create stacks
        s.addattr(tableaux=[])     # register extra stack variable
        x = l.XM + 8 * l.XS + l.XS // 2
        y = l.YM
        for i in range(3, 0, -1):
            x = l.XM
            for j in range(8):
                s.tableaux.append(
                    Dikapala_TableauStack(
                        x, y, self, i - 1, TABLEAU_YOFFSET))
                x = x + l.XS
            x = x + l.XM
            s.reserves.append(Dikapala_ReserveStack(x, y, self))
            y = y + th
        x, y = l.XM, y + l.YM
        for i in range(8):
            s.rows.append(Dikapala_RowStack(x, y, self, max_accept=1))
            x = x + l.XS
        x = self.width - l.XS
        y = self.height - l.YS
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, "sw")

        # define stack-groups
        self.sg.openstacks = s.tableaux + s.rows + s.reserves
        self.sg.talonstacks = [s.talon]
        self.sg.dropstacks = s.tableaux + s.rows

    #
    # game overrides
    #

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.tableaux, frames=0)
        self._startAndDealRow()

    def isGameWon(self):
        for stack in self.s.tableaux:
            if len(stack.cards) != 4:
                return 0
        return 1

    def fillStack(self, stack):
        if self.s.talon.cards:
            if stack in self.s.rows and len(stack.cards) == 0:
                self.s.talon.dealRow(rows=[stack])

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                (card1.rank + 3 == card2.rank or card2.rank + 3 == card1.rank))

    def getHighlightPilesStacks(self):
        return ()


# ************************************************************************
# *
# ************************************************************************

def r(id, gameclass, name, game_type, decks, redeals, skill_level):
    game_type = game_type | GI.GT_MUGHAL_GANJIFA
    gi = GameInfo(id, gameclass, name, game_type, decks, redeals, skill_level,
                  suits=list(range(8)), ranks=list(range(12)))
    registerGame(gi)
    return gi


r(14401, MughalCircles, 'Mughal Circles', GI.GT_MUGHAL_GANJIFA, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(14402, Ghulam, 'Ghulam', GI.GT_MUGHAL_GANJIFA, 1, 0, GI.SL_MOSTLY_SKILL)
r(14403, Shamsher, 'Shamsher', GI.GT_MUGHAL_GANJIFA, 1, 0, GI.SL_MOSTLY_SKILL)
r(14404, EightLegions, 'Eight Legions', GI.GT_MUGHAL_GANJIFA, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(14405, Ashrafi, 'Ashrafi', GI.GT_MUGHAL_GANJIFA, 1, 0, GI.SL_MOSTLY_SKILL)
r(14406, Tipati, 'Tipati', GI.GT_MUGHAL_GANJIFA, 1, 0, GI.SL_BALANCED)
r(14407, Ashwapati, 'Ashwapati', GI.GT_MUGHAL_GANJIFA, 1, -1, GI.SL_BALANCED)
r(14408, Gajapati, 'Gajapati', GI.GT_MUGHAL_GANJIFA, 1, -1, GI.SL_BALANCED)
r(14409, Narpati, 'Narpati', GI.GT_MUGHAL_GANJIFA, 1, 0, GI.SL_BALANCED)
r(14410, Garhpati, 'Garhpati', GI.GT_MUGHAL_GANJIFA, 1, -1, GI.SL_BALANCED)
r(14411, Dhanpati, 'Dhanpati', GI.GT_MUGHAL_GANJIFA, 1, 1, GI.SL_BALANCED)
r(14412, AkbarsTriumph, 'Akbar\'s Triumph', GI.GT_MUGHAL_GANJIFA, 1, 2,
  GI.SL_BALANCED)
r(14413, AkbarsConquest, 'Akbar\'s Conquest', GI.GT_MUGHAL_GANJIFA, 2, 2,
  GI.SL_BALANCED)
r(16000, Vajra, 'Vajra', GI.GT_MUGHAL_GANJIFA, 1, 0, GI.SL_MOSTLY_SKILL)
r(16001, Danda, 'Danda', GI.GT_MUGHAL_GANJIFA, 1, 0, GI.SL_MOSTLY_SKILL)
r(16002, Khadga, 'Khadga', GI.GT_MUGHAL_GANJIFA, 1, 0, GI.SL_MOSTLY_SKILL)
r(16003, Makara, 'Makara', GI.GT_MUGHAL_GANJIFA, 1, 0, GI.SL_MOSTLY_SKILL)
r(16004, AshtaDikapala, 'Ashta Dikapala', GI.GT_MUGHAL_GANJIFA, 1, 0,
  GI.SL_BALANCED)

del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
from . import dashavatara  # noqa: F401
from . import hanafuda  # noqa: F401
from . import hanafuda1  # noqa: F401
from . import hexadeck  # noqa: F401
from . import larasgame  # noqa: F401
from . import matrix  # noqa: F401
from . import mughal  # noqa: F401
from . import tarock  # noqa: F401
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import math

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.pysoltk import bind
from pysollib.stack import \
        InitialDealTalonStack, \
        OpenStack
from pysollib.util import ANY_RANK

# ************************************************************************
# * Matrix Row Stack
# ************************************************************************


class Matrix_RowStack(OpenStack):

    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=1, max_accept=1, max_cards=1,
                  base_rank=ANY_RANK)
        OpenStack.__init__(self, x, y, game, **cap)

    def canFlipCard(self):
        return 0

    def canDropCards(self, stacks):
        return (None, 0)

    def cancelDrag(self, event=None):
        if event is None:
            self._stopDrag()

    def _findCard(self, event):
        # we need to override this because the shade may be hiding
        # the tile (from Tk's stacking view)
        return len(self.cards) - 1

    def initBindings(self):
        bind(self.group, "<1>", self._Stack__clickEventHandler)
        bind(self.group, "<Control-1>", self._Stack__controlclickEventHandler)

    def getBottomImage(self):
        return self.game.app.images.getBlankBottom()

    def blockMap(self):
        ncards = self.game.gameinfo.ncards
        id, sqrt = self.id, int(math.sqrt(ncards))
        line, row, column = int(id / sqrt), [], []
        for r in self.game.s.rows[line * sqrt:sqrt + line * sqrt]:
            row.append(r.id)
        while id >= sqrt:
            id = id - sqrt
        while id < ncards:
            column.append(id)
            id = id + sqrt
        return [row, column]

    def basicIsBlocked(self):
        stack_map = self.blockMap()
        for j in range(2):
            for i in range(len(stack_map[j])):
                if not self.game.s.rows[stack_map[j][i]].cards:
                    return 0
        return 1

    def clickHandler(self, event):
        game = self.game
        row = game.s.rows
        if not self.cards or game.drag.stack is self or self.basicIsBlocked():
            return 1
        game.playSample("move", priority=10)
        stack_map = self.blockMap()
        for j in range(2):
            dir = 1
            for i in range(len(stack_map[j])):
                to_stack = row[stack_map[j][i]]
                if to_stack is self:
                    dir = -1
                if not to_stack.cards:
                    self._stopDrag()
                    step = 1
                    from_stack = row[stack_map[j][i + dir]]
                    while from_stack is not self:
                        from_stack.playMoveMove(
                            1, to_stack, frames=0, sound=False)
                        to_stack = from_stack
                        step = step + 1
                        from_stack = row[stack_map[j][i + dir * step]]
                    self.playMoveMove(1, to_stack, frames=0, sound=False)
                    return 1
        return 1


# ************************************************************************
# * Matrix Game
# ************************************************************************

class Matrix3(Game):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s
        grid = math.sqrt(self.gameinfo.ncards)
        assert grid == int(grid)
        grid = int(grid)

        # Set window size
        w, h = l.XM * 2 + l.CW * grid, l.YM * 2 + l.CH * grid
        self.setSize(w, h)

        # Create rows
        for j in range(grid):
            x, y = l.XM, l.YM + l.CH * j
            for i in range(grid):
                s.rows.append(Matrix_RowStack(x, y, self))
                x = x + l.CW

        # Create talon
        x, y = -2*l.XS, 0               # invisible
        s.talon = InitialDealTalonStack(x, y, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game extras
    #

    def _shuffleHook(self, cards):
        # create solved game
        ncards = len(cards)-1
        for c in cards:
            if c.rank == ncards:
                cards.remove(c)
                break
        n = 0
        for i in range(ncards-1):
            for j in range(i+1, ncards):
                if cards[i].rank > cards[j].rank:
                    n += 1
        cards.reverse()
        if n % 2:
            cards[0], cards[1] = cards[1], cards[0]
        return [c]+cards

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == self.gameinfo.ncards
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[:self.gameinfo.ncards - 1],
                             frames=3)

    def isGameWon(self):
        if self.busy:
            return 0
        s = self.s.rows
        mylen = len(s) - 1
        for r in s[:mylen]:
            if not r.cards or not r.cards[0].rank == r.id:
                return 0
        self.s.talon.dealRow(rows=s[mylen:], frames=0)
        return 1

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return ((card1.rank + 1 == card2.rank) or
                (card1.rank - 1 == card2.rank))


# ************************************************************************
# * Size variations
# ************************************************************************

class Matrix4(Matrix3):
    pass


class Matrix5(Matrix3):
    pass


class Matrix6(Matrix3):
    pass


class Matrix7(Matrix3):
    pass


class Matrix8(Matrix3):
    pass


class Matrix9(Matrix3):
    pass


class Matrix10(Matrix3):
    pass


class Matrix20(Matrix3):
    pass


# ************************************************************************
# * Register a Matrix game
# ************************************************************************

def r(id, gameclass, short_name):
    name = short_name
    ncards = int(name[:2]) * int(name[:2])
    gi = GameInfo(
        id, gameclass, name,
        GI.GT_MATRIX, 1, 0, GI.SL_SKILL,
        category=GI.GC_TRUMP_ONLY, short_name=short_name,
        suits=(), ranks=(), trumps=list(range(ncards)),
        si={"decks": 1, "ncards": ncards})
    gi.ncards = ncards
    gi.rules_filename = "matrix.html"
    registerGame(gi)
    return gi


r(22223, Matrix3, " 3x3 Matrix")
r(22224, Matrix4, " 4x4 Matrix")
r(22225, Matrix5, " 5x5 Matrix")
r(22226, Matrix6, " 6x6 Matrix")
r(22227, Matrix7, " 7x7 Matrix")
r(22228, Matrix8, " 8x8 Matrix")
r(22229, Matrix9, " 9x9 Matrix")
r(22230, Matrix10, "10x10 Matrix")
# r(22240, Matrix20, "20x20 Matrix")

del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# Imports
import math

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import CautiousDefaultHint, DefaultHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        AC_RowStack, \
        AbstractFoundationStack, \
        InitialDealTalonStack, \
        OpenStack, \
        ReserveStack, \
        SS_FoundationStack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ANY_RANK, ANY_SUIT, NO_RANK, UNLIMITED_ACCEPTS, \
        UNLIMITED_MOVES

# ************************************************************************
# * Hex A Deck Foundation Stacks
# ************************************************************************


class HexADeck_FoundationStack(SS_FoundationStack):
    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, max_move=0, max_cards=12)
        SS_FoundationStack.__init__(self, x, y, game, suit, **cap)


class HexATrump_Foundation(HexADeck_FoundationStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        for s in self.game.s.foundations[:3]:
            if len(s.cards) != 16:
                return 0
        return 1


class Merlins_Foundation(AbstractFoundationStack):
    def __init__(self, x, y, game, suit, **cap):
        kwdefault(cap, mod=16, dir=0, base_rank=NO_RANK, max_move=0)
        AbstractFoundationStack.__init__(self, x, y, game, suit, **cap)

    def acceptsCards(self, from_stack, cards):
        if not AbstractFoundationStack.acceptsCards(self, from_stack, cards):
            return 0
        if not self.cards:
            return 1
        stack_dir = self.game.getFoundationDir()
        if stack_dir == 0:
            card_dir = (cards[0].rank - self.cards[-1].rank) % self.cap.mod
            return card_dir in (1, 15)
        else:
            return (self.cards[-1].rank + stack_dir) % self.cap.mod \
                == cards[0].rank


# ************************************************************************
# * Hex A Deck Row Stacks
# ************************************************************************

class HexADeck_OpenStack(OpenStack):

    def __init__(self, x, y, game, yoffset, **cap):
        kwdefault(cap, max_move=UNLIMITED_MOVES, max_accept=UNLIMITED_ACCEPTS,
                  dir=-1)
        OpenStack.__init__(self, x, y, game, **cap)
        self.CARD_YOFFSET = yoffset

    def isRankSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        for c2 in cards[1:]:
            if not c1.rank + dir == c2.rank:
                return 0
            c1 = c2
        return 1

    def isAlternateColorSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        for c2 in cards[1:]:
            if (c1.color < 2 and c1.color == c2.color or
                    not c1.rank + dir == c2.rank):
                return 0
            c1 = c2
        return 1

    def isSuitSequence(self, cards, dir=None):
        if not dir:
            dir = self.cap.dir
        c1 = cards[0]
        for c2 in cards[1:]:
            if not ((c1.color == 2 or c2.color == 2 or c1.suit == c2.suit) and
                    c1.rank + dir == c2.rank):
                return 0
            c1 = c2
        return 1


class HexADeck_RK_RowStack(HexADeck_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if (not self.basicAcceptsCards(from_stack, cards) or
                not self.isRankSequence(cards)):
            return 0
        if not self.cards:
            return cards[0].rank == 15 or self.cap.base_rank == ANY_RANK
        return self.isRankSequence([self.cards[-1], cards[0]])

    def canMoveCards(self, cards):
        return (self.basicCanMoveCards(cards) and self.isRankSequence(cards))


class HexADeck_AC_RowStack(HexADeck_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if (not self.basicAcceptsCards(from_stack, cards) or
                not self.isAlternateColorSequence(cards)):
            return 0
        if not self.cards:
            return cards[0].rank == 15 or self.cap.base_rank == ANY_RANK
        return self.isAlternateColorSequence([self.cards[-1], cards[0]])

    def canMoveCards(self, cards):
        return (self.basicCanMoveCards(cards) and
                self.isAlternateColorSequence(cards))


class HexADeck_SS_RowStack(HexADeck_OpenStack):

    def acceptsCards(self, from_stack, cards):
        if (not self.basicAcceptsCards(from_stack, cards) or
                not self.isSuitSequence(cards)):
            return 0
        if not self.cards:
            return cards[0].rank == 15 or self.cap.base_rank == ANY_RANK
        return self.isSuitSequence([self.cards[-1], cards[0]])

    def canMoveCards(self, cards):
        return (self.basicCanMoveCards(cards) and self.isSuitSequence(cards))


class Bits_RowStack(ReserveStack):

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if stackcards or cards[0].suit == 4:
            return 0
        i = int(self.id // 4)
        for r in self.game.s.rows[i * 4:self.id]:
            if not r.cards:
                return 0
        return ((self.game.s.foundations[i].cards[-1].rank + 1 >>
                 (self.id % 4)) % 2 == (cards[0].rank + 1) % 2)


class Bytes_RowStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if stackcards or cards[0].suit == 4:
            return 0
        id = self.id - 16
        i = int(id // 2)
        for r in self.game.s.rows[16 + i * 2:self.id]:
            if not r.cards:
                return 0
        return self.game.s.foundations[i].cards[-1].rank == cards[0].rank


class HexAKlon_RowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if stackcards:
            if (stackcards[-1].suit == 4 or cards[0].suit == 4):
                return 1
        return AC_RowStack.acceptsCards(self, from_stack, cards)


class HexADeck_ACRowStack(AC_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        stackcards = self.cards
        if stackcards:
            if (stackcards[-1].suit == 4 or cards[0].suit == 4):
                return stackcards[-1].rank == cards[0].rank + 1
        return AC_RowStack.acceptsCards(self, from_stack, cards)


class Familiar_ReserveStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if not ReserveStack.acceptsCards(self, from_stack, cards):
            return 0
        # Only take Wizards
        return cards[0].suit == 4

    def getBottomImage(self):
        return self.game.app.images.getSuitBottom(4)


class Merlins_BraidStack(OpenStack):
    def __init__(self, x, y, game):
        OpenStack.__init__(self, x, y, game)
        self.CARD_YOFFSET = self.game.app.images.CARD_YOFFSET
        # use a sine wave for the x offsets
        self.CARD_XOFFSET = []
        j = 1
        for i in range(20):
            self.CARD_XOFFSET.append(int(math.sin(j) * 20))
            j = j + .9


class Merlins_RowStack(ReserveStack):
    def fillStack(self):
        if not self.cards and self.game.s.braid.cards:
            self.game.moveMove(1, self.game.s.braid, self)

    def getBottomImage(self):
        return self.game.app.images.getBraidBottom()


class Merlins_ReserveStack(ReserveStack):
    def acceptsCards(self, from_stack, cards):
        if from_stack is self.game.s.braid or from_stack in self.game.s.rows:
            return 0
        return ReserveStack.acceptsCards(self, from_stack, cards)

    def getBottomImage(self):
        return self.game.app.images.getTalonBottom()


# ************************************************************************
# *
# ************************************************************************

class AbstractHexADeckGame(Game):
    RANKS = (_("Ace"), "2", "3", "4", "5", "6", "7", "8", "9",
             "A", "B", "C", "D", "E", "F", "10")


class Merlins_Hint(DefaultHint):
    pass


# ************************************************************************
# * Bits n Bytes
# ************************************************************************

class BitsNBytes(Game):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s
        font = self.app.getFont("canvas_default")

        # Set window size
        self.setSize(l.XM * 4 + l.XS * 8, l.YM + l.YS * 4)

        # Create bit stacks
        self.bit_texts = []
        y = l.YM
        for j in range(4):
            x = l.XM * 4 + l.XS * 7
            for i in range(4):
                stack = Bits_RowStack(x, y, self, max_cards=1, max_accept=1,
                                      base_suit=j, max_move=0)
                s.rows.append(stack)
                stack.texts.misc = MfxCanvasText(self.canvas,
                                                 x + l.CW // 2, y + l.CH // 2,
                                                 anchor="center", font=font)
                x = x - l.XS
            y = y + l.YS

        # Create byte stacks
        y = l.YM
        for j in range(4):
            x = l.XM * 3 + l.XS * 3
            for i in range(2):
                s.rows.append(
                    Bytes_RowStack(
                        x, y, self, max_cards=1,
                        max_accept=1, base_suit=ANY_SUIT, max_move=0))
                x = x - l.XS
            y = y + l.YS

        # Create foundations
        x = l.XM * 2 + l.XS
        y = l.YM
        for i in range(4):
            s.foundations.append(
                SS_FoundationStack(
                    x, y, self, i, mod=1,
                    max_move=0, max_cards=1))
            y = y + l.YS
        self.setRegion(s.rows, (0, 0, 999999, 999999))

        # Create talon
        x = l.XM
        y = l.YM
        s.talon = WasteTalonStack(x, y, self, num_deal=2, max_rounds=2)
        l.createText(s.talon, "s")
        y += l.YS + l.TEXT_HEIGHT
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")

        # Define stack groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def updateText(self):
        if self.preview > 1:
            return
        for j in range(4):
            if not len(self.s.foundations[j].cards):
                break
            s = self.s.foundations[j].cards[-1].rank + 1
            for i in range(4):
                stack = self.s.rows[i + j * 4]
                stack.texts.misc.config(text=str(s % 2))
                s = int(s // 2)

    def _shuffleHook(self, cards):
        topcards, ranks = [None] * 4, [None] * 4
        for c in cards[:]:
            if not c.suit == 4:
                if not topcards[c.suit]:
                    haverank = 0
                    for i in range(4):
                        if c.rank == ranks[i]:
                            haverank = 1
                    if not haverank:
                        topcards[c.suit] = c
                        ranks[c.suit] = c.rank
                        cards.remove(c)
        cards = topcards + cards
        cards.reverse()
        return cards

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.foundations)
        self.s.talon.dealCards()

    def isGameWon(self):
        for s in self.s.rows:
            if not s.cards:
                return 0
        return 1

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return 0


# ************************************************************************
# * Hex A Klon
# ************************************************************************

class HexAKlon(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = HexAKlon_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=-1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(
            l.s.talon.x, l.s.talon.y, self,
            max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations[:4]:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))
        r = l.s.foundations[4]
        s.foundations.append(
            HexATrump_Foundation(
                r.x, r.y, self, 4, mod=4,
                max_move=0, max_cards=4, base_rank=ANY_RANK))

        # Create rows
        for r in l.s.rows:
            s.rows.append(
                self.RowStack_Class(
                    r.x, r.y, self,
                    suit=ANY_SUIT, base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Hex A Klon by Threes
# ************************************************************************

class HexAKlonByThrees(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = HexAKlon_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=-1, num_deal=3, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(
            l.s.talon.x, l.s.talon.y, self,
            max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations[:4]:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))
        r = l.s.foundations[4]
        s.foundations.append(
            HexATrump_Foundation(
                r.x, r.y, self, 4, mod=4,
                max_move=0, max_cards=4, base_rank=ANY_RANK))

        # Create rows
        for r in l.s.rows:
            s.rows.append(
                self.RowStack_Class(
                    r.x, r.y, self,
                    suit=ANY_SUIT, base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * King Only Hex A Klon
# ************************************************************************

class KingOnlyHexAKlon(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = HexAKlon_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=-1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations[:4]:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))
        r = l.s.foundations[4]
        s.foundations.append(
            HexATrump_Foundation(
                r.x, r.y, self, 4, mod=4,
                max_move=0, max_cards=4, base_rank=ANY_RANK))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT, base_rank=15))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def _shuffleHook(self, cards):
        basecard = [None]
        for c in cards[:]:
            if c.suit == 4:
                if basecard[0] is None:
                    basecard[0] = c
                    cards.remove(c)
        cards = basecard + cards
        cards.reverse()
        return cards

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Klondike Plus 16
# ************************************************************************

class KlondikePlus16(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = HexAKlon_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT, base_rank=15))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * The Familiar
# ************************************************************************

class TheFamiliar(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT, base_rank=15))

        # Create reserve
        x, y = l.XM, self.height - l.YS
        s.reserves.append(Familiar_ReserveStack(x, y, self, max_cards=3))
        self.setRegion(
            s.reserves, (-999, y - l.YM, x + l.XS, 999999), priority=1)
        l.createText(s.reserves[0], "se")

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Two Familiars
# ************************************************************************

class TwoFamiliars(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=12, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT, base_rank=15))

        # Create reserve
        x, y = l.XM, self.height - l.YS
        s.reserves.append(Familiar_ReserveStack(x, y, self, max_cards=3))
        self.setRegion(
            s.reserves, (-999, y - l.YM, x + l.XS, 999999), priority=1)
        l.createText(s.reserves[0], "se")

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68 * 2
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Ten by Eight
# ************************************************************************

class TenByEight(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.gypsyLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=-1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=10, waste=1, playcards=30)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68 * 2
        frames = 0
        for i in range(8):
            if i == 5:
                frames = -1
                self.startDealSample()
            self.s.talon.dealRow(frames=frames)
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Drawbridge
# ************************************************************************

class Drawbridge(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.harpLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=7, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows) - 1):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Double Drawbridge
# ************************************************************************

class DoubleDrawbridge(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.harpLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=10, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(
                self.RowStack_Class(
                    r.x, r.y, self,
                    suit=ANY_SUIT, base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68 * 2
        for i in range(len(self.s.rows) - 1):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Hidden Passages
# ************************************************************************

class HiddenPassages(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=7, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations[:4]:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))
        r = l.s.foundations[4]
        s.foundations.append(
            HexATrump_Foundation(
                r.x, r.y, self, 4, mod=4,
                max_move=0, max_cards=4, base_rank=ANY_RANK))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #
    def _shuffleHook(self, cards):
        topcards = [None] * 4
        for c in cards[:]:
            if c.rank == 0 and not c.suit == 4:
                topcards[c.suit] = c
                cards.remove(c)
        cards = topcards + cards
        cards.reverse()
        return cards

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        self.s.talon.dealRow(rows=self.s.foundations[:4], frames=0)
        for i in range(2):
            self.s.talon.dealRow(flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Cluitjar's Lair
# ************************************************************************

class CluitjarsLair(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = HexADeck_ACRowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=7, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations[:4]:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))
        r = l.s.foundations[4]
        s.foundations.append(
            HexATrump_Foundation(
                r.x, r.y, self, 4, mod=4,
                max_move=0, max_cards=4, base_rank=ANY_RANK))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #
    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(2):
            self.s.talon.dealRow(flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Merlin's Meander
# ************************************************************************

class MerlinsMeander(AbstractHexADeckGame):
    Hint_Class = Merlins_Hint
    MERLINS_CARDS = 20

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (piles up to 20 cards are playable - needed for Braid_BraidStack)
        h = max(4*l.YS + 30, l.YS+(self.MERLINS_CARDS-1)*l.YOFFSET)
        self.setSize(10*l.XS+l.XM, l.YM + h)

        # extra settings
        self.base_card = None

        # Create rows, reserves
        s.addattr(braid=None)      # register extra stack variable
        x, y = l.XM, l.YM
        for i in range(2):
            s.rows.append(Merlins_RowStack(x + l.XS * 0.5, y, self))
            s.rows.append(Merlins_RowStack(x + l.XS * 4.5, y, self))
            s.reserves.append(
                Familiar_ReserveStack(x + l.XS * 6.5, y, self, max_cards=3))
            y = y + l.YS * 3
        y = l.YM + l.YS
        for i in range(2):
            s.rows.append(Merlins_ReserveStack(x, y, self))
            s.rows.append(Merlins_ReserveStack(x + l.XS, y, self))
            s.rows.append(Merlins_ReserveStack(x, y + l.YS, self))
            s.rows.append(Merlins_ReserveStack(x + l.XS, y + l.YS, self))
            x = x + l.XS * 4

        # Create braid
        x, y = l.XM + l.XS * 2.2, l.YM
        s.braid = Merlins_BraidStack(x, y, self)

        # Create talon, waste
        x, y = l.XM + l.XS * 7, l.YM + l.YS * 1.5
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "s")
        s.talon.texts.rounds = MfxCanvasText(
            self.canvas,
            x + l.CW // 2, y - l.YM,
            anchor="s",
            font=self.app.getFont("canvas_default"))
        x -= l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")

        # Create foundations
        x, y = l.XM + l.XS * 8, l.YM
        for i in range(4):
            s.foundations.append(
                Merlins_Foundation(
                    x, y, self, i, mod=16,
                    max_cards=16, base_rank=ANY_RANK))
            s.foundations.append(
                Merlins_Foundation(
                    x + l.XS, y, self, i, mod=16,
                    max_cards=16, base_rank=ANY_RANK))
            y = y + l.YS
        self.texts.info = MfxCanvasText(
            self.canvas,
            x + l.CW + l.XM // 2, y,
            anchor="n",
            font=self.app.getFont("canvas_default"))

        # define stack-groups
        self.sg.talonstacks = [s.talon] + [s.waste]
        self.sg.openstacks = s.foundations + s.rows + s.reserves
        self.sg.dropstacks = [s.braid] + s.rows + [s.waste] + s.reserves

    #
    # game overrides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68 * 2
        self.startDealSample()
        self.base_card = None
        self.updateText()
        for i in range(self.MERLINS_CARDS):
            self.s.talon.dealRow(rows=[self.s.braid])
        self.s.talon.dealRow()
        # deal base_card to foundations, update cap.base_rank
        self.base_card = self.s.talon.getCard()
        while self.base_card.suit == 4:
            self.s.talon.cards.remove(self.base_card)
            self.s.talon.cards.insert(0, self.base_card)
            self.base_card = self.s.talon.getCard()
        to_stack = self.s.foundations[2 * self.base_card.suit]
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, to_stack)
        self.updateText()
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        # deal first card to WasteStack
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                ((card1.rank + 1) % 16 == card2.rank or
                 (card2.rank + 1) % 16 == card1.rank))

    def getHighlightPilesStacks(self):
        return ()

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)

    #
    # game extras
    #

    def updateText(self):
        if self.preview > 1 or not self.texts.info:
            return
        if not self.base_card:
            t = ""
        else:
            t = self.RANKS[self.base_card.rank]
            dir = self.getFoundationDir() % 16
            if dir == 1:
                t = t + _(" Ascending")
            elif dir == 15:
                t = t + _(" Descending")
        self.texts.info.config(text=t)

    def isGameWon(self):
        for s in self.s.rows:
            if s.cards and s.cards[0].suit != 4:
                return 0
        if not len(self.s.talon.cards) and len(self.s.waste.cards) == 1:
            return self.s.waste.cards[0].suit == 4
        return len(self.s.talon.cards) + len(self.s.waste.cards) == 0


# ************************************************************************
# * Mage's Game
# ************************************************************************

class MagesGame(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.gypsyLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=12, texts=0, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        self._startDealNumRows(4)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.rows[2:10])
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# *
# ************************************************************************

class Convolution(AbstractHexADeckGame):
    RowStack_Class = StackWrapper(HexADeck_RK_RowStack, base_rank=NO_RANK)

    #
    # game layout
    #

    def createGame(self, rows=9, reserves=8):
        # create layout
        l, s = Layout(self), self.s

        # set size
        maxrows = max(rows, reserves)
        self.setSize(l.XM + (maxrows + 2) * l.XS, l.YM + 6 * l.YS)

        #
        playcards = 4 * l.YS // l.YOFFSET
        xoffset, yoffset = [], []
        for i in range(playcards):
            xoffset.append(0)
            yoffset.append(l.YOFFSET)
        for i in range(68 * self.gameinfo.decks - playcards):
            xoffset.append(l.XOFFSET)
            yoffset.append(0)

        # create stacks
        x, y = l.XM + (maxrows - reserves) * l.XS // 2, l.YM
        for i in range(reserves):
            s.reserves.append(ReserveStack(x, y, self))
            x = x + l.XS
        x, y = l.XM + (maxrows - rows) * l.XS // 2, l.YM + l.YS
        self.setRegion(s.reserves, (-999, -999, 999999, y - l.YM // 2))
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self, yoffset=yoffset)
            stack.CARD_XOFFSET = xoffset
            stack.CARD_YOFFSET = yoffset
            s.rows.append(stack)
            x = x + l.XS
        x, y = l.XM + maxrows * l.XS, l.YM
        for i in range(2):
            for suit in range(5):
                s.foundations.append(
                    SS_FoundationStack(x, y, self, suit=suit, max_cards=16))
                y = y + l.YS
            x, y = x + l.XS, l.YM
        self.setRegion(self.s.foundations, (x - l.XS * 2, -999, 999999,
                       self.height - (l.YS + l.YM)), priority=1)
        s.talon = InitialDealTalonStack(
            self.width - 3 * l.XS // 2, self.height - l.YS, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        i = 0
        while self.s.talon.cards:
            if self.s.talon.cards[-1].rank == 15:
                if self.s.rows[i].cards:
                    i = i + 1
            self.s.talon.dealRow(rows=[self.s.rows[i]], frames=4)

    # must look at cards
    def _getClosestStack(self, cx, cy, stacks, dragstack):
        closest, cdist = None, 999999999
        for stack in stacks:
            if stack.cards and stack is not dragstack:
                dist = (stack.cards[-1].x - cx)**2 + \
                    (stack.cards[-1].y - cy)**2
            else:
                dist = (stack.x - cx)**2 + (stack.y - cy)**2
            if dist < cdist:
                closest, cdist = stack, dist
        return closest

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isRankSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# *
# ************************************************************************

class Labyrinth(Convolution):
    RowStack_Class = StackWrapper(HexADeck_AC_RowStack, base_rank=NO_RANK)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isAlternateColorSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# *
# ************************************************************************

class Snakestone(Convolution):
    RowStack_Class = StackWrapper(HexADeck_SS_RowStack, base_rank=NO_RANK)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isSuitSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# *
# ************************************************************************

def r(id, gameclass, name, game_type, decks, redeals, skill_level):
    game_type = game_type | GI.GT_HEXADECK
    gi = GameInfo(id, gameclass, name, game_type, decks, redeals, skill_level,
                  suits=list(range(4)), ranks=list(range(16)),
                  trumps=list(range(4)))
    registerGame(gi)
    return gi


r(165, BitsNBytes, 'Bits n Bytes', GI.GT_HEXADECK, 1, 1, GI.SL_BALANCED)
r(166, HexAKlon, 'Hex A Klon', GI.GT_HEXADECK, 1, -1, GI.SL_BALANCED)
r(16666, KlondikePlus16, 'Klondike Plus 16', GI.GT_HEXADECK, 1, 1,
  GI.SL_BALANCED)
r(16667, HexAKlonByThrees, 'Hex A Klon by Threes', GI.GT_HEXADECK, 1, -1,
  GI.SL_BALANCED)
r(16668, KingOnlyHexAKlon, 'King Only Hex A Klon', GI.GT_HEXADECK, 1, -1,
  GI.SL_BALANCED)
r(16669, TheFamiliar, 'The Familiar', GI.GT_HEXADECK, 1, 1, GI.SL_BALANCED)
r(16670, TwoFamiliars, 'Two Familiars', GI.GT_HEXADECK, 2, 1, GI.SL_BALANCED)
r(16671, TenByEight, '10 x 8', GI.GT_HEXADECK, 2, -1, GI.SL_BALANCED)
r(16672, Drawbridge, 'Drawbridge', GI.GT_HEXADECK, 1, 1, GI.SL_BALANCED)
r(16673, DoubleDrawbridge, 'Double Drawbridge', GI.GT_HEXADECK, 2, 1,
  GI.SL_BALANCED)
r(16674, HiddenPassages, 'Hidden Passages', GI.GT_HEXADECK, 1, 1,
  GI.SL_MOSTLY_LUCK)
r(16675, CluitjarsLair, 'Cluitjar\'s Lair', GI.GT_HEXADECK, 1, 0,
  GI.SL_BALANCED)
r(16676, MerlinsMeander, 'Merlin\'s Meander', GI.GT_HEXADECK, 2, 2,
  GI.SL_BALANCED)
r(16677, MagesGame, 'Mage\'s Game', GI.GT_HEXADECK, 1, 0, GI.SL_BALANCED)
r(16678, Convolution, 'Convolution', GI.GT_HEXADECK, 2, 0, GI.SL_MOSTLY_SKILL)
r(16679, Labyrinth, 'Hex Labyrinth', GI.GT_HEXADECK, 2, 0, GI.SL_MOSTLY_SKILL)
r(16680, Snakestone, 'Snakestone', GI.GT_HEXADECK, 2, 0, GI.SL_MOSTLY_SKILL)

del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.ultra.hanafuda_common import \
        AbstractFlowerGame, \
        FlowerClock_RowStack, \
        Flower_OpenStack, \
        HanafudaRK_RowStack, \
        Hanafuda_SS_FoundationStack, \
        Hanafuda_SequenceStack, \
        JapaneseGarden_RowStack, \
        Queue_BraidStack, \
        Queue_Foundation, \
        Queue_Hint, \
        Queue_ReserveStack, \
        Queue_RowStack, \
        Samuri_RowStack
from pysollib.hint import AbstractHint, CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        BasicRowStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        OpenStack, \
        ReserveStack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ANY_RANK, ANY_SUIT, NO_RANK


# ************************************************************************
# * Paulownia
# ************************************************************************


class Paulownia(AbstractFlowerGame):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = Hanafuda_SS_FoundationStack
    RowStack_Class = Hanafuda_SequenceStack
    MaxRounds = -1
    BaseRank = 0
    NumDeal = 1

    #
    # Game layout
    #

    def createGame(self, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=self.MaxRounds,
                                   num_deal=self.NumDeal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(self.Foundation_Class(r.x, r.y, self,
                                 suit=r.suit, base_rank=3))

        # Create row stacks
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                          base_rank=self.BaseRank, yoffset=l.YOFFSET))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * self.gameinfo.decks
        for i in range(8):
            self.s.talon.dealRow(rows=self.s.rows[i + 1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()


class Pine(Paulownia):
    MaxRounds = 1
    NumDeal = 3


class Eularia(Paulownia):
    BaseRank = ANY_RANK


class Peony(Eularia):
    NumDeal = 3


class Iris(Peony):
    MaxRounds = 1


# ************************************************************************
# * Queue
# ************************************************************************

class LesserQueue(AbstractFlowerGame):
    Hint_Class = Queue_Hint
    BRAID_CARDS = 20
    BRAID_OFFSET = 1

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        decks = self.gameinfo.decks
        yoffset = l.YOFFSET*self.BRAID_OFFSET
        h = l.YM+max(l.YS*5.5, l.YS+self.BRAID_CARDS*yoffset+2*l.TEXT_MARGIN)
        self.setSize(l.XM + l.XS * 10.5, h)

        # extra settings
        self.base_card = None

        # Create rows, reserves
        s.addattr(braid=None)
        x, x0 = l.XM + l.XS * 2, (decks - 1.5) % 2.5
        for j in range(decks // 2):
            y = l.YM
            for i in range(2):
                s.rows.append(Queue_RowStack(x + l.XS * (x0 + j), y, self))
                s.rows.append(Queue_RowStack(x + l.XS * (4 + x0 + j + .5), y,
                                             self))
                y = y + l.YS * (3 + (decks > 2))
        y = l.YM + l.YS
        for i in range(2):
            s.rows.append(Queue_ReserveStack(x, y, self))
            s.rows.append(Queue_ReserveStack(x + l.XS, y, self))
            s.rows.append(Queue_ReserveStack(x, y + l.YS, self))
            s.rows.append(Queue_ReserveStack(x + l.XS, y + l.YS, self))
            if decks - 2:
                s.rows.append(Queue_ReserveStack(x, y + l.YS * 2, self))
                s.rows.append(Queue_ReserveStack(x + l.XS, y + l.YS * 2, self))
            x = x + l.XS * 4.5

        # Create braid
        x, y = l.XM + l.XS * 4.25, l.YM
        s.braid = Queue_BraidStack(x, y, self, yoffset=self.BRAID_OFFSET)

        # Create talon, waste
        x, y = l.XM, h-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "n")
        s.talon.texts.rounds = MfxCanvasText(
            self.canvas,
            self.width//2, h-2*l.TEXT_MARGIN,
            anchor="center",
            font=self.app.getFont("canvas_default"))
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "n")

        # Create foundations
        x = l.XM
        for j in range(decks // 2):
            y = l.YM
            for i in range(4):
                s.foundations.append(Queue_Foundation(
                    x, y, self, -1, mod=12,
                    max_cards=12, base_suit=ANY_SUIT, base_rank=i, rank=i))
                s.foundations.append(
                    Queue_Foundation(
                        x + l.XS * (9.5 - j * 2),
                        y, self, -1, mod=12,
                        max_cards=12, base_suit=ANY_SUIT, base_rank=i, rank=i))
                y = y + l.YS
            x = x + l.XS
        self.texts.info = MfxCanvasText(
            self.canvas,
            self.width//2, h-l.TEXT_MARGIN,
            anchor="center",
            font=self.app.getFont("canvas_default"))

        # define stack-groups
        self.sg.talonstacks = [s.talon] + [s.waste]
        self.sg.openstacks = s.foundations + s.rows + s.reserves
        self.sg.dropstacks = [s.braid] + s.rows + [s.waste] + s.reserves

    #
    # game overrides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * self.gameinfo.decks
        self.startDealSample()
        self.base_card = None
        self.updateText()
        for i in range(self.BRAID_CARDS):
            self.s.talon.dealRow(rows=[self.s.braid])
        self.s.talon.dealRow()
        # deal base_card to foundations, update cap.base_rank
        self.base_card = self.s.talon.getCard()
        to_stack = self.s.foundations[2 * self.base_card.rank]
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, to_stack)
        self.updateText()
        for s in self.s.foundations:
            s.cap.base_suit = self.base_card.suit
        # deal first card to WasteStack
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.rank == card2.rank and
                ((card1.suit + 1) % 12 == card2.suit or
                 (card2.suit + 1) % 12 == card1.suit))

    def getHighlightPilesStacks(self):
        return ()

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_suit = self.base_card.suit

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)

    #
    # game extras
    #

    def updateText(self):
        if self.preview > 1 or not self.texts.info:
            return
        if not self.base_card:
            t = ""
        else:
            t = self.SUITS[self.base_card.suit]
            dir = self.getFoundationDir()
            if dir == 1:
                t = t + _(" Ascending")
            elif dir == 11:
                t = t + _(" Descending")
        self.texts.info.config(text=t)

    def getFoundationDir(self):
        for s in self.s.foundations:
            if len(s.cards) >= 2:
                return (s.cards[-1].suit - s.cards[-2].suit) % 12
        return 0


class GreaterQueue(LesserQueue):
    Hint_Class = Queue_Hint
    BRAID_CARDS = 40
    BRAID_OFFSET = .5


# ************************************************************************
# * Japanese Garden
# ************************************************************************

class JapaneseGarden(AbstractFlowerGame):
    Hint_Class = CautiousDefaultHint
    RowStack_Class = FlowerClock_RowStack
    WIDTH = 10
    HEIGHT = 6
    XROWS = 3
    YROWS = 2
    MAX_CARDS = 6
    MAX_MOVE = 1
    XRESERVES = 6
    YRESERVES = 2
    MAX_RESERVE = 0
    INITIAL_DEAL = 6
    DEAL_RESERVES = 1

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        self.setSize(l.XM + l.XS * self.WIDTH, l.YM * 3 + l.YS * self.HEIGHT)

        # Create foundations
        x = self.width // 2 + l.XM // 2 - l.XS * 3
        y = l.YM
        for j in range(2):
            for i in range(6):
                s.foundations.append(
                    Hanafuda_SS_FoundationStack(
                        x, y, self, i + (j * 6),
                        max_cards=4, max_accept=1, base_rank=3))
                x = x + l.XS
            x = self.width // 2 + l.XM // 2 - l.XS * 3
            y = y + l.YS

        # Create flower beds
        x = l.XM
        y = l.YM * 2 + l.YS * 2
        for j in range(self.YROWS):
            for i in range(self.XROWS):
                row = self.RowStack_Class(
                    x, y, self, yoffset=0, max_accept=self.MAX_MOVE,
                    max_move=self.MAX_MOVE, max_cards=self.MAX_CARDS,
                    base_rank=0)
                row.CARD_XOFFSET = l.CW // 2
                s.rows.append(row)
                x = x + self.width // self.XROWS
            x = l.XM
            y = y + l.YS
        self.setRegion(s.rows, (l.XM, l.YS * 2, 999999, y))

        # Create pool
        x = self.width // 2 + l.XM // 2 - (l.XS * self.XRESERVES) // 2
        for j in range(self.YRESERVES):
            for i in range(self.XRESERVES):
                s.reserves.append(
                    ReserveStack(x, y, self, max_accept=self.MAX_RESERVE))
                x = x + l.XS
            x = self.width // 2 + l.XM // 2 - l.XS * (self.XRESERVES // 2)
            y = y + l.YS
        if s.reserves:
            self.setRegion(
                s.reserves, (l.XM, l.YS * (2 + self.YROWS), 999999, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(l.XM, l.YM, self)

        # Define stack-groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48
        self.startDealSample()
        for i in range(self.INITIAL_DEAL):
            self.s.talon.dealRow()
        if self.DEAL_RESERVES:
            self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealCards()


class JapaneseGardenII(JapaneseGarden):
    RowStack_Class = JapaneseGarden_RowStack


class JapaneseGardenIII(JapaneseGardenII):
    XROWS = 2
    YROWS = 4
    MAX_CARDS = 7
    XRESERVES = 0
    YRESERVES = 0
    DEAL_RESERVES = 0


class SixSages(JapaneseGarden):
    Hint_Class = CautiousDefaultHint
    XROWS = 2
    YROWS = 3
    MAX_CARDS = 9
    XRESERVES = 1
    YRESERVES = 1
    MAX_RESERVE = 1
    INITIAL_DEAL = 8
    DEAL_RESERVES = 0


class SixTengus(SixSages):
    RowStack_Class = HanafudaRK_RowStack
    HEIGHT = 5
    MAX_MOVE = 2
    XRESERVES = 0
    YRESERVES = 0


# ************************************************************************
# * Hanafuda Four Seasons
# ************************************************************************

class HanafudaFourSeasons(AbstractFlowerGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        self.setSize(l.XM + l.XS * 7, l.YM + l.YS * 5)

        # Create rows
        x, y, offset = l.XM, l.YM, self.app.images.CARD_YOFFSET
        for i in range(6):
            s.rows.append(Samuri_RowStack(x, y, self, offset, max_cards=8,
                                          max_accept=8, base_rank=0))
            x = x + l.XS + l.XM + (l.XM * (i == 2))
        x, y = l.XM, y + l.YS * 2.5
        for i in range(6):
            s.rows.append(Samuri_RowStack(x, y, self, offset, max_cards=8,
                                          max_accept=8, base_rank=0))
            x = x + l.XS + l.XM + (l.XM * (i == 2))
        self.setRegion(s.rows, (0, 0, 999999, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(-l.XS, -l.YS, self)

        # Define stack-groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * self.gameinfo.decks
        self.startDealSample()
        for i in range(4):
            self.s.talon.dealRow(flip=1)

    #
    # Game extras
    #

    def isGameWon(self):
        for r in self.s.rows:
            cards = r.cards
            if not len(cards) == 4:
                return 0
            if not (cards[0].suit == r.id and r.isHanafudaSequence(cards)):
                return 0
        return 1


# ************************************************************************
# * Wisteria
# ************************************************************************

class Wisteria(AbstractFlowerGame):
    RowStack_Class = StackWrapper(Hanafuda_SequenceStack, base_rank=NO_RANK)

    #
    # game layout
    #

    def createGame(self, rows=13):
        # create layout
        l, s = Layout(self), self.s

        # set size
        self.setSize(l.XM + rows * l.XS, l.YM + 6 * l.YS)

        # create stacks
        x, y = self.width // 2 - l.XS * 3, l.YM
        for i in range(2):
            for suit in range(6):
                s.foundations.append(
                    Hanafuda_SS_FoundationStack(
                        x, y, self, suit=suit + (6 * i)))
                x = x + l.XS
            x, y = self.width // 2 - l.XS * 3, y + l.YS
        self.setRegion(
            self.s.foundations, (-999, -999, 999999, l.YM + l.YS * 2),
            priority=1)
        x, y = l.XM, l.YM + l.YS * 2
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self, yoffset=l.YOFFSET)
            s.rows.append(stack)
            x = x + l.XS
        s.talon = InitialDealTalonStack(l.XS, l.YS // 2, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        i = 0
        while self.s.talon.cards:
            if self.s.talon.cards[-1].rank == 0:
                if self.s.rows[i].cards:
                    i = i + 1
            self.s.talon.dealRow(rows=[self.s.rows[i]], frames=4)


# ************************************************************************
# * Flower Arrangement Hint
# ************************************************************************

class FlowerArrangement_Hint(AbstractHint):
    def computeHints(self):
        game = self.game

        # 2)See if we can move a card to the tableaux
        if not self.hints:
            for r in game.sg.dropstacks:
                pile = r.getPile()
                if not pile or len(pile) != 1:
                    continue
                if r in game.s.tableaux:
                    rr = self.ClonedStack(r, stackcards=r.cards[:-1])
                    if rr.acceptsCards(None, pile):
                        # do not move a card that is already in correct place
                        continue
                    base_score = 80000 + (4 - r.cap.base_suit)
                else:
                    base_score = 80000
                # find a stack that would accept this card
                for t in game.s.tableaux:
                    if t is not r and t.acceptsCards(r, pile):
                        score = base_score + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 3)See if we can move a card from the tableaux
        #    to a row stack. This can only happen if there are
        #    no more cards to deal.
        if not self.hints:
            for r in game.s.tableaux:
                pile = r.getPile()
                if not pile or len(pile) != 1:
                    continue
                rr = self.ClonedStack(r, stackcards=r.cards[:-1])
                if rr.acceptsCards(None, pile):
                    # do not move a card that is already in correct place
                    continue
                # find a stack that would accept this card
                for t in game.s.rows:
                    if t is not r and t.acceptsCards(r, pile):
                        score = 70000 + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 4)See if we can move a card within the row stacks
        if not self.hints:
            for r in game.s.rows:
                pile = r.getPile()
                if not pile or len(pile) != 1 or len(pile) == len(r.cards):
                    continue
                base_score = 60000
                # find a stack that would accept this card
                for t in game.s.rows:
                    if t is not r and t.acceptsCards(r, pile):
                        score = base_score + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 5)See if we can deal cards
        if self.level >= 2:
            if game.canDealCards():
                self.addHint(self.SCORE_DEAL, 0, game.s.talon, None)


# ************************************************************************
# * Flower Arrangement Stacks
# ************************************************************************

class FlowerArrangement_TableauStack(Flower_OpenStack):
    def __init__(self, x, y, game, yoffset, **cap):
        kwdefault(cap, dir=-1, max_move=1, max_cards=4, max_accept=1,
                  base_rank=3)
        OpenStack.__init__(self, x, y, game, **cap)
        self.CARD_YOFFSET = yoffset

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        # check that the base card is correct
        suits = list(range(self.cap.mod, (self.cap.mod + 4)))
        if self.cards and (self.cards[0].rank == 3 and
                           self.cards[-1].suit in suits):
            return self.isHanafudaSequence([self.cards[-1], cards[0]])
        return not self.cards and cards[0].rank == 3 and cards[0].suit in suits

    def getBottomImage(self):
        return self.game.app.images.getSuitBottom()


class FlowerArrangement_RowStack(BasicRowStack):

    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return 0
        # check
        return not (self.cards or self.game.s.talon.cards)

    def getBottomImage(self):
        return self.game.app.images.getTalonBottom()


# ************************************************************************
# * Flower Arrangement
# ************************************************************************

class FlowerArrangement(Game):
    Hint_Class = FlowerArrangement_Hint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        TABLEAU_YOFFSET = min(9, max(3, l.YOFFSET // 3))

        # set window
        th = l.YS + 3 * TABLEAU_YOFFSET
        # (set piles so that at least 2/3 of a card is visible with 10 cards)
        h = (10-1)*l.YOFFSET + l.CH*2//3
        self.setSize(10*l.XS+l.XM, l.YM + 3*th + l.YM + h)

        # create stacks
        s.addattr(tableaux=[])     # register extra stack variable
        x = l.XM + 8 * l.XS + l.XS // 2
        y = l.YM
        for i in range(3):
            x = l.XM
            for j in range(8):
                s.tableaux.append(
                    FlowerArrangement_TableauStack(
                        x, y, self, TABLEAU_YOFFSET, mod=i * 4))
                x = x + l.XS
            y = y + th
        x, y = l.XM, y + l.YM
        for i in range(8):
            s.rows.append(FlowerArrangement_RowStack(x, y, self, max_accept=1))
            x = x + l.XS
        x = l.XM + 8 * l.XS + l.XS // 2
        y = self.height - l.YS
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, "se")

        # define stack-groups
        self.sg.openstacks = s.tableaux + s.rows
        self.sg.talonstacks = [s.talon]
        self.sg.dropstacks = s.tableaux + s.rows

    #
    # game overrides
    #

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.tableaux, frames=0)
        self._startAndDealRow()

    def isGameWon(self):
        for stack in self.s.tableaux:
            if len(stack.cards) != 4:
                return 0
        return 1

    def fillStack(self, stack):
        if self.s.talon.cards:
            if stack in self.s.rows and len(stack.cards) == 0:
                self.s.talon.dealRow(rows=[stack])

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                (card1.rank + 3 == card2.rank or card2.rank + 3 == card1.rank))

    def getHighlightPilesStacks(self):
        return ()


# ************************************************************************
# * Register the games
# ************************************************************************

def r(id, gameclass, name, game_type, decks, redeals, skill_level):
    game_type = game_type | GI.GT_HANAFUDA
    gi = GameInfo(id, gameclass, name, game_type, decks, redeals, skill_level,
                  suits=list(range(12)), ranks=list(range(4)))
    registerGame(gi)
    return gi


r(12369, Paulownia, 'Paulownia', GI.GT_HANAFUDA, 1, -1, GI.SL_BALANCED)
r(12370, LesserQueue, 'Lesser Queue', GI.GT_HANAFUDA, 2, 2, GI.SL_BALANCED)
r(12371, GreaterQueue, 'Greater Queue', GI.GT_HANAFUDA, 4, 2, GI.SL_BALANCED)
r(12373, JapaneseGarden, 'Japanese Garden', GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(12374, JapaneseGardenII, 'Japanese Garden II', GI.GT_HANAFUDA | GI.GT_OPEN,
  1, 0, GI.SL_MOSTLY_SKILL)
r(12375, SixSages, 'Six Sages', GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(12376, SixTengus, 'Six Tengus', GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(12377, JapaneseGardenIII, 'Japanese Garden III', GI.GT_HANAFUDA | GI.GT_OPEN,
  1, 0, GI.SL_MOSTLY_SKILL)
r(12378, HanafudaFourSeasons, 'Hanafuda Four Seasons',
  GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL)
r(12380, Eularia, 'Eularia', GI.GT_HANAFUDA, 1, -1, GI.SL_BALANCED)
r(12381, Peony, 'Peony', GI.GT_HANAFUDA, 1, -1, GI.SL_BALANCED)
r(12382, Iris, 'Iris', GI.GT_HANAFUDA, 1, 0, GI.SL_BALANCED)
r(12383, Pine, 'Pine', GI.GT_HANAFUDA, 1, 0, GI.SL_BALANCED)
r(12384, Wisteria, 'Wisteria', GI.GT_HANAFUDA, 1, 0, GI.SL_MOSTLY_SKILL)
r(12385, FlowerArrangement, 'Flower Arrangement', GI.GT_HANAFUDA, 2, 0,
  GI.SL_BALANCED)

del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import re
import time

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import AbstractHint
from pysollib.layout import Layout
from pysollib.mfxutil import Image, Struct, kwdefault
from pysollib.mygettext import _
from pysollib.mygettext import ungettext
from pysollib.pysoltk import ANCHOR_NW, EVENT_HANDLED, bind
from pysollib.pysoltk import MfxCanvasImage, MfxCanvasText
from pysollib.pysoltk import MfxMessageDialog
from pysollib.settings import DEBUG, TOOLKIT
from pysollib.stack import \
        InitialDealTalonStack, \
        OpenStack
from pysollib.util import ANY_SUIT, NO_RANK

from six.moves import range


def factorial(x):
    if x <= 1:
        return 1
    a = 1
    for i in range(x):
        a *= (i+1)
    return a


# ************************************************************************
# *
# ************************************************************************

class Mahjongg_Hint(AbstractHint):
    # FIXME: no intelligence whatsoever is implemented here
    def computeHints(self):
        game = self.game
        # get free stacks
        stacks = []
        for r in game.s.rows:
            if r.cards and not r.basicIsBlocked():
                stacks.append(r)
        # find matching tiles
        i = 0
        for r in stacks:
            for t in stacks[i+1:]:
                if game.cardsMatch(r.cards[0], t.cards[0]):
                    # simple scoring...
                    # score = 10000 + r.id + t.id
                    rb = r.blockmap
                    tb = t.blockmap
                    score = \
                        10000 + \
                        1000 * (len(rb.below) + len(tb.below)) + \
                        len(rb.all_left) + len(rb.all_right) + \
                        len(tb.all_left) + len(tb.all_right)
                    self.addHint(score, 1, r, t)
            i += 1


# ************************************************************************
# *
# ************************************************************************

# class Mahjongg_Foundation(AbstractFoundationStack):
class Mahjongg_Foundation(OpenStack):

    def __init__(self, x, y, game, suit=ANY_SUIT, **cap):
        kwdefault(cap, max_move=0, max_accept=0, max_cards=game.NCARDS)
        OpenStack.__init__(self, x, y, game, **cap)

    def acceptsCards(self, from_stack, cards):
        # We do not accept any cards - pairs will get
        # delivered by _dropPairMove() below.
        return 0

    def basicIsBlocked(self):
        return 1

    # def initBindings(self):
    #    pass

    def _position(self, card):
        # AbstractFoundationStack._position(self, card)
        OpenStack._position(self, card)

        fnds = self.game.s.foundations

        cols = (3, 2, 1, 0)
        for i in cols:
            for j in range(9):
                n = i*9+j
                if fnds[n].cards:
                    fnds[n].group.tkraise()
        return

    def getHelp(self):
        return ''


# ************************************************************************
# *
# ************************************************************************

class Mahjongg_RowStack(OpenStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=1, max_accept=1, max_cards=2,
                  base_rank=NO_RANK)
        OpenStack.__init__(self, x, y, game, **cap)

    def basicIsBlocked(self):
        # any of above blocks
        for stack in self.blockmap.above:
            if stack.cards:
                return 1
        # any of left blocks - but we can try right as well
        for stack in self.blockmap.left:
            if stack.cards:
                break
        else:
            return 0
        # any of right blocks
        for stack in self.blockmap.right:
            if stack.cards:
                return 1
        return 0

    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return 0
        return self.game.cardsMatch(self.cards[0], cards[-1])

    def canFlipCard(self):
        return 0

    def canDropCards(self, stacks):
        return (None, 0)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        self._dropPairMove(ncards, to_stack, frames=-1, shadow=shadow)

    def _dropPairMove(self, n, other_stack, frames=-1, shadow=-1):
        # print 'drop:', self.id, other_stack.id
        assert n == 1 and self.acceptsCards(
            other_stack, [other_stack.cards[-1]])
        if not self.game.demo:
            self.game.playSample("droppair", priority=200)
        old_state = self.game.enterState(self.game.S_FILL)
        c = self.cards[0]
        if c.suit == 3:
            if c.rank >= 8:
                i = 35
            elif c.rank >= 4:
                i = 34
            else:
                i = 30+c.rank
        elif c.rank == 9:
            i = 27+c.suit
        else:
            i = c.suit*9+c.rank
        f = self.game.s.foundations[i]
        self.game.moveMove(n, self, f, frames=frames, shadow=shadow)
        self.game.moveMove(n, other_stack, f, frames=frames, shadow=shadow)
        self.game.leaveState(old_state)
        self.fillStack()
        other_stack.fillStack()

    #
    # Mahjongg special overrides
    #

    # Mahjongg special: we must preserve the relative stacking order
    # to keep our pseudo 3D look.
    def _position(self, card):
        OpenStack._position(self, card)
        #
        if TOOLKIT == 'tk':
            rows = [s for s in self.game.s.rows[:self.id] if s.cards]
            if rows:
                self.group.tkraise(rows[-1].group)
                return
            rows = [s for s in self.game.s.rows[self.id+1:] if s.cards]
            if rows:
                self.group.lower(rows[0].group)
                return
        elif TOOLKIT == 'kivy':
            rows = [s for s in self.game.s.rows[:self.id] if s.cards]
            if rows:
                # self.group.tkraise(rows[-1].group)
                return
            rows = [s for s in self.game.s.rows[self.id+1:] if s.cards]
            if rows:
                # self.group.lower(rows[0].group)
                return
        elif TOOLKIT == 'gtk':
            # FIXME (this is very slow)
            for s in self.game.s.rows[self.id+1:]:
                s.group.tkraise()

    # In Mahjongg games type there are a lot of stacks, so we optimize
    # and don't create bindings that are not used anyway.
    def initBindings(self):
        group = self.group
        # FIXME: dirty hack to access the Stack's private methods
        # bind(group, "<1>", self._Stack__clickEventHandler)
        # bind(group, "<3>", self._Stack__controlclickEventHandler)
        # bind(group, "<Control-1>", self._Stack__controlclickEventHandler)
        #
        bind(group, "<1>", self.__clickEventHandler)
        bind(group, "<3>", self.__controlclickEventHandler)
        bind(group, "<Control-1>", self.__controlclickEventHandler)
        # bind(group, "<Enter>", self._Stack__enterEventHandler)
        # bind(group, "<Leave>", self._Stack__leaveEventHandler)

    def __defaultClickEventHandler(self, event, handler):
        self.game.event_handled = True  # for Game.undoHandler
        if self.game.demo:
            self.game.stopDemo(event)
        if self.game.busy:
            return EVENT_HANDLED
        handler(event)
        return EVENT_HANDLED

    def __clickEventHandler(self, event):
        # print 'click:', self.id
        return self.__defaultClickEventHandler(event, self.clickHandler)

    def __controlclickEventHandler(self, event):
        return self.__defaultClickEventHandler(event, self.controlclickHandler)

    def clickHandler(self, event):
        game = self.game
        drag = game.drag
        # checks
        if not self.cards:
            return 1
        card = self.cards[-1]
        from_stack = drag.stack
        if from_stack is self:
            # remove selection
            self.game.playSample("nomove")
            self._stopDrag()
            return 1
        if self.basicIsBlocked():
            # remove selection
            # self.game.playSample("nomove")
            return 1
        # possible move
        if from_stack:
            if self.acceptsCards(from_stack, from_stack.cards):
                self._stopDrag()
                # this code actually moves the tiles
                from_stack.playMoveMove(1, self, frames=0, sound=True)
                if TOOLKIT == 'kivy':
                    if drag.shade_img:
                        # drag.shade_img.dtag(drag.shade_stack.group)
                        drag.shade_img.delete()
                        # game.canvas.delete(drag.shade_img)
                        drag.shade_img = None
                return 1
        drag.stack = self
        self.game.playSample("startdrag")
        # create the shade image (see stack.py, _updateShade)
        if drag.shade_img:
            # drag.shade_img.dtag(drag.shade_stack.group)
            drag.shade_img.delete()
            # game.canvas.delete(drag.shade_img)
            drag.shade_img = None
        img = game.app.images.getHighlightedCard(
            card.deck, card.suit, card.rank)
        if img is None:
            return 1
        img = MfxCanvasImage(game.canvas, self.x, self.y, image=img,
                             anchor=ANCHOR_NW, group=self.group)
        drag.shade_img = img
        # raise/lower the shade image to the correct stacking order
        img.tkraise(card.item)
        drag.shade_stack = self
        return 1

    def cancelDrag(self, event=None):
        if event is None:
            self._stopDrag()

    def _findCard(self, event):
        # we need to override this because the shade may be hiding
        # the tile (from Tk's stacking view)
        return len(self.cards) - 1

    def getBottomImage(self):
        return None


# ************************************************************************
# *
# ************************************************************************

class AbstractMahjonggGame(Game):
    Hint_Class = Mahjongg_Hint
    RowStack_Class = Mahjongg_RowStack

    GAME_VERSION = 3

    NCARDS = 144

    def getTiles(self):
        # decode tile positions
        L = self.L

        assert L[0] == "0"
        assert (len(L) - 1) % 3 == 0

        tiles = []
        max_tl, max_tx, max_ty = -1, -1, -1
        t = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
        for i in range(1, len(L), 3):
            n = t.find(L[i])
            level, height = n // 7, n % 7 + 1
            tx = t.find(L[i+1])
            ty = t.find(L[i+2])
            assert n >= 0 and tx >= 0 and ty >= 0
            max_tl = max(level + height - 1, max_tl)
            max_tx = max(tx, max_tx)
            max_ty = max(ty, max_ty)
            for tl in range(level, level + height):
                tiles.append((tl, tx, ty))
        assert len(tiles) == self.NCARDS
        # tiles.sort()
        # tiles = tuple(tiles)
        return tiles, max_tl, max_tx, max_ty

    #
    # game layout
    #

    def createGame(self):
        tiles, max_tl, max_tx, max_ty = self.getTiles()

        # start layout
        l, s = Layout(self), self.s
        show_removed = self.app.opt.mahjongg_show_removed

        # dx, dy = 2, -2
        # dx, dy = 3, -3
        cs = self.app.cardset
        if cs.version >= 6:
            dx = l.XOFFSET
            dy = -l.YOFFSET
            d_x = cs.SHADOW_XOFFSET
            d_y = cs.SHADOW_YOFFSET
            if self.preview:
                # Fixme
                dx, dy, d_x, d_y = dx//2, dy//2, d_x//2, d_y//2
            self._delta_x, self._delta_y = dx, -dy
        else:
            dx = 3
            dy = -3
            d_x = 0
            d_y = 0
            self._delta_x, self._delta_y = 0, 0
        # print dx, dy, d_x, d_y, cs.version

        font = self.app.getFont("canvas_default")

        # width of self.texts.info
        # ti_width = Font(self.canvas, font).measure(_('Remaining'))
        ti_width = 80

        # set window size
        dxx, dyy = abs(dx) * (max_tl+1), abs(dy) * (max_tl+1)
        # foundations dxx dyy
        if self.NCARDS > 144:
            fdxx = abs(dx)*8
            fdyy = abs(dy)*8
        else:
            fdxx = abs(dx)*4
            fdyy = abs(dy)*4
        cardw, cardh = l.CW - d_x, l.CH - d_y
        if show_removed:
            left_margin = l.XM + 4*cardw+fdxx+d_x + l.XM
        else:
            left_margin = l.XM
        tableau_width = (max_tx+2)*cardw//2+dxx+d_x
        right_margin = l.XM+ti_width+l.XM
        w = left_margin + tableau_width + right_margin
        h = l.YM + dyy + (max_ty + 2) * cardh // 2 + d_y + l.YM
        if show_removed:
            h = max(h, l.YM+fdyy+cardh*9+d_y+l.YM)
        self.setSize(w, h)

        # set game extras
        self.check_dist = l.CW*l.CW + l.CH*l.CH     # see _getClosestStack()

        # sort tiles (for 3D)
        tiles.sort(key=lambda x: (x[0], x[2]-x[1]))

        # create a row stack for each tile and compute the tilemap
        tilemap = {}
        x0 = left_margin
        y0 = l.YM + dyy
        for level, tx, ty in tiles:
            # print level, tx, ty
            x = x0 + (tx * cardw) // 2 + level * dx
            y = y0 + (ty * cardh) // 2 + level * dy
            stack = self.RowStack_Class(x, y, self)
            # stack.G = (level, tx, ty)
            stack.CARD_XOFFSET = dx
            stack.CARD_YOFFSET = dy
            s.rows.append(stack)
            # tilemap - each tile covers 4 positions
            tilemap[(level, tx, ty)] = stack
            tilemap[(level, tx+1, ty)] = stack
            tilemap[(level, tx, ty+1)] = stack
            tilemap[(level, tx+1, ty+1)] = stack

        # compute blockmap
        for stack in s.rows:
            level, tx, ty = tiles[stack.id]
            above, below, left, right = {}, {}, {}, {}
            # above blockers
            for tl in range(level+1, level+2):
                above[tilemap.get((tl, tx, ty))] = 1
                above[tilemap.get((tl, tx+1, ty))] = 1
                above[tilemap.get((tl, tx, ty+1))] = 1
                above[tilemap.get((tl, tx+1, ty+1))] = 1
            #
            for tl in range(level):
                below[tilemap.get((tl, tx, ty))] = 1
                below[tilemap.get((tl, tx+1, ty))] = 1
                below[tilemap.get((tl, tx, ty+1))] = 1
                below[tilemap.get((tl, tx+1, ty+1))] = 1
            # left blockers
            left[tilemap.get((level, tx-1, ty))] = 1
            left[tilemap.get((level, tx-1, ty+1))] = 1
            # right blockers
            right[tilemap.get((level, tx+2, ty))] = 1
            right[tilemap.get((level, tx+2, ty+1))] = 1
            # up blockers
            # up[tilemap.get((level, tx, ty-1))] = 1
            # up[tilemap.get((level, tx+1, ty-1))] = 1
            # bottom blockers
            # bottom[tilemap.get((level, tx, ty+2))] = 1
            # bottom[tilemap.get((level, tx+1, ty+2))] = 1
            # sanity check - assert that there are no overlapping tiles
            assert tilemap.get((level, tx, ty)) is stack
            assert tilemap.get((level, tx+1, ty)) is stack
            assert tilemap.get((level, tx, ty+1)) is stack
            assert tilemap.get((level, tx+1, ty+1)) is stack
            #
            above = tuple([_f for _f in above.keys() if _f])
            below = tuple([_f for _f in below.keys() if _f])
            left = tuple([_f for _f in left.keys() if _f])
            right = tuple([_f for _f in right.keys() if _f])
            # up = tuple(filter(None, up.keys()))
            # bottom = tuple(filter(None, bottom.keys()))

            # assemble
            stack.blockmap = Struct(
                above=above,
                below=below,
                left=left,
                right=right,
                # up=up,
                # bottom=bottom,
                all_left=None,
                all_right=None,
            )

        def get_all_left(s):
            if s.blockmap.all_left is None:
                s.blockmap.all_left = {}
            for t in s.blockmap.left:
                if t.blockmap.all_left is None:
                    get_all_left(t)
                s.blockmap.all_left.update(t.blockmap.all_left)
                s.blockmap.all_left[t] = 1

        def get_all_right(s):
            if s.blockmap.all_right is None:
                s.blockmap.all_right = {}
            for t in s.blockmap.right:
                if t.blockmap.all_right is None:
                    get_all_right(t)
                s.blockmap.all_right.update(t.blockmap.all_right)
                s.blockmap.all_right[t] = 1

        for r in s.rows:
            get_all_left(r)
            get_all_right(r)
        for r in s.rows:
            r.blockmap.all_left = tuple(r.blockmap.all_left.keys())
            r.blockmap.all_right = tuple(r.blockmap.all_right.keys())

        # create other stacks
        for i in range(4):
            for j in range(9):
                if show_removed:
                    x = l.XM+i*cardw
                    y = l.YM+fdyy+j*cardh
                else:
                    if TOOLKIT == 'tk':
                        x = -l.XS-self.canvas.xmargin
                        y = l.YM+dyy
                    elif TOOLKIT == 'kivy':
                        x = -1000
                        y = l.YM+dyy
                    elif TOOLKIT == 'gtk':
                        # FIXME
                        x = self.width - l.XS
                        y = self.height - l.YS
                stack = Mahjongg_Foundation(x, y, self)
                if show_removed:
                    stack.CARD_XOFFSET = dx
                    stack.CARD_YOFFSET = dy
                s.foundations.append(stack)

        self.texts.info = MfxCanvasText(self.canvas,
                                        self.width - l.XM - ti_width,
                                        l.YM + dyy,
                                        anchor="nw", font=font)
        # the Talon is invisble
        s.talon = InitialDealTalonStack(-l.XS-self.canvas.xmargin,
                                        self.height-dyy, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        if self.app.opt.mahjongg_create_solvable == 0:
            return cards
        # try to create a solvable game
        if self.app.opt.mahjongg_create_solvable == 1:
            # easy
            return self._shuffleHook1(cards[:])
        # hard
        new_cards = self._shuffleHook2(self.s.rows, cards)
        if new_cards is None:
            return cards
        return new_cards

    def _shuffleHook1(self, cards):
        # old version; it generate a very easy layouts
        old_cards = cards[:]
        rows = self.s.rows

        def is_blocked(s, new_cards):
            # any of above blocks
            for stack in s.blockmap.above:
                if new_cards[stack.id] is None:
                    return True
            # any of left blocks - but we can try right as well
            for stack in s.blockmap.left:
                if new_cards[stack.id] is None:
                    break
            else:
                return False
            # any of right blocks
            for stack in s.blockmap.right:
                if new_cards[stack.id] is None:
                    return True
            return False

        def create_solvable(cards, new_cards):
            if not cards:
                return new_cards
            # select two matching cards
            c1 = cards[0]
            del cards[0]
            c2 = None
            for i in range(len(cards)):
                if self.cardsMatch(c1, cards[i]):
                    c2 = cards[i]
                    del cards[i]
                    break
            #
            free_stacks = []            # none-blocked stacks
            for r in rows:
                if new_cards[r.id] is None and not is_blocked(r, new_cards):
                    free_stacks.append(r)
            if len(free_stacks) < 2:
                return None             # try another way
            #
            i = factorial(len(free_stacks))//2//factorial(len(free_stacks)-2)
            old_pairs = []
            for j in range(i):
                nc = new_cards[:]
                while True:
                    # create uniq pair
                    r1 = self.random.randrange(0, len(free_stacks))
                    r2 = self.random.randrange(0, len(free_stacks)-1)
                    if r2 >= r1:
                        r2 += 1
                    if (r1, r2) not in old_pairs and (r2, r1) not in old_pairs:
                        old_pairs.append((r1, r2))
                        break
                # add two selected cards to new_cards
                s1 = free_stacks[r1]
                s2 = free_stacks[r2]
                nc[s1.id] = c1
                nc[s2.id] = c2
                # check if this layout is solvable (backtracking)
                nc = create_solvable(cards[:], nc)
                if nc:
                    return nc
            return None                 # try another way

        new_cards = create_solvable(cards, [None]*len(cards))
        if new_cards:
            new_cards.reverse()
            return new_cards
        print('oops! can\'t create a solvable game')
        return old_cards

    def _shuffleHook2(self, rows, cards):

        start_time = time.time()
        iters = [0]
        # limitations
        max_time = 5.0                  # seconds
        max_iters = 2*len(cards)

        def is_suitable(stack, cards):
            for s in stack.blockmap.below:
                if cards[s.id] == 1:
                    continue
                # check if below stacks are non-empty
                if cards[s.id] is None:
                    return False

            for s in stack.blockmap.left:
                if cards[s.id] == 1:
                    continue
                if cards[s.id] is None:
                    for t in s.blockmap.all_left:
                        if cards[t.id] == 1:
                            continue
                        if cards[t.id] is not None:
                            # we have empty stack between two non-empty
                            return False

            for s in stack.blockmap.right:
                if cards[s.id] == 1:
                    continue
                if cards[s.id] is None:
                    for t in s.blockmap.all_right:
                        if cards[t.id] == 1:
                            continue
                        if cards[t.id] is not None:
                            # we have empty stack between two non-empty
                            return False
            return True

        def create_solvable(cards, new_cards):
            iters[0] += 1
            if iters[0] > max_iters:
                return None
            if time.time() - start_time > max_time:
                return None
            if not cards:
                return new_cards

            nc = new_cards[:]

            # select two matching cards
            c1 = cards[0]
            del cards[0]
            c2 = None
            for i in range(len(cards)):
                if self.cardsMatch(c1, cards[i]):
                    c2 = cards[i]
                    del cards[i]
                    break

            # find suitable stacks
            #  suitable_stacks = []
            #  for r in rows:
            #      if nc[r.id] is None and is_suitable(r, nc):
            #          suitable_stacks.append(r)
            suitable_stacks = [r for r in rows
                               if nc[r.id] is None and is_suitable(r, nc)]

            old_pairs = []
            i = factorial(len(suitable_stacks))//2 \
                // factorial(len(suitable_stacks)-2)
            for j in range(i):
                if iters[0] > max_iters:
                    return None
                if time.time() - start_time > max_time:
                    return None

                # select two suitable stacks
                while True:
                    # create a uniq pair
                    r1 = self.random.randrange(0, len(suitable_stacks))
                    r2 = self.random.randrange(0, len(suitable_stacks))
                    if r1 == r2:
                        continue
                    if (r1, r2) not in old_pairs and (r2, r1) not in old_pairs:
                        old_pairs.append((r1, r2))
                        break
                s1 = suitable_stacks[r1]
                s2 = suitable_stacks[r2]
                # check if s1 don't block s2
                nc[s1.id] = c1
                if not is_suitable(s2, nc):
                    nc[s1.id] = None
                    continue
                nc[s2.id] = c2
                # check if this layout is solvable (backtracking)
                ret = create_solvable(cards[:], nc)
                if ret:
                    ret = [x for x in ret if x != 1]
                    return ret
                nc[s1.id] = nc[s2.id] = None  # try another way

            return None

        new_cards = [None]*len(self.s.rows)  # None - empty stack, 1 - non-used
        drows = dict.fromkeys(rows)     # optimization
        for r in self.s.rows:
            if r not in drows:
                new_cards[r.id] = 1
        del drows

        while True:
            ret = create_solvable(cards[:], new_cards)
            if DEBUG:
                print('create_solvable time:', time.time() - start_time)
            if ret:
                ret.reverse()
                return ret
            if time.time() - start_time > max_time or \
                    iters[0] <= max_iters:
                print('oops! can\'t create a solvable game')
                return None
            iters = [0]
        print('oops! can\'t create a solvable game')
        return None

    def _mahjonggShuffle(self):
        talon = self.s.talon
        rows = []
        cards = []

        for r in self.s.rows:
            if r.cards:
                rows.append(r)
                cards.append(r.cards[0])
        if not rows:
            return

        if self.app.opt.mahjongg_create_solvable == 0:
            self.playSample('turnwaste')
            old_state = self.enterState(self.S_FILL)
            self.saveSeedMove()
            for r in rows:
                self.moveMove(1, r, talon, frames=0)
            self.shuffleStackMove(talon)
            for r in rows:
                self.moveMove(1, talon, r, frames=0)
            self.leaveState(old_state)
            self.finishMove()
            return

        self.playSample('turnwaste')
        old_state = self.enterState(self.S_FILL)
        self.saveSeedMove()

        new_cards = self._shuffleHook2(rows, cards)
        if new_cards is None:
            if TOOLKIT != 'kivy':
                MfxMessageDialog(self.top, title=_('Warning'),
                                 text=_('''\
Sorry, I can\'t find
a solvable configuration.'''),
                                 bitmap='warning')

            self.leaveState(old_state)
            # self.finishMove()
            # hack
            am = self.moves.current[0]
            am.undo(self)               # restore random
            self.moves.current = []
            return

        self.stats.shuffle_moves += 1
        # move new_cards to talon
        for c in new_cards:
            for r in rows:
                if r.cards and r.cards[0] is c:
                    self.moveMove(1, r, talon, frames=0)
                    break
        # deal
        for r in rows:
            self.moveMove(1, talon, r, frames=0)

        self.leaveState(old_state)
        self.finishMove()

    def canShuffle(self):
        return True

    def startGame(self):
        assert len(self.s.talon.cards) == self.NCARDS
        # self.s.talon.dealRow(rows = self.s.rows, frames = 0)
        n = 12
        self.s.talon.dealRow(rows=self.s.rows[:self.NCARDS-n], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[self.NCARDS-n:])
        assert len(self.s.talon.cards) == 0

    def isGameWon(self):
        return sum([len(f.cards) for f in self.s.foundations]) == self.NCARDS

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        if stack1.basicIsBlocked() or stack2.basicIsBlocked():
            return 0
        return self.cardsMatch(card1, card2)

    def getAutoStacks(self, event=None):
        return ((), (), ())

    def updateText(self):
        if self.preview > 1 or self.texts.info is None:
            return

        # find matching tiles
        stacks = []
        for r in self.s.rows:
            if r.cards and not r.basicIsBlocked():
                stacks.append(r)
        f, i = 0, 0
        for r in stacks:
            n = 0
            for t in stacks[i+1:]:
                if self.cardsMatch(r.cards[0], t.cards[0]):
                    n += 1
            # if n == 3: n = 1
            # elif n == 2: n = 0
            n = n % 2
            f += n
            i += 1

        if f == 0:
            f = _('No Free\nMatching\nPairs')
        else:
            f = ungettext('%d Free\nMatching\nPair',
                          '%d Free\nMatching\nPairs',
                          f) % f
        t = sum([len(ii.cards) for ii in self.s.foundations])
        r1 = ungettext('%d\nTile\nRemoved\n\n',
                       '%d\nTiles\nRemoved\n\n',
                       t) % t
        r2 = ungettext('%d\nTile\nRemaining\n\n',
                       '%d\nTiles\nRemaining\n\n',
                       self.NCARDS - t) % (self.NCARDS - t)

        t = r1 + r2 + f
        self.texts.info.config(text=t)

    #
    # Mahjongg special overrides
    #

    def getHighlightPilesStacks(self):
        # Mahjongg special: highlight all moveable tiles
        return ((self.s.rows, 1),)

    def _highlightCards(self, info, sleep=1.5, delta=(1, 1, 1, 1)):
        if not Image:
            delta = (-self._delta_x, 0, 0, -self._delta_y)
            return Game._highlightCards(self, info, sleep=sleep, delta=delta)

        if not info:
            return 0
        if self.pause:
            return 0
        self.stopWinAnimation()
        items = []
        for s, c1, c2, color in info:
            assert c1 is c2
            assert c1 in s.cards
            x, y = s.x, s.y
            img = self.app.images.getHighlightedCard(
                c1.deck, c1.suit, c1.rank, 'black')
            if img is None:
                continue
            img = MfxCanvasImage(self.canvas, x, y, image=img,
                                 anchor=ANCHOR_NW, group=s.group)
            if self.drag.stack and s is self.drag.stack:
                img.tkraise(self.drag.shade_img)
            else:
                img.tkraise(c1.item)
            items.append(img)
        if not items:
            return 0
        self.canvas.update_idletasks()
        if sleep:
            self.sleep(sleep)
            items.reverse()
            for r in items:
                r.delete()
            self.canvas.update_idletasks()
            return EVENT_HANDLED
        else:
            # remove items later (find_card_dialog)
            return items

    def getCardFaceImage(self, deck, suit, rank):
        if suit == 3:
            cs = self.app.cardset
            if len(cs.ranks) >= 12 and len(cs.suits) >= 4:
                # make Mahjongg type games playable with other cardsets
                if rank >= 8:       # flower
                    suit = 1
                    rank = len(cs.ranks) - 2
                elif rank >= 4:     # season
                    rank = max(10, len(cs.ranks) - 3)
                else:               # wind
                    suit = rank
                    rank = len(cs.ranks) - 1
        return self.app.images.getFace(deck, suit, rank)

    def getCardBackImage(self, deck, suit, rank):
        # We avoid screen updates caused by flipping cards - all
        # cards are face up anyway. The Talon should be invisible
        # or else the top tile of the Talon will be visible during
        # game start.
        return self.getCardFaceImage(deck, suit, rank)

    def _createCard(self, id, deck, suit, rank, x, y):
        # if deck >= 1 and suit == 3 and rank >= 4:
        if deck % 4 and suit == 3 and rank >= 4:
            return None
        return Game._createCard(self, id, deck, suit, rank, x, y)

    def _getClosestStack(self, cx, cy, stacks, dragstack):
        closest, cdist = None, 999999999
        # Since we only compare distances,
        # we don't bother to take the square root.
        for stack in stacks:
            dist = (stack.x - cx)**2 + (stack.y - cy)**2
            if dist < cdist:
                # Mahjongg special: if the stack is very close, do
                # not consider blocked stacks
                if dist > self.check_dist or not stack.basicIsBlocked():
                    closest, cdist = stack, dist
        return closest

    #
    # Mahjongg extras
    #

    def cardsMatch(self, card1, card2):
        if card1.suit != card2.suit:
            return 0
        if card1.suit == 3:
            if card1.rank >= 8:
                return card2.rank >= 8
            if card1.rank >= 4:
                return 7 >= card2.rank >= 4
        return card1.rank == card2.rank


#  mahjongg util
def comp_cardset(ncards):
    # calc decks, ranks & trumps
    assert ncards % 4 == 0
    assert 0 < ncards <= 288  # ???
    decks = 1
    cards = ncards//4
    if ncards > 144:
        assert ncards % 8 == 0
        decks = 2
        cards = cards//2
    ranks, trumps = divmod(cards, 3)
    if ranks > 10:
        trumps += (ranks-10)*3
        ranks = 10
    if trumps > 4:
        trumps = 4+(trumps-4)*4
    assert 0 <= ranks <= 10 and 0 <= trumps <= 12
    return decks, ranks, trumps

# ************************************************************************
# * register a Mahjongg type game
# ************************************************************************


def r(id, short_name, name=None, ncards=144, layout=None):
    assert layout
    if not name:
        name = "Mahjongg " + short_name
    classname = re.sub('\\W', '', name)
    # create class
    gameclass = type(classname, (AbstractMahjonggGame,), {})
    gameclass.L = layout
    gameclass.NCARDS = ncards
    decks, ranks, trumps = comp_cardset(ncards)
    gi = GameInfo(id, gameclass, name,
                  GI.GT_MAHJONGG, 4*decks, 0,  # GI.SL_MOSTLY_SKILL,
                  category=GI.GC_MAHJONGG, short_name=short_name,
                  suits=list(range(3)), ranks=list(range(ranks)),
                  trumps=list(range(trumps)),
                  si={"decks": decks, "ncards": ncards})
    gi.ncards = ncards
    gi.rules_filename = "mahjongg.html"
    registerGame(gi)
    return gi
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.games.mahjongg.mahjongg import r

# ************************************************************************
# * game definitions
# ************************************************************************

r(5001, "Altar", layout="0aaaacaaiaakaama" +
    "aoaaqaasaauaawaa" +
    "CaaEaaacaccaicck" +
    "ccmccoccqccsccuc" +
    "awcaCcaEcaieckec" +
    "mecoecqecsecueaw" +
    "eaigckgcmgcogcqg" +
    "csgcugawgaiiakia" +
    "miaoiaqiasiauiaw" +
    "iaokaqkaamacmaom" +
    "aqmaCmaEmaaoacoa" +
    "ooaqoaCoaEohabhc" +
    "bhCbhEbkpijpkipm" +
    "hanhcnhCnhEnhpoo" +
    "bboDbobnoDnvlcvn" +
    "cvpcvrcvtcvlevne" +
    "vpevrevtevlgwngw" +
    "pgwrgvtgCocCqcCm" +
    "eCoeCqeCse")
r(5002, "Arena", layout="0eaadcaceabgaaia" +
    "aqabsacuadwaeyad" +
    "accccbecagcakcbm" +
    "caocascbuccwcdyc" +
    "caebceaeeameaueb" +
    "wecyebagacgakgbm" +
    "gaogawgbygcaibci" +
    "aeiamiauibwicyid" +
    "akcckbekagkakkbm" +
    "kaokaskbukcwkdyk" +
    "eamdcmcembgmaima" +
    "qmbsmcumdwmeym")
r(5003, "Arena 2", layout="0daadcabeabgaaia" +
    "akaamaaoaaqaasab" +
    "uabwadyadAadaccc" +
    "cbecagcaucbwccyc" +
    "dAcdaecceaeeawec" +
    "yedAedagccgaegaw" +
    "gcygdAgdaicciaei" +
    "awicyidAidakcckb" +
    "ekagkaukbwkcykdA" +
    "kdamdcmbembgmaim" +
    "asmbumbwmdymdAm")
#
r(5004, "Arrow", layout="0aaaaqbaacaccasc" +
    "aqdaudaaeaceaeea" +
    "geaieakeameaoeas" +
    "eaweaqfaufayfaag" +
    "acgaegaggaigakga" +
    "mgaogasgawgaAgaC" +
    "gaqhauhayhaaiaci" +
    "aeiagiaiiakiamia" +
    "oiasiawiaqjaujaa" +
    "kackaskaqlaamhbc" +
    "hrdhbehdehfehheh" +
    "jehlehnehpehtehr" +
    "fhvfhbghdghfghhg" +
    "hjghlghnghpghtgh" +
    "xghrhhvhhbihdihf" +
    "ihhihjihlihnihpi" +
    "htihrjhbkoceoeeo" +
    "geoieokeomeooeoq" +
    "eosfocgoegoggoig" +
    "okgomgoogoqgougo" +
    "shocioeiogioiiok" +
    "iomiooioqivfevhe" +
    "vjevlevnevpevfgv" +
    "hgvjgvlgvngvpgvr" +
    "gvfivhivjivlivni" +
    "vpiCkeCmeCoeCkgC" +
    "mgCogCqgCkiCmiCo" +
    "i")
r(5005, "Art Moderne", layout="0acaaeaagaaiaaka" +
    "amaaoaauaawaaaba" +
    "lcapcatcavcaxcaa" +
    "daddaleapeaseaue" +
    "bxeaafacfalganga" +
    "pgargatgavgaxgaa" +
    "hachaliapiasiaui" +
    "bxiaajadjalkapka" +
    "tkavkaxkaalacmae" +
    "magmaimakmammaom" +
    "aumawmhdahfahhah" +
    "jahlahnahvahxahu" +
    "chwchychedhldhpd" +
    "haehtehvehdfhlfh" +
    "pfhaghsghughwghd" +
    "hhlhhphhaihtihvi" +
    "hejhljhpjhukhwkh" +
    "ykhdmhfmhhmhjmhl" +
    "mhnmhvmhxmowaoya" +
    "ovcoxcozcofdokdo" +
    "ueoweoyeoefokfom" +
    "gotgovgoehokhoui" +
    "owioyiofjokjovko" +
    "xkozkowmoymvgdvj" +
    "dvffvjfvlgvfhvjh" +
    "vgjvjjChdCgfCifC" +
    "kgCghCihChj")
r(5006, "Balance", layout="0eoaeebbgbbibbkb" +
    "bmbbqbbsbbubbwbe" +
    "ybeoccedcydcoecc" +
    "faefcgfcwfayfcAf" +
    "cogachaghawhaAhc" +
    "oiaajacjaejagjai" +
    "jaujawjayjaAjaCj" +
    "cokadlaflaxlazlc" +
    "omagoaioakoamoao" +
    "oaqoasoauoawohbj" +
    "hdjhfjhhjhvjhxjh" +
    "zjhBjjeljylhhoij" +
    "ojloknokpojroito" +
    "hvoocjoejogjowjo" +
    "yjoAjvdjvfjvxjvz" +
    "jCejCyj")
r(5007, "Bat", layout="0ecaeAaaabalbanb" +
    "apbarbaCbcccaeca" +
    "yccAcaadandapdaC" +
    "dcceaeebgeaieaue" +
    "bweayecAeaafanfa" +
    "pfaCfbcgbegaggbi" +
    "gakgasgbugawgbyg" +
    "bAgaahamhbohaqha" +
    "Chbcibeiagibiiak" +
    "iasibuiawibyibAi" +
    "aajamjbojaqjaCjc" +
    "ckaekbgkaikakkas" +
    "kaukbwkaykcAkaal" +
    "aolaClccmaemaima" +
    "kmasmaumaymcAmaa" +
    "naCnecobkobsoeAo" +
    "hobhodhofhaghCgh" +
    "aihCi")
#
r(5008, "Beatle", layout="0aeaagaauaawaaic" +
    "akcamcaocaqcasca" +
    "eeageaieakeameao" +
    "eaqeaseaueadgafg" +
    "ahgajgalgangapga" +
    "rgatgavgaeiagiai" +
    "iakiamiaoiaqiasi" +
    "auiaikakkamkaoka" +
    "qkaskaemagmaumaw" +
    "mhhbhtbhjchlchnc" +
    "hpchrchdehfehheh" +
    "jehlehnehpehreht" +
    "eiegiggiigikgimg" +
    "iogiqgisghughdih" +
    "fihhihjihlihnihp" +
    "ihrihtihjkhlkhnk" +
    "hpkhrkhhlhtloceo" +
    "geoieokeomeooeoq" +
    "eoseociogioiioki" +
    "omiooioqiosivbdv" +
    "hevjevlevnevpevr" +
    "evfgvhgvjgvlgvng" +
    "vpgvrgvhivjivliv" +
    "nivpivrivbjCaaCa" +
    "cCggCigCkgCmgCog" +
    "CqgCakCam")
r(5009, "Big Hole", layout="0daadcadeadgadia" +
    "dkadmadoaaaccccd" +
    "ecdgcdicdkccmcao" +
    "caaeccedeedkecme" +
    "aoeaagccgdegdkgc" +
    "mgaogaaiccideidg" +
    "idiidkicmiaoidak" +
    "dckdekdgkdikdkkd" +
    "mkdok")
r(5010, "Bizarre", layout="0aaaaGadkbdmbdob" +
    "dqbdsbdubdwbdkdc" +
    "mdcodcqdcsdcuddw" +
    "ddkfcmfbofbqfbsf" +
    "cufdwfdkhcmhboha" +
    "qhbshcuhdwhakjbm" +
    "jcojdqjcsjbujawj" +
    "aklbmlcolcqlcslb" +
    "ulawlaknbmnbonbq" +
    "nbsnbunawnakpamp" +
    "aopaqpaspaupawpa" +
    "aqaGq")
r(5011, "Boat", layout="0alaapaataajcblc" +
    "apcbtcavcahebjec" +
    "leapectebveaxeaf" +
    "gbhgcjgdlgapgdtg" +
    "cvgbxgazgadibfic" +
    "hidjieliapietidv" +
    "icxibziaBiapkaam" +
    "bcmbembgmbimbkmb" +
    "mmbombqmbsmbumbw" +
    "mbymbAmbCmaEmado" +
    "bfobhobjoblobnob" +
    "pobrobtobvobxobz" +
    "oaBoaiqbkqbmqboq" +
    "bqqbsqbuqawq")
r(5012, "Bug", layout="0bhabnabtaajbapb" +
    "avbcadaidakdamda" +
    "odaqdasdaudawdac" +
    "eayeagfbifbkfbmf" +
    "bofbqfbsfbufbwfa" +
    "Afdegaygbchbghci" +
    "hckhcmhcohcqhcsh" +
    "cuhbwhaAhdeiayia" +
    "gjbijbkjbmjbojbq" +
    "jbsjbujbwjaAjack" +
    "aykcalailaklamla" +
    "olaqlaslaulawlaj" +
    "napnavnbhobnobto" +
    "hyhojfolfonfopfo" +
    "rfotfovfojjoljon" +
    "jopjorjotjovjvjh" +
    "vlhvnhvphvrhvthC" +
    "khCmhCohCqhCsh")
r(5013, "Butterfly", layout="0dmadqaaabaebayb" +
    "aCbagccocawcaada" +
    "edaidaudaydaCdac" +
    "eageakedoeaseawe" +
    "aAeaafaefbifamfa" +
    "qfbufayfaCfacgag" +
    "gbkgeogbsgawgaAg" +
    "aahaehbihbmhbqhb" +
    "uhayhaChaciagibk" +
    "ieoibsiawiaAiaaj" +
    "aejbijamjaqjbuja" +
    "yjaCjackagkakkeo" +
    "kaskawkaAkaalael" +
    "ailaulaylaClacma" +
    "gmeomawmaAmaanae" +
    "naynaCncoohgdhwd" +
    "heehyehcfhgfhwfh" +
    "AfhaghCghaihCihc" +
    "jhgjhwjhAjhekhyk" +
    "hglhwl")
#
r(5014, "Castle", layout="0eaaccaceacgacia" +
    "ckaemacacaccaeca" +
    "gcaicakccmcdaeac" +
    "eaeeageaieakedme" +
    "aoecagacgaegagga" +
    "igakgcmgbogaqgda" +
    "iaciaeiagiaiiaki" +
    "dmiaoicakackaeka" +
    "gkaikakkcmkeamcc" +
    "mcemcgmcimckmemm" +
    "hddhfdhhdhjdhdfh" +
    "ffhhfhjfhdhhfhhh" +
    "hhjhhdjhfjhhjhjj" +
    "oeeogeoieoegoggo" +
    "igoeiogioiivffvh" +
    "fvfhvhhCgg")
r(5015, "Cat and Mouse", layout="0cfabhacjablacna" +
    "bpacrabtacBacFab" +
    "dbbvbbbcbxcbBccD" +
    "cbFcahdajdaldbzd" +
    "baecBebDecFeahfa" +
    "jfalfbagahhajhal" +
    "hbuhbBhbbibsibwi" +
    "bFibqjbBjbckbokb" +
    "xkbFkcelbglcilbk" +
    "lcmlbsmbwmbunbAo" +
    "cCocEocGohiehkeh" +
    "ighkgohdojdoldoh" +
    "fojfolfohhojholh" +
    "oBkoFloAnvievkev" +
    "igvkgvBlvFmCjdCh" +
    "fClfCjh")
r(5016, "Ceremonial", layout="0bcabeaajaalaana" +
    "apaaraataavabAab" +
    "CabdcbfcbzcbBcaa" +
    "dapdaEdbeebgeane" +
    "arebyebAeaafbifb" +
    "kfapfbufbwfaEfbm" +
    "gbsgaahaphaEhbmi" +
    "bsiaajbijbkjapjb" +
    "ujbwjaEjbekbgkan" +
    "karkbykbAkaalapl" +
    "aElbdmbfmbzmbBmb" +
    "cobeoajoaloanoap" +
    "oaroatoavobAobCo" +
    "hkahmahoahqahsah" +
    "uahaehoehqehEeha" +
    "gipghEghaiipihEi" +
    "hakhokhqkhEkhkoh" +
    "mohoohqohsohuoon" +
    "aopaoraopeoahoEh" +
    "opkonoopoorovph")
r(5017, "Checkered", layout="0baabCaacbbebagb" +
    "bibakbbmbaobbqba" +
    "sbbubawbbybaAbbc" +
    "daedbgdaidbkdamd" +
    "bodaqdbsdaudbwda" +
    "ydbAdacfbefagfbi" +
    "fakfbmfaofbqfasf" +
    "bufawfbyfaAfbcha" +
    "ehbghaihbkhamhbo" +
    "haqhbshauhbwhayh" +
    "bAhacjbejagjbija" +
    "kjbmjaojbqjasjbu" +
    "jawjbyjaAjbclael" +
    "bglailbklamlbola" +
    "qlbslaulbwlaylbA" +
    "lacnbenagnbinakn" +
    "bmnaonbqnasnbuna" +
    "wnbynaAnbaobCo")
#
r(5018, "Chip", layout="0aeaaiaamaaqaata" +
    "becbgcbicbkcbmcb" +
    "ocbqcbscbucbwcaa" +
    "dbcdbydaAdbeecge" +
    "cieckecmecoecqec" +
    "secuebweaagbcgbe" +
    "gdggbigakgamgaog" +
    "aqgbsgdugbwgbyga" +
    "Agbeicgiciickicm" +
    "icoicqicsicuibwi" +
    "aajbcjbyjaAjbekb" +
    "gkbikbkkbmkbokbq" +
    "kbskbukbwkaemaim" +
    "ammaqmaum")
r(5019, "Columns", layout="0egaaiaakaamaaoa" +
    "aqaasaauaewaaeba" +
    "ybagcaicaocaucaw" +
    "ceadbcdaedaydbAd" +
    "eCdageekeameaoea" +
    "qeeseawebafbCfag" +
    "gakgasgawgaahamh" +
    "eohaqhaChagiakia" +
    "siawibajbCjagkdk" +
    "kamkaokaqkeskawk" +
    "ealbclaelaylbAle" +
    "Clagmaimaomaumaw" +
    "maenaynegoaioako" +
    "amoaooaqoasoauoe" +
    "wohgfhwfjghjwhhg" +
    "jhwj")
r(5020, "Crown", layout="0baabcabeabgabka" +
    "bmaboabqabsabwab" +
    "yabAabCabacaccae" +
    "cbgcbkcamcbocaqc" +
    "bscbwcaycaAcbCcb" +
    "aeaeebgebkeameaq" +
    "ebsebweayebCebag" +
    "aegbggbigbkgamga" +
    "qgbsgbugbwgaygbC" +
    "gbaiaeiagiaiiaki" +
    "amiaqiasiauiawia" +
    "yibCibakbCkbamac" +
    "maemagmaimakmbom" +
    "asmaumawmaymaAmb" +
    "Cmbaobcobeobgobi" +
    "obkoamobooaqobso" +
    "buobwobyobAobCo")
#
r(5021, "Cupola", layout="0aiaakaamaaoaaqa" +
    "asaagbaubaecawca" +
    "cdaydabfeofazfaa" +
    "hajhalhanhapharh" +
    "athaAhaajeojaAja" +
    "blazlacnaynaeoaw" +
    "oagpaupaiqakqamq" +
    "aoqaqqasqhjbhlbh" +
    "nbhpbhrbhhchtchf" +
    "dhvdhdehxehcghyg" +
    "hkhhmhhohhqhhshh" +
    "bihzihckhykhdmhx" +
    "mhfnhvnhhohtohjp" +
    "hlphnphpphrpokco" +
    "mcoocoqcoidosdog" +
    "eoueoefowfodholh" +
    "onhophorhoxhodjo" +
    "xjoelowlogmoumoi" +
    "nosnokoomoooooqo" +
    "vldvndvpdvjevrev" +
    "hfvtfvfgvvgvmhvo" +
    "hvqhveivwivfkvvk" +
    "vhlvtlvjmvrmvlnv" +
    "nnvpnCifCsfCggCu" +
    "gCnhCphCfiCviCgk" +
    "CukCilCsl")
r(5022, "Deep Well", layout="0acaaeaagaaiaaka" +
    "amaaaccccceccgcc" +
    "icckccmcaocaaecc" +
    "eeeeegeeieekecme" +
    "aoeaagccgeegekgc" +
    "mgaogaaiccieeiek" +
    "icmiaoiaakcckeek" +
    "egkeikekkcmkaoka" +
    "amccmcemcgmcimck" +
    "mcmmaomacoaeoago" +
    "aioakoamo")
r(5023, "Dragon", layout="0bgaaiaegceicdkc" +
    "cmcbocbqcbscbuca" +
    "wcaycaceaeeageai" +
    "eakebmeboeaqease" +
    "aueaweayeadgbfga" +
    "hgajgalgangapgaE" +
    "gayhaChaaiaciaei" +
    "agiaiiakiamiaoia" +
    "qiasiauiaAiaEiaC" +
    "jabkadkafkahkajk" +
    "alkaEkaamacmaema" +
    "gmbimakmaaoacobe" +
    "oagoaiockoamoixc" +
    "hdejhejigkkgjmgh" +
    "Ehhbihdikhikjijl" +
    "iiniipihrihtihCi" +
    "hEjhckhgkhkkhbmh" +
    "fmhboihopneocioE" +
    "iobn")
r(5024, "Dude", layout="0bfabtabhbbjbblb" +
    "brbaBbatcavcaxca" +
    "zcaedagdbldbndbp" +
    "dbrdacebjebueaye" +
    "aAeaCeaafbhfcmfc" +
    "ofcqfcsfbwfaEfbf" +
    "gckgcugbygcphbAh" +
    "beickicuicpjbBjc" +
    "jkclkcnkcrkctkcv" +
    "kcjmclmcnmcrmctm" +
    "cvmcpncjocvockqc" +
    "mqcoqcqqcsqcuq")
# r(5025, "Eagle", layout="0cmadoacqaasbbmc" +
#    "bocaedagdaudawdb" +
#    "cebieakebmeboeaq" +
#    "ebsebyeaefagfauf" +
#    "awfbcgbigakgbmgb" +
#    "ogaqgbsgbygaehag" +
#    "hauhawhaaiacibmi" +
#    "boiayiaAibejbwja" +
#    "akackbmkbokaykaA" +
#    "kaambkmanmbqmaAm" +
#    "cioclocpocsoheeh" +
#    "gehuehweheghgghu" +
#    "ghwghbihzihbkhzk" +
#    "omdoododeofeoheo" +
#    "teoveoxeomfoofod" +
#    "gofgohgotgovgoxg" +
#    "omhoohobjomjoojo" +
#    "zjvndveevgevuevw" +
#    "evnfvegvggvugvwg" +
#    "vnhvnjCfeCveCfgC" +
#    "vg")
r(5026, "Enterprise", layout="0agaaiaakaamaaoa" +
    "aqaasaauaawaayaa" +
    "acbccbecbgcbicbk" +
    "cbmcbocbqcbscbuc" +
    "bwcbycbAcbCcaEcd" +
    "qedogdmhaAiaajbc" +
    "jcejdgjeijekjemj" +
    "eojcqjayjaCjaAkh" +
    "haijailainaipair" +
    "aitaivahxaiAjodc" +
    "ofcohcojcolconco" +
    "pcorcotcovcoxcoz" +
    "coBcvkavmavoavqa" +
    "vsavecvgcvicvkcv" +
    "mcvocvqcvscvucvw" +
    "cvycChcCjcClcCnc" +
    "CpcCrcCtcCvc")
#
r(5027, "Eye", layout="0amaaoaakbaqbaic" +
    "amcaocascagdakda" +
    "qdaudaeeaieameao" +
    "easeaweacfagfakf" +
    "aqfaufayfaagaega" +
    "igamgaogasgawgaA" +
    "gachaghakhaqhauh" +
    "ayhaeiaiiamiaoia" +
    "siawiagjakjaqjau" +
    "jaikamkaokaskakl" +
    "aqlammaomhlbhobh" +
    "jchqchhdhldhodhs" +
    "dhfehjehqehuehdf" +
    "hhfhlfhofhsfhwfh" +
    "fghjghqghughdhhh" +
    "hhlhhohhshhwhhfi" +
    "hjihqihuihhjhljh" +
    "ojhsjhjkhqkhllho" +
    "lolcoocojdoqdohe" +
    "oleooeoseoffojfo" +
    "qfoufohgolgoogos" +
    "gowgofhojhoqhouh" +
    "ohioliooiosiojjo" +
    "qjolkookvldvodvj" +
    "evqevhfvlfvofvsf" +
    "vfgvjgvqgvhhvlhv" +
    "ohvshvjivqivljvo" +
    "j")
r(5028, "F-15 Eagle", layout="0aobaqbasbaubbEc" +
    "bGcandapdardatda" +
    "lebDebFeajfanfap" +
    "farfalgatgavgaxg" +
    "azgaBgaDgabhadha" +
    "fhahhajhanhaphar" +
    "haliatiaviaxiazi" +
    "aBiaDiajjanjapja" +
    "rjalkbDkbFkanlap" +
    "larlatlbEmbGmaon" +
    "aqnasnaunhpahrah" +
    "tahvahochqchschu" +
    "chmehoehqehsehif" +
    "hkfhmghoghqghsgh" +
    "ughwghyghAghCgia" +
    "hichjehjghjihjkh" +
    "hmihoihqihsihuih" +
    "wihyihAihCihijhk" +
    "jhmkhokhqkhskhom" +
    "hqmhsmhumhpohroh" +
    "tohvoozfoBfoDfom" +
    "hozjoBjoDjvAfvCf" +
    "vAjvCjCBfCDfCfhC" +
    "hhCjhCBjCDj")
r(5029, "Farandole", layout="0beabgabmaboabqa" +
    "bwabyabcbbibbkbb" +
    "sbbubbAbafcaxcbb" +
    "dbBdckecmecqecse" +
    "bbfbgfcifcufbwfb" +
    "Bfbegbygbahbchaj" +
    "hblhcnhcphbrhath" +
    "bAhbChbeibyibbjb" +
    "gjcijcujbwjbBjck" +
    "kcmkcqkcskbblbBl" +
    "afmaxmbcnbinbknb" +
    "snbunbAnbeobgobm" +
    "oboobqobwobyo")
r(5030, "Fish", layout="0afaajaasaauaawa" +
    "bhbaobaqbaybacca" +
    "mcbscbucbwcaAcak" +
    "dbodbqdaydaCdace" +
    "aeeaiebmebsebueb" +
    "weaEeagfbkfbofbq" +
    "fayfaCfacgaegaig" +
    "bmgbsgbugbwgaAga" +
    "EgakhbohbqhbyhaC" +
    "haciamibsibuibwi" +
    "aAiaojaqjayjahka" +
    "skaukawkbjlcemal" +
    "mbcndgnbCnaaoeio" +
    "aqoasodAoaEodkpb" +
    "opbupdypcmqcwqhc" +
    "dhcfhefhifhchore" +
    "oteolfonfopfovfo" +
    "rgotgovhoxh")
#
r(5031, "Five Pyramids", layout="0aaaacaaeaagaaya" +
    "aAaaCaaEaaacacca" +
    "ecagcapcaycaAcaC" +
    "caEcaaeaceaeeage" +
    "apeayeaAeaCeaEea" +
    "agacgaegaggangap" +
    "gargaygaAgaCgaEg" +
    "alhathaniapiaria" +
    "akackaekagkapkay" +
    "kaAkaCkaEkaamacm" +
    "aemagmapmaymaAma" +
    "CmaEmaaoacoaeoag" +
    "oayoaAoaCoaEoaaq" +
    "acqaeqagqayqaAqa" +
    "CqaEqhbbhdbhfbhz" +
    "bhBbhDbhbdhddhfd" +
    "hpdhzdhBdhDdhbfh" +
    "dfhffipfhzfhBfhD" +
    "fhnhhphhrhipjhbl" +
    "hdlhflhplhzlhBlh" +
    "DlhbnhdnhfnhznhB" +
    "nhDnhbphdphfphzp" +
    "hBphDpoccoecoAco" +
    "CcoceoeeoAeoCeoo" +
    "hoqhocmoemoAmoCm" +
    "ocooeooAooCovddv" +
    "BdvphvdnvBn")
# r(5032, "Five Pyramids 2", layout="0aoaaabacbaebagb" +
#    "awbaybaAbaCbboca" +
#    "adacdaedagdaidak" +
#    "damdaqdasdaudawd" +
#    "aydaAdaCdcoeaafa" +
#    "cfaefagfawfayfaA" +
#    "faCfamgdogaqgadh" +
#    "azhagibiickidmid" +
#    "oidqicsibuiawiad" +
#    "jazjamkdokaqkaal" +
#    "aclaelaglawlayla" +
#    "AlaClcomaanacnae" +
#    "nagnainaknamnaqn" +
#    "asnaunawnaynaAna" +
#    "Cnbooaapacpaepag" +
#    "pawpaypaApaCpaoq" +
#    "hbchdchfchxchzch" +
#    "Bchbehdehfehxehz" +
#    "ehBehbmhdmhfmhxm" +
#    "hzmhBmhbohdohfoh" +
#    "xohzohBoocdoedoy" +
#    "doAdocnoenoynoAn")
r(5033, "Flowers", layout="0baaccaceabgaaka" +
    "bmaboaaqaauabwab" +
    "yaaAadacdgcckccq" +
    "ccuccAcbaeccecee" +
    "bgeakebmeboeaqea" +
    "uebwebyeaAeadgan" +
    "gaxgafhahhajhalh" +
    "apharhathavhadia" +
    "niaxiaakbckbekag" +
    "kakkbmkbokaqkauk" +
    "bwkbykaAkcamcgmc" +
    "kmcqmcumcAmaaobc" +
    "obeoagoakobmoboo" +
    "aqoauobwobyoaAoo" +
    "naoxaoneoxeodkon" +
    "koxkodoonooxovda" +
    "vde")
r(5034, "Flying Dragon", layout="0acaaeaagaaiaaka" +
    "amaaoaaqaasaauaa" +
    "waayaagcbicbkcbm" +
    "cbocbqcbscaucaee" +
    "agebieckecmecoec" +
    "qebseaueaweacgae" +
    "gaggbigckgdmgdog" +
    "cqgbsgaugawgayga" +
    "ahaAhaChaciaeiag" +
    "ibiickidmidoicqi" +
    "bsiauiawiayiaeka" +
    "gkbikckkcmkcokcq" +
    "kbskaukawkagmbim" +
    "bkmbmmbombqmbsma" +
    "umacoaeoagoaioak" +
    "oamoaooaqoasoauo" +
    "awoayoCnh")
r(5035, "Fortress Towers", layout="0faaecadeacgabia" +
    "bkacmadoaeqafsae" +
    "acaccagcaicakcam" +
    "caqcescdaeaceage" +
    "aieakeameaqedsed" +
    "agacgaggaigakgam" +
    "gaqgdsgeaiaciagi" +
    "aiiakiamiaqiesif" +
    "akeckdekcgkbikbk" +
    "kcmkdokeqkfskhjc" +
    "hjehjghji")
#
r(5036, "Full Vision", layout="0aaaaiaamaaoaaqa" +
    "asaawaaEaacbaeba" +
    "gbaybaAbaCbaacai" +
    "camcaocaqcascawc" +
    "aEcacdaedagdayda" +
    "AdaCdaaeaieaweaE" +
    "eaefamfasfaAfagg" +
    "aigakgaugawgayga" +
    "ehamhashaAhagiai" +
    "iakiauiawiayiaej" +
    "amjasjaAjaakaika" +
    "wkaEkaclaelaglay" +
    "laAlaClaamaimaom" +
    "aqmawmaEmacnaena" +
    "gnamnasnaynaAnaC" +
    "naaoaioaooaqoawo" +
    "aEohpahbbhhbhnbh" +
    "rbhxbhDbhdchfchp" +
    "chzchBchbdhhdhxd" +
    "hDdhfghlghtghzgh" +
    "hhhjhhvhhxhhfihl" +
    "ihtihzihblhhlhxl" +
    "hDlhdmhfmhzmhBmh" +
    "bnhhnhnnhpnhrnhx" +
    "nhDnooboqboccogc" +
    "oycoCcoghokhouho" +
    "yhocmogmoymoCmvp" +
    "b")
#
r(5037, "Full Vision 2", layout="0aaaacaafaahaaka" +
    "amaapaaraauaawaa" +
    "zaaBaaacaccafcah" +
    "cakcamcapcarcauc" +
    "awcazcaBcaaeacea" +
    "feaheakeameapear" +
    "eaueaweazeaBeaag" +
    "acgafgahgakgamga" +
    "pgargaugawgazgaB" +
    "gaajacjaejagjakj" +
    "amjapjarjavjaxja" +
    "zjaBjaalaclaelag" +
    "laklamlaplarlavl" +
    "axlazlaBlaeoagoa" +
    "ioakoamoapoaroat" +
    "oavoaxohbbhgbhlb" +
    "hqbhvbhAbhadhcdh" +
    "fdhhdhkdhmdhpdhr" +
    "dhudhwdhzdhBdhbf" +
    "hgfhlfhqfhvfhAfh" +
    "djhyjhbkhfkhkkhm" +
    "khpkhrkhwkhAkhdl" +
    "hylobcogcolcoqco" +
    "vcoAcobeogeoleoq" +
    "eoveoAeockoekolk" +
    "oqkoxkozkvbdvgdv" +
    "ldvqdvvdvAdvdkvy" +
    "k")
r(5038, "Future", layout="0cgaaiaakaamaboa" +
    "aqaasaauacwaagcc" +
    "icakcamcbocaqcas" +
    "ccucawcaeeageaie" +
    "bkebmeboebqebsea" +
    "ueaweayeacfaAfaa" +
    "gcegcggdigdkgdmg" +
    "dogdqgdsgdugcwgc" +
    "ygaCgachaAhaeiag" +
    "iaiibkibmiboibqi" +
    "bsiauiawiayiagkc" +
    "ikakkamkbokaqkas" +
    "kcukawkcgmaimakm" +
    "ammbomaqmasmaumc" +
    "wmhcghAgoneopeon" +
    "iopiClgCngCpgCrg")
r(5039, "Garden", layout="0adaafaaoaaqaaza" +
    "aBaaabaibalbatba" +
    "wbaEbaccaecagcan" +
    "capcarcaycaAcaCc" +
    "aadaidaldatdawda" +
    "Edaceaeeageaneap" +
    "eareayeaAeaCeaaf" +
    "aifalfatfawfaEfa" +
    "chaehaghanhaphar" +
    "hayhaAhaChaajaij" +
    "aljatjawjaEjacka" +
    "ekagkankapkarkay" +
    "kaAkaCkaalailall" +
    "atlawlaElacmaema" +
    "gmanmapmarmaymaA" +
    "maCmaanainalnatn" +
    "awnaEnadoafoaooa" +
    "qoazoaBoheahpahA" +
    "ahcdhedhgdhndhpd" +
    "hrdhydhAdhCdhdhh" +
    "fhhohhqhhzhhBhhc" +
    "lhelhglhnlhplhrl" +
    "hylhAlhClheohpoh" +
    "Aooddofdoodoqdoz" +
    "doBdoehophoAhodl" +
    "oflooloqlozloBlv" +
    "edvpdvAdvelvplvA" +
    "l")
r(5040, "Gayle's", layout="0dcaceabgaaiaaka" +
    "amaaoaaqaasabuac" +
    "wadyaagcbicckccm" +
    "ccoccqcbscaucake" +
    "bmeboeaqeacgaega" +
    "ggbigbkgbmgbogbq" +
    "gbsgaugawgaygaah" +
    "aAhaciaeiagibiib" +
    "kibmiboibqibsiau" +
    "iawiayiakkbmkbok" +
    "aqkagmbimckmcmmc" +
    "omcqmbsmaumdcoce" +
    "obgoaioakoamoaoo" +
    "aqoasobuocwodyoo" +
    "jholhonhophorhvn" +
    "cvmhvohvnmCnh")
r(5041, "Glade", layout="0aaaacaaCaaEaaac" +
    "accaCcaEcahdejdc" +
    "ldcndbpdcrdctdev" +
    "daxddhfcjfblfbnf" +
    "bpfbrfbtfcvfdxfc" +
    "hhbjhblhanharhbt" +
    "hbvhcxhdhjcjjblj" +
    "bnjbpjbrjbtjcvjd" +
    "xjahlejlcllcnlbp" +
    "lcrlctlevlaxlaam" +
    "acmaCmaEmaaoacoa" +
    "CoaEohbahDahbchD" +
    "chbmhDmhbohDoobb" +
    "oDbobnoDn")
r(5042, "H for Haga", layout="0aaaacaaeaagaaka" +
    "amaaoaaqaaacacca" +
    "ecagcakcamcaocaq" +
    "caaeaceaeeageake" +
    "ameaoeaqeaifaaga" +
    "cgaegaggakgamgao" +
    "gaqgaihaaiaciaei" +
    "agiakiamiaoiaqia" +
    "ijaakackaekagkak" +
    "kamkaokaqkaamacm" +
    "aemagmakmammaoma" +
    "qmaaoacoaeoagoak" +
    "oamoaooaqohbbhdb" +
    "hfbhlbhnbhpbhbdh" +
    "ddhfdhldhndhpdhb" +
    "fhdfhffhlfhnfhpf" +
    "hhghjghbhhdhhfhh" +
    "lhhnhhphhhihjihb" +
    "jhdjhfjhljhnjhpj" +
    "hblhdlhflhllhnlh" +
    "plhbnhdnhfnhlnhn" +
    "nhpnoccoecomcooc" +
    "oceoeeomeooeocgo" +
    "egomgoogoghoihok" +
    "hocioeiomiooiock" +
    "oekomkookocmoemo" +
    "mmoomvddvndvdlvn" +
    "l")
# r(5043, "H for Haga Traditional", layout="0acaaeaagaaiaaka" +
#    "amaaoaaqaasaauaa" +
#    "waayabgcbicakcam" +
#    "caocaqcbscbucaee" +
#    "bgebieakeameaoea" +
#    "qebsebueaweacgae" +
#    "gbggbigbkgbmgbog" +
#    "bqgbsgbugawgayga" +
#    "ahaAhaciaeibgibi" +
#    "ibkibmiboibqibsi" +
#    "buiawiayiaekbgkb" +
#    "ikakkamkaokaqkbs" +
#    "kbukawkbgmbimakm" +
#    "ammaomaqmbsmbuma" +
#    "coaeoagoaioakoam" +
#    "oaooaqoasoauoawo" +
#    "ayoklcknckpchdhh" +
#    "xhklmknmkpm")
r(5044, "Helios", layout="0eaadcaduaewadac" +
    "bccbucdwcbaeacea" +
    "eeaiedkedmeaoeas" +
    "eauebwebagacgaeg" +
    "aggdigdogaqgasga" +
    "ugbwgblhbaiaciae" +
    "iagidiidoiaqiasi" +
    "auibwibakackaeka" +
    "ikdkkdmkaokaskau" +
    "kbwkdambcmbumdwm" +
    "eaodcoduoewohchh" +
    "ehhghhqhhshhuhCl" +
    "eCihCohClk")
r(5045, "High and Low", layout="0eaadcaceabgaaia" +
    "bkacmadoaeqadacc" +
    "ccdecagcbicckcbm" +
    "ceocdqccaebceeee" +
    "bgeciedkeamedoec" +
    "qebagacgdegcggdi" +
    "gekgbmgcogbqgaai" +
    "bciceidgieiidkic" +
    "miboiaqiaekagkbi" +
    "kakkamkahmajmhim")
#
# r(5046, "Hourglass", layout="0aaaacaaeaagaaia" +
#    "akaamaaoaaqaasaa" +
#    "uaawaayaaacamcay" +
#    "cacdawdaaeaeeame" +
#    "aueayeacfagfasfa" +
#    "wfaagaegaigamgaq" +
#    "gaugaygachaghbkh" +
#    "bohashawhaaiaeia" +
#    "iiamiaqiauiayiac" +
#    "jagjasjawjaakaek" +
#    "amkaukaykaclawla" +
#    "amammaymaaoacoae" +
#    "oagoaioakoamoaoo" +
#    "aqoasoauoawoayoh" +
#    "abhmbhybhadhmdhy" +
#    "dhcehwehafhefhuf" +
#    "hyfhcghgghsghwgh" +
#    "ahhehhihhqhhuhhy" +
#    "hhcihgihsihwihaj" +
#    "hejhujhyjhckhwkh" +
#    "alhmlhylhanhmnhy" +
#    "noacoycoaeoyeoag" +
#    "oygoaioyioakoyko" +
#    "amoymvadvydvafvy" +
#    "fvahvyhvajvyjval" +
#    "vylCaeCyeCagCygC" +
#    "aiCyiCakCyk")
r(5047, "Inca", layout="0aoaaqaaibakbamb" +
    "asbaubawbbocbqca" +
    "idbkdbmdbsdbudaw" +
    "dcoecqeaifbkfcmf" +
    "csfbufawfaagacgd" +
    "ogdqgaCgaEgahhbj" +
    "hclhcthbvhaxhaai" +
    "acidoidqiaCiaEia" +
    "hjbjjcljctjbvjax" +
    "jaakackdokdqkaCk" +
    "aEkailbklcmlcslb" +
    "ulawlcomcqmainbk" +
    "nbmnbsnbunawnboo" +
    "bqoaipakpampaspa" +
    "upawpaoqaqqhbihD" +
    "iCphCpj")
r(5048, "Inner Circle", layout="0aaaacaayaaAaaac" +
    "eccceccgcbicbkca" +
    "mcaocbqcbsccuccw" +
    "ceycaAcccecyedgf" +
    "cifbkfbqfcsfdufb" +
    "cgbygaghbuhbciby" +
    "iegjdijckjbmjboj" +
    "cqjdsjeujcckcyka" +
    "amecmcemcgmbimbk" +
    "mbqmbsmcumcwmdym" +
    "aAmaaoacoakoaqoa" +
    "yoaAo")
r(5049, "Joker", layout="0aaaaAaadbafbahb" +
    "ajbalbanbapbarba" +
    "tbavbaxbabdbddbf" +
    "dbhdbjdbldbndbpd" +
    "brdbtdbvdbxdazdc" +
    "bfbdfaffahfajfal" +
    "fanfapfarfatfavf" +
    "bxfczfcbhbdhafha" +
    "vhbxhczhajiamiap" +
    "iasicbjbdjafjavj" +
    "bxjczjcblbdlafla" +
    "hlajlallanlaplar" +
    "latlavlbxlczlabn" +
    "bdnbfnbhnbjnblnb" +
    "nnbpnbrnbtnbvnbx" +
    "naznadpafpahpajp" +
    "alpanpapparpatpa" +
    "vpaxpaaqaAqhgghu" +
    "ghgkhuk")
r(5050, "K for Kyodai", layout="0caaccaceacmacoa" +
    "cqacacbcccecckcb" +
    "mccoccaebceceeci" +
    "ebkecmecagbcgceg" +
    "cggbigckgcaibcib" +
    "eibgiciicakbckce" +
    "kcgkbikckkcambcm" +
    "cemcimbkmcmmcaob" +
    "coceockobmocooca" +
    "qccqceqcmqcoqcqq")
# r(5051, "K for Kyodai Traditional", layout="0acaaeaagaaiaaka" +
#    "amaaoaaqaasaauaa" +
#    "waayaagcaicakcam" +
#    "caocaqcascaucaee" +
#    "ageaieakeameaoea" +
#    "qeaseaueaweacgae" +
#    "gaggaigakgamgaog" +
#    "aqgasgaugawgayga" +
#    "ahaAhaciaeiagiai" +
#    "iakiamiaoiaqiasi" +
#    "auiawiayiaekagka" +
#    "ikakkamkaokaqkas" +
#    "kaukawkagmaimakm" +
#    "ammaomaqmasmauma" +
#    "coaeoagoaioakoam" +
#    "oaooaqoasoauoawo" +
#    "ayokjckrckpdkjeh" +
#    "gfknfhufkjghghkl" +
#    "hhuhkjihgjknjhuj" +
#    "kjkkplkjmkrm")
r(5052, "Km", layout="0baabcabiaakaboa" +
    "cqacyabAabacaccb" +
    "gcaicbocaqcdscdw" +
    "caycbAcdudbaeace" +
    "beeageboeaqeasea" +
    "weayebAeeufbagac" +
    "gbegaggbogaqgayg" +
    "bAgduhbaiacibgia" +
    "iiboiaqiayibAiba" +
    "kbckbikakkbokbqk" +
    "bykbAkjcfhgfoabo" +
    "oboAboadoodoAdoa" +
    "foefoofoAfoahooh" +
    "oAhoajoojoAjvacv" +
    "ocvAcvaevoevAeva" +
    "gvogvAgvaivoivAi" +
    "CadCodCAdCafCofC" +
    "AfCahCohCAh")
r(5053, "Kujaku", layout="0bnabpabrabtabva" +
    "bxablbczbaBbbhcb" +
    "jcancapcarcatcav" +
    "caxcaddbfdaldazd" +
    "dBdaDdaheajeabfc" +
    "dfaffaAfdCfaEfba" +
    "hcchaehakhamhaoh" +
    "ashaAhdChaEhabjc" +
    "djafjaAjdCjaEjah" +
    "kajkadlbflallazl" +
    "dBlaDlbhmbjmanma" +
    "pmarmatmavmaxmbl" +
    "ncznaBnbnobpobro" +
    "btobvobxohnghpgh" +
    "tghjhhnihpihtioo" +
    "foqfoufoihoojoqj" +
    "oujvpevrevvfvhhv" +
    "vjvpkvrkCwgCCgCg" +
    "hCwiCCi")
r(5054, "Labyrinth", layout="0caaacaaeaagaaia" +
    "akaamaaoaaqaasaa" +
    "uaawaayaaAaaCacE" +
    "aaacbkcbocbucaEc" +
    "aaebcebeebgebkeb" +
    "oebsebuebyebAeaE" +
    "eaagbkgbygaEgaai" +
    "beibiibkiboibqib" +
    "sibuibwibyibAiaE" +
    "iaakbekbokbwkaEk" +
    "aambembgmbimbkmb" +
    "ombqmbsmbwmbAmbC" +
    "maEmaaobkobwoaEo" +
    "caqacqbeqdgqdkqb" +
    "mqaoqaqqasqauqbw" +
    "qdyqdCqbEq")
r(5055, "Lion", layout="0bdbbfbcjbclbawb" +
    "aybbbcbhcaucaAcc" +
    "jdcldasdaCdbaeaq" +
    "ecvfczfaDfbbgapg" +
    "aEhcbiceichickia" +
    "oicxiaFjcckcfkci" +
    "kclkbokcwkcykbul" +
    "bAlaElcbmcemchmc" +
    "kmcnmbqmaDnccocf" +
    "ocioclocooaroato" +
    "avoaxoazoaBohvah" +
    "xahzahtbhBbhrchD" +
    "dhpehEfhoghFhhni" +
    "hGjhFlhEnhsohCoh" +
    "uphwphyphApwkc")
r(5056, "Lost ", layout="0afaaxaabbadbahb" +
    "ajbblbbnbbpbbrba" +
    "tbavbazbaBbafcax" +
    "cabdaddbkdcodbsd" +
    "azdaBdbiebmebqeb" +
    "ueaafacfaefbgfdo" +
    "fbwfayfaAfaCfaah" +
    "aehbghcihckhdmhd" +
    "ohdqhcshcuhbwhay" +
    "haChaajacjaejbgj" +
    "dojbwjayjaAjaCjb" +
    "ikbmkbqkbukablad" +
    "lbklcolbslazlaBl" +
    "afmaxmabnadnahna" +
    "jnblnbnnbpnbrnat" +
    "navnaznaBnafoaxo" +
    "ombooboqbomnoono" +
    "qn")
r(5057, "Maya", layout="0aaaacaaeaagaaia" +
    "aqaasaauaawaayaa" +
    "acaccaecagcaicaq" +
    "cascaucawcaycaae" +
    "aceaeeageaieakea" +
    "meaoeaqeaseaueaw" +
    "eayeaigakgamgaog" +
    "aqgaiiakiamiaoia" +
    "qiaakackaekagkai" +
    "kakkamkaokaqkask" +
    "aukawkaykaamacma" +
    "emagmaimaqmasmau" +
    "mawmaymaaoacoaeo" +
    "agoaioaqoasoauoa" +
    "woayohcbhebhgbhs" +
    "bhubhwbhcdhedhgd" +
    "hsdhudhwdhkfhmfh" +
    "ofhkhhmhhohhkjhm" +
    "jhojhclhelhglhsl" +
    "hulhwlhcnhenhgnh" +
    "snhunhwnoccoecog" +
    "coscoucowcolfonf" +
    "olhonholjonjocmo" +
    "emogmosmoumowmvd" +
    "cvfcvtcvvcvmfvmh" +
    "vmjvdmvfmvtmvvmC" +
    "ecCucCmgCmiCemCu" +
    "m")
r(5058, "Mesh", layout="0baabcabeabiabka" +
    "bmabqabsabuabyab" +
    "AabCabacbecbicbm" +
    "cbqcbucbycbCcbae" +
    "bcebeeagebiebkeb" +
    "meaoebqebsebueaw" +
    "ebyebAebCeaegbig" +
    "bmgbqgbugaygbaib" +
    "cibeiagibiibkibm" +
    "iaoibqibsibuiawi" +
    "byibAibCibakbekb" +
    "ikbmkbqkbukbykbC" +
    "kbambcmbembimbkm" +
    "bmmbqmbsmbumbymb" +
    "AmbCm")
r(5059, "Moth", layout="0baaccaceabgaana" +
    "apaarabyacAacCab" +
    "Eaaibawbbccagcak" +
    "ccpcaucaycbCcaid" +
    "amdasdawdadeakeb" +
    "oebqeaueaBeamfas" +
    "facgaegahgajgbog" +
    "bqgavgaxgaAgaCga" +
    "mhashadiakiboibq" +
    "iauiaBiaijamjasj" +
    "awjbckagkakkcpka" +
    "ukaykbCkailawlcc" +
    "mcembgmbpmbymcAm" +
    "cCmbanbEnhoahqah" +
    "ichwchmehsehdghi" +
    "ghwghBghmihsihik" +
    "hwkopaoneopeorep" +
    "pgoniopiorivdavB" +
    "avoevqevoivqivdm" +
    "vBmCpeCpi")
r(5060, "N for Namida", layout="0caaccaceacgacqa" +
    "csacuacacbccbecb" +
    "gcbiccqcbsccucca" +
    "ebcebeebgebiebke" +
    "cqebsecuecagbcgc" +
    "egbigbkgbmgcqgbs" +
    "gcugcaibciceibki" +
    "bmiboibqibsicuic" +
    "akbckcekbmkbokbq" +
    "kbskcukcamccmcem" +
    "comcqmcsmcum")
# r(5061, "N for Namida Traditional", layout="0acaaeaagaaiaaka" +
#    "amaaoaaqaasaauaa" +
#    "waayacgcaicakcbm" +
#    "ccoccqcasccucaee" +
#    "cgecieakeameaoea" +
#    "qeasecueaweacgae" +
#    "gcggcigakgcmgaog" +
#    "aqgasgcugawgayga" +
#    "ahaAhaciaeicgiai" +
#    "iakicmiaoicqiasi" +
#    "cuiawiayiaekcgka" +
#    "ikakkamkaokcqkas" +
#    "kcukawkcgmaimckm" +
#    "cmmbomaqmasmcuma" +
#    "coaeoagoaioakoam" +
#    "oaooaqoasoauoawo" +
#    "ayoikfikhiohioji" +
#    "sjisl")
# r(5062, "Naoki Haga Traditional", layout="0acaaeaagaaiaaka" +
#    "amaaoaaqaasaauaa" +
#    "waayadgcaicakcdm" +
#    "caocaqcascaucaee" +
#    "dgeaiedkedmeaoec" +
#    "qecseaueaweacgae" +
#    "gdggaigakgdmgaog" +
#    "aqgasgaugawgayga" +
#    "ahaAhaciaeiagiai" +
#    "iakiamidoiaqiasi" +
#    "duiawiayiaekagkc" +
#    "ikckkamkdokdqkds" +
#    "kdukawkagmaimakm" +
#    "ammdomaqmasmduma" +
#    "coaeoagoaioakoam" +
#    "oaooaqoasoauoawo" +
#    "ayojidvrevjk")
#
r(5063, "New Layout", layout="0aeaagaaiaakabpa" +
    "auaawaayaaAaacca" +
    "Ccahdajdavdaxdaa" +
    "eacealeateaCeaEe" +
    "anfarfaagacgahga" +
    "pgaCgaEganharhaa" +
    "iacialiatiaCiaEi" +
    "ahjajjavjaxjacka" +
    "Ckaemagmaimakmbp" +
    "maumawmaymaAmhfa" +
    "hhahjahvahxahzah" +
    "cdhidhwdhCdhkehu" +
    "ehafhcfhmfhofhqf" +
    "hsfhCfhEfhahhchh" +
    "mhhohhqhhshhChhE" +
    "hhkihuihcjhijhwj" +
    "hCjhfmhhmhjmhvmh" +
    "xmhzmogaoiaowaoy" +
    "aoceojeoveoCeolf" +
    "otfoagocgongopgo" +
    "rgoCgoEgolhothoc" +
    "iojiovioCiogmoim" +
    "owmoymvhavxavcfv" +
    "kfvufvCfvmgvogvq" +
    "gvsgvchvkhvuhvCh" +
    "vhmvxmCcgClgCngC" +
    "pgCrgCtgCCg")
r(5064, "Order", layout="0afaahaajaalaana" +
    "apaaraataaabayba" +
    "icakcamcaocaqcba" +
    "dacdaedaudawdbyd" +
    "akebmeaoecafbcfa" +
    "efaufbwfcyfaggai" +
    "gakgbmgaogaqgasg" +
    "cahcchbehbuhcwhc" +
    "yhagiaiiakibmiao" +
    "iaqiasicajbcjaej" +
    "aujbwjcyjakkbmka" +
    "okbalaclaelaulaw" +
    "lbylaimakmammaom" +
    "aqmaanaynafoahoa" +
    "joaloanoapoaroat" +
    "ohgahiaikaimaioa" +
    "hqahsahlchnchghh" +
    "ihhkhhohhqhhshhl" +
    "mhnmhgohioikoimo" +
    "ioohqohsoomcpmho" +
    "mm")
r(5065, "Pattern", layout="0aaaacaafaahaaka" +
    "amaapaaraauabwab" +
    "zaaBaaacaccafcah" +
    "cakcamcapcarcbuc" +
    "cwcczcbBccafacfa" +
    "ffchfckfcmfapfar" +
    "fcufawfazfcBfaah" +
    "cchcfhahhakhamhc" +
    "phcrhcuhawhazhcB" +
    "haakackafkahkakk" +
    "cmkcpkarkcukcwkc" +
    "zkcBkaamacmafmah" +
    "mckmammapmcrmaum" +
    "cwmczmaBmibailai" +
    "fbihbibciqciqfil" +
    "hialihl")
# r(5066, "Phoenix", layout="0aaaacaapaaraaEa" +
#    "aGaaebatbaCbaaca" +
#    "gcapcarcaAcaGcai" +
#    "daydakeboebqebse" +
#    "aweaafacfaefamfa" +
#    "ufaCfaEfaGfaggbp" +
#    "gbrgaAgaahaihamh" +
#    "auhayhaGhaeiakic" +
#    "picriawiaCiaajam" +
#    "jaujaGjbpkbrkacl" +
#    "aelaglailamlaula" +
#    "ylaAlaClaElakmbp" +
#    "mbrmawmacnafnamn" +
#    "aunaBnaEnaioaooa" +
#    "soayoacpafpaBpaE" +
#    "pakqawqhbbhFbhdc" +
#    "hDchfdhBdhhehzeh" +
#    "jfhxfhdghlghvghD" +
#    "ghfhhBhhhihnihti" +
#    "hzihjjhxjhdkhlkh" +
#    "vkhDkhflhnlhtlhB" +
#    "lhhmhzmhjnhxnhlo" +
#    "hvohnphtponfppfp" +
#    "rfotfoplorlvqivq" +
#    "lCqf")
r(5067, "Portal", layout="0accagcawcaAcaed" +
    "aydaceageaweaAea" +
    "mgaqgamiaqiackag" +
    "kawkaAkaelaylacm" +
    "agmawmaAmhbbhdbh" +
    "fbhhbhvbhxbhzbhB" +
    "bhbdhhdhvdhBdhbf" +
    "hdfhffhhfhlfhnfh" +
    "pfhrfhvfhxfhzfhB" +
    "fhlhhrhhbjhdjhfj" +
    "hhjhljhnjhpjhrjh" +
    "vjhxjhzjhBjhblhh" +
    "lhvlhBlhbnhdnhfn" +
    "hhnhvnhxnhznhBno" +
    "aaocaoeaogaoiaou" +
    "aowaoyaoAaoCaoac" +
    "oicoucoCcoaeoieo" +
    "keomeooeoqeoseou" +
    "eoCeoagocgoegogg" +
    "oigokgosgougowgo" +
    "ygoAgoCgoaiocioe" +
    "iogioiiokiosioui" +
    "owioyioAioCioako" +
    "ikokkomkookoqkos" +
    "koukoCkoamoimoum" +
    "oCmoaoocooeoogoo" +
    "ioouoowooyooAooC" +
    "o")
r(5068, "Rocket", layout="0amaaoaaqaazaaBa" +
    "aDaakbaicamcaoca" +
    "qcascaxcazcaBcaD" +
    "cagdakdaudaeeaie" +
    "ameaqeaseaweayea" +
    "cfagfakfaofaufaB" +
    "faegasgawgaygaah" +
    "bchbghbihbkhbmhb" +
    "ohcqhauhaAhaChae" +
    "iasiawiayiacjagj" +
    "akjaojaujaBjaeka" +
    "ikamkaqkaskawkay" +
    "kaglaklaulaimamm" +
    "aomaqmasmaxmazma" +
    "BmaDmaknamoaooaq" +
    "oazoaBoaDohnahpa" +
    "hlbhBbhjchnchpch" +
    "hdhsdhfehxehdfhs" +
    "fhughehhshiwhhyh" +
    "huihdjhsjhfkhxkh" +
    "hlhslhjmhnmhpmhl" +
    "nhBnhnohpoonbopb" +
    "osgodhofhohhojho" +
    "lhonhouhosionnop" +
    "nvobvehvghvihvsh" +
    "vonCfh")
r(5069, "Scorpion", layout="0avaacbaebagbaib" +
    "aacaxcazcagdaida" +
    "kdaoeaseayeaAeaa" +
    "facfaefagfaifakf" +
    "cmgaogcqgasgcuga" +
    "wgbygbAgckhciidm" +
    "iaoicqiasiduiawi" +
    "byibAickjcmkaokc" +
    "qkaskcukawkbykaa" +
    "laclaelaglailakl" +
    "aomasmawmagnaina" +
    "knaaoacpaepagpai" +
    "phdbhfbhhbhwbhbc" +
    "hychhdhzehbfhdfh" +
    "ffhhfhjfhofhsfho" +
    "hhshhwhhojhsjhwj" +
    "hblhdlhflhhlhjlh" +
    "olhslhwlhhnhbohd" +
    "phfphhpoogosgoyh" +
    "ooiosiowioyjooko" +
    "skvohvqhvshvojvq" +
    "jvsj")
r(5070, "Screw Up", layout="0ciackacmabgbbob" +
    "cecbicbkcbmccqcb" +
    "gdbodcceceeakeam" +
    "ecqecsebgfbofccg" +
    "cegakgamgcqgcsgb" +
    "ghbohcciceiaiiak" +
    "icqicsibgjbojcck" +
    "cekaikakkcqkcskb" +
    "glbolcembimbkmbm" +
    "mcqmbgnbonciocko" +
    "cmoilfikhijjvbfv" +
    "tfvbhvthvbjvtjCa" +
    "fCufCahCuhCajCuj")
#
r(5071, "Seven", layout="0aaaacaafaahaaka" +
    "amaapaaraauaawaa" +
    "zaaBaaEaaGaaacac" +
    "cafcahcakcamcapc" +
    "arcaucawcazcaBca" +
    "EcaGcaaeaceafeah" +
    "eakeameapeareaue" +
    "aweazeaBeaEeaGea" +
    "agacgafgahgakgam" +
    "gapgargaugawgazg" +
    "aBgaEgaGgaaiacia" +
    "fiahiakiamiapiar" +
    "iauiawiaziaBiaEi" +
    "aGiaakackafkahka" +
    "kkamkapkarkaukaw" +
    "kazkaBkaEkaGkaam" +
    "acmafmahmakmamma" +
    "pmarmaumawmazmaB" +
    "maEmaGmaaoacoafo" +
    "ahoakoamoapoaroa" +
    "uoawoazoaBoaEoaG" +
    "oaaqacqafqahqakq" +
    "amqapqarqauqawqa" +
    "zqaBqaEqaGqhqchl" +
    "ehvehggiqghAghbi" +
    "hlihvihFihgkiqkh" +
    "Akhlmhvmhqo")
#
r(5072, "Seven Pyramids", layout="0aaaacaaeaagaaoa" +
    "aqaayaaAaaCaaEaa" +
    "acaccaecagcaocaq" +
    "caycaAcaCcaEcaae" +
    "aceaeeageayeaAea" +
    "CeaEeaagacgaegag" +
    "gangapgargaygaAg" +
    "aCgaEganiapiaria" +
    "akackaekagkankap" +
    "karkaykaAkaCkaEk" +
    "aamacmaemagmayma" +
    "AmaCmaEmaaoacoae" +
    "oagoaooaqoayoaAo" +
    "aCoaEoaaqacqaeqa" +
    "gqaoqaqqayqaAqaC" +
    "qaEqhbbhdbhfbhpb" +
    "hzbhBbhDbhbdhddh" +
    "fdhzdhBdhDdhbfhd" +
    "fhffhzfhBfhDfhoh" +
    "hqhhojhqjhblhdlh" +
    "flhzlhBlhDlhbnhd" +
    "nhfnhznhBnhDnhbp" +
    "hdphfphpphzphBph" +
    "DpoccoecoAcoCcoc" +
    "eoeeoAeoCeopiocm" +
    "oemoAmoCmocooeoo" +
    "AooCovddvBdvdnvB" +
    "n")
r(5073, "Shield", layout="0aaaacaaeaagaaia" +
    "akaamaaoaaxaaaca" +
    "ccaecagcaicakcam" +
    "caocbxcaaeaceaee" +
    "ageaieakeameaoec" +
    "xeabgadgafgahgaj" +
    "galgangdxgaciaei" +
    "agiaiiakiamidxie" +
    "tjeBjaekagkaikak" +
    "kbvkexkbzkagmaim" +
    "cxmahodxohcbhebh" +
    "gbhibhkbhmbhcdhe" +
    "dhgdhidhkdhmdhcf" +
    "iefigfiifikfhmfh" +
    "dhifhihhijhhlhhe" +
    "jigjiijhkjhglhil" +
    "odbofbohbojbolbo" +
    "ddofdohdojdoldoh" +
    "lvfcvhcvjcvfevhe" +
    "vjevggvigvhiChdC" +
    "hf")
r(5074, "Siam", layout="0afaazaadbahbaxb" +
    "aBbacdaedagdaida" +
    "ndardawdaydaAdaC" +
    "daleateabfadfaff" +
    "ahfajfavfaxfazfa" +
    "BfaDfaahachaehag" +
    "haihakhamhaohaqh" +
    "ashauhawhayhaAha" +
    "ChaEhabjadjafjah" +
    "jajjavjaxjazjaBj" +
    "aDjalkatkaclaela" +
    "glailanlarlawlay" +
    "laAlaCladnahnaxn" +
    "aBnafoazohddhfdh" +
    "hdhxdhzdhBdhcfhe" +
    "fhgfhifhwfhyfhAf" +
    "hCfhbhhdhhfhhhhh" +
    "jhhlhhnhiphhrhht" +
    "hhvhhxhhzhhBhhDh" +
    "hcjhejhgjhijhwjh" +
    "yjhAjhCjhdlhflhh" +
    "lhxlhzlhBloedogd" +
    "oydoAdodfoffohfo" +
    "xfozfoBfochoehog" +
    "hoihowhoyhoAhoCh" +
    "odjofjohjoxjozjo" +
    "BjoelogloyloAl")
#
# r(5075, "Space Ship", layout="0afaahaajaalaana" +
#    "apaaraataavaadba" +
#    "xbabcancazcaaeaf" +
#    "eaheajealeaneape" +
#    "areateaveaAeadfa" +
#    "xfangadhaxhaniad" +
#    "jaxjankadlaxlanm" +
#    "adnaxnanohgahiah" +
#    "kahmahoahqahsahu" +
#    "ahebhwbhcchychad" +
#    "hmdhodhAdhgehieh" +
#    "kehqehsehuehmfho" +
#    "fhdghxghnhhdihxi" +
#    "hnjhdkhxkhnlhdmh" +
#    "xmhnnohaojaolaon" +
#    "aopaoraotaofbovb" +
#    "odcoxcobdozdoheo" +
#    "jeoleoneopeoreot" +
#    "eqngodhoxhqniodj" +
#    "oxjqnkodloxlqnmv" +
#    "iavkavmavoavqavs" +
#    "avgbvubvecvwcvcd" +
#    "vydvievkevmevoev" +
#    "qevsevdivxivdkvx" +
#    "kCnaCjeCleCneCpe" +
#    "CreCdjCxj")
#
r(5076, "Square", layout="0daadcadeadgadia" +
    "dkadacdccdecdgcd" +
    "icdkcdaedcedeedg" +
    "ediedkedagdcgdeg" +
    "dggdigdkgdaidcid" +
    "eidgidiidkidakdc" +
    "kdekdgkdikdkk")
r(5077, "Squares", layout="0caabcaceabgacia" +
    "bkacmaboacqabsac" +
    "uaaacauccddafdah" +
    "dajdaldandapdcrd" +
    "aaeauebdfbrfaagb" +
    "ggcigckgcmgbogau" +
    "gcdhcrhaaibgicii" +
    "ckicmiboiauibdjb" +
    "rjaakaukcdlaflah" +
    "lajlallanlaplcrl" +
    "aamaumcaobcoceob" +
    "gociobkocmoboocq" +
    "obsocuohidikdhmd" +
    "hiliklhmlvjgvlgv" +
    "jivli")
r(5078, "Squaring", layout="0caaacaceaciaaka" +
    "cmacqaasacuacyaa" +
    "AacCaaacaecaicdk" +
    "camcaqcaucaycdAc" +
    "aCccaeaceceeciea" +
    "kecmecqeasecuecy" +
    "eaAecCecahachceh" +
    "cihakhcmhcqhashc" +
    "uhcyhaAhcChaajdc" +
    "jaejaijamjaqjdsj" +
    "aujayjaCjcalaclc" +
    "elcilaklcmlcqlas" +
    "lculcylaAlcCl")
r(5079, "Stairs", layout="0aoaaebaybeacdcc" +
    "agcaicakcbmccocb" +
    "qcascaucawcdAceC" +
    "caedayddaeaieaoe" +
    "auedCebefbyfaaga" +
    "igaogaugaCgbchce" +
    "hbghakhbmhbqhash" +
    "bwhcyhbAhaaiaiia" +
    "oiauiaCibejbyjda" +
    "kaikaokaukdCkael" +
    "ayleamdcmagmaima" +
    "kmbmmcombqmasmau" +
    "mawmdAmeCmaenayn" +
    "aoohechychofhahk" +
    "ohhChhojhemhym")
r(5080, "Star Ship", layout="0eoaaabdmbdqbaCb" +
    "accckccscaAcaadb" +
    "idbudaCdbceageco" +
    "eawebAeaafaefamf" +
    "aqfayfaCfecgagga" +
    "igbkgdogbsgaugaw" +
    "geAgaahaehamhaqh" +
    "ayhaChbciagicoia" +
    "wibAiaajbijbujaC" +
    "jackckkcskaAkaal" +
    "dmldqlaCleomhach" +
    "CchaehCehaghegim" +
    "giqghyghCghaihCi" +
    "hakhCkoadoCdoafo" +
    "CfoahoChoajoCjva" +
    "evCevagvCgvaivCi" +
    "CafCCfCahCCh")
#
r(5081, "Steps Pyramid", layout="0aaaacaaeaagaaia" +
    "akaamaaoaaqaaaca" +
    "ccaecagcaicakcam" +
    "caocaqcaaeaceaoe" +
    "aqeaagacgaogaqga" +
    "aiaciaoiaqiaakac" +
    "kaekagkaikakkamk" +
    "aokaqkaamacmaema" +
    "gmaimakmammaomaq" +
    "mhbbhdbhfbhhbhjb" +
    "hlbhnbhpbhbdhddh" +
    "fdhhdhjdhldhndhp" +
    "dhbfhdfhnfhpfhbh" +
    "hdhhnhhphhbjhdjh" +
    "fjhhjhjjhljhnjhp" +
    "jhblhdlhflhhlhjl" +
    "hllhnlhplpccoeco" +
    "gcoicokcomcpococ" +
    "epeepgepiepkepme" +
    "ooeocgpegpmgoogo" +
    "cipeipgipiipkipm" +
    "iooipckoekogkoik" +
    "okkomkpokCffChfC" +
    "jfClfCfhChhCjhCl" +
    "h")
r(5082, "Stonehenge", layout="0cdachackacoacra" +
    "cvacyacCacaccFca" +
    "jeaneareavecagcF" +
    "gddhdhhdlhdphdth" +
    "dxhdBhcajcFjajka" +
    "nkarkavkcancFncd" +
    "pchpckpcopcrpcvp" +
    "cypcCpveavgavlav" +
    "navsavuavzavBava" +
    "dvFdvafvFfvakvFk" +
    "vamvFmvepvgpvlpv" +
    "npvspvupvzpvBpCe" +
    "hCghCihCkhCmhCoh" +
    "CqhCshCuhCwhCyhC" +
    "Ah")
r(5083, "SunMoon", layout="0dgaciabkaamabya" +
    "debbrbbBbdccbvcc" +
    "addcecheckecnebD" +
    "ecafbtfbAfdcgdjg" +
    "dlgbxgcahchhcnhd" +
    "cidjidlibribDica" +
    "jbvjdckchkckkcnk" +
    "bAkcalbsldcmbxmd" +
    "enbBndgociobkoam" +
    "obuovaevagvaivak" +
    "Ckh")
r(5084, "Temple", layout="0baaacaaeaalaana" +
    "apaaraataaAaaCab" +
    "Eaaacaccalcbncbp" +
    "cbrcatcaCcaEcajd" +
    "avdaaeblebnebpeb" +
    "rebteaEeaffahfaj" +
    "favfaxfazfblgbng" +
    "bpgbrgbtgadhafha" +
    "hhajhavhaxhazhaB" +
    "hblibnibpibribti" +
    "afjahjajjavjaxja" +
    "zjaakblkbnkbpkbr" +
    "kbtkaEkajlavlaam" +
    "acmalmbnmbpmbrma" +
    "tmaCmaEmbaoacoae" +
    "oaloanoapoaroato" +
    "aAoaCobEohhghjgh" +
    "vghxghhihjihvihx" +
    "iooeoqeokgomgoog" +
    "oqgosgougokiomio" +
    "oioqiosiouiookoq" +
    "kvpgvpi")
#
# r(5085, "Teotihucan", layout="0aaaacaaeaagaaia" +
#    "akaamaaoaaqaasaa" +
#    "acascaaeaseaagcg" +
#    "gckgcogasgaaicgi" +
#    "ckicoiasiaakaska" +
#    "amasmaaoacoaeoag" +
#    "oaioakoamoaooaqo" +
#    "asoajqhbbhdbhfbh" +
#    "hbhjbhlbhnbhpbhr" +
#    "bhbdhrdhbfhrfhbh" +
#    "hrhhbjhrjhblhrlh" +
#    "bnhdnhfnhhnhjnhl" +
#    "nhnnhpnhrnhjpocc" +
#    "oecogcoicokcomco" +
#    "ocoqcoceoqeocgoq" +
#    "gocioqiockoqkocm" +
#    "oemogmoimokmommo" +
#    "omoqmojovddvfdvh" +
#    "dvjdvldvndvpdvdf" +
#    "vffvhfvjfvlfvnfv" +
#    "pfvdhwfhvhhwjhvl" +
#    "hwnhvphvdjvfjvhj" +
#    "vjjvljvnjvpjvdlv" +
#    "flvhlvjlvllvnlvp" +
#    "lvjn")
r(5086, "The Door", layout="0amaaoaaqaeicekc" +
    "emceoceqcesceuca" +
    "gediedueaweaegag" +
    "gdigdugawgaygaei" +
    "bgidiiduibwiayia" +
    "ckaekcgkdikakkas" +
    "kdukcwkaykaAkaam" +
    "acmbemcgmdimakma" +
    "smdumcwmbymaAmaC" +
    "maaobcobeocgodio" +
    "akoasoduocwobyob" +
    "AoaCo")
#
r(5087, "The Great Wall", layout="0aaaacaaeaagaaia" +
    "akaamaaoaaqaasaa" +
    "uaawaayaaAaaCaaE" +
    "aaacaccaecagcaic" +
    "akcamcaocaqcasca" +
    "ucawcaycaAcaCcaE" +
    "caaeaceaeeageaie" +
    "akeameaoeaqeasea" +
    "ueaweayeaAeaCeaE" +
    "eaagacgaegaggaig" +
    "akgamgaogaqgasga" +
    "ugawgaygaAgaCgaE" +
    "gaaiaciaeiagiaii" +
    "akiamiaoiaqiasia" +
    "uiawiayiaAiaCiaE" +
    "iaakackaekagkaik" +
    "akkamkaokaqkaska" +
    "ukawkaykaAkaCkaE" +
    "kaamacmaemagmaim" +
    "akmammaomaqmasma" +
    "umawmaymaAmaCmaE" +
    "maaoacoaeoagoaio" +
    "akoamoaooaqoasoa" +
    "uoawoayoaAoaCoaE" +
    "oaaqacqaeqagqaiq" +
    "akqamqaoqaqqasqa" +
    "uqawqayqaAqaCqaE" +
    "q")
r(5088, "Theater", layout="0baaccaceabgaaia" +
    "amaaqabsacuacwab" +
    "yacaccccbecagcak" +
    "cbmcaocascbuccwc" +
    "cyccaebceaeeaieb" +
    "kebmeboeaqeauebw" +
    "ecyebagacgaggaig" +
    "akgbmgaogaqgasga" +
    "wgbygcaibciaeiai" +
    "ibkibmiboiaqiaui" +
    "bwicyicakcckbeka" +
    "gkakkbmkaokaskbu" +
    "kcwkcykbamccmcem" +
    "bgmaimammaqmbsmc" +
    "umcwmbym")
r(5089, "Tile Fighter", layout="0bfaahaatabvadcc" +
    "becakcbmcbocaqcb" +
    "wcdycbaecceaiebk" +
    "ebmeboebqeasecye" +
    "bAebagbigckgamga" +
    "ogcqgbsgbAgcchae" +
    "haghauhawhcyhbai" +
    "biickiamiaoicqib" +
    "sibAibakcckaikbk" +
    "kbmkbokbqkaskcyk" +
    "bAkdcmbemakmbmmb" +
    "omaqmbwmcymbfoah" +
    "oatobvohnhonepaf" +
    "pAfpahpAhpajpAjo" +
    "nk")
r(5090, "Tilepiles", layout="0aaaacaaeaagaaia" +
    "aobaqbasbaubayba" +
    "AbaCbaEbahcajcal" +
    "cacdaedardatdaxd" +
    "azdaBdakeameaoea" +
    "ffahfaufawfayfan" +
    "gapgargaihakhaxh" +
    "azhaqiasiauiajja" +
    "ljanjaAjaCjatkav" +
    "kaxkaelaglailakl" +
    "aolaqlawmaymaAma" +
    "CmaEmabnadnafnah" +
    "najnhbahdahfahha" +
    "hpbhrbhtbhzbhBbh" +
    "Dbhichkchddhsdhy" +
    "dhAdhlehnehgfhvf" +
    "hxfhoghqghjhhyhh" +
    "rihtihkjhmjhBjhu" +
    "khwkhflhhlhjlhpl" +
    "hxmhzmhBmhDmhcnh" +
    "enhgnhinocaoeaog" +
    "aoqbosboAboCbojc" +
    "ozdomeowfopgosio" +
    "ljovkogloiloymoA" +
    "moCmodnofnohnvda" +
    "vfavrbvBbvhlvzmv" +
    "BmvenvgnCeaCAmCf" +
    "n")
r(5091, "Time Tunnel", layout="0aaabcaceaegaeia" +
    "ekaemacoabqaasaa" +
    "acccceeceoccqcas" +
    "caaecceeeeeoecqe" +
    "aseaagccgeegeogc" +
    "qgasgaaiccieeieo" +
    "icqiasiaakbckcek" +
    "egkeikekkemkcokb" +
    "qkaskvcdvqdwcfwq" +
    "fvchvqh")
r(5092, "Tomb", layout="0eaabcabeabgabia" +
    "bkabmaboabqaesab" +
    "accccceccgccicck" +
    "ccmccoccqcbscaae" +
    "dcebeeageaieakea" +
    "meboedqeasebagcc" +
    "gcegeggaigakgemg" +
    "cogcqgbsgdaibcib" +
    "eidgiaiiakidmibo" +
    "ibqidsibgkaikakk" +
    "bmkaimakmhjevfcv" +
    "hcvjcvlcvncCgcCi" +
    "cCkcCmc")
#
# r(5093, "Tower and Walls", layout="0ekadmaeoadqaesa" +
#    "dkccmccoccqcdscd" +
#    "aeecedeeegedieek" +
#    "ecmedoecqeesedue" +
#    "ewedyeeAedCedkgc" +
#    "mgcogcqgdsgekidm" +
#    "ieoidqiesi")
r(5094, "Traditional Reviewed", layout="0acaaeaaiaakaama" +
    "aoaaqaasaawaayaa" +
    "gcaicbkccmccocbq" +
    "cascaucaeeagebie" +
    "bkecmecoebqebsea" +
    "ueaweacgaegbggci" +
    "gckgcmgcogcqgcsg" +
    "bugawgaygaahaAha" +
    "ciaeibgiciickicm" +
    "icoicqicsibuiawi" +
    "ayiaekagkbikbkkc" +
    "mkcokbqkbskaukaw" +
    "kagmaimbkmcmmcom" +
    "bqmasmaumacoaeoa" +
    "ioakoamoaooaqoas" +
    "oawoayovnfvlhwnh" +
    "vphvnj")
r(5095, "Tree of Life", layout="0ababdacfadhacja" +
    "blaanaapabractad" +
    "vacxabzaaBaaccaA" +
    "caadbfdajdaldand" +
    "apdardatdbxdaCda" +
    "ceaAeaafaefagfai" +
    "fbkfbsfaufawfayf" +
    "aCfacgamgaqgaAga" +
    "ehaihauhayhalibo" +
    "iariagjawjblkaok" +
    "brkaambcmcembgma" +
    "imclmaomcrmaumbw" +
    "mcymbAmaCmacoago" +
    "cloaoocroawoaAoa" +
    "iqakqamqcoqaqqas" +
    "qauqhoaicdimdiqd" +
    "iAdhdfiffhhfixfh" +
    "zfilqirq")
#
r(5096, "Twin Temples", layout="0aaaacaaeaagaaia" +
    "akaaqaasaauaawaa" +
    "yaaAaaacakcaqcaA" +
    "camdaodaaeakeaqe" +
    "aAeagfaifamfaofa" +
    "sfaufaagakgaqgaA" +
    "gamhaohaaiakiaqi" +
    "aAiaakackaekagka" +
    "ikakkaqkaskaukaw" +
    "kaykaAkhbbhdbhfb" +
    "hhbhjbhrbhtbhvbh" +
    "xbhzbhbdhjdhldhp" +
    "dhrdhzdhbfhffhvf" +
    "hzfhbhhjhhlhhphh" +
    "rhhzhhbjhdjhfjhh" +
    "jhjjhrjhtjhvjhxj" +
    "hzjoccoecogcoico" +
    "scoucowcoycokdoq" +
    "doceoieoseoyeocg" +
    "oigosgoygokhoqho" +
    "cioeiogioiiosiou" +
    "iowioyivddvfdvhd" +
    "vjdvrdvtdvvdvxdv" +
    "dfvhfvjfvrfvtfvx" +
    "fvdhvfhvhhvjhvrh" +
    "vthvvhvxhCeeCgeC" +
    "ueCweCegCggCugCw" +
    "g")
r(5097, "Vi", layout="0aaaaEaaacaccaCc" +
    "aEcbaeaceaeeaAea" +
    "CebEecagbcgaegag" +
    "gaygaAgbCgcEgcai" +
    "bcibeiagiaiiawia" +
    "yibAibCicEicakcc" +
    "kbekbgkaikakkauk" +
    "awkbykbAkcCkcEkd" +
    "amccmcembgmbimak" +
    "mammasmaumbwmbym" +
    "cAmcCmdEmeaodcoc" +
    "eocgobiobkoamoao" +
    "oaqoasobuobwocyo" +
    "cAodCoeEo")
r(5098, "Victory Arrow", layout="0ataaabbcbbebbgb" +
    "bibbkbambavbaxca" +
    "adamdbvdazdadebf" +
    "ebheajeaBeaafamf" +
    "aofbvfbxfbzfaDfa" +
    "dgajgaqgaahagham" +
    "haohbshbuhbwhbyh" +
    "bAhbChbEhadiajia" +
    "qiaajamjaojbvjbx" +
    "jbzjaDjadkbfkbhk" +
    "ajkaBkaalamlbvla" +
    "zlaxmaanbcnbenbg" +
    "nbinbknamnavnato" +
    "hachmchaehmehdfh" +
    "jfhaghmghoghdhhj" +
    "hhqhhaihmihoihdj" +
    "hjjhakhmkhamhmmo" +
    "dbofbohbojboadom" +
    "doafomfoahonhoph" +
    "orhothovhoxhozho" +
    "Bhoajomjoalomlod" +
    "nofnohnojn")
r(5099, "Wavelets", layout="0agaaqaaAaagcaqc" +
    "aAccaeaeeaieaoea" +
    "seayeaCecGeaggaq" +
    "gaAgcaiaeiaiiaoi" +
    "asiayiaCicGiagka" +
    "qkaAkcamaemaimao" +
    "masmaymaCmcGmago" +
    "aqoaAoagqaqqaAqh" +
    "gbhqbhAbhdehjehn" +
    "ehtehxehDehghhqh" +
    "hAhhdihjihnihtih" +
    "xihDihgjhqjhAjhd" +
    "mhjmhnmhtmhxmhDm" +
    "hgphqphApogcoqco" +
    "Acoceokeomeoueow" +
    "eoEeoggoqgoAgoci" +
    "okiomiouiowioEio" +
    "gkoqkoAkocmokmom" +
    "moumowmoEmogooqo" +
    "oAovgdvqdvAdvbev" +
    "levvevFevgfvqfvA" +
    "fvghvqhvAhvbivli" +
    "vvivFivgjvqjvAjv" +
    "glvqlvAlvbmvlmvv" +
    "mvFmvgnvqnvAn")
r(5100, "Well", layout="0aiaakaamaaoaagc" +
    "aicakcamcaocaqca" +
    "cebeeegeeieekeem" +
    "eeoeeqebseaueaaf" +
    "awfacgbegeggaiga" +
    "kgamgaogeqgbsgau" +
    "gaahawhacibeiegi" +
    "aiiakiamiaoieqib" +
    "siauiaajawjackbe" +
    "kegkeikekkemkeok" +
    "eqkbskaukbimakma" +
    "mmbomaioakoamoao" +
    "ohcfhufhchhuhhcj" +
    "huj")
# r(5101, "What a Pyramid", layout="0aaaacaaeaagaaia" +
#    "akaamaaoaaqaasaa" +
#    "uaawaaacaccbecbg" +
#    "cbicbkcbmcbocbqc" +
#    "bscaucawcaceaeeb" +
#    "geciedkedmecoebq" +
#    "easeaueaegbggdig" +
#    "bkgbmgdogbqgasga" +
#    "eibgidiibkibmido" +
#    "ibqiasiackaekbgk" +
#    "cikdkkdmkcokbqka" +
#    "skaukaamacmbembg" +
#    "mbimbkmbmmbombqm" +
#    "bsmaumawmaaoacoa" +
#    "eoagoaioakoamoao" +
#    "oaqoasoauoawo")
r(5102, "Yummy", layout="0aoaaibakbbmbbqb" +
    "asbaubaocagdbidb" +
    "kdbmdbqdbsdbudaw" +
    "daoeaefbgfcifckf" +
    "dmfdqfcsfcufbwfa" +
    "yfaogaahachbehcg" +
    "hbihakhashbuhcwh" +
    "byhaAhaChaoiaejb" +
    "gjcijckjdmjdqjcs" +
    "jcujbwjayjaokagl" +
    "bilbklbmlbqlbslb" +
    "ulawlaomainaknbm" +
    "nbqnasnaunaooiob" +
    "iodkofkohkojioli" +
    "on")
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.games.mahjongg.mahjongg import r

# test
# r(5991, "AAA 1", ncards=4, layout="0daa")
# r(5992, "AAA 2", ncards=8, layout="0daadca")
# r(5993, "AAA 3", ncards=20, layout="0daaCabdacKbbdca" +
#    "Ccbdcc")
# r(5994, "AAA 4", ncards=20, layout="0daaDabdacdcaDcb" +
#    "dcc")

# ************************************************************************
# * game definitions
# ************************************************************************

r(5401, "Taipei", layout="0aagabbabdabjabl" +
    "hccacfachhckadba" +
    "ddhdehdghdiadjad" +
    "lhecaefoegaehhek" +
    "afcifehfgvfgifia" +
    "fkagahgcageaggog" +
    "gagihgkagmhhaahc" +
    "ohehhfvhfhhhvhho" +
    "hiahkhhmaiahidai" +
    "eaigoigCigaiihij" +
    "aimhjbajcojehjfv" +
    "jfJjghjhvjhojiaj" +
    "khjlakahkdakeakg" +
    "okgCkgQkgakihkja" +
    "kmhlbalcolehlfvl" +
    "fJlghlhvlholialk" +
    "hllamahmdameamgo" +
    "mgCmgamihmjammhn" +
    "aanconehnfvnfhnh" +
    "vnhoniankhnmaoah" +
    "ocaoeaogoogaoiho" +
    "kaomapcipehpgvpg" +
    "ipiapkhqcaqfoqga" +
    "qhhqkarbardhrehr" +
    "ghriarjarlhscasf" +
    "ashhskatbatdatja" +
    "tlaug")
r(5402, "Hare", layout="0aacaamacabccace" +
    "ackbcmacobeacecb" +
    "eebekcembeoofavf" +
    "cofeofkvfmofobga" +
    "cgcbgebgkcgmbgoa" +
    "iabicbiebikbimai" +
    "oakcakebkhakkakm" +
    "amebmgbmiamkbogo" +
    "ohboicqfcqhcqjas" +
    "ejsfasgjshasijsj" +
    "askCtgCtibuddufd" +
    "uhdujbulovdCvgCv" +
    "iovlbwddwfdwhdwj" +
    "bwlcyfcyhcyjbAhb" +
    "Ch")
r(5403, "Horse", layout="0bafbahbajbcdbch" +
    "bclaedbefbehbeja" +
    "elagfaghagjaifhi" +
    "gaihhiiaijakfhkg" +
    "akhhkiakjbmecmgc" +
    "mibmkcodcofcohco" +
    "jcolcqdcqfvqgcqh" +
    "vqicqjcqlbsbcsfv" +
    "sgcshvsicsjbsnot" +
    "botnbubcudcufvug" +
    "cuhvuicujculbunb" +
    "wbcwdcwfcwhcwjcw" +
    "lbwnbycayfbyhayj" +
    "bymaAbaAnaCaaCo")
r(5404, "Rat", layout="0aaabacoadbaeaag" +
    "bcacccccebcgvddo" +
    "dgbeacecceebegag" +
    "abgcbggagmbicbie" +
    "aigaimckeckgckia" +
    "kmblcblkcmevmfcm" +
    "gvmhcmibmmamobnc" +
    "Cngbnkhnocoevofc" +
    "ogvohcoibomaoobp" +
    "cbpkcqecqgcqiaqm" +
    "bscbseasgasmauab" +
    "ucbugaumbwacwccw" +
    "ebwgvxdoxgbyacyc" +
    "cyebygaAabAcoAdb" +
    "AeaAg")
r(5405, "Tiger", layout="0baabacbambaobca" +
    "bccbcmbcobebaegh" +
    "ehaeibenbgbbggbg" +
    "ibgnaibbidcifcih" +
    "dijbilainakdhkea" +
    "kfokfhkgakhpkhhk" +
    "iakjokjhkkaklbme" +
    "pmfbmgomhbmiomjb" +
    "mkboeoofbogoohbo" +
    "ipojbokbqeoqfbqg" +
    "pqhbqioqjbqkbsdd" +
    "sfcshcsjbslbubbu" +
    "dbuhbulbunbwbbwi" +
    "bwnbybbygbynbAbb" +
    "AibAnbCbbCgbCn")
r(5406, "Ram", layout="0aacaaeaagaaihbe" +
    "hbghbibccaceocea" +
    "cgaciociackadaod" +
    "chdehdihdkheabec" +
    "aeepeeaeioeiaeka" +
    "faofchfehfihfkhg" +
    "abgcageogeaggagi" +
    "ogiagkahahhehhgh" +
    "hibicaieaigaiibk" +
    "cblgbmcbmeamione" +
    "hniankanmcocboev" +
    "oebogaoiooihokho" +
    "mbooopehpiapkapm" +
    "bqcbqeaqibrgbscb" +
    "ucaueaugauiavahv" +
    "ehvghvihwabwcawe" +
    "oweawgawiowiawka" +
    "xaoxchxehxihxkhy" +
    "abycayepyeayioyi" +
    "aykazaozchzehzih" +
    "zkbAcaAeoAeaAgaA" +
    "ioAiaAkhBehBghBi" +
    "aCcaCeaCgaCi")
r(5407, "Wedges", layout="0aagbaicakdamaca" +
    "acibckccmbeaaeca" +
    "ekbemcgabgcageag" +
    "mdiacicbieaigeka" +
    "dkcckebkgakiakoh" +
    "lofmaemcdmecmgbm" +
    "iamkammamoomohno" +
    "eoaeocdoecogaoia" +
    "oodqadqccqeaqgcs" +
    "acscaseasmbuaauc" +
    "aukbumawaawibwkc" +
    "wmaygbyicykdym")
r(5408, "Monkey", layout="0aaahabaacoachad" +
    "aaeaakbcaaceackh" +
    "clacmocmhcnacood" +
    "abeabeoofoagahgb" +
    "agcaghbgobicbigb" +
    "iiaimhinaioojgbk" +
    "cdkebkgvkgdkibkk" +
    "bkmolgdmebmgvmgd" +
    "miongdoebogvogdo" +
    "iaokholaomaooopg" +
    "hpobqcdqebqgvqgd" +
    "qiaqooqoorghroas" +
    "ahsbascbsgasmaso" +
    "auaaughuhauiawih" +
    "wjawkowkhwlawmby" +
    "maAchAdaAeoAehAf" +
    "vAfaAgoAgCAghAhv" +
    "AhaAioAiCAihAjvA" +
    "jaAkoAkhAlaAmaCa" +
    "hCbaCc")
r(5409, "Rooster", layout="0aaaaagabchcccce" +
    "ccgadcvdfadiceec" +
    "egaeohfoageagoog" +
    "ohhoaiehifaigaim" +
    "aiohjmbkeokfbkgo" +
    "khbkiakkakmamccm" +
    "evmfcmgvmhcmiamk" +
    "anahncCnghoaaoco" +
    "occoevofcogvohco" +
    "iapaopahpchqaaqc" +
    "oqcbqeoqfbqgvqgo" +
    "qhbqiaqkaqmaraor" +
    "ahrchrmhsaascbsg" +
    "oshbsiaskasmasoa" +
    "taotahtohuaaufhu" +
    "gauhauoavabweowf" +
    "bwgowhbwivxgayab" +
    "ycoydbyeoyfbygoy" +
    "hbyihzaaAaaAeaAj" +
    "hAkaAlhBaaCaaCeh" +
    "CfaCgaCl")
r(5410, "Dog", layout="0aaeaaghbehbgacc" +
    "aceoceacgocgacia" +
    "ckhdchdehdghdihd" +
    "kaecoecaeeaegaei" +
    "aekhfcagcaichida" +
    "ieoiehifaigvjebk" +
    "ackcckeckgbkibkk" +
    "vlcoliolkbmacmcc" +
    "mgbmibmkamoonavn" +
    "conkboacoccoecog" +
    "bokaomaooopavpco" +
    "pkbqacqccqgbqibq" +
    "kvrcoriorkbsacsc" +
    "csecsgbsibskvtea" +
    "uchudaueouehufau" +
    "gawchxcaycoycaye" +
    "aygayiaykhzchzeh" +
    "zghzihzkaAcaAeoA" +
    "eaAgoAgaAiaAkhBe" +
    "hBgaCeaCg")
r(5411, "Snake", layout="0bagbaiobhbcgbci" +
    "bdebecbegbfebgcb" +
    "habicbiicikcimbj" +
    "avjlbkcbkebkgbki" +
    "ckkckmakooleolgo" +
    "livllhlobmcbmebm" +
    "gbmicmkcmmamoomo" +
    "vnlhnocokcomaooo" +
    "oovplhpobqcbqebq" +
    "gbqicqkcqmaqoore" +
    "orgorivrlbscbseb" +
    "sgbsicskcsmbtabu" +
    "cbvabwcbwebwgbwi" +
    "bwkbycbyebygbyib" +
    "ykbAjaCj")
r(5412, "Boar", layout="0aacaaehafaagoag" +
    "hahaaiaakhbchbka" +
    "ccoccaciackockac" +
    "mhdchdkhdmaecaee" +
    "aekoekaemoemhfkh" +
    "fmagiagkogkagmhh" +
    "kaiiaikakcbkgbki" +
    "akmolgolibmcbmeb" +
    "mgbmibmkbmmoncon" +
    "epngpnionkonmano" +
    "aoabocvocboevoeb" +
    "ogboibokvokbomvo" +
    "mhooopcopeppgppi" +
    "opkopmapobqcbqeb" +
    "qgbqibqkbqmorgor" +
    "iascbsgbsiasmaui" +
    "aukhvkawiawkowka" +
    "wmhxkhxmaycayeay" +
    "koykaymoymhzchzk" +
    "hzmaAcoAcaAiaAko" +
    "AkaAmhBchBkaCcaC" +
    "ehCfaCgoCghChaCi" +
    "aCk")
r(5413, "Ox", layout="0aahabeabkbcgoch" +
    "bciaeaaecbegbeia" +
    "emaeohfbhfnagaag" +
    "cagebggbgiagkagm" +
    "agoaicbiebigbiib" +
    "ikaimakcbkeckgck" +
    "ibkkakmbmecmgcmi" +
    "bmkaodioeaofjoga" +
    "ohjoiaojiokaolcq" +
    "edqgdqicqkcsedsg" +
    "dsicskaucbuecugc" +
    "uibukaumawcbwecw" +
    "gcwibwkawmayaayc" +
    "ayebygbyiaykayma" +
    "yohzbhznaAaaAcaA" +
    "haAmaAo")
r(5414, "Bridge 2", layout="0daadacdaedagdai" +
    "dakdamdaocccccec" +
    "cgccicckccmbeebe" +
    "gbeibekaggagiaih" +
    "hjhakhokhhlhvlha" +
    "mfamhomhCmhhnhvn" +
    "hJnhanjaofaohooh" +
    "Cohhphvphaqhoqhh" +
    "rhashaugauibwebw" +
    "gbwibwkcyccyecyg" +
    "cyicykcymdAadAcd" +
    "AedAgdAidAkdAmdA" +
    "o")

# r(5501, "Big X", layout="0aacaamhbchbmacb" +
#    "occacdaclocmacnh" +
#    "dbhddhdlhdnaeaae" +
#    "coedaeeaekoelaem" +
#    "aeohfchfehfkhfma" +
#    "gbagdogeagfagjog" +
#    "kaglagnhhdhhfhhj" +
#    "hhlaicaieoifaiga" +
#    "iioijaikaimhjehj" +
#    "ghjihjkakdakfokg" +
#    "akhokiakjaklhlfh" +
#    "lhhljameamgomgam" +
#    "iomiamkhnfhnhhnj" +
#    "aofoofaohoohaojo" +
#    "ojhpfhphhpjaqeaq" +
#    "goqgaqioqiaqkhrf" +
#    "hrhhrjasdasfosga" +
#    "shosiasjaslhteht" +
#    "ghtihtkaucaueouf" +
#    "augauioujaukaumh" +
#    "vdhvfhvjhvlawbaw" +
#    "doweawfawjowkawl" +
#    "awnhxchxehxkhxma" +
#    "yaaycoydayeaykoy" +
#    "laymayohzbhzdhzl" +
#    "hznaAboAcaAdaAlo" +
#    "AmaAnhBchBmaCcaC" +
#    "m")
# r(5502, "Axis", layout="0bafcahbajbbdvbh" +
#    "bblcchCchbdcvdhb" +
#    "dmcehCehbfbvfhbf" +
#    "ncghahaahohiahio" +
#    "ajabjhajohkabkfb" +
#    "kjhkoalabldbllal" +
#    "ohmacmhhmoanaanc" +
#    "vnhanmanoiobcohi" +
#    "onapbwphapniqbcq" +
#    "hiqnaraarcvrharm" +
#    "arohsacshhsoatab" +
#    "tdbtlatohuabufbu" +
#    "jhuoavabvhavohwa" +
#    "hwoaxaaxocyhbzbv" +
#    "zhbzncAhCAhbBcvB" +
#    "hbBmcChCChbDdvDh" +
#    "bDlbEfcEhbEj")
# r(5503, "Cobweb", layout="0aacaafhagaahoah" +
#    "haiaajaamacbhcca" +
#    "cdaclhcmacnadfhd" +
#    "gadhodhhdiadjaea" +
#    "aeohfaafcafeafha" +
#    "fkafmhfoagaogaag" +
#    "oogohhaahcahhahm" +
#    "hhoaiaoiaaiooioh" +
#    "jaajdajhajlhjoak" +
#    "aakoalealhalkama" +
#    "amoancanfhnganhh" +
#    "nianjanmaoahoboo" +
#    "gooihonaooopbapc" +
#    "bpgvpgbpivpiapmo" +
#    "pnaqahqboqgoqihq" +
#    "naqoarcarfhrgarh" +
#    "hriarjarmasaasoa" +
#    "teathatkauaauohv" +
#    "aavdavhavlhvoawa" +
#    "owaawoowohxaaxca" +
#    "xhaxmhxoayaoyaay" +
#    "ooyohzaazcazeazh" +
#    "azkazmhzoaAaaAoa" +
#    "BfhBgaBhoBhhBiaB" +
#    "jaCbhCcaCdaClhCm" +
#    "aCnaEcaEfhEgaEho" +
#    "EhhEiaEjaEm")
# r(5504, "Pyramids", layout="0aaaaacaakaamhbb" +
#    "abeabgabihblacaa" +
#    "ccackacmhdbadead" +
#    "gadihdlaeaaecaek" +
#    "aemaffhfgafhahba" +
#    "heahiahlhibhiehi" +
#    "ihilajbojbajdoje" +
#    "ajfajhojiajjajlo" +
#    "jlhkbvkbhkevkehk" +
#    "ghkivkihklvklalb" +
#    "olbClbaldoleClea" +
#    "lfolgalholiClial" +
#    "jallollCllhmbvmb" +
#    "hmevmehmgvmghmiv" +
#    "mihmlvmlanbonbCn" +
#    "bandoneCneanfong" +
#    "anhoniCnianjanlo" +
#    "nlCnlhobvobhoevo" +
#    "ehoghoivoiholvol" +
#    "apbopbapdopeapfa" +
#    "phopiapjaploplhq" +
#    "bhqehqihqlarbare" +
#    "ariarlatfhtgatha" +
#    "uaaucaukaumhvbav" +
#    "eavgavihvlawaawc" +
#    "awkawmhxbaxeaxga" +
#    "xihxlayaaycaykay" +
#    "m")
# r(5505, "Wicker", layout="0bafbakbbcbbhbbm" +
#    "bcebcjbdbbdgbdlb" +
#    "edbeibenbfabffbf" +
#    "kbgcbghbgmbhebhj" +
#    "bibbigbilbjdbjib" +
#    "jnbkabkfbkkblcbl" +
#    "hblmbmebmjbnbbng" +
#    "bnlbodboibonbpab" +
#    "pfbpkbqcbqhbqmbr" +
#    "ebrjbsbbsgbslbtd" +
#    "btibtnbuabufbukb" +
#    "vcbvhbvmbwebwjbx" +
#    "bbxgbxlbydbyibyn" +
#    "bzfbzkbAh")

r(5801, "Faro", name="Double Mahjongg Faro", ncards=288, layout="0aaaha" +
    "baachadaae" +
    "oaehafaagiahaaih" +
    "ajaakoakhalaamha" +
    "naaoobcvbhobmacb" +
    "hccvccacdacgichC" +
    "chaciaclhcmvcmac" +
    "nodcCdcvdhodmCdm" +
    "aebhecvecaedheea" +
    "efcehCehaejhekae" +
    "lhemvemaenofcvfh" +
    "ofmbgcagfhggagho" +
    "ghhgiagjbgmahaah" +
    "ohiahioajapjaajc" +
    "cjebjhcjkajmajop" +
    "johkahkcokhhkmhk" +
    "oalaalcqlcalfhlg" +
    "alhvlhhlialjalmq" +
    "lmalohmcomhCmhhm" +
    "manbqncandhneanf" +
    "bnhvnhanjhnkanlq" +
    "nmannhocooeoohoo" +
    "khomapcppcCpdbpe" +
    "vpebphwphbpkvpkC" +
    "plapmppmhqcoqeoq" +
    "hoqkhqmarbqrcard" +
    "hrearfbrhvrharjh" +
    "rkarlqrmarnhscos" +
    "hCshhsmataatcqtc" +
    "atfhtgathvthhtia" +
    "tjatmqtmatohuahu" +
    "couhhumhuoavapva" +
    "avccvebvhcvkavma" +
    "vopvohwahwoaxaax" +
    "obycayfhygayhoyh" +
    "hyiayjbymozcvzho" +
    "zmaAbhAcvAcaAdhA" +
    "eaAfcAhCAhaAjhAk" +
    "aAlhAmvAmaAnoBcC" +
    "BcvBhoBmCBmaCbhC" +
    "cvCcaCdaCgiChCCh" +
    "aCiaClhCmvCmaCno" +
    "DcvDhoDmaEahEbaE" +
    "chEdaEeoEehEfaEg" +
    "iEhaEihEjaEkoEkh" +
    "ElaEmhEnaEo")
# r(5802, "Big Square", name="Double Mahjongg Big Square", ncards=288,
# layout="0daadacdaedagdai" +
#    "dakdcadccdcedcgd" +
#    "cidckdeadecdeede" +
#    "gdeidekdgadgcdge" +
#    "dggdgidgkdiadicd" +
#    "iedigdiidikdkadk" +
#    "cdkedkgdkidkkdma" +
#    "dmcdmedmgdmidmkd" +
#    "oadocdoedogdoido" +
#    "kdqadqcdqedqgdqi" +
#    "dqkdsadscdsedsgd" +
#    "sidskduaducduedu" +
#    "gduidukdwadwcdwe" +
#    "dwgdwidwk")
r(5803, "Two Squares", name="Double Mahjongg Two Squares", ncards=288,
        layout="0daadacdaedagdai" +
    "dakdcadccdcedcgd" +
    "cidckdeadecdeede" +
    "gdeidekdgadgcdge" +
    "dggdgidgkdiadicd" +
    "iedigdiidikdkadk" +
    "cdkedkgdkidkkdoa" +
    "docdoedogdoidokd" +
    "qadqcdqedqgdqidq" +
    "kdsadscdsedsgdsi" +
    "dskduaducduedugd" +
    "uidukdwadwcdwedw" +
    "gdwidwkdyadycdye" +
    "dygdyidyk")
# r(5804, "Rows", name="Double Mahjongg Rows", ncards=288,
# layout="0daadacCaddaeCaf" +
#    "dagCahdaidakdcad" +
#    "ckeeadeceeeeegde" +
#    "ieekegaegkeiadic" +
#    "eieeigdiieikekae" +
#    "kkemadmcemeemgdm" +
#    "iemkeoaeokeqadqc" +
#    "eqeeqgdqieqkesae" +
#    "skeuaduceueeugdu" +
#    "ieukewaewkeyadyc" +
#    "eyeeygdyieykdAad" +
#    "AkdCadCcCCddCeCC" +
#    "fdCgCChdCidCk")
r(5805, "Twin Picks", name="Double Mahjongg Twin Picks", ncards=288,
        layout="0aacaaeaagaaiaak" +
    "aamhbdhbfhbhhbjh" +
    "blacaaccaceoceac" +
    "gocgaciociackock" +
    "acmacohdbhddhdfv" +
    "dfhdhvdhhdjvdjhd" +
    "lhdnaeaaecoecaee" +
    "oeeaegoegCegaeio" +
    "eiCeiaekoekaemoe" +
    "maeohfbhfdvfdhff" +
    "vffhfhvfhhfjvfjh" +
    "flvflhfnagaagcog" +
    "cageogeCgeaggogg" +
    "CggagiogiCgiagko" +
    "gkCgkagmogmagohh" +
    "bhhdvhdhhfvhfhhh" +
    "vhhhhjvhjhhlvhlh" +
    "hnaiaaicoicaieoi" +
    "eaigoigCigaiioii" +
    "Ciiaikoikaimoima" +
    "iohjbhjdhjfvjfhj" +
    "hvjhhjjvjjhjlhjn" +
    "akaakcakeokeakgo" +
    "kgakiokiakkokkak" +
    "makohldhlfhlhhlj" +
    "hllamcameamgamia" +
    "mkammapaapcapeap" +
    "gapiapkapmapoasc" +
    "aseasgasiaskasmh" +
    "tdhtfhthhtjhtlau" +
    "aaucaueoueaugoug" +
    "auiouiaukoukauma" +
    "uohvbhvdhvfvvfhv" +
    "hvvhhvjvvjhvlhvn" +
    "awaawcowcaweowea" +
    "wgowgCwgawiowiCw" +
    "iawkowkawmowmawo" +
    "hxbhxdvxdhxfvxfh" +
    "xhvxhhxjvxjhxlvx" +
    "lhxnayaaycoycaye" +
    "oyeCyeaygoygCyga" +
    "yioyiCyiaykoykCy" +
    "kaymoymayohzbhzd" +
    "vzdhzfvzfhzhvzhh" +
    "zjvzjhzlvzlhznaA" +
    "aaAcoAcaAeoAeaAg" +
    "oAgCAgaAioAiCAia" +
    "AkoAkaAmoAmaAohB" +
    "bhBdhBfvBfhBhvBh" +
    "hBjvBjhBlhBnaCaa" +
    "CcaCeoCeaCgoCgaC" +
    "ioCiaCkoCkaCmaCo" +
    "hDdhDfhDhhDjhDla" +
    "EcaEeaEgaEiaEkaE" +
    "m")
r(5806, "Roost", name="Double Mahjongg Roost", ncards=288,
        layout="0aaahabaacoachad" +
    "vadaaeoaehafvafa" +
    "agoaghahvahaaioa" +
    "ihajaakaamaaoCbf" +
    "hblhbnacbhccacdo" +
    "cdhcevceacfocfhc" +
    "gvcgachochhciacj" +
    "aclocmacnhdkhdma" +
    "eiaekoelaemaeoaf" +
    "aafcafehfjhflvfl" +
    "hfnhgchgeaghagjo" +
    "gkaglCglogmagnah" +
    "bohcahdoheahfhhi" +
    "hhkvhlhhmhibhidv" +
    "iehifaiioijaikoi" +
    "laimajaajcojdaje" +
    "Cjeojfajghjjvjkh" +
    "jlajohkcvkdhkevk" +
    "fhkgakjokkaklalb" +
    "olcaldolealfClfo" +
    "lgalhhlkblnhmbhm" +
    "dvmehmfvmghmhamk" +
    "omnanaancondaneo" +
    "nfangCngonhanian" +
    "mhnnanohochoevof" +
    "hogvohhoiapbapdo" +
    "peapfopgaphCphop" +
    "iapjhpkaploplhpm" +
    "apnhqchqevqfhqgv" +
    "qhhqiaraarcordar" +
    "eorfargCrgorhari" +
    "armhrnarohsbhsdv" +
    "sehsfvsghshaskos" +
    "natbotcatdoteatf" +
    "Ctfotgathhtkbtnh" +
    "ucvudhuevufhugau" +
    "joukaulavaavcovd" +
    "aveCveovfavghvjv" +
    "vkhvlavohwbhwdvw" +
    "ehwfawiowjawkowl" +
    "awmaxboxcaxdoxea" +
    "xfhxihxkvxlhxmhy" +
    "chyeayhayjoykayl" +
    "Cyloymaynazaazca" +
    "zehzjhzlvzlhznaA" +
    "iaAkoAlaAmaAohBk" +
    "hBmaCbhCcaCdoCdh" +
    "CevCeaCfoCfhCgvC" +
    "gaChoChhCiaCjaCl" +
    "oCmaCnCDfhDlhDna" +
    "EahEbaEcoEchEdvE" +
    "daEeoEehEfvEfaEg" +
    "oEghEhvEhaEioEih" +
    "EjaEkaEmaEo")
r(5807, "Castle", name="Double Mahjongg Big Castle", ncards=288,
        layout="0eaadacdaeeageai" +
    "dakdameaodcadcoc" +
    "ddvdecdfvdgcdhCd" +
    "hvdicdjvdkcdldea" +
    "deoafdaflcgacgoa" +
    "hdahlciacioajdaj" +
    "lckahkdhklckoald" +
    "elfblheljallcmah" +
    "mdhmlcmoandbnfbn" +
    "janleoahodoofooj" +
    "holeooapdbpfvpfb" +
    "pjvpjapleqahqdoq" +
    "foqjhqleqoardbrf" +
    "brjarlcsahsdhslc" +
    "soatdetfbthetjat" +
    "lcuahudhulcuoavd" +
    "avlcwacwoaxdaxlc" +
    "yacyoazdazldAadA" +
    "ocBdvBecBfvBgcBh" +
    "CBhvBicBjvBkcBld" +
    "CadCoeEadEcdEeeE" +
    "geEidEkdEmeEo")
r(5808, "Eight Squares", name="Double Mahjongg Eight Squares", ncards=288,
        layout="0daadacdaedahdaj" +
    "daldcadccdcedchd" +
    "cjdcldeadecdeede" +
    "hdejdeldhadhcdhe" +
    "dhhdhjdhldjadjcd" +
    "jedjhdjjdjldladl" +
    "cdledlhdljdlldoa" +
    "docdoedohdojdold" +
    "qadqcdqedqhdqjdq" +
    "ldsadscdsedshdsj" +
    "dsldvadvcdvedvhd" +
    "vjdvldxadxcdxedx" +
    "hdxjdxldzadzcdze" +
    "dzhdzjdzl")
r(5809, "Big Flying Dragon", name="Double Mahjongg Big Flying Dragon",
        ncards=288, layout="0aajacaaciackacs" +
    "aeaaegaeihejaeka" +
    "emaesagaageaggbg" +
    "ibgkagmagoagsaia" +
    "aicaiebigbiibikb" +
    "imaioaiqaisakabk" +
    "cbkebkgbkibkkbkm" +
    "bkobkqaksbmabmcc" +
    "mecmgcmicmkcmmcm" +
    "obmqbmsboaboccoe" +
    "dogdoidokdomcoob" +
    "oqbosbqabqccqedq" +
    "geqieqkdqmcqobqq" +
    "bqsJrjbsabsccsed" +
    "sgesieskdsmcsobs" +
    "qbssbuabuccuedug" +
    "duidukdumcuobuqb" +
    "usbwabwccwecwgcw" +
    "icwkcwmcwobwqbws" +
    "ayabycbyebygbyib" +
    "ykbymbyobyqaysaA" +
    "aaAcaAebAgbAibAk" +
    "bAmaAoaAqaAsaCaa" +
    "CeaCgbCibCkaCmaC" +
    "oaCsaEaaEgaEihEj" +
    "aEkaEmaEsaGaaGia" +
    "GkaGsaIaaIjaIsaK" +
    "j")
r(5810, "Sphere", name="Double Mahjongg Sphere", ncards=288,
        layout="0aajaalaanabhhbk" +
    "hbmabpacfhciacjo" +
    "ckaclocmacnhcoac" +
    "raddhdgadhodivdk" +
    "hdlvdmodoadphdqa" +
    "dtaefoegveihejae" +
    "koekaemoemhenveo" +
    "oeqaerafchfdhffh" +
    "fhafiafohfphfrhf" +
    "tafuageogeaggpgg" +
    "pgihgjpgkbglpgmh" +
    "gnpgoagqpgqagsog" +
    "sahbhhchhfhhhahj" +
    "ahnhhphhrhhuahva" +
    "idoidvieaifoigai" +
    "hoiihijoikbiloim" +
    "hinoioaipoiqairv" +
    "isaitoitajahjbhj" +
    "dhjfhjhvjlhjphjr" +
    "hjthjvajwakcokcv" +
    "kdakeokeakgokgak" +
    "iokiakkokkakmokm" +
    "akookoakqokqakso" +
    "ksvktakuokualahl" +
    "bhldhlfvlfhlhvlh" +
    "hljvljhllvllhlnv" +
    "lnhlpvlphlrvlrhl" +
    "thlvalwamcomcvmd" +
    "ameomeamgomgamio" +
    "miamkomkammommam" +
    "oomoamqomqamsoms" +
    "vmtamuomuanahnbh" +
    "ndhnfhnhvnlhnphn" +
    "rhnthnvanwaodood" +
    "voeaofoogaohooih" +
    "ojookboloomhonoo" +
    "oaopooqaorvosaot" +
    "ootapbhpchpfhpha" +
    "pjapnhpphprhpuap" +
    "vaqeoqeaqgpqgpqi" +
    "hqjpqkbqlpqmhqnp" +
    "qoaqqpqqaqsoqsar" +
    "chrdhrfhrhariaro" +
    "hrphrrhrtaruasfo" +
    "sgvsihsjaskoskas" +
    "mosmhsnvsoosqasr" +
    "atdhtgathotivtkh" +
    "tlvtmotoatphtqat" +
    "taufhuiaujoukaul" +
    "oumaunhuoauravhh" +
    "vkhvmavpawjawlaw" +
    "n")

# ----------------------------------------------------------------------

r(5901, "Happy New Year", name="Half Mahjongg Happy New Year", ncards=72,
        layout="0aafaajaanaceaci" +
    "acmbedbehaelofdo" +
    "fhhflbgdbghagloh" +
    "dohhaibbidaighih" +
    "aiiailhimainojma" +
    "kaakeckhakjbkmbk" +
    "oolmambbmdamghmh" +
    "amiamlhmmamnondo" +
    "nhbodbohaolopdop" +
    "hhplbqdbqhaqlase" +
    "asiasmaufaujaun")
# r(5902, "K 2", name="Half Mahjongg K 2", ncards=72,
# layout="0aagabcabehbfobg" +
#    "hbhabiabkacgvcga" +
#    "dbidgadlaegvegbf" +
#    "aifgbfmaggbhaihg" +
#    "bhmaigbjahjgbjma" +
#    "kgokgblahlgblmam" +
#    "gbnaingbnmaogbpa" +
#    "ipgbpmaqgvqgarbi" +
#    "rgarlasgvsgatcat" +
#    "ehtfotghthatiatk" +
#    "aug")
# r(5903, "Abstract", name="Half Mahjongg Abstract", ncards=72,
# layout="0aaaaagabcabebdd" +
#    "adgadioedhehafch" +
#    "fdafeafhagahhaah" +
#    "dahgaiahjaojbbjc" +
#    "ajfakaalcamfamha" +
#    "nbhncandhngaogbo" +
#    "iapdhqdaqiarcord" +
#    "arehrihsdasgasia" +
#    "tdauaaufhvbavcav" +
#    "iawaawehxeaxiayc" +
#    "ayebyghzdaAdaAha" +
#    "BbaBfhCfaCiaDcaD" +
#    "eaDghDhaEaaEi")
r(5904, "Smile", name="Half Mahjongg Smile", ncards=72,
        layout="0bagoahbaibbebbk" +
    "bccbcmbebbenaffb" +
    "fjbgahgfbgoahfbh" +
    "kbiabiobjlbkabko" +
    "bllbmabmoanfbnkb" +
    "oahofbooapfbpjbq" +
    "bbqnbscbsmbtebtk" +
    "bugouhbui")
r(5905, "Wall", name="Half Mahjongg Wall", ncards=72,
        layout="0eaabacbaebagbai" +
    "bakbameaoacaacoa" +
    "eaaeoagaagoaiaai" +
    "oakaakoamaamoaoa" +
    "aooaqaaqoasaasoa" +
    "uaauoawaawoayaay" +
    "oaAaaAoaCaaCoeEa" +
    "bEcbEebEgbEibEkb" +
    "EmeEo")

# ----------------------------------------------------------------------

# r(5601, "Skomoroh 1", ncards=28, layout="0aacaaeaaghbdhbf" +
#    "acaacdoceacfacih" +
#    "ddhdfaebaeeoeeae" +
#    "hhfdhffagaagdoge" +
#    "agfagihhdhhfaica" +
#    "ieaig")
# r(5602, "Skomoroh 2", ncards=116, layout="0aaeaaghahaaiaak" +
#    "abaaboacfbchacja" +
#    "daadoaeghehaeiaf" +
#    "aafocghahaahcahf" +
#    "vhhahjahmahohidc" +
#    "ihhilajaajdajfwj" +
#    "hajjajlajohkdhkg" +
#    "akhokhhkihklalaa" +
#    "lcalewlhalkalmal" +
#    "ohmfamgimhamihmj" +
#    "anaancanewnhanka" +
#    "nmanohodhogaohoo" +
#    "hhoiholapaapdapf" +
#    "wphapjaplapohqdc" +
#    "qhhqlaraarcarfvr" +
#    "harjarmarocshata" +
#    "atoaughuhauiavaa" +
#    "voawfbwhawjaxaax" +
#    "oayeayghyhayiayk")
# r(5603, "Skomoroh 3", ncards=132, layout="0aachadaaeoaeXae" +
#    "hafyafaagoagXagh" +
#    "ahaaiabaabkhcahc" +
#    "kadaadeadgadkhea" +
#    "hefhekafaafeafga" +
#    "fkhgahgfhgkahaah" +
#    "eahgahkhiahifhik" +
#    "ajaajeajgajkhkah" +
#    "kfhkkalaalealgal" +
#    "khmahmfhmkanaane" +
#    "onfangankhofXofa" +
#    "pbapdapfspfaphap" +
#    "jhqfXqfaraareorf" +
#    "argarkhsahsfhska" +
#    "taateatgatkhuahu" +
#    "fhukavaaveavgavk" +
#    "hwahwfhwkaxaaxea" +
#    "xgaxkhyahyfhykaz" +
#    "aazeazgazkhAahAf" +
#    "hAkaBaaBeaBgaBkh" +
#    "CahCkaDaaDkaEchE" +
#    "daEeoEeXEehEfyEf" +
#    "aEgoEgXEghEhaEi")
# r(5604, "Skomoroh 4", ncards=52, layout="0aajaalaanabhabp" +
#    "acfacnacraddadla" +
#    "dtaejafcafuagiah" +
#    "bbhoahvaiiajaajw" +
#    "akjalaalwamkamma" +
#    "naanwaonapaapwaq" +
#    "oarbbriarvasoatc" +
#    "atuaunavdavlavta" +
#    "wfawjawraxhaxpay" +
#    "jaylayn")
# r(5605, "Skomoroh 5", ncards=208, layout="0aahaajaalaanaap" +
#    "hbihbkoblhbmhboa" +
#    "ccaceacgaciackac" +
#    "macoacqacsacuaec" +
#    "aeuagdagjaglagna" +
#    "gthhkhhmaieaijai" +
#    "loilainaishjkhjm" +
#    "akfakjakloklakna" +
#    "krhlkhlmameamgam" +
#    "jamlomlamnamqams" +
#    "anchndhnkhnmhnta" +
#    "nuaoeaohaojaoloo" +
#    "laonaopaosapchpd" +
#    "hpkhpmhptapuaqea" +
#    "qhaqjaqlaqnaqpaq" +
#    "saraarchrdhrtaru" +
#    "arwaseasgasiaska" +
#    "smasoasqassataht" +
#    "batchtdhtfithitj" +
#    "itlitnitphtrhtta" +
#    "tuhtvatwaueaugau" +
#    "iaukaumauoauqaus" +
#    "avaavchvdhvtavua" +
#    "vwaweawhawjawlaw" +
#    "nawpawsaxchxdhxk" +
#    "hxmhxtaxuayeayha" +
#    "yjayloylaynaypay" +
#    "sazchzdhzkhzmhzt" +
#    "azuaAeaAgaAjaAlo" +
#    "AlaAnaAqaAshBkhB" +
#    "maCfaCjaCloClaCn" +
#    "aCrhDkhDmaEeaEja" +
#    "EloElaEnaEshFkhF" +
#    "maGdaGjaGlaGnaGt" +
#    "aIcaIuaKcaKeaKga" +
#    "KiaKkaKmaKoaKqaK" +
#    "saKuhLihLkoLlhLm" +
#    "hLoaMhaMjaMlaMna" +
#    "Mp")
# r(5606, "Skomoroh 6", layout="0aadaafaahaajaal" +
#    "aanaapadaaddadfa" +
#    "dhadjadladnadpad" +
#    "sheehegheihekhem" +
#    "heoafaafdaffoffa" +
#    "fhofhafjofjaflof" +
#    "lafnofnafpafshge" +
#    "hggvgghgivgihgkv" +
#    "gkhgmvgmhgoahaCh" +
#    "hChjChlahsaidaif" +
#    "oifaihoihJiiaijo" +
#    "ijJikailoilainoi" +
#    "naipajahjehjgvjg" +
#    "CjhhjivjihjkvjkC" +
#    "jlhjmvjmhjoajsak" +
#    "dakfokfakhokhJki" +
#    "akjokjJkkaklokla" +
#    "knoknakpalaClhCl" +
#    "jCllalshmehmgvmg" +
#    "hmivmihmkvmkhmmv" +
#    "mmhmoanaandanfon" +
#    "fanhonhanjonjanl" +
#    "onlannonnanpansh" +
#    "oehoghoihokhomho" +
#    "oapaapdapfaphapj" +
#    "aplapnappapsasda" +
#    "sfashasjaslasnas" +
#    "p")
# r(5607, "Skomoroh 7", ncards=56, layout="0aabaadaafaahaaj" +
#    "aapaaraatablabwa" +
#    "daadmadwafaafnaf" +
#    "wahaahnahwajfajh" +
#    "ajmajwakdakjalbd" +
#    "llalvamnamtanaan" +
#    "kanpanrapaapjapw" +
#    "araarjarwataatka" +
#    "twavaavlawdawfaw" +
#    "hawnawpawrawtawv")
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.mahjongg.mahjongg import AbstractMahjonggGame, \
        Mahjongg_RowStack, \
        comp_cardset
from pysollib.hint import AbstractHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.mygettext import ungettext
from pysollib.pysoltk import MfxCanvasLine, MfxCanvasText
from pysollib.settings import TOOLKIT
from pysollib.stack import \
        AbstractFoundationStack, \
        InitialDealTalonStack
from pysollib.util import ANY_SUIT

from six.moves import range


class Shisen_Hint(AbstractHint):
    TOP_MATCHING = False
    # FIXME: no intelligence whatsoever is implemented here

    def computeHints(self):
        game = self.game
        # get free stacks
        stacks = []
        for r in game.s.rows:
            if r.cards:
                stacks.append(r)
        # find matching tiles
        i = 0
        for r in stacks:
            for t in stacks[i+1:]:
                # if game.cardsMatch(r.cards[0], t.cards[0]):
                if r.acceptsCards(t, t.cards):
                    # simple scoring...
                    if self.TOP_MATCHING:
                        score = 2000 - r.rown - t.rown
                    else:
                        score = 1000 + r.rown + t.rown
                    self.addHint(score, 1, r, t)
            i += 1


class NotShisen_Hint(Shisen_Hint):
    TOP_MATCHING = True


# ************************************************************************
# * Shisen-Sho
# ************************************************************************


class Shisen_Foundation(AbstractFoundationStack):
    def __init__(self, x, y, game, suit=ANY_SUIT, **cap):
        kwdefault(cap, max_move=0, max_accept=0, max_cards=game.NCARDS)
        AbstractFoundationStack.__init__(self, x, y, game, suit, **cap)

    def acceptsCards(self, from_stack, cards):
        # We do not accept any cards - pairs will get
        # delivered by _dropPairMove() below.
        return 0

    def basicIsBlocked(self):
        return 1

    def initBindings(self):
        pass


class Shisen_RowStack(Mahjongg_RowStack):

    def basicIsBlocked(self):
        return 0

    def acceptsCards(self, from_stack, cards):
        if not self.game.cardsMatch(self.cards[0], cards[-1]):
            return 0

        cols, rows = self.game.L
        game_cols = self.game.cols
        x1, y1 = self.coln+1, self.rown+1
        x2, y2 = from_stack.coln+1, from_stack.rown+1
        dx, dy = x2 - x1, y2 - y1

        a = []
        for i in range(cols+2):
            a.append([5]*(rows+2))

        def can_move(x, y, nx, ny, direct, d, direct_chng_cnt):
            if nx == x2 and ny == y2:
                return 1
            if nx < 0 or ny < 0 or nx > cols+1 or ny > rows+1:
                return 0
            if nx in (0, cols+1) or ny in (0, rows+1) \
                    or not game_cols[nx-1][ny-1].cards:
                if direct_chng_cnt == 0:
                    return 1
                elif direct_chng_cnt == 1:
                    if direct != d:
                        if d == 1 and dy > 0:
                            return 1
                        elif d == 2 and dy < 0:
                            return 1
                        elif d == 3 and dx > 0:
                            return 1
                        elif d == 4 and dx < 0:
                            return 1
                    else:
                        return 1
                elif direct_chng_cnt == 2:
                    if direct != d:
                        if d in (1, 2) and x == x2:
                            return 1
                        elif y == y2:
                            return 1
                    else:
                        if d == 1 and y < y2:
                            return 1
                        elif d == 2 and y > y2:
                            return 1
                        elif d == 3 and x < x2:
                            return 1
                        elif d == 4 and x > x2:
                            return 1
                elif direct_chng_cnt == 3:
                    if direct == d:
                        return 1

            return 0

        res_path = [None]

        def do_accepts(x, y, direct, direct_chng_cnt, path):
            # if direct_chng_cnt > 3:
            #    return
            if a[x][y] < direct_chng_cnt:
                return
            # if res_path[0]:
            #    return
            a[x][y] = direct_chng_cnt
            if x == x2 and y == y2:
                res_path[0] = path
                return

            if can_move(x, y, x, y+1, direct, 1, direct_chng_cnt):  # 1
                # dcc = direct == 1 and direct_chng_cnt or direct_chng_cnt+1
                p = path[:]
                if direct == 1:
                    dcc = direct_chng_cnt
                else:
                    dcc = direct_chng_cnt+1
                    p.append((x, y))
                do_accepts(x, y+1, 1, dcc, p)
            if can_move(x, y, x, y-1, direct, 2, direct_chng_cnt):  # 2
                # dcc = direct == 2 and direct_chng_cnt or direct_chng_cnt+1
                p = path[:]
                if direct == 2:
                    dcc = direct_chng_cnt
                else:
                    dcc = direct_chng_cnt+1
                    p.append((x, y))
                do_accepts(x, y-1, 2, dcc, p)
            if can_move(x, y, x+1, y, direct, 3, direct_chng_cnt):  # 3
                # dcc = direct == 3 and direct_chng_cnt or direct_chng_cnt+1
                p = path[:]
                if direct == 3:
                    dcc = direct_chng_cnt
                else:
                    dcc = direct_chng_cnt+1
                    p.append((x, y))
                do_accepts(x+1, y, 3, dcc, p)
            if can_move(x, y, x-1, y, direct, 4, direct_chng_cnt):  # 4
                # dcc = direct == 4 and direct_chng_cnt or direct_chng_cnt+1
                p = path[:]
                if direct == 4:
                    dcc = direct_chng_cnt
                else:
                    dcc = direct_chng_cnt+1
                    p.append((x, y))
                do_accepts(x-1, y, 4, dcc, p)

        do_accepts(x1, y1, 0, 0, [])
        # from pprint import pprint
        # pprint(a)

        if a[x2][y2] > 3:
            return None

        res_path = res_path[0]
        res_path.append((x2, y2))
        # print res_path
        return res_path

    def fillStack(self):
        self.game.fillStack(self)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        assert ncards == 1 and to_stack in self.game.s.rows
        if to_stack.cards:
            self._dropPairMove(ncards, to_stack, frames=-1, shadow=shadow)
        else:
            Mahjongg_RowStack.moveMove(self, ncards, to_stack, frames=frames,
                                       shadow=shadow)

    def _dropPairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        old_state = game.enterState(game.S_FILL)
        f = game.s.foundations[0]
        game.updateStackMove(game.s.talon, 2 | 16)            # for undo
        if not game.demo:
            if game.app.opt.shisen_show_hint:
                self.drawArrow(other_stack, game.app.opt.timeouts['hint'])
            game.playSample("droppair", priority=200)
        #
        game.moveMove(n, self, f, frames=frames, shadow=shadow)
        game.moveMove(n, other_stack, f, frames=frames, shadow=shadow)
        self.fillStack()
        other_stack.fillStack()
        game.updateStackMove(game.s.talon, 1 | 16)            # for redo
        game.leaveState(old_state)

    def drawArrow(self, other_stack, sleep):
        game = self.game
        images = game.app.images
        cs = game.app.cardset
        path = self.acceptsCards(other_stack, [other_stack.cards[-1]])
        # print path
        x0, y0 = game.XMARGIN, game.YMARGIN
        cardw, cardh = images.CARDW, images.CARDH
        if cs.version >= 6:
            cardw -= cs.SHADOW_XOFFSET
            cardh -= cs.SHADOW_YOFFSET
        coords = []
        dx = game._delta_x
        xf, yf = images._xfactor, images._yfactor
        for x, y in path:
            if x == 0:
                coords.append(6)
            elif x == game.L[0]+1:
                coords.append(int(round(xf * (x0+cardw*(x-1)+10+dx))))
            else:
                coords.append(int(round(xf * (x0+cardw/2+cardw*(x-1)+dx))))
            if y == 0:
                coords.append(6)
            elif y == game.L[1]+1:
                coords.append(int(round(yf * (y0+cardh*(y-1)+6))))
            else:
                coords.append(int(round(yf * (y0+cardh/2+cardh*(y-1)))))
        # print coords
        # s1 = min(cardw/2, cardh/2, 30)
        # w = min(s1/3, 7)
        # s2 = min(w, 10)
        w = 7
        arrow = MfxCanvasLine(game.canvas,
                              coords,
                              {'width': w,
                               'fill': game.app.opt.colors['hintarrow'],
                               # 'arrow': 'last',
                               # 'arrowshape': (s1, s1, s2)
                               }
                              )
        game.canvas.update_idletasks()
        if TOOLKIT == "kivy":
            arrow.delete_deferred(sleep)
            return
        game.sleep(sleep)
        if arrow is not None:
            arrow.delete()
        game.canvas.update_idletasks()


class AbstractShisenGame(AbstractMahjonggGame):
    Hint_Class = NotShisen_Hint  # Shisen_Hint
    RowStack_Class = Shisen_RowStack

    # NCARDS = 144
    GRAVITY = True

    def createGame(self):
        cols, rows = self.L
        assert cols*rows == self.NCARDS

        # start layout
        l, s = Layout(self), self.s
        # dx, dy = 3, -3

        cs = self.app.cardset
        if cs.version >= 6:
            dx = l.XOFFSET
            dy = -l.YOFFSET
            d_x = cs.SHADOW_XOFFSET
            d_y = cs.SHADOW_YOFFSET
            self._delta_x, self._delta_y = dx, -dy
        else:
            dx = 3
            dy = -3
            d_x = 0
            d_y = 0
            self._delta_x, self._delta_y = 0, 0

        font = self.app.getFont("canvas_default")

        # width of self.texts.info
        # ti_width = Font(self.canvas, font).measure(_('Remaining'))
        ti_width = 80

        # set window size
        dxx, dyy = abs(dx), abs(dy)
        cardw, cardh = l.CW - d_x, l.CH - d_y
        w = l.XM+dxx + cols*cardw+d_x + l.XM+ti_width+l.XM
        h = l.YM+dyy + rows*cardh+d_y + l.YM
        self.setSize(w, h)
        self.XMARGIN = l.XM+dxx
        self.YMARGIN = l.YM+dyy

        # set game extras
        self.check_dist = l.CW*l.CW + l.CH*l.CH     # see _getClosestStack()

        #
        self.cols = [[] for i in range(cols)]
        cl = range(cols)
        if dx > 0:
            cl = reversed(cl)
        for col in cl:
            for row in range(rows):
                x = l.XM + dxx + col * cardw
                y = l.YM + dyy + row * cardh
                stack = self.RowStack_Class(x, y, self)
                stack.CARD_XOFFSET = 0
                stack.CARD_YOFFSET = 0
                stack.coln, stack.rown = col, row
                s.rows.append(stack)
                self.cols[col].append(stack)
        # from pprint import pprint
        # pprint(self.cols)

        # create other stacks
        y = l.YM + dyy
        ivx = -l.XS-self.canvas.xmargin
        if TOOLKIT == 'kivy':
            ivx = -1000
        s.foundations.append(Shisen_Foundation(ivx, y, self))
        self.texts.info = MfxCanvasText(self.canvas,
                                        self.width - l.XM - ti_width, y,
                                        anchor="nw", font=font)
        # the Talon is invisble
        s.talon = InitialDealTalonStack(-l.XS-self.canvas.xmargin,
                                        self.height-dyy, self)

        # Define stack groups
        l.defaultStackGroups()

    def fillStack(self, stack):
        if not self.GRAVITY:
            return
        to_stack = stack
        for from_stack in self.cols[stack.coln][stack.rown+1::-1]:
            if not from_stack.cards:
                continue
            self.moveMove(1, from_stack, to_stack, frames=0)
            to_stack = from_stack

    def updateText(self):
        if self.preview > 1 or self.texts.info is None:
            return

        if self.app.opt.shisen_show_matching:
            # find matching tiles
            stacks = self.s.rows
            f, i = 0, 0
            for r in stacks:
                i = i + 1
                if not r.cards:
                    continue
                for t in stacks[i:]:
                    if not t.cards:
                        continue
                    if r.acceptsCards(t, t.cards):
                        f += 1
            if f == 0:
                f = _('No Free\nMatching\nPairs')
            else:
                f = ungettext('%d Free\nMatching\nPair',
                              '%d Free\nMatching\nPairs',
                              f) % f
        else:
            f = ''

        t = len(self.s.foundations[0].cards)
        r1 = ungettext('%d\nTile\nRemoved\n\n',
                       '%d\nTiles\nRemoved\n\n',
                       t) % t
        r2 = ungettext('%d\nTile\nRemaining\n\n',
                       '%d\nTiles\nRemaining\n\n',
                       self.NCARDS - t) % (self.NCARDS - t)

        t = r1 + r2 + f
        self.texts.info.config(text=t)

    def drawHintArrow(self, from_stack, to_stack, ncards, sleep):
        from_stack.drawArrow(to_stack, sleep)

    def _shuffleHook(self, cards):
        return cards

    def canShuffle(self):
        return False


class Shisen_18x8(AbstractShisenGame):
    L = (18, 8)


class Shisen_14x6(AbstractShisenGame):
    L = (14, 6)
    NCARDS = 84


class Shisen_24x12(AbstractShisenGame):
    L = (24, 12)
    NCARDS = 288


class Shisen_18x8_NoGravity(AbstractShisenGame):
    L = (18, 8)
    GRAVITY = False


class Shisen_14x6_NoGravity(AbstractShisenGame):
    L = (14, 6)
    NCARDS = 84
    GRAVITY = False


class Shisen_24x12_NoGravity(AbstractShisenGame):
    L = (24, 12)
    NCARDS = 288
    GRAVITY = False


# ************************************************************************
# * Not Shisen-Sho
# ************************************************************************

class NotShisen_RowStack(Shisen_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not self.game.cardsMatch(self.cards[0], cards[-1]):
            return 0
        if self.coln != from_stack.coln and self.rown != from_stack.rown:
            return 0
        return [(self.coln+1, self.rown+1),
                (from_stack.coln+1, from_stack.rown+1)]


class NotShisen_14x6(AbstractShisenGame):
    Hint_Class = NotShisen_Hint
    RowStack_Class = NotShisen_RowStack
    L = (14, 6)
    NCARDS = 84


class NotShisen_18x8(AbstractShisenGame):
    Hint_Class = NotShisen_Hint
    RowStack_Class = NotShisen_RowStack
    L = (18, 8)


class NotShisen_24x12(AbstractShisenGame):
    Hint_Class = NotShisen_Hint
    RowStack_Class = NotShisen_RowStack
    L = (24, 12)
    NCARDS = 288


# ************************************************************************
# * register a Shisen-Sho type game
# ************************************************************************

def r(id, gameclass, name, rules_filename="shisensho.html"):
    decks, ranks, trumps = comp_cardset(gameclass.NCARDS)
    gi = GameInfo(id, gameclass, name,
                  GI.GT_SHISEN_SHO, 4*decks, 0, GI.SL_MOSTLY_SKILL,
                  category=GI.GC_MAHJONGG, short_name=name,
                  suits=list(range(3)), ranks=list(range(ranks)),
                  trumps=list(range(trumps)),
                  si={"decks": decks, "ncards": gameclass.NCARDS})
    gi.ncards = gameclass.NCARDS
    gi.rules_filename = rules_filename
    registerGame(gi)
    return gi


r(11001, Shisen_14x6, "Shisen-Sho 14x6")
r(11002, Shisen_18x8, "Shisen-Sho 18x8")
r(11003, Shisen_24x12, "Shisen-Sho 24x12")
r(11004, Shisen_14x6_NoGravity, "Shisen-Sho (No Gravity) 14x6")
r(11005, Shisen_18x8_NoGravity, "Shisen-Sho (No Gravity) 18x8")
r(11006, Shisen_24x12_NoGravity, "Shisen-Sho (No Gravity) 24x12")
r(11011, NotShisen_14x6, "Not Shisen-Sho 14x6", "notshisensho.html")
r(11012, NotShisen_18x8, "Not Shisen-Sho 18x8", "notshisensho.html")
r(11013, NotShisen_24x12, "Not Shisen-Sho 24x12", "notshisensho.html")


del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# This layouts converted from Kyodai Mahjongg game
# http://www.kyodai.com/index.en.html
# http://files.cyna.net/layouts.zip

from pysollib.games.mahjongg.mahjongg import r

# ************************************************************************
# * game definitions
# ************************************************************************

#
r(5200, "Another Round", ncards=140, layout="0aagaaihbhacfach" +
    "acjhdghdiaecaeea" +
    "egoehaeiaekaemhf" +
    "dhffhfhhfjhflaga" +
    "agcageogeaggogga" +
    "giogiagkogkagmag" +
    "ohhbhhdhhfhhhhhj" +
    "hhlhhnaiaaicoica" +
    "ieoieaigoigaiioi" +
    "iaikoikaimoimaio" +
    "hjbhjdhjfhjhhjjh" +
    "jlhjnakaakcakeak" +
    "gakiakkakmakoama" +
    "amcammamoaoaaoca" +
    "oeaogaoiaokaomao" +
    "ohpbhpdhpfhphhpj" +
    "hplhpnaqaaqcoqca" +
    "qeoqeaqgoqgaqioq" +
    "iaqkoqkaqmoqmaqo" +
    "hrbhrdhrfhrhhrjh" +
    "rlhrnasaascaseos" +
    "easgosgasiosiask" +
    "oskasmasohtdhtfh" +
    "thhtjhtlaucaueau" +
    "gouhauiaukaumhvg" +
    "hviawfawhawjhxha" +
    "ygayi")
r(5201, "Aqab's", layout="0caedagcaicccbcg" +
    "cckceabegcembgga" +
    "hdahjbigbkabkeck" +
    "gbkibkmbmabmccme" +
    "dmgcmibmkbmmboac" +
    "ocdoedogdoicokbo" +
    "mbqabqccqedqgcqi" +
    "bqkbqmbsabsecsgb" +
    "sibsmbugawdbwgaw" +
    "jcyabygcymcAcbAg" +
    "cAkcCedCgcCi")
#
r(5202, "Big Mountain", layout="0aaaaaqaeihfiagh" +
    "ogiagjhhhvhihhja" +
    "igoihaiiCiioijai" +
    "khjgvjhhjivjjhjk" +
    "akfokgakhCkhokia" +
    "kjCkjokkaklhlfvl" +
    "ghlhvlihljvlkhll" +
    "ameomfamgomhCmha" +
    "miomjCmjamkomlam" +
    "mhnehngvnghnivni" +
    "hnkvnkhnmaodaofo" +
    "ofaohoohCohaojoo" +
    "jCojaoloolaonhpe" +
    "hpgvpghpivpihpkv" +
    "pkhpmaqdaqfoqfaq" +
    "hoqhCqhaqjoqjCqj" +
    "aqloqlaqnhrehrgv" +
    "rghrivrihrkvrkhr" +
    "maseosfasgoshCsh" +
    "asiosjCsjaskosla" +
    "smhtfvtghthvtiht" +
    "jvtkhtlaufougauh" +
    "CuhouiaujCujouka" +
    "ulhvgvvhhvivvjhv" +
    "kawgowhawiCwiowj" +
    "awkhxhvxihxjayho" +
    "yiayjhziaAiaGaaG" +
    "q")
#
r(5203, "Bridge", layout="0aaaaacaaeaagaai" +
    "hbahbchbehbghbio" +
    "caoccoceocgociwd" +
    "avdcvdevdgwdioeb" +
    "oedoefoehvfahfcv" +
    "fchfevfehfgvfgvf" +
    "iogbagdogdagfogf" +
    "oghvhahhcvhchhev" +
    "hehhgvhgvhioibai" +
    "doidaifoifoihvja" +
    "hjcvjchjevjehjgv" +
    "jgvjiokbokdokfok" +
    "hvlavlcvlevlgvli" +
    "CmaCmivnavncvnev" +
    "ngvniooboodoofoo" +
    "hvpahpcvpchpevpe" +
    "hpgvpgvpioqbaqdo" +
    "qdaqfoqfoqhvrahr" +
    "cvrchrevrehrgvrg" +
    "vriosbasdosdasfo" +
    "sfoshvtahtcvtcht" +
    "evtehtgvtgvtioub" +
    "oudoufouhwvavvcv" +
    "vevvgwviowaowcow" +
    "eowgowihxahxchxe" +
    "hxghxiayaaycayea" +
    "ygayi")
r(5204, "Butterfly 2", layout="0aaeaagabcabiadb" +
    "adjhefvefaenafaa" +
    "feofeafgofgaflaf" +
    "phgdvgdwgfhghvgh" +
    "ahaaheoheahgohga" +
    "hkahqhifvifcinbj" +
    "bbjjajqblcbliblq" +
    "bmocndcnhcnmapbb" +
    "pdapfbphapjbplap" +
    "nhqbpqdiqfpqhiqj" +
    "pqlhqnarbbrdarfb" +
    "rharjbrlarnctdct" +
    "hctmbuobvcbvibvq" +
    "bxbbxjaxqhyfvyfc" +
    "ynazaazeozeazgoz" +
    "gazkazqhAdvAdwAf" +
    "hAhvAhaBaaBeoBea" +
    "BgoBgaBlaBphCfvC" +
    "faCnaDbaDjaFcaFi" +
    "aGeaGg")
r(5205, "ChessMania", layout="0aaaaacaaeaagaaj" +
    "aalaanaapacaacgb" +
    "cmaeaaegaejaelae" +
    "naepaibbidaifbih" +
    "aijbilainbipbkba" +
    "kdbkfakhbkjaklbk" +
    "nakpambbmdamfbmh" +
    "amjbmlamnbmponfo" +
    "nhonjonlbobaodbo" +
    "faohbojaolbonaop" +
    "opfppioplaqbbqda" +
    "qfbqhaqjbqlaqnbq" +
    "porforlbsbasdbsf" +
    "ashbsjaslbsnaspa" +
    "ubbudaufbuhaujbu" +
    "launbupbwbawdbwf" +
    "awhbwjawlbwnawpa" +
    "BaaBcaBgaBjaBlaB" +
    "paDabDdaDgaDjbDm" +
    "aDpaFaaFeaFgaFja" +
    "FnaFp")
r(5206, "Cross", layout="0baebagbaiaccdce" +
    "bcgdciackaeacecd" +
    "eebegdeicekaemcg" +
    "adgcdgebggdgidgk" +
    "cgmbiabicaiebiga" +
    "iibikbimbkabkcak" +
    "ebkgakibkkbkmcma" +
    "dmcdmebmgdmidmkc" +
    "mmaoacocdoebogdo" +
    "icokaomaqcdqebqg" +
    "dqiaqkbsebsgbsi")
r(5207, "Cupido's Heart", layout="0aadaalbbfbbjcch" +
    "addadlbefcehbejc" +
    "ghdhfdidcihdjbdj" +
    "jckhdkldlacmhdmn" +
    "dnbdodcohdopeqed" +
    "qqdsddspdtbdundv" +
    "adwldxbdxjdyddyh" +
    "dzfcAhaCecChaCkb" +
    "EfcEhbEjcGh")
r(5208, "Diamond", ncards=140, layout="0aaiaakacgbcibck" +
    "acmaeebegceicekb" +
    "emaeoagcbgecggdg" +
    "idgkcgmbgoagqaia" +
    "bicciedigeiieikd" +
    "imciobiqaisakabk" +
    "cckedkgekiekkdkm" +
    "ckobkqaksamcbmec" +
    "mgdmidmkcmmbmoam" +
    "qaoebogcoicokbom" +
    "aooaqgbqibqkaqma" +
    "siask")
r(5209, "Dragon 2", layout="0bafbbdobeobgbbh" +
    "bcfbcmbdkodlodnb" +
    "dobecaegbemofcbg" +
    "abgcbghbgjagloha" +
    "vhbohcbiabicbijb" +
    "ilojbbjhojjojlbk" +
    "bbkfokhbkjvkjbkl" +
    "vklolbolfblholjo" +
    "llbmbcmdbmfbmjbm" +
    "lboioojbokaoohpo" +
    "bqhbqjaqobrforho" +
    "rjasdosfbshvshbs" +
    "jvsjbslbsnhtdbtf" +
    "othotjaubaudbuhb" +
    "ujbwgbwkbwmbydoy" +
    "ebyfbymayohzobAc" +
    "aAobBjbCdoCebCfo" +
    "CgbCh")
r(5210, "Empty Pyramids", layout="0aaiabghbiabkacc" +
    "acehcgocihckacma" +
    "coadghdiadkaeiah" +
    "iaighiiaikajehjg" +
    "ojihjkajmakchkeo" +
    "kgvkiokkhkmakoal" +
    "ahlcolevlgClivlk" +
    "olmhloalqhmaamch" +
    "meomgvmiomkhmmam" +
    "ohmqonahncanehng" +
    "onihnkanmhnoonqv" +
    "oaoochoeaoghoiao" +
    "khomooovoqCpavpc" +
    "opehpgapiopihpko" +
    "pmvpoCpqvqaoqchq" +
    "eaqghqiaqkhqmoqo" +
    "vqqorahrcarehrgo" +
    "rihrkarmhroorqhs" +
    "aaschseosgvsiosk" +
    "hsmasohsqatahtco" +
    "tevtgCtivtkotmht" +
    "oatqauchueougvui" +
    "oukhumauoavehvgo" +
    "vihvkavmawghwiaw" +
    "kaxiaAiaBghBiaBk" +
    "aCcaCehCgoCihCka" +
    "CmaCoaDghDiaDkaE" +
    "i")
r(5211, "Fish face", layout="0bajbciocjbckvdj" +
    "behoeibejoekbelc" +
    "ggcgmchichkcifci" +
    "ncjhcjlckebkjcko" +
    "clgclmcmebmiomjb" +
    "mkcmocnccnqcoebo" +
    "ioojbokcoobpbcpg" +
    "cpmbprcqebqjcqoa" +
    "racrhcrlarsbsfbs" +
    "nbtiotjbtkbugbum" +
    "bwhbwlbyibykcAjc" +
    "BhcBlbDgbDmaFfaF" +
    "n")
r(5212, "Floating City", layout="0oagoaiocdocfoch" +
    "ocjoclocphdahdch" +
    "dmhdoaeboebaedae" +
    "faehaejaelaenoen" +
    "hfahfcvfchfmvfmh" +
    "foagbagnahdvheah" +
    "fahhahjvhkahlaib" +
    "ainvjgvjiakbCkha" +
    "knhlfhlhhljambam" +
    "damfomgamhCmhomi" +
    "amjamlamnomphnfh" +
    "nhhnjjoaaobCobao" +
    "dCodaofCofoogaoh" +
    "CohooiaojCojaolC" +
    "olaonConjooCopoo" +
    "qhpfhphhpjaqbaqd" +
    "aqfoqgaqhCqhoqia" +
    "qjaqlaqnoqphrfhr" +
    "hhrjasbCshasnvtg" +
    "vtiaubaunavdvvea" +
    "vfavhavjvvkavlaw" +
    "bawnhxahxcvxchxm" +
    "vxmhxoayboybayda" +
    "yfayhayjaylaynoy" +
    "nhzahzchzmhzooAd" +
    "oAfoAhoAjoAloApo" +
    "CgoCi")
# r(5213, "Flowers 2", layout="0aaiacgbciackadc" +
#    "adoaeiafabfcafea" +
#    "fmbfoafqahcahoai" +
#    "haijhjiakfakhakj" +
#    "aklhlghlihlkamda" +
#    "mfamhomhamjomjam" +
#    "lamnhnehnghnivni" +
#    "hnkhnmaobaodaofo" +
#    "ofaohoohaojoojao" +
#    "loolaonaophpchpe" +
#    "hpgvpghpivpihpkv" +
#    "pkhpmhpoaqbaqdoq" +
#    "daqfoqfaqhoqhCqh" +
#    "aqjoqjCqjaqloqla" +
#    "qnoqnaqphrchrehr" +
#    "gvrghrivrihrkvrk" +
#    "hrmhroasbasdasfo" +
#    "sfashoshasjosjas" +
#    "loslasnasphtehtg" +
#    "htivtihtkhtmauda" +
#    "ufauhouhaujoujau" +
#    "launhvghvihvkawf" +
#    "awhawjawlhxiayha" +
#    "yjazcazoaBabBcaB" +
#    "eaBmbBoaBqaCiaDc" +
#    "aDoaEgbEiaEkaGi")
# r(5214, "Full Vision 3", layout="0aaeaagaaihbehbi" +
#    "acbhccacdacfhcga" +
#    "chacjhckaclacnhc" +
#    "oacpaeahebaecaee" +
#    "aegaeiaekhelaema" +
#    "gbhgcagdagfhggag" +
#    "hagjhgkaglagnhgo" +
#    "agphhehhiaieaiga" +
#    "iiainhioaiphjgak" +
#    "eakgakiaknhkoakp" +
#    "hlehliambhmcamda" +
#    "mfhmgamhamjhmkam" +
#    "lamnhmoampaoahob" +
#    "aocaoehofaogaoia" +
#    "okholaomaqbhqcaq" +
#    "daqfhqgaqhaqjhqk" +
#    "aqlaqnhqoaqphreh" +
#    "riaseasgasiasnhs" +
#    "oasphtgaueaugaui" +
#    "aunhuoauphvehvia" +
#    "wbhwcawdawfhwgaw" +
#    "hawjhwkawlawnhwo" +
#    "awpayahybaycayea" +
#    "ygayiaykhylaymaA" +
#    "bhAcaAdaAfhAgaAh" +
#    "aAjhAkaAlaAnhAoa" +
#    "AphBehBiaCeaCgaC" +
#    "i")
r(5215, "Hidden Words", layout="0haahachaehaghal" +
    "abaabcobdabeabga" +
    "bjablbbnabphcahc" +
    "chceocghchhckhcq" +
    "adgadmodohefheih" +
    "emheoafgafjofjaf" +
    "lafnafphgfogghgk" +
    "hgmhgohichiehikh" +
    "inajaojaajcojdaj" +
    "eajghjhajjajlajn" +
    "ajphkbhkfokjhklh" +
    "kpalaalghlialjal" +
    "mombhmchmehmnana" +
    "ancanebnganjanla" +
    "nnbnphochoiholhq" +
    "chqfhqihqkaraarc" +
    "arearjhschshhslh" +
    "snhspatgatjatlat" +
    "natphuchuhhunava" +
    "avcaveavjhvkhwdh" +
    "wfhxihxmhxqayahy" +
    "baycayeaygayjayl" +
    "aynhyoayphzfhzka" +
    "AabAdaAghAhaAjaA" +
    "maAphBlhBnhBqaCa" +
    "hCbaCghCiaCjaCph" +
    "DfhDp")
r(5216, "Hovercraft", layout="0aadaafaahaajjbg" +
    "dccdceacgdcidckj" +
    "dgaedaefaehaejhf" +
    "gagfpggaghhhgaig" +
    "ajajjgajmhkaakgh" +
    "kmalaolaalmolmhm" +
    "avmaemghmmvmmana" +
    "onaCnaenceneenie" +
    "nkanmonmCnmhoavo" +
    "aeoghomvomapaopa" +
    "apmopmhqaaqghqma" +
    "rajrgarmasghtgau" +
    "fpugauhhvgawdawf" +
    "awhawjjxgdycdyea" +
    "ygdyidykjzgaAdaA" +
    "faAhaAj")
r(5217, "Hurdles", layout="0aaaaacaaeaagaai" +
    "aakaamaaohbahbch" +
    "behbghbihbkhbmhb" +
    "oacaocaaccoccace" +
    "oceacgocgaciocia" +
    "ckockacmocmacooc" +
    "ohdahdchdehdghdi" +
    "hdkhdmhdoaeaaeca" +
    "eeaegaeiaekaemae" +
    "oagaagcageaggagi" +
    "agkagmagohhahhch" +
    "hehhghhihhkhhmhh" +
    "oaiaoiaaicoicaie" +
    "oieaigoigaiioiia" +
    "ikoikaimoimaiooi" +
    "ohjahjchjehjghji" +
    "hjkhjmhjoakaakca" +
    "keakgakiakkakmak" +
    "oamaamcameamgami" +
    "amkammamohnahnch" +
    "nehnghnihnkhnmhn" +
    "oaoaooaaocoocaoe" +
    "ooeaogoogaoiooia" +
    "okookaomoomaoooo" +
    "ohpahpchpehpghpi" +
    "hpkhpmhpoaqaaqca" +
    "qeaqgaqiaqkaqmaq" +
    "o")
r(5218, "Tornado", layout="0babaadaambaoabi" +
    "begbekofdbfeoffa" +
    "fiofioflbfmofnbg" +
    "chgibgoahaahiohi" +
    "ahqhibhiihipajba" +
    "jeijfajgvjgajioj" +
    "iajkvjkijlajmajp" +
    "hkbhkihkpalcalia" +
    "lohmchmoandinean" +
    "fanianlinmannapb" +
    "ipdapevpeipfapga" +
    "pkiplapmvpmipnap" +
    "pardirearfariarl" +
    "irmarnhschsoatca" +
    "tiatohubhuihupav" +
    "baveivfavgvvgavi" +
    "oviavkvvkivlavma" +
    "vphwbhwihwpaxaax" +
    "ioxiaxqbychyibyo" +
    "ozdbzeozfaziozio" +
    "zlbzmoznbAgbAkaD" +
    "ibEbaEdaEmbEo")
#
r(5219, "IloveU", layout="0caddafcahdaldan" +
    "dapdcbcciceacejc" +
    "gacgkdibcilckdck" +
    "mcmecmndngdnpcoe" +
    "concqdcqmdsbcslc" +
    "uacukcwacwjdybcy" +
    "idzldzndzpcAddAf" +
    "cAhdBpdDldDndDp")
r(5220, "Inazuma", layout="0caaaaocaqcccacm" +
    "ccoacqceebeiaekc" +
    "emaeoagacggcgkag" +
    "mciaaicciibimaka" +
    "ckcakeckkamccmea" +
    "mgcmmaoecogaoico" +
    "ocqaaqgdqiaqkcqq" +
    "cscasicskasmcuea" +
    "ukcumauocwgawmcw" +
    "oawqbyecyiayocyq" +
    "aAecAgcAkaAqaCcc" +
    "CeaCgbCicCmaEacE" +
    "caEecEocGaaGccGq")
r(5221, "JPs", layout="0baabakbbmbcabck" +
    "bcobdmbdqbeabeob" +
    "fqbgabhobhqbiabi" +
    "cbiebigbiibikbim" +
    "bjobkabkcbkebkgb" +
    "kibkkbkmamqbqabq" +
    "cbqebqgbqibqkbqm" +
    "bqobqqbsabscbseb" +
    "sgbsibskbsmbsobs" +
    "qbuabuhbujbwabwh" +
    "bwjaxqbyabyhbyjb" +
    "AabAcbAgbAibCabC" +
    "cbCebCgbCibEabEc" +
    "bEebEgbEibGe")
r(5222, "Japan", ncards=96, layout="0baabacbaebagbai" +
    "bcaacebcibeaaeeb" +
    "eibgabgcbgebggbg" +
    "iahoajkajoalgali" +
    "alkhllalmaloangb" +
    "nibnkanmapebpgbp" +
    "iapkapmbrebrgari" +
    "arkatehtfatgatia" +
    "vaavcavebwibwoax" +
    "aaxcbxmbyiaykaza" +
    "bAgbAibAkbAmbAob" +
    "CiaCkbDmbEibEo")
r(5223, "Krebs", layout="0aaaaacaaeaagbai" +
    "balaanaapaaraata" +
    "caactaeaaetagaag" +
    "taiaCikaitvjkaka" +
    "CkjokkCklaktvljh" +
    "lkvllamaCmiomjam" +
    "kCmkomlCmmamtvni" +
    "hnjvnkhnlvnmaoaC" +
    "ohooiaojCojookao" +
    "lColoomConaotvph" +
    "hpivpjhpkvplhpmv" +
    "pnbqaCqgoqhaqiCq" +
    "ioqjaqkCqkoqlaqm" +
    "CqmoqnCqobqtvrhh" +
    "rivrjhrkvrlhrmvr" +
    "nCshosiasjCsjosk" +
    "aslCslosmCsnbtav" +
    "tihtjvtkhtlvtmbt" +
    "tCuioujaukCukoul" +
    "Cumavavvjhvkvvla" +
    "vtCwjowkCwlaxavx" +
    "kaxtCykazaaztaBa" +
    "aBtaDaaDtaFaaFta" +
    "HaaHcaHeaHgdHidH" +
    "laHnaHpaHraHt")
r(5224, "Kumo", layout="0caadaccaecagbai" +
    "bamdaqdcacccaceb" +
    "cgbckdcoceaaecce" +
    "ebeidembeqcgabgc" +
    "cggdgkbgobiabied" +
    "iibimbiqbkcdkgck" +
    "kbkockqbmadmebmi" +
    "cmmamocmqdocbogb" +
    "okaomcoodoqdqabq" +
    "ebqicqkcqmdqocqq")
r(5225, "Kyodai 14", layout="0aaiachhciacjodi" +
    "aefhegaehheiveia" +
    "ejhekaelofhCfiof" +
    "jagchgdagehgfagg" +
    "hghagivgihgjagkh" +
    "glagmhgnagoohiai" +
    "bhicaidaihhiiaij" +
    "ainhioaipakcbkgo" +
    "khbkivkiokjbkkak" +
    "ohlchloamcbmfbml" +
    "amoaoahobaochoda" +
    "oeooehofvofaogoo" +
    "ghohvohaoiooihoj" +
    "vojaokookholvola" +
    "omoomhonaoohopao" +
    "qaqcbqfbqlaqohrc" +
    "hroascbsgoshbsiv" +
    "siosjbskasoaubhu" +
    "caudauhhuiaujaun" +
    "huoaupoviawchwda" +
    "wehwfawghwhawivw" +
    "ihwjawkhwlawmhwn" +
    "awooxhCxioxjayfh" +
    "ygayhhyivyiayjhy" +
    "kayloziaAhhAiaAj" +
    "aCi")
r(5226, "Kyodai 17", layout="0daacaccaecagcai" +
    "cakdamccaccgccmc" +
    "eacegcemcgacgccg" +
    "ecggcgicgkcgmcia" +
    "digcimckadkgckmc" +
    "macmccmecmgcmicm" +
    "kcmmcoacogcomcqa" +
    "cqgcqmdsacsccsec" +
    "sgcsicskdsm")
#
r(5227, "Kyodai 18", layout="0daidchdcjdegdek" +
    "dgfdgldiedimdkda" +
    "kidkndmcamhamjdm" +
    "odobaogaoiaokdop" +
    "dqaaqfaqhaqjaqld" +
    "qqdsbasgasiaskds" +
    "pducauhaujduodwd" +
    "awidwndyedymdAfd" +
    "AldCgdCkdEhdEjdG" +
    "i")
r(5228, "Kyodai 20", layout="0aaeaagaaiaakaam" +
    "aaohbjacdaciacka" +
    "cpaecbehbelaeqag" +
    "baggagmagraiaaif" +
    "higaihoihhiiviia" +
    "ijoijCijhikvikai" +
    "loilhimainaisaka" +
    "akebkjakoaksamaa" +
    "mdcmhamjcmlampam" +
    "saoahobaocoochod" +
    "vodaoeooeCoehofv" +
    "ofaogooghohaoiko" +
    "jaokholaomoomhon" +
    "vonaoooooCoohopv" +
    "opaoqooqhoraosaq" +
    "aaqdcqhaqjcqlaqp" +
    "aqsasaasebsjasoa" +
    "ssauaaufhugauhou" +
    "hhuivuiaujoujCuj" +
    "hukvukauloulhuma" +
    "unausawbawgawmaw" +
    "raycbyhbylayqaAd" +
    "aAiaAkaAphBjaCea" +
    "CgaCiaCkaCmaCo")
#
r(5229, "Kyodai 23", layout="0aaehbeacdoceacf" +
    "hdevdeaecaeeoeea" +
    "eghfdvfehffagaag" +
    "cageogeaggagihhb" +
    "hhdhhfhhhaiaaico" +
    "icaieoieaigoigai" +
    "ihjbhjdvjdhjfvjf" +
    "hjhakaakcokcakeo" +
    "keCkeakgokgakihl" +
    "bhldvldhlfvlfhlh" +
    "amaamcomcameomea" +
    "mgomgamihnbhndhn" +
    "fhnhaoaaocaoeooe" +
    "aogaoihpdhpfaqaa" +
    "qcaqeoqeaqgaqihr" +
    "bhrdhrfhrhasaasc" +
    "oscaseoseasgosga" +
    "sihtbhtdvtdhtfvt" +
    "fhthauaaucoucaue" +
    "oueCueaugougauih" +
    "vbhvdvvdhvfvvfhv" +
    "hawaawcowcaweowe" +
    "awgowgawihxbhxdh" +
    "xfhxhayaaycayeoy" +
    "eaygayihzdvzehzf" +
    "aAcaAeoAeaAghBev" +
    "BeaCdoCeaCfhDeaE" +
    "e")
#
r(5230, "Kyodai 24", layout="0aaaiabaacaaejaf" +
    "aagaaiiajaakvbci" +
    "bdCbfibhvbiacaic" +
    "baccacevceicfacg" +
    "vcgaciicjackvdci" +
    "ddCddCdfidhCdhvd" +
    "iaeaiebaecaeevee" +
    "iefaegvegaeiieja" +
    "ekvfcifdCfdifhCf" +
    "hvfiagaigbagcage" +
    "vgeigfaggvggagii" +
    "gjagkvhcihdChdih" +
    "hChhvhiaiaiibaic" +
    "aievieiifaigviga" +
    "iiiijaikvjcijdCj" +
    "dCjfijhCjhvjiaka" +
    "ikbakcakevkeikfa" +
    "kgvkgakiikjakkvl" +
    "cildClfilhvliama" +
    "imbamcamejmfamga" +
    "miimjamk")
r(5231, "Kyodai 25", layout="0cagbaicakbcgbck" +
    "odgodkbegbekcggc" +
    "gkbieoifbigciibi" +
    "koilbimbkiolicma" +
    "bmicmqboabogdoib" +
    "okboqcqabqcoqdbq" +
    "edqgdqkbqmoqnbqo" +
    "cqqbsabsgdsibskb" +
    "sqcuabuicuqovibw" +
    "ibyeoyfbygcyibyk" +
    "oylbymcAgcAkbCgb" +
    "CkoDgoDkbEgbEkcG" +
    "gbGicGk")
#
r(5232, "Kyodai 26", layout="0aahhbhacgacihdg" +
    "hdiaefaehaejhffh" +
    "fhhfjageaggagiag" +
    "khhehhghhihhkaid" +
    "aifaihaijailhjdh" +
    "jhhjlakcakeakgak" +
    "iakkakmhlchlehlg" +
    "hlihlkhlmambamda" +
    "mfamhamjamlamnhn" +
    "bhnfhnhhnjhnnaoa" +
    "aocaoeaogaoiaoka" +
    "omaoohpahpchpehp" +
    "ghpihpkhpmhpoaqa" +
    "aqcaqeaqgaqiaqka" +
    "qmaqohrahrchrehr" +
    "ghrihrkhrmhroasa" +
    "ascaseasgasiaska" +
    "smasohtbhtfhthht" +
    "jhtnaubaudaufauh" +
    "aujaulaunhvchveh" +
    "vghvihvkhvmawcaw" +
    "eawgawiawkawmhxd" +
    "hxhhxlaydayfayha" +
    "yjaylhzehzghzihz" +
    "kaAeaAgaAiaAkhBf" +
    "hBhhBjaCfaChaCjh" +
    "DghDiaEgaEihFhaG" +
    "h")
#
r(5233, "Kyodai 27", layout="0aagacfhcgachaee" +
    "hefaegoeghehaeiv" +
    "fgagdhgeagfogfhg" +
    "gCggaghoghhgiagj" +
    "vhfvhhaichidaieo" +
    "iehifCifaigoighi" +
    "hCihaiioiihijaik" +
    "vjevjgvjiakbhkca" +
    "kdokdhkeCkeakfok" +
    "fhkgCkgakhokhhki" +
    "Ckiakjokjhkkaklv" +
    "ldvlfvlhvljamahm" +
    "bamcomchmdameome" +
    "hmfCmfamgomghmhC" +
    "mhamiomihmjamkom" +
    "khmlammvndvnfvnh" +
    "vnjaobhocaodoodh" +
    "oeCoeaofoofhogCo" +
    "gaohoohhoiCoiaoj" +
    "oojhokaolvpevpgv" +
    "piaqchqdaqeoqehq" +
    "fCqfaqgoqghqhCqh" +
    "aqioqihqjaqkvrfv" +
    "rhasdhseasfosfhs" +
    "gCsgashoshhsiasj" +
    "vtgauehufaugough" +
    "uhauiawfhwgawhay" +
    "g")
#
r(5234, "Kyodai 28", layout="0baibbgbbkbcebci" +
    "bcmbdcbdobeabeib" +
    "eqbgacggvghcgiCg" +
    "ivgjcgkbgqbiacif" +
    "ciicilbiqbkackea" +
    "khakjckmbkqhlhhl" +
    "jbmacmdamgamiomi" +
    "amkcmnbmqhnhhnjb" +
    "oacoeaohaojcombo" +
    "qbqacqfcqicqlbqq" +
    "bsacsgvshcsiCsiv" +
    "sjcskbsqbuabuibu" +
    "qbvcbvobwebwibwm" +
    "bxgbxkbyi")
#
r(5235, "Kyodai 41", layout="0CaeCagCaivbevbg" +
    "vbiCcdoceocgociC" +
    "cjvddhdevdfhdgCd" +
    "gvdhhdivdjCecaee" +
    "oeeCeeaegoegaeio" +
    "eiCeiCekCfavfbof" +
    "chfdvfdhffvffCfg" +
    "hfhvfhhfjvfjofkv" +
    "flCfmCgdageogeag" +
    "goggagiogiCgjCha" +
    "vhbohchhdvhdhhfv" +
    "hfChghhhvhhhhjvh" +
    "johkvhlChmCicaie" +
    "oieCieaigoigaiio" +
    "iiCiiCikCjavjboj" +
    "chjdvjdhjfvjfCjg" +
    "hjhvjhhjjvjjojkv" +
    "jlCjmCkdakeokeak" +
    "gokgakiokiCkjCla" +
    "vlbolchldvldhlfv" +
    "lfClghlhvlhhljvl" +
    "jolkvllClmCmcame" +
    "omeCmeamgomgamio" +
    "miCmiCmkvndhnevn" +
    "fhngCngvnhhnivnj" +
    "CodooeoogooiCojv" +
    "pevpgvpiCqeCqgCq" +
    "i")
#
r(5236, "Kyodai 42", layout="0oaboadCagoajoal" +
    "hbahbcvbchbeobfv" +
    "bgobhhbihbkvbkhb" +
    "macbacdacjaclhdb" +
    "hddodevdfCdgvdho" +
    "dihdjhdlaecaekhf" +
    "chfeoffvfgofhhfi" +
    "hfkagdCggagjhhdh" +
    "hfhhhhhjaieaiihj" +
    "ehjghjiakfCkgakh" +
    "hlfvlghlhCmfamgo" +
    "mgCmhhnfvnghnhao" +
    "gCoghpfhphCqcvqd" +
    "oqeCqeaqgoqgoqiC" +
    "qivqjCqkhrfhrhas" +
    "gCsghtfvtghthCuf" +
    "augougCuhhvfvvgh" +
    "vhawfCwgawhhxehx" +
    "ghxiayeayihzdhzf" +
    "hzhhzjaAdCAgaAjh" +
    "BchBeoBfvBgoBhhB" +
    "ihBkaCcaCkhDbhDd" +
    "oDevDfCDgvDhoDih" +
    "DjhDlaEbaEdaEjaE" +
    "lhFahFcvFchFeoFf" +
    "vFgoFhhFihFkvFkh" +
    "FmoGboGdCGgoGjoG" +
    "l")
r(5237, "Lattice", layout="0aaiacebciacmaec" +
    "beeaegbeiaekbema" +
    "eoagecgiagmaicbi" +
    "eaigciiaikbimaio" +
    "akeckiakmamcbmeb" +
    "mgdmibmkbmmamobo" +
    "eeoibomaqabqccqe" +
    "eqgdqieqkcqmbqoa" +
    "qqbseesibsmaucbu" +
    "ebugduibukbumauo" +
    "awecwiawmaycbyea" +
    "ygcyiaykbymayoaA" +
    "ecAiaAmaCcbCeaCg" +
    "bCiaCkbCmaCoaEeb" +
    "EiaEmaGi")
#
# r(5238, "Leo", layout="0aapabiablhbphcf" +
#    "acghchhclacnocpa" +
#    "djodladpvdpheeae" +
#    "fheiaelvelhepCep" +
#    "ofihflCflafnofph" +
#    "gdagevgiagjoglag" +
#    "pvgphhiChiahlvhl" +
#    "hhpChphicaidoiih" +
#    "ilCilainoipvjiaj" +
#    "jojlajpvjpbkabkc" +
#    "hkiCkiaklvklhkpC" +
#    "kpolbolihllalnol" +
#    "pbmabmcvmiamjoml" +
#    "ampvmphnianlhnpo" +
#    "oiholaonoophpfap" +
#    "hapjappaqfhqiaql" +
#    "hqphrdarnasehsqh" +
#    "tcatpaudbumhuphv" +
#    "bcvgavqawccwlhwq" +
#    "hxbcxjaxpayccylh" +
#    "yphzbczgazqaAdbA" +
#    "mhAqhBcaBpaCehCp" +
#    "hDeaDgaDohEgaEia" +
#    "EmhEohFiaFkhFmhG" +
#    "k")
#
r(5239, "Loose Ends", layout="0aaaoabaaioapaaq" +
    "hbahbihbqacbocca" +
    "chociacjocoacphd" +
    "bhdivdihdpaecoed" +
    "aegaeioeiaekoena" +
    "eohfchfivfihfoag" +
    "dogeaghogiagjogm" +
    "agnhhdhhivhihhna" +
    "ieoifaiioiioilai" +
    "mhjfhjihjlakgokg" +
    "akiakkokkhlholih" +
    "ljamahmbamcomchm" +
    "dvmdameomehmfvmf" +
    "amgvmhamiCmivmja" +
    "mkhmlvmlammommhm" +
    "nvmnamoomohmpamq" +
    "hnhonihnjaogooga" +
    "oiaokookhpfhpihp" +
    "laqeoqfaqioqioql" +
    "aqmhrdhrivrihrna" +
    "sdoseashosiasjos" +
    "masnhtchtivtihto" +
    "aucoudaugauiouia" +
    "ukounauohvbhvivv" +
    "ihvpawbowcawhowi" +
    "awjowoawphxahxih" +
    "xqayaoybayioypay" +
    "q")
r(5240, "Mini Traditional", ncards=48, layout="0aaeacdacfhdeaec" +
    "aeeoeeaeghfdvfeh" +
    "ffagbagdogeagfag" +
    "hhhchhevhehhgaia" +
    "aicoicaieoieaigo" +
    "igaiihjchjevjehj" +
    "gakbakdokeakfakh" +
    "hldvlehlfamcameo" +
    "meamghneaodaofaq" +
    "e")
r(5241, "Mini-Layout", ncards=8, layout="0aabaadacahcbhcd" +
    "aceaebaed")
r(5242, "Mission Impossible", layout="0baabamaapccaccm" +
    "acpdeacecbeeaegb" +
    "eicekdemaepcgacg" +
    "magpbiabimaipakp" +
    "bmacmcdmeemgdmic" +
    "mkbmmampcocaopdq" +
    "eaqpcscaspbuacuc" +
    "dueeugduicukbuma" +
    "upawpbyabycbyeby" +
    "gbyibykbymaypcAa" +
    "cAgaApdCadCgaCpe" +
    "EaaEp")
#
r(5243, "Multi X", layout="0aaaaaiaaqhbbhbh" +
    "hbjhbpoccocgocko" +
    "covddvdfvdlvdnce" +
    "eCeecemCemvfdvff" +
    "vflvfnogcoggogko" +
    "gohhbhhhhhjhhpai" +
    "aaiiaiqhjbojcvjd" +
    "Cjevjfojghjhojih" +
    "jjojkvjlCjmvjnoj" +
    "ohjpakaakiakqhlb" +
    "hlhhljhlpomcomgo" +
    "mkomovndvnfvnlvn" +
    "ncoeCoecomComvpd" +
    "vpfvplvpnoqcoqgo" +
    "qkoqohrbhrhhrjhr" +
    "pasaasiasqhtbotc" +
    "vtdCtevtfotghtho" +
    "tihtjotkvtlCtmvt" +
    "notohtpauaauiauq" +
    "hvbhvhhvjhvpowco" +
    "wgowkowovxdvxfvx" +
    "lvxncyeCyecymCym" +
    "vzdvzfvzlvznoAco" +
    "AgoAkoAohBbhBhhB" +
    "jhBpaCaaCiaCq")
# r(5244, "New Layout 2", layout="0CabCadCafacapca" +
#    "hccvccacepcehcgv" +
#    "cgheaveaaecpeche" +
#    "eveeaegpegCfaCfc" +
#    "CfeCfgagapgahgcv" +
#    "gcagepgehggvggCh" +
#    "aChcCheChghiavia" +
#    "aicpichievieaigp" +
#    "igakaqkahkcwkcak" +
#    "eqkehkgwkghmawma" +
#    "amcqmchmewmeamgq" +
#    "mgaoaqoahocwocao" +
#    "eqoehogwoghqavqa" +
#    "aqcpqchqevqeaqgp" +
#    "qgCraCrcCreCrgas" +
#    "apsahscvscasepse" +
#    "hsgvsgCtaCtcCteC" +
#    "tghuavuaaucpuchu" +
#    "evueaugpugawapwa" +
#    "hwcvwcawepwehwgv" +
#    "wgCybCydCyf")
r(5245, "Okie's Nitemare", layout="0aaoaaqbbeabmhbp" +
    "acoacqcddbdgadmh" +
    "dpaeoaeqbfccffaf" +
    "mhfpagoagqbhehhp" +
    "aiiaioaiqhjihjqa" +
    "kiakqalohlqammhm" +
    "oamqandankhnmano" +
    "onohnqaobaoihoka" +
    "ompomhooaoqapghp" +
    "iapkopkhpmapoopo" +
    "hpqaqabqcoqdbqeo" +
    "qfhqgaqioqihqkvq" +
    "kCqlaqmpqmhqoaqq" +
    "arghriarkorkhrma" +
    "roorohrqasbasihs" +
    "kasmpsmhsoasqatd" +
    "atkhtmatootohtqa" +
    "umhuoauqavohvqaw" +
    "iawqhxihxqbyeayi" +
    "ayoayqhzpbAccAfa" +
    "AoaAqaBmhBpcCdbC" +
    "gaCoaCqaDmhDpbEe" +
    "aEoaEqaFmhFpaGoa" +
    "Gq")
r(5246, "Orbital", ncards=84, layout="0dafdahdajdchceh" +
    "bghbihbkhclablfb" +
    "ljclocnabncbnebn" +
    "kbnmcnocpabpfbpj" +
    "cpobqhbshbuhcwhd" +
    "yhdAfdAhdAj")
r(5247, "Owl", layout="0baebagbaibakbam" +
    "bcdbcncecbejbeoc" +
    "gbbghcgjbglbgpci" +
    "cbijbiobkdbkncla" +
    "blpbmebmmcnbanpc" +
    "odaofbohbojbolbo" +
    "nhopipfappoppcqd" +
    "aqfbqhbqjbqlbqnh" +
    "qpcrbarpbsebsmct" +
    "abtpbudbuncwcbwj" +
    "bwocybbyhcyjbylb" +
    "ypcAcbAjbAobCdbC" +
    "nbEebEgbEibEkbEm")
r(5248, "Pantheon", layout="0baebcebdgbdqbee" +
    "aeiaekaemaeobfcb" +
    "fgbfqbgebhcbiebj" +
    "cojdbjgbjqbkabke" +
    "akiakkakmakoolbb" +
    "lcoldblgblqbmabm" +
    "eonbbncboaoodboe" +
    "opbbpcbpgbpqbqab" +
    "qeaqiaqkaqmaqoor" +
    "bbrcbrgbrqbsaosd" +
    "bseotbbtcbuabueo" +
    "vbbvcovdbvgbvqbw" +
    "abweawiawkawmawo" +
    "bxcoxdbxgbxqbyeb" +
    "zcbAebBcbBgbBqbC" +
    "eaCiaCkaCmaCobDg" +
    "bDqbEebGe")
#
r(5249, "Papillon", layout="0bagbaibakobhobj" +
    "bcfbchbcjbclodho" +
    "djbecbeebegbeibe" +
    "kbembeoofdofnbgd" +
    "bgnbiebimojeojmb" +
    "kdbkfbklbknbmcbm" +
    "gbmkbmobobbohboj" +
    "bopopibqabqibqqo" +
    "ribsbbshbsjbspbu" +
    "cbugbukbuobwdbwf" +
    "bwlbwnoxeoxmbyeb" +
    "ymbAdbAnoBdoBnbC" +
    "cbCebCgbCibCkbCm" +
    "bCooDhoDjbEfbEhb" +
    "EjbEloFhoFjbGgbG" +
    "ibGk")
r(5250, "Pyramid 1", layout="0aagaaiaceacghch" +
    "aciackaecbeebegb" +
    "eibekaemagabgcbg" +
    "ecggcgibgkbgmago" +
    "aiabicciecigvihc" +
    "iicikbimaioakabk" +
    "cckedkgdkickkbkm" +
    "akoamabmccmedmgd" +
    "micmkbmmamoaoabo" +
    "ccoecogvohcoicok" +
    "bomaooaqabqcbqec" +
    "qgcqibqkbqmaqoas" +
    "cbsebsgbsibskasm" +
    "aueaughuhauiauka" +
    "wgawi")
r(5251, "Pyramid 2", layout="0aaeaagaaiaccbce" +
    "bcgbciackaeabecb" +
    "eeoefbegoehbeibe" +
    "kaemagacgcdgedgg" +
    "dgicgkagmbiadice" +
    "ieeigeiidikbimbk" +
    "adkcekeekgekidkk" +
    "bkmamacmcdmedmgd" +
    "micmkammaoabocbo" +
    "eoofbogoohboibok" +
    "aomaqcbqebqgbqia" +
    "qkaseasgasi")
#
r(5252, "Quad", layout="0baabacbaeaagbai" +
    "bakbamobbobdobjo" +
    "blbcabccvccbceac" +
    "gbcibckvckbcmodb" +
    "oddodjodlbeabecv" +
    "ecbeeaegbeibekve" +
    "kbemofbofdofjofl" +
    "bgabgcbgeaggbgib" +
    "gkbgmaiaaicaiebi" +
    "gaiiaikaimbkabkc" +
    "bkeakgbkibkkbkmo" +
    "lboldoljollbmabm" +
    "cvmcbmeamgbmibmk" +
    "vmkbmmonbondonjo" +
    "nlboabocvocboeao" +
    "gboibokvokbomopb" +
    "opdopjoplbqabqcb" +
    "qeaqgbqibqkbqm")
#
r(5253, "Rectangle", layout="0daadacdaedagdca" +
    "dccdcedcgdeadecd" +
    "eedegdgadgcdgedg" +
    "gdiadicdiedigdka" +
    "dkcdkedkgdmadmcd" +
    "medmgdoadocdoedo" +
    "gdqadqcdqedqg")
r(5254, "Reindeer", ncards=64, layout="0haeabdocchdbadn" +
    "aecheehemaffafla" +
    "fohgkahfahhahjaj" +
    "fajjalfalhaljall" +
    "hmmanfanjonnaooa" +
    "pfaphapjarfarjas" +
    "latfathatjhtmoua" +
    "hufounhvbhvjavoa" +
    "wchwfawkhxdaxghx" +
    "hhxlayioymazevzn" +
    "aAiaBchBdaBgaBoh" +
    "CbhChaCioDaoDivE" +
    "h")
r(5255, "Rings", layout="0aahabfhbhabjacd" +
    "hcfachochhcjaclh" +
    "ddadfodfhdhvdhad" +
    "jodjhdlaebaedhef" +
    "aehoehhejaelaenh" +
    "fcaffhfhafjhfmag" +
    "caghagmhhchhmaic" +
    "aihaimhjcajfhjha" +
    "jjhjmakbakdhkfak" +
    "hokhhkjaklaknhld" +
    "alfolfhlhvlhaljo" +
    "ljhllamdhmfamhom" +
    "hhmjamlanfhnhanj" +
    "aoaaohaooaqaaqha" +
    "qoarfhrharjasdhs" +
    "fashoshhsjaslhtd" +
    "atfotfhthvthatjo" +
    "tjhtlaubaudhufau" +
    "houhhujaulaunhvc" +
    "avfhvhavjhvmawca" +
    "whawmhxchxmaycay" +
    "haymhzcazfhzhazj" +
    "hzmaAbaAdhAfaAho" +
    "AhhAjaAlaAnhBdaB" +
    "foBfhBhvBhaBjoBj" +
    "hBlaCdhCfaChoChh" +
    "CjaClaDfhDhaDjaE" +
    "h")
r(5256, "River Bridge", ncards=116, layout="0aafaalacfachacj" +
    "aclhdfhdhhdjhdlo" +
    "efoehoejoelvffvf" +
    "loggogiogkvhfhhh" +
    "hhjvhloigaiioiio" +
    "ikvjfhjhhjjvjlaj" +
    "oakcokgakiokiokk" +
    "akmakqalavlfhlhh" +
    "ljvllomgamiomiom" +
    "kvnfhnhhnjvnloog" +
    "aoiooiookvpfhphh" +
    "pjvploqgaqioqioq" +
    "kvrfhrhhrjvrlosg" +
    "asiosioskvtfhthh" +
    "tjvtlaucougauiou" +
    "ioukauoavavvfhvh" +
    "hvjvvlavmavqowga" +
    "wiowiowkvxfhxhhx" +
    "jvxloygoyioykvzf" +
    "vzloAfoAhoAjoAlh" +
    "BfhBhhBjhBlaCfaC" +
    "haCjaClaEfaEl")
#
r(5257, "Roman Arena", layout="0CaaCacCaeCagCai" +
    "vbbvbdvbfvbhCcao" +
    "ccoceocgCcivdbhd" +
    "dadehdfvdhCeaoec" +
    "oegCeivfbhfdafeh" +
    "ffvfhCgaogcoggCg" +
    "ivhbhhdahehhfvhh" +
    "CiaoicoigCiivjbh" +
    "jdajehjfvjhCkaok" +
    "cokgCkivlbhldale" +
    "hlfvlhCmaomcCmcC" +
    "meomgCmgCmivnbhn" +
    "dvndanehnfvnfvnh" +
    "CoaoocooeCoeoogC" +
    "oivpbhpdvpdapehp" +
    "fvpfvphCqaoqcCqc" +
    "CqeoqgCqgCqivrbh" +
    "rdarehrfvrhCsaos" +
    "cosgCsivtbhtdate" +
    "htfvthCuaoucougC" +
    "uivvbhvdavehvfvv" +
    "hCwaowcowgCwivxb" +
    "hxdaxehxfvxhCyao" +
    "ycoygCyivzbhzdaz" +
    "ehzfvzhCAaoAcoAe" +
    "oAgCAivBbvBdvBfv" +
    "BhCCaCCcCCeCCgCC" +
    "i")
r(5258, "Rugby", layout="0aafaahaceacgaci" +
    "aecaeeaegaeiaeka" +
    "gaagcagehgfagghg" +
    "hagiagkagmaiaaic" +
    "hidaiehifaighiha" +
    "iihijaikaimakahk" +
    "bakchkdakeikfakg" +
    "ikhakihkjakkhkla" +
    "kmamahmbamchmdam" +
    "eimfamgvmgimhami" +
    "hmjamkhmlammondo" +
    "njaoahobaochodao" +
    "evoeiofaogvogioh" +
    "aoivoihojaokhola" +
    "omopdopjaqahqbaq" +
    "chqdaqeiqfaqgvqg" +
    "iqhaqihqjaqkhqla" +
    "qmasahsbaschsdas" +
    "eisfasgishasihsj" +
    "askhslasmauaauch" +
    "udauehufaughuhau" +
    "ihujaukaumawaawc" +
    "awehwfawghwhawia" +
    "wkawmaycayeaygay" +
    "iaykaAeaAgaAiaCf" +
    "aCh")
r(5259, "Shapeshifter", layout="0aaoacmhcnacoaek" +
    "hemaenheoaepagih" +
    "gkaglogmhgnagohg" +
    "paiaaighiiaijoij" +
    "hilaimoinbiohjaa" +
    "kaokaakehkgakhok" +
    "hhkjakkokkokmhkn" +
    "akohkphlavlaamao" +
    "maamchmeamfomghm" +
    "hamiomiomkhmlamm" +
    "omnbmohnavnavngv" +
    "nivnkaoaooaCoaho" +
    "caodooehofaogoog" +
    "CogooiCoihojaoko" +
    "okCokoomhonaooho" +
    "phpavpavpgvpivpk" +
    "aqaoqaaqchqeaqfo" +
    "qghqhaqioqioqkhq" +
    "laqmoqnbqohravra" +
    "asaosaasehsgasho" +
    "shhsjaskoskosmhs" +
    "nasohsphtaauaaug" +
    "huiaujoujhulaumo" +
    "unbuoawihwkawlow" +
    "mhwnawohwpaykhym" +
    "aynhyoaypaAmhAna" +
    "AoaCo")
#
r(5260, "Space Bridge", layout="0aaaaacaaeaagaai" +
    "aakaamaaoaaqhbbh" +
    "bdhbfhbhhbjhblhb" +
    "nhbpacaoccoceocg" +
    "ociockocmocoacqh" +
    "dbvddvdfvdivdlvd" +
    "nhdpaeaoecCeeCei" +
    "Cemoeoaeqhfbvfdv" +
    "fnhfpagaogcogoag" +
    "qhhbhhpaiaoicoio" +
    "aiqhjbajfajlhjpa" +
    "kaokchkghkkokoak" +
    "qhlbvldClealholh" +
    "aljoljClmvlnhlpa" +
    "maomchmivmiomoam" +
    "qhnbanhonhanjonj" +
    "hnpaoaoochoghoko" +
    "ooaoqhpbapfaplhp" +
    "paqaoqcoqoaqqhrb" +
    "vrdvrnhrpasaoscC" +
    "seCsiCsmosoasqht" +
    "bvtdvtfvtivtlvtn" +
    "htpauaoucoueougo" +
    "uioukoumouoauqhv" +
    "bhvdhvfhvhhvjhvl" +
    "hvnhvpawaawcawea" +
    "wgawiawkawmawoaw" +
    "q")
r(5261, "Space Shuttle", layout="0aalaanacibckbcm" +
    "aeebegbeibekbemb" +
    "gcbgecggcgicgkcg" +
    "mbiacicciedigdii" +
    "dikdimckadkcekee" +
    "kgekiekkekmbmacm" +
    "ccmedmgdmidmkdmm" +
    "bocboecogcoicokc" +
    "omaqebqgbqibqkbq" +
    "masibskbsmaulaun")
r(5262, "Stage 1", layout="0aaebagaaiaccbce" +
    "ccgbciackaeabecc" +
    "eevefcegvehceibe" +
    "kaemagacgcdgedgg" +
    "dgicgkagmaiadicd" +
    "iedigdiidikaimak" +
    "adkcdkedkgdkidkk" +
    "akmamacmcdmedmgd" +
    "micmkammaoabocco" +
    "evofcogvohcoibok" +
    "aomaqcbqecqgbqia" +
    "qkasebsgasi")
r(5263, "Stage 2", layout="0aafaahaceacgaci" +
    "aeeaegaeiagcbgeb" +
    "ggbgiagkaiabicci" +
    "ecigciibikaimbka" +
    "ckcckeckgckickkb" +
    "kmbmaombbmcomdbm" +
    "epmfbmgpmhbmiomj" +
    "bmkomlbmmboaoobb" +
    "ocoodboepofbogpo" +
    "hboioojbokoolbom" +
    "bqacqccqecqgcqic" +
    "qkbqmasabsccsecs" +
    "gcsibskasmaucbue" +
    "bugbuiaukaweawga" +
    "wiayeaygayiaAfaA" +
    "h")
r(5264, "Stairs 2", layout="0aaadacaaedagaai" +
    "dakacadccacedcga" +
    "cidckbeadecbeede" +
    "gbeidekbgacgcbge" +
    "cggbgicgkciacicc" +
    "iecigciicikckabk" +
    "cckebkgckibkkdma" +
    "bmcdmebmgdmibmkd" +
    "oaaocdoeaogdoiao" +
    "kdqaaqcdqeaqgdqi" +
    "aqk")
r(5265, "Stairs 3", layout="0eaeeageaieakeam" +
    "dcfdchdcjdclcegc" +
    "eicekbgabghbgjbg" +
    "qaicaiiaioalfali" +
    "allhmibnaanibnqa" +
    "ocioiaoobpaapibp" +
    "qhqiarfariarlauc" +
    "auiauobwabwhbwjb" +
    "wqcygcyicykdAfdA" +
    "hdAjdAleCeeCgeCi" +
    "eCkeCm")
r(5266, "Stargate", layout="0hagobeabgobgobi" +
    "hcehcghcjoddadeo" +
    "dgadiodkhechelaf" +
    "cofcafgpfgafkofm" +
    "hgbhgghgnahaohap" +
    "hgahmohohiahilhi" +
    "pajaojavjcvjevjg" +
    "vjivjkajoojphkav" +
    "kaokdokfokhokjhk" +
    "palaolaClavlchle" +
    "hlghlivlkolpalqh" +
    "mavmaomdamfamhom" +
    "jhmpanaonaCnavnc" +
    "hnehnivnkanopnph" +
    "oavoaoodaofaohoo" +
    "jhopapaopaCpavpc" +
    "hpehpghpivpkoppa" +
    "pqhqavqaoqdoqfoq" +
    "hoqjhqparaoravrc" +
    "vrevrgvrivrkaroo" +
    "rphsahslhspataot" +
    "aptgatmotohubhug" +
    "hunavcovcavgpvga" +
    "vkovmhwchwloxdax" +
    "eoxgaxioxkhyehyg" +
    "hyjozeazgozgozih" +
    "Ag")
#
r(5267, "Sukis", layout="0aaaaacaaeaagaai" +
    "aakaamaaoaaqhbbh" +
    "bfhbjhbnacaaccac" +
    "eacgaciackacmaco" +
    "acqafaafcafeafga" +
    "fiafkafmafoafqhg" +
    "bhgpahaahcaheahg" +
    "ahiahkahmahoahqa" +
    "kahkbakcakeakgak" +
    "iakkakmakoakqhlp" +
    "amaamcameamgamia" +
    "mkammamoamqapaap" +
    "capeapgapiapkapm" +
    "apoapqhqbhqparaa" +
    "rcareargariarkar" +
    "maroarqauaaucaue" +
    "augauiaukaumauoa" +
    "uqhvpawahwbawcaw" +
    "eawgawiawkawmawo" +
    "awqazaazcazeazga" +
    "ziazkazmazoazqhA" +
    "bhApaBaaBcaBeaBg" +
    "aBiaBkaBmaBoaBqa" +
    "EaaEcaEeaEgaEiaE" +
    "kaEmaEoaEqhFbhFf" +
    "hFjhFnaGaaGcaGea" +
    "GgaGiaGkaGmaGoaG" +
    "q")
#
r(5268, "Temple 1", layout="0aaaaaeaaiabchbd" +
    "abghbhacahcbocca" +
    "cehcfocgaciadchd" +
    "dodeadghdhaeaheb" +
    "oecaeehefoegaeia" +
    "fchfdpfeafghfhag" +
    "ahgbogcagehgfogg" +
    "agiahchhdvhdohev" +
    "hfahghhhaiahiboi" +
    "caiehifoigaiiajc" +
    "hjdvjdojeCjevjfa" +
    "jghjhakahkbokcak" +
    "ehkfokgakialchld" +
    "vldoleClevlfalgh" +
    "lhamahmbomcamehm" +
    "fomgamianchndvnd" +
    "oneCnevnfanghnha" +
    "oahoboocaoehofoo" +
    "gaoiapchpdvpdope" +
    "vpfapghphaqahqbo" +
    "qcaqehqfoqgaqiar" +
    "chrdprearghrhasa" +
    "hsboscasehsfosga" +
    "siatchtdoteatght" +
    "hauahuboucauehuf" +
    "ougauiavchvdavgh" +
    "vhawaaweawi")
#
r(5269, "Temple 2", layout="0aacaagaakabahbb" +
    "abehbfabihbjacco" +
    "cchcdacgocghchac" +
    "kadahdbadeodehdf" +
    "adiodihdjaecoech" +
    "edaegoeghehaekaf" +
    "ahfbafeofehffafi" +
    "ofihfjagcogchgda" +
    "ggpgghghagkahahh" +
    "bahephehhfahiohi" +
    "hhjaicoichidaigp" +
    "ighihaikajahjbaj" +
    "epjehjfajiojihjj" +
    "akcokchkdakgpkgh" +
    "khakkalahlbalepl" +
    "ehlfaliolihljamc" +
    "omchmdamgpmghmha" +
    "mkanahnbaneonehn" +
    "fanionihnjaocooc" +
    "hodaogooghohaoka" +
    "pahpbapeopehpfap" +
    "iopihpjaqcoqchqd" +
    "aqgoqghqhaqkarah" +
    "rbareorehrfarior" +
    "ihrjaschsdasghsh" +
    "askataateati")
r(5270, "Totally Random-Made", layout="0aaevajaaoabbhbh" +
    "obioceCceacgaclC" +
    "clpcmhddvddwdhhd" +
    "moecaedCedoeghej" +
    "oenhffafgCfhafjo" +
    "fjCfkvfmagaCgfvg" +
    "gvgjhgkCgnahfohh" +
    "Chjahlohlahoaibh" +
    "ichieaihvihhiioj" +
    "cajdojeCjiojjwjl" +
    "ojookmhkovkoClcC" +
    "lfvlgolhvliCljpl" +
    "khlmvlmalpClpvmd" +
    "hmghmjammCmmCnco" +
    "ndCnganhCniankho" +
    "dvodaoeCoehofhoh" +
    "vohvokoolvomaooC" +
    "phopibplCpnvqhar" +
    "ahreorfCrharkhrl" +
    "ormasfashvsiCsjh" +
    "tfCthotiatjptnht" +
    "oaucoufhuhvuhauo" +
    "hvbavgovjCvjavkv" +
    "vkhwghwjawnawpbx" +
    "daxjoxkayfaymayo" +
    "aCdaCiaEiaFe")
r(5271, "Trika", layout="0hagaahiaiaajhak" +
    "abfablhceicihcma" +
    "ddoddodfadhvdhCd" +
    "iadjvdjodladnodn" +
    "heeieihemaffaflh" +
    "ggaghigiagjhgkci" +
    "iakgokghkhakioki" +
    "hkjakkokkhlfhlla" +
    "meomeamiammommhn" +
    "dhnnaocoocaogaoi" +
    "aokaooooohpbhphh" +
    "pjhppaqapqaaqehq" +
    "faqioqihqlaqmaqq" +
    "pqqhrbhrhhrjhrpa" +
    "scoscasgasiaskas" +
    "oosohtdhtnaueoue" +
    "auiaumoumhvfhvla" +
    "wgowghwhawiowihw" +
    "jawkowkcyihAgaAh" +
    "iAiaAjhAkaBfaBlh" +
    "CeiCihCmaDdoDdoD" +
    "faDhvDhCDiaDjvDj" +
    "oDlaDnoDnhEeiEih" +
    "EmaFfaFlhGgaGhiG" +
    "iaGjhGk")
r(5272, "Twin", layout="0aaeaagaaibccbce" +
    "bcgbcibckaeabecc" +
    "eecegceibekaemag" +
    "abgccgedggcgibgk" +
    "agmaiabicciecigc" +
    "iibikaimbkcbkebk" +
    "gbkibkkbmebmgbmi" +
    "bocboebogboiboka" +
    "qabqccqecqgcqibq" +
    "kaqmasabsccsedsg" +
    "csibskasmauabucc" +
    "uecugcuibukaumbw" +
    "cbwebwgbwibwkaye" +
    "aygayi")
#
r(5273, "Two Domes", layout="0aaiabghbiabkace" +
    "hcghckacmhdeodho" +
    "djhdmaecoefveioe" +
    "laeohfdvfgvfkhfn" +
    "agbogeCghCgjogma" +
    "gphhcvhfvhlhhoai" +
    "aoidCigCikoinaiq" +
    "hjcvjfajhvjlhjoa" +
    "kbokeCkhCkjokmak" +
    "phldvlgvlkhlnamc" +
    "omfvmiomlamohneo" +
    "nhonjhnmaoehogho" +
    "kaomapghpiapkaqe" +
    "hqgoqhaqivqioqjh" +
    "qkaqmarghriarkas" +
    "ehsghskasmhteoth" +
    "otjhtmaucoufvuio" +
    "ulauohvdvvgvvkhv" +
    "nawboweCwhCwjowm" +
    "awphxcvxfvxlhxoa" +
    "yaoydCygCykoynay" +
    "qhzcvzfazhvzlhzo" +
    "aAboAeCAhCAjoAma" +
    "AphBdvBgvBkhBnaC" +
    "coCfvCioClaCohDe" +
    "oDhoDjhDmaEehEgh" +
    "EkaEmaFghFiaFkaG" +
    "i")
#
r(5274, "Vagues", layout="0aacCaeaagCaiaak" +
    "Camhbcvbehbgvbih" +
    "bkvbmoccoceocgoc" +
    "iockocmvdchdevdg" +
    "hdivdkhdmCecaeeC" +
    "egaeiCekaemvfchf" +
    "evfghfivfkhfmaga" +
    "ogcogeoggogiogko" +
    "gmagohhahhcvhehh" +
    "gvhihhkvhmhhooia" +
    "aicCieaigCiiaikC" +
    "imoiovjahjcvjehj" +
    "gvjihjkvjmvjoCka" +
    "okcokeokgokiokko" +
    "kmCkovlavlchlevl" +
    "ghlivlkhlmvlooma" +
    "CmcameCmgamiCmka" +
    "mmomohnavnchnevn" +
    "ghnivnkhnmhnoaoa" +
    "oocooeoogooiooko" +
    "omaoohpcvpehpgvp" +
    "ihpkvpmaqcCqeaqg" +
    "CqiaqkCqmhrcvreh" +
    "rgvrihrkvrmoscos" +
    "eosgosioskosmvtc" +
    "htevtghtivtkhtmC" +
    "ucaueCugauiCukau" +
    "m")
r(5275, "Well2", layout="0aaaaacaaeaagaai" +
    "aakaamaaoacacccc" +
    "ceccgccicckccmac" +
    "oaeadecdeedegdei" +
    "dekdemaeoagadgcd" +
    "gedgkdgmagoaiadi" +
    "cdiedikdimaioaka" +
    "dkcdkedkgdkidkkd" +
    "kmakoamacmccmecm" +
    "gcmicmkcmmamoaoa" +
    "aocaoeaogaoiaoka" +
    "omaoo")
#
r(5276, "Whatever", layout="0oaeoaghbdhbfhbh" +
    "hcbaceoceacgocgh" +
    "cjadcadiheboeeoe" +
    "ghejafcafihgboge" +
    "ogghgjahcwhfahio" +
    "iahiboicoieoigoi" +
    "ihijoikajcvjdwjf" +
    "vjhajiokahkbokcC" +
    "kdokeokgCkhokihk" +
    "jokkalcvldwlfvlh" +
    "aliomahmbvmbomcC" +
    "mdomeomgCmhomihm" +
    "jvmjomkancvndwnf" +
    "vnhaniooahobvobo" +
    "ocCodooeoogCohoo" +
    "ihojvojookapcvpd" +
    "wpfvphapioqahqbo" +
    "qcCqdoqeoqgCqhoq" +
    "ihqjoqkarcvrdwrf" +
    "vrhariosahsbosco" +
    "seosgosihsjoskat" +
    "cwtfatihuboueoug" +
    "hujavcavihwboweo" +
    "wghwjaxcaxihybay" +
    "eoyeaygoyghyjhzd" +
    "hzfhzhoAeoAg")
r(5277, "Win", layout="0aaeaahaakaanbed" +
    "begbejbembepbheb" +
    "hhbhkbhnbhqbjdbj" +
    "gbjjbjmbjpbmcbme" +
    "bmgbmibmkbmmbmoc" +
    "occoicoocqbcqhcq" +
    "ncsbcshcsncuacuc" +
    "cuecugcuicukcumc" +
    "wbcwhcwncybcyhcy" +
    "ncAccAicAocCccCe" +
    "cCgcCicCkcCmcCo")
r(5278, "X-Files", layout="0aaaaaiaaqhbiacb" +
    "acgaciociackacph" +
    "dibecaeiaeoegdeg" +
    "neieeiidimdkfckl" +
    "ekpelbbmgbmkaocb" +
    "ohooibojaooaqahq" +
    "baqcoqchqdaqeaqi" +
    "aqmhqnaqooqohqpa" +
    "qqascbshosibsjas" +
    "obugbukewbcwfcwl" +
    "ewpdyeeyidymeAde" +
    "AnaCcaCiaCohDiaE" +
    "baEgaEioEiaEkaEp" +
    "hFiaGaaGiaGq")
r(5279, "X-Shape", layout="0aaibbabbqcdabdc" +
    "bdocdqaeicfacfcb" +
    "febfmcfocfqchabh" +
    "cchebhgbhkchmbho" +
    "chqbjabjecjgbjic" +
    "jkbjmbjqblgdlibl" +
    "kbnabnecngbnicnk" +
    "bnmbnqcpabpccpeb" +
    "pgbpkcpmbpocpqcr" +
    "acrcbrebrmcrocrq" +
    "asictabtcbtoctqb" +
    "vabvqawi")
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
from . import mahjongg1  # noqa: F401
from . import mahjongg2  # noqa: F401
from . import mahjongg3  # noqa: F401
from . import shisensho  # noqa: F401
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.tile.basetilemfxdialog import BaseTileMfxDialog
from pysollib.ui.tktile.solverdialog import BaseSolverDialog, solver_dialog

from .tkwidget import PysolCombo


# ************************************************************************
# *
# ************************************************************************

class SolverDialog(BaseSolverDialog, BaseTileMfxDialog):
    def _createGamesVar(self, frame, row):
        cb = PysolCombo(frame, values=tuple(self.gamenames),
                        selectcommand=self.gameSelected,
                        state='readonly', width=40)
        cb.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
        return cb

    def _createPresetVar(self, frame, row):
        cb = PysolCombo(frame, values=tuple(self.presets), state='readonly',
                        selectcommand=self._OnAssignToPreset)
        cb.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
        cb.current(0)
        return cb

    def _createShowProgressButton(self, frame):
        return self._calcToolkit().Checkbutton(
            frame, variable=self.progress_var,
            text=_('Show progress'))

    def initKw(self, kw):
        strings = [_('&Start'), _('&Play'), _('&New'), 'sep', _('&Close'), ]
        kw = KwStruct(kw,
                      strings=strings,
                      default=0,
                      )
        return self._calc_MfxDialog().initKw(self, kw)

    def connectGame(self, game):
        name = self.app.getGameTitleName(game.id)
        if name in self.gamenames:
            self.start_button.config(state='normal')
            i = self.gamenames.index(name)
            self.games_var.current(i)
        else:
            self.start_button.config(state='disabled')
            self.games_var.current(0)
        self.play_button.config(state='disabled')


solver_dialog = solver_dialog


def create_solver_dialog(parent, game):
    global solver_dialog
    try:
        solver_dialog.top.wm_deiconify()
        solver_dialog.top.tkraise()
    except Exception:
        # traceback.print_exc()
        solver_dialog = SolverDialog(parent, game)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# imports
import os
import sys

from pysollib.mygettext import _

import six
from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxTooltip

if __name__ == '__main__':
    d = os.path.abspath(os.path.join(sys.path[0], os.pardir, os.pardir))
    sys.path.append(d)
    import gettext
    gettext.install('pysol', d, unicode=True)

# ************************************************************************
# *
# ************************************************************************


class MfxStatusbar:
    def __init__(self, top, row, column, columnspan):
        self.top = top
        self._show = True
        self._widgets = []
        self._tooltips = []
        #
        self._row = row
        self._column = column
        self._columnspan = columnspan
        self._label_column = 0
        #
        self.padx = 1
        self.label_relief = 'sunken'
        self.top_frame = ttk.Frame(self.top)
        self.top_frame.grid(row=self._row, column=self._column,
                            columnspan=self._columnspan, sticky='ew')
        self.frame = ttk.Frame(self.top_frame)
        self.frame.pack(side='left', expand=True, fill='both', padx=0, pady=1)

    # util
    def _createLabel(self, name, expand=False, width=0, tooltip=None):
        frame = ttk.Frame(self.frame, borderwidth=1, relief=self.label_relief)
        frame.grid(row=0, column=self._label_column,
                   sticky='nsew', padx=self.padx)
        if expand:
            self.frame.grid_columnconfigure(self._label_column,
                                            weight=1)
        self._label_column += 1
        setattr(self, name + '_frame', frame)
        self._widgets.append(frame)
        label = ttk.Label(frame, width=width, anchor='center')
        label.pack(expand=True, fill='both')
        setattr(self, name + '_label', label)
        self._widgets.append(label)
        if tooltip:
            b = MfxTooltip(label)
            self._tooltips.append(b)
            b.setText(tooltip)
        return label

    def _createSizegrip(self):
        sg = ttk.Sizegrip(self.top_frame)
        sg.pack(side='right', anchor='se')

    #
    # public methods
    #

    def updateText(self, **kw):
        for k, v in kw.items():
            label = getattr(self, k + '_label')
            text = six.text_type(v)
            width = label['width']
            if width and len(text) > width:
                label['width'] = len(text)
            label['text'] = text

    def config(self, name, show):
        frame = getattr(self, name + '_frame')
        if show:
            frame.grid()
        else:
            frame.grid_remove()

    def configLabel(self, name, **kw):
        if 'fg' in kw:
            kw['foreground'] = kw['fg']
            del kw['fg']
        label = getattr(self, name + '_label')
        label.config(**kw)

    def show(self, show=True, resize=False):
        if self._show == show:
            return False
        if resize:
            self.top.wm_geometry('')    # cancel user-specified geometry
        if not show:
            # hide
            self.top_frame.grid_forget()
        else:
            # show
            self.top_frame.grid(row=self._row, column=self._column,
                                columnspan=self._columnspan, sticky='ew')
        self._show = show
        return True

    def hide(self, resize=False):
        self.show(False, resize)

    def destroy(self):
        for w in self._tooltips:
            if w:
                w.destroy()
        self._tooltips = []
        for w in self._widgets:
            if w:
                w.destroy()
        self._widgets = []


class PysolStatusbar(MfxStatusbar):
    def __init__(self, top):
        MfxStatusbar.__init__(self, top, row=4, column=0, columnspan=3)
        #
        for n, t, w in (
            ('stuck',       _("'You Are Stuck' indicator"), 3),
            ('time',        _('Playing time'),            10),
            ('moves',       _('Moves/Total moves'),       10),
            ('gamenumber',  _('Game number'),             26),
            ('stats',       _('Games played: won/lost'),  12),
                ):
            self._createLabel(n, tooltip=t, width=w)
        #
        label = self._createLabel('info', expand=True)
        label.config(padding=(8, 0))
        self._createSizegrip()


class HelpStatusbar(MfxStatusbar):
    def __init__(self, top):
        MfxStatusbar.__init__(self, top, row=3, column=0, columnspan=3)
        label = self._createLabel('info', expand=True)
        label.config(justify='left', anchor='w', padding=(8, 0))


class HtmlStatusbar(MfxStatusbar):
    def __init__(self, top, row, column, columnspan):
        MfxStatusbar.__init__(self, top, row=row, column=column,
                              columnspan=columnspan)
        label = self._createLabel('url', expand=True)
        label.config(justify='left', anchor='w', padding=(8, 0))
        self._createSizegrip()


# ************************************************************************
# *
# ************************************************************************


class TestStatusbar(PysolStatusbar):
    def __init__(self, top, args):
        PysolStatusbar.__init__(self, top)
        # test some settings
        self.updateText(moves=999, gamenumber='#0123456789ABCDEF0123')
        self.updateText(info='Some info text.')


def statusbar_main(args):
    tk = tkinter.Tk()
    TestStatusbar(tk, args)
    tk.mainloop()
    return 0


if __name__ == '__main__':
    sys.exit(statusbar_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog


class PlayerOptionsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        self.app = app
        #
        self.update_stats_var = tkinter.BooleanVar()
        self.update_stats_var.set(app.opt.update_player_stats != 0)
        self.confirm_var = tkinter.BooleanVar()
        self.confirm_var.set(app.opt.confirm != 0)
        self.win_animation_var = tkinter.BooleanVar()
        self.win_animation_var.set(app.opt.win_animation != 0)
        #
        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        widget = ttk.Label(frame, text=_("\nPlease enter your name"),
                           takefocus=0)
        widget.grid(row=0, column=0, columnspan=2, sticky='ew', padx=0, pady=5)
        #
        w = kw.get("e_width", 30)    # width in characters
        names = self.app.getAllUserNames()
        self.player_var = ttk.Combobox(frame, width=w, values=tuple(names))
        self.player_var.current(names.index(app.opt.player))
        self.player_var.grid(row=1, column=0, sticky='ew', padx=0, pady=5)
        #
        widget = ttk.Checkbutton(frame, variable=self.confirm_var,
                                 text=_("Confirm quit"))
        widget.grid(row=2, column=0, columnspan=2, sticky='ew', padx=0, pady=5)
        widget = ttk.Checkbutton(frame, variable=self.update_stats_var,
                                 text=_("Update statistics and logs"))
        widget.grid(row=3, column=0, columnspan=2, sticky='ew', padx=0, pady=5)
        #  widget = ttk.Checkbutton(frame, variable=self.win_animation_var,
        #                               text="Win animation")
        #  widget.pack(side='top', padx=kw.padx, pady=kw.pady)
        frame.columnconfigure(0, weight=1)
        #
        self.player = self.player_var.get()
        self.confirm = self.confirm_var.get()
        self.update_stats = self.update_stats_var.get()
        self.win_animation = self.win_animation_var.get()
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def mDone(self, button):
        self.button = button
        self.player = self.player_var.get()
        self.confirm = self.confirm_var.get()
        self.update_stats = self.update_stats_var.get()
        self.win_animation = self.win_animation_var.get()
        raise SystemExit

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")), default=0,
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os

from pysollib.mfxutil import Image, ImageOps, ImageTk
from pysollib.mygettext import _, n_
from pysollib.settings import TITLE
from pysollib.ui.tktile.menubar import MfxMenu, createToolbarMenu
from pysollib.ui.tktile.tkconst import EVENT_HANDLED
from pysollib.ui.tktile.tkutil import loadImage
from pysollib.util import IMAGE_EXTENSIONS
from pysollib.winsystems import TkSettings

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxTooltip


class AbstractToolbarButton:
    def __init__(self, parent, toolbar, toolbar_name, position):
        self.toolbar = toolbar
        self.toolbar_name = toolbar_name
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        if orient == 'horizontal':
            padx, pady = TkSettings.toolbar_button_padding
            self.grid(row=0,
                      column=self.position,
                      padx=padx, pady=pady,
                      sticky='nsew')
        else:
            pady, padx = TkSettings.toolbar_button_padding
            self.grid(row=self.position,
                      column=0,
                      padx=padx, pady=pady,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()


class ToolbarCheckbutton(AbstractToolbarButton, ttk.Checkbutton):
    def __init__(self, parent, toolbar, toolbar_name, position, **kwargs):
        kwargs['style'] = 'Toolbutton'
        ttk.Checkbutton.__init__(self, parent, **kwargs)
        AbstractToolbarButton.__init__(
            self, parent, toolbar, toolbar_name, position)


class ToolbarButton(AbstractToolbarButton, ttk.Button):
    def __init__(self, parent, toolbar, toolbar_name, position, **kwargs):
        kwargs['style'] = 'Toolbutton'
        ttk.Button.__init__(self, parent, **kwargs)
        AbstractToolbarButton.__init__(
            self, parent, toolbar, toolbar_name, position)


class ToolbarSeparator(ttk.Separator):
    def __init__(self, parent, toolbar, position, **kwargs):
        kwargs['orient'] = 'vertical'
        ttk.Separator.__init__(self, parent, **kwargs)
        self.toolbar = toolbar
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        if orient == 'horizontal':
            padx, pady = 4, 6
            self.config(orient='vertical')
            self.grid(row=0,
                      column=self.position,
                      padx=padx, pady=pady,
                      sticky='nsew')
        else:
            padx, pady = 4, 6
            self.config(orient='horizontal')
            self.grid(row=self.position,
                      column=0,
                      padx=pady, pady=padx,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()


class ToolbarLabel(tkinter.Message):
    def __init__(self, parent, toolbar, toolbar_name, position, **kwargs):
        tkinter.Message.__init__(self, parent, **kwargs)
        self.toolbar = toolbar
        self.toolbar_name = toolbar_name
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        padx, pady = TkSettings.toolbar_label_padding
        if orient == 'horizontal':
            self.grid(row=0,
                      column=self.position,
                      padx=padx, pady=pady,
                      sticky='nsew')
        else:
            self.grid(row=self.position,
                      column=0,
                      padx=padx, pady=pady,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()


# ************************************************************************
# * Note: Applications should call show/hide after constructor.
# ************************************************************************

class PysolToolbarTk:

    def __init__(self, top, menubar, dir,
                 size=0, relief='flat', compound='none'):
        self.top = top
        self.menubar = menubar
        self.side = -1
        self._tooltips = []
        self._widgets = []
        self.dir = dir
        self.size = size
        self.compound = compound
        self.orient = 'horizontal'
        #
        self.frame = ttk.Frame(top, class_='Toolbar',
                               relief=TkSettings.toolbar_relief,
                               borderwidth=TkSettings.toolbar_borderwidth)
        #
        for label, f, t in (
            (n_("New"),      self.mNewGame,   _("New game")),
            (n_("Restart"),  self.mRestart,   _("Restart the\ncurrent game")),
            (None,           None,            None),
            (n_("Open"),     self.mOpen,      _("Open a\nsaved game")),
            (n_("Save"),     self.mSave,      _("Save game")),
            (None,           None,            None),
            (n_("Undo"),     self.mUndo,      _("Undo last move")),
            (n_("Redo"),     self.mRedo,      _("Redo last move")),
            (n_("Autodrop"), self.mDrop,      _("Auto drop cards")),
            (n_("Shuffle"),  self.mShuffle,   _("Shuffle tiles")),
            (n_("Pause"),    self.mPause,     _("Pause game")),
            (None,           None,            None),
            (n_("Statistics"), self.mPlayerStats, _("View statistics")),
            (n_("Rules"),    self.mHelpRules, _("Rules for this game")),
            (None,           None,            None),
            (n_("Quit"),     self.mQuit,      _("Quit %s") % TITLE),
                ):
            if label is None:
                sep = self._createSeparator()
                sep.bind("<3>", self.rightclickHandler)
            elif label == 'Pause':
                self._createButton(label, f, check=True, tooltip=t)
            else:
                self._createButton(label, f, tooltip=t)
        self.pause_button.config(variable=menubar.tkopt.pause)

        self.popup = MfxMenu(master=None, label=n_('Toolbar'), tearoff=0)
        createToolbarMenu(menubar, self.popup)

        position = len(self._widgets)
        self.frame.rowconfigure(position, weight=1)
        self.frame.columnconfigure(position, weight=1)
        #
        self._createLabel("player", label=n_('Player'),
                          tooltip=_("Player options"))
        #
        self.player_label.bind("<1>", self.mOptPlayerOptions)
        self.frame.bind("<3>", self.rightclickHandler)
        #
        self.setCompound(compound, force=True)

    def config(self, w, v):
        if w == 'player':
            # label
            if v:
                self.player_label.show(orient=self.orient)
            else:
                self.player_label.hide()
        else:
            # button
            widget = getattr(self, w+'_button')
            if v:
                widget.show(orient=self.orient)
            else:
                widget.hide()
        #
        prev_visible = None
        last_visible = None
        for w in self._widgets:
            if isinstance(w, ToolbarSeparator):
                if prev_visible is None or isinstance(prev_visible,
                                                      ToolbarSeparator):
                    w.hide()
                else:
                    w.show(orient=self.orient)
            if w.visible:
                prev_visible = w
                if not isinstance(w, ToolbarLabel):
                    last_visible = w
        if isinstance(last_visible, ToolbarSeparator):
            last_visible.hide()

    # util
    def _loadImage(self, name):
        file = os.path.join(self.dir, name)
        image = None
        for ext in IMAGE_EXTENSIONS:
            file = os.path.join(self.dir, name+ext)
            if os.path.isfile(file):
                image = loadImage(file=file)
                break
        return image

    def _createSeparator(self):
        position = len(self._widgets)
        sep = ToolbarSeparator(self.frame,
                               position=position,
                               toolbar=self,
                               takefocus=0)
        sep.show(orient=self.orient)
        self._widgets.append(sep)
        return sep

    def _createDisabledButtonImage(self, tkim):
        # grayscale and light-up image
        if not tkim:
            return None
        im = tkim._pil_image
        dis_im = ImageOps.grayscale(im)
        # color = '#ffffff'
        # factor = 0.6
        color = '#dedede'
        factor = 0.7
        sh = Image.new(dis_im.mode, dis_im.size, color)
        tmp = Image.blend(dis_im, sh, factor)
        dis_im = Image.composite(tmp, im, im)
        dis_tkim = ImageTk.PhotoImage(image=dis_im)
        return dis_tkim

    def _setButtonImage(self, button, name):
        image = self._loadImage(name)
        setattr(self, name + "_image", image)
        if Image:
            dis_image = self._createDisabledButtonImage(image)
            if dis_image:
                setattr(self, name + "_disabled_image", dis_image)
                button.config(image=(image, 'disabled', dis_image))
        else:
            button.config(image=image)

    def _createButton(self, label, command, check=False, tooltip=None):
        name = label.lower()
        position = len(self._widgets)
        kw = {
            'position': position,
            'toolbar': self,
            'toolbar_name': name,
            'command': command,
            'takefocus': 0,
            'text': _(label),
            }

        if check:
            button = ToolbarCheckbutton(self.frame, **kw)
        else:
            button = ToolbarButton(self.frame, **kw)
        self._setButtonImage(button, name)
        button.show(orient=self.orient)
        setattr(self, name + "_button", button)
        self._widgets.append(button)
        if tooltip:
            b = MfxTooltip(button)
            self._tooltips.append(b)
            b.setText(tooltip)
        return button

    def _createLabel(self, name, label=None, tooltip=None):
        aspect = (400, 300)[self.getSize() != 0]
        position = len(self._widgets)+1
        label = ToolbarLabel(self.frame,
                             position=position,
                             toolbar=self,
                             toolbar_name=name,
                             relief="ridge",
                             justify="center",
                             aspect=aspect)
        label.show(orient=self.orient)
        setattr(self, name + "_label", label)
        self._widgets.append(label)
        if tooltip:
            b = MfxTooltip(label)
            self._tooltips.append(b)
            b.setText(tooltip)
        return label

    def _busy(self):
        if not self.side or not self.game or not self.menubar:
            return 1
        self.game.stopDemo()
        self.game.interruptSleep()
        return self.game.busy

    #
    # public methods
    #

    def show(self, side=1, resize=1):
        if self.side == side:
            return 0
        if resize:
            self.top.wm_geometry("")    # cancel user-specified geometry
        if not side:
            # hide
            self.frame.grid_forget()
        else:
            # show
            pack_func = self.frame.grid_configure

            if side == 1:
                # top
                padx, pady = TkSettings.horizontal_toolbar_padding
                pack_func(row=0, column=1, sticky='ew', padx=padx, pady=pady)
            elif side == 2:
                # bottom
                padx, pady = TkSettings.horizontal_toolbar_padding
                pack_func(row=2, column=1, sticky='ew', padx=padx, pady=pady)
            elif side == 3:
                # left
                padx, pady = TkSettings.vertical_toolbar_padding
                pack_func(row=1, column=0, sticky='ns', padx=padx, pady=pady)
            else:
                # right
                padx, pady = TkSettings.vertical_toolbar_padding
                pack_func(row=1, column=2, sticky='ns', padx=padx, pady=pady)
            # set orient
            orient = side in (1, 2) and 'horizontal' or 'vertical'
            self._setOrient(orient)
        self.side = side
        return 1

    def hide(self, resize=1):
        self.show(0, resize)

    def destroy(self):
        for w in self._tooltips:
            if w:
                w.destroy()
        self._tooltips = []
        for w in self._widgets:
            if w:
                w.destroy()
        self._widgets = []

    def setCursor(self, cursor):
        if self.side:
            self.frame.config(cursor=cursor)
            self.frame.update_idletasks()

    def updateText(self, **kw):
        for name in kw.keys():
            label = getattr(self, name + "_label")
            label["text"] = kw[name]

    def updateImages(self, dir, size):
        if dir == self.dir and size == self.size:
            return 0
        if not os.path.isdir(dir):
            return 0
        self.dir, self.size = dir, size
        data = []
        for w in self._widgets:
            if not isinstance(w, (ToolbarButton, ToolbarCheckbutton)):
                continue
            name = w.toolbar_name
            data.append((name, w))
        label = self.player_label
        aspect = (400, 300)[size != 0]
        label.config(aspect=aspect)
        for name, w in data:
            self._setButtonImage(w, name)
        self.setCompound(self.compound, force=True)
        return 1

    def setCompound(self, compound, force=False):
        if not force and self.compound == compound:
            return False
        for w in self._widgets:
            if not isinstance(w, (ToolbarButton, ToolbarCheckbutton)):
                continue
            w.config(compound=compound)
        self.compound = compound
        return True

    def _setOrient(self, orient='horizontal', force=False):
        if not force and self.orient == orient:
            return False
        for w in self._widgets:
            if w.visible:
                w.show(orient=orient, force=True)
        self.orient = orient
        return True

    #
    # Mouse event handlers
    #

    def rightclickHandler(self, event):
        if self._busy():
            return EVENT_HANDLED
        if self.popup:
            self.popup.tk_popup(event.x_root, event.y_root)
        return EVENT_HANDLED

    def getSize(self):
        if self.compound == 'text':
            return 0
        size = self.size
        comp = int(self.compound in ('top', 'bottom'))
        return int((size+comp) != 0)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.ui.tktile.selecttree import BaseSelectDialogTreeCanvas
from pysollib.ui.tktile.selecttree import BaseSelectDialogTreeLeaf
from pysollib.ui.tktile.selecttree import BaseSelectDialogTreeNode

from .tktree import MfxTreeInCanvas, MfxTreeLeaf, MfxTreeNode

# ************************************************************************
# * Nodes
# ************************************************************************


class SelectDiagCommon:
    def _calc_MfxTreeNode(self):
        return MfxTreeNode

    def _calc_MfxTreeInCanvas(self):
        return MfxTreeInCanvas

    def _calc_MfxTreeLeaf(self):
        return MfxTreeLeaf


class SelectDialogTreeLeaf(SelectDiagCommon,
                           BaseSelectDialogTreeLeaf, MfxTreeLeaf):
    pass


class SelectDialogTreeNode(SelectDiagCommon,
                           BaseSelectDialogTreeNode, MfxTreeNode):
    pass

# ************************************************************************
# * Canvas that shows the tree (left side)
# ************************************************************************


class SelectDialogTreeCanvas(SelectDiagCommon,
                             BaseSelectDialogTreeCanvas, MfxTreeInCanvas):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog, PysolScale


class TimeoutsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        # self.createBitmaps(top_frame, kw)

        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        self.demo_sleep_var = tkinter.DoubleVar()
        self.demo_sleep_var.set(app.opt.timeouts['demo'])
        self.hint_sleep_var = tkinter.DoubleVar()
        self.hint_sleep_var.set(app.opt.timeouts['hint'])
        self.raise_card_sleep_var = tkinter.DoubleVar()
        self.raise_card_sleep_var.set(app.opt.timeouts['raise_card'])
        self.highlight_piles_sleep_var = tkinter.DoubleVar()
        self.highlight_piles_sleep_var.set(app.opt.timeouts['highlight_piles'])
        self.highlight_cards_sleep_var = tkinter.DoubleVar()
        self.highlight_cards_sleep_var.set(app.opt.timeouts['highlight_cards'])
        self.highlight_samerank_sleep_var = tkinter.DoubleVar()
        self.highlight_samerank_sleep_var.set(
            app.opt.timeouts['highlight_samerank'])
        #
        lframe = ttk.LabelFrame(frame, text=_('Set delays in seconds'),
                                padding=(10, 5))
        lframe.pack(expand=True, fill='both', padx=4)
        row = 0
        for title, var in (
            (_('Demo:'),                self.demo_sleep_var),
            (_('Hint:'),                self.hint_sleep_var),
            (_('Raise card:'),          self.raise_card_sleep_var),
            (_('Highlight piles:'),     self.highlight_piles_sleep_var),
            (_('Highlight cards:'),     self.highlight_cards_sleep_var),
            (_('Highlight same rank:'), self.highlight_samerank_sleep_var),
                ):
            ttk.Label(
                lframe, text=title, anchor='w').grid(
                    row=row, column=0, sticky='we')
            widget = PysolScale(lframe, from_=0.2, to=9.9, value=var.get(),
                                resolution=0.1, orient='horizontal',
                                length="3i", variable=var, takefocus=0)
            widget.grid(row=row, column=1)
            row += 1
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)
        #
        self.demo_timeout = self.demo_sleep_var.get()
        self.hint_timeout = self.hint_sleep_var.get()
        self.raise_card_timeout = self.raise_card_sleep_var.get()
        self.highlight_piles_timeout = self.highlight_piles_sleep_var.get()
        self.highlight_cards_timeout = self.highlight_cards_sleep_var.get()
        self.highlight_samerank_timeout = \
            self.highlight_samerank_sleep_var.get()

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")), default=0,
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.pysolaudio import pysolsoundserver
from pysollib.settings import TITLE
from pysollib.ui.tktile.tkconst import EVENT_HANDLED

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog, MfxMessageDialog
from .tkwidget import PysolScale


class SoundOptionsDialog(MfxDialog):

    def __init__(self, parent, title, app, **kw):
        self.app = app
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.saved_opt = app.opt.copy()
        self.sound = tkinter.BooleanVar()
        self.sound.set(app.opt.sound != 0)
        self.sound_mode = tkinter.BooleanVar()
        self.sound_mode.set(app.opt.sound_mode != 0)
        self.sample_volume = tkinter.IntVar()
        self.sample_volume.set(app.opt.sound_sample_volume)
        self.music_volume = tkinter.IntVar()
        self.music_volume.set(app.opt.sound_music_volume)
        self.samples = [
            ('areyousure',    _('Are You Sure'),   tkinter.BooleanVar()),

            ('deal',          _('Deal'),           tkinter.BooleanVar()),
            ('dealwaste',     _('Deal waste'),     tkinter.BooleanVar()),

            ('turnwaste',     _('Turn waste'),     tkinter.BooleanVar()),
            ('startdrag',     _('Start drag'),     tkinter.BooleanVar()),

            ('drop',          _('Drop'),           tkinter.BooleanVar()),
            ('droppair',      _('Drop pair'),      tkinter.BooleanVar()),
            ('autodrop',      _('Auto drop'),      tkinter.BooleanVar()),

            ('flip',          _('Flip'),           tkinter.BooleanVar()),
            ('autoflip',      _('Auto flip'),      tkinter.BooleanVar()),
            ('move',          _('Move'),           tkinter.BooleanVar()),
            ('nomove',        _('No move'),        tkinter.BooleanVar()),

            ('undo',          _('Undo'),           tkinter.BooleanVar()),
            ('redo',          _('Redo'),           tkinter.BooleanVar()),

            ('autopilotlost', _('Autopilot lost'), tkinter.BooleanVar()),
            ('autopilotwon',  _('Autopilot won'),  tkinter.BooleanVar()),

            ('gamefinished',  _('Game finished'),  tkinter.BooleanVar()),
            ('gamelost',      _('Game lost'),      tkinter.BooleanVar()),
            ('gamewon',       _('Game won'),       tkinter.BooleanVar()),
            ('gameperfect',   _('Perfect game'),   tkinter.BooleanVar()),
            ]

        #
        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=5)
        frame.columnconfigure(1, weight=1)
        #
        row = 0
        w = ttk.Checkbutton(frame, variable=self.sound,
                            text=_("Sound enabled"))
        w.grid(row=row, column=0, columnspan=2, sticky='ew')
        #
        if os.name == "nt" and pysolsoundserver:
            row += 1
            w = ttk.Checkbutton(frame, variable=self.sound_mode,
                                text=_("Use DirectX for sound playing"),
                                command=self.mOptSoundDirectX)
            w.grid(row=row, column=0, columnspan=2, sticky='ew')
        #
        if app.audio.CAN_PLAY_MUSIC:  # and app.startup_opt.sound_mode > 0:
            row += 1
            ttk.Label(frame, text=_('Sample volume:'), anchor='w'
                      ).grid(row=row, column=0, sticky='ew')
            w = PysolScale(frame, from_=0, to=128, resolution=1,
                           orient='horizontal', takefocus=0,
                           length="3i",  # label=_('Sample volume'),
                           variable=self.sample_volume)
            w.grid(row=row, column=1, sticky='w', padx=5)
            row += 1
            ttk.Label(frame, text=_('Music volume:'), anchor='w'
                      ).grid(row=row, column=0, sticky='ew')
            w = PysolScale(frame, from_=0, to=128, resolution=1,
                           orient='horizontal', takefocus=0,
                           length="3i",  # label=_('Music volume'),
                           variable=self.music_volume)
            w.grid(row=row, column=1, sticky='w', padx=5)

        else:
            # remove "Apply" button
            kw.strings[1] = None
        #
        frame = ttk.LabelFrame(top_frame, text=_('Enable samples'))
        frame.pack(expand=True, fill='both', padx=5, pady=5)
        frame.columnconfigure(0, weight=1)
        frame.columnconfigure(1, weight=1)
        #
        row = 0
        col = 0
        for n, t, v in self.samples:
            v.set(app.opt.sound_samples[n])
            w = ttk.Checkbutton(frame, text=t, variable=v)
            w.grid(row=row, column=col, sticky='ew', padx=3, pady=1)
            if col == 1:
                col = 0
                row += 1
            else:
                col = 1
        #
        top_frame.columnconfigure(1, weight=1)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        strings = [_("&OK"), _("&Apply"), _("&Cancel"), ]
        kw = KwStruct(kw,
                      strings=strings,
                      default=0,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if button == 0 or button == 1:
            self.app.opt.sound = self.sound.get()
            self.app.opt.sound_mode = int(self.sound_mode.get())
            self.app.opt.sound_sample_volume = self.sample_volume.get()
            self.app.opt.sound_music_volume = self.music_volume.get()
            for n, t, v in self.samples:
                self.app.opt.sound_samples[n] = v.get()
        elif button == 2:
            self.app.opt = self.saved_opt
        if self.app.audio:
            self.app.audio.updateSettings()
            if button == 1:
                self.app.audio.playSample("drop", priority=1000)
        if button == 1:
            return EVENT_HANDLED
        return MfxDialog.mDone(self, button)

    def mCancel(self, *event):
        return self.mDone(2)

    def wmDeleteWindow(self, *event):
        return self.mDone(0)

    def mOptSoundDirectX(self, *event):
        # print self.sound_mode.get()
        MfxMessageDialog(
            self.top, title=_("Sound preferences info"),
            text=_("""\
Changing DirectX settings will take effect
the next time you restart """)+TITLE,
            bitmap="warning",
            default=0, strings=(_("&OK"),))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.tile.basetilemfxdialog import BaseTileMfxDialog
from pysollib.ui.tktile.colorsdialog import BaseColorsDialog

# ************************************************************************
# *
# ************************************************************************


class ColorsDialog(BaseColorsDialog, BaseTileMfxDialog):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os
import time

from pysollib.mfxutil import KwStruct
from pysollib.mfxutil import format_time
from pysollib.mygettext import _
from pysollib.settings import TOP_TITLE
from pysollib.stats import ProgressionFormatter, PysolStatsFormatter
from pysollib.ui.tktile.tkutil import bind, loadImage

from six.moves import tkinter
from six.moves import tkinter_font
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog, MfxMessageDialog


# ************************************************************************
# *
# ************************************************************************

class StatsDialog(MfxDialog):
    SELECTED_TAB = 0

    def __init__(self, parent, title, app, player, gameid, **kw):

        kw = self.initKw(kw)
        title = _('Statistics')
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)

        self.font = app.getFont('default')
        self.tkfont = tkinter_font.Font(parent, self.font)
        self.font_metrics = self.tkfont.metrics()
        style = ttk.Style(parent)
        heading_font = style.lookup('Heading', 'font')  # treeview heading
        self.heading_tkfont = tkinter_font.Font(parent, heading_font)

        self.selected_game = None

        top_frame, bottom_frame = self.createFrames(kw)
        notebook = ttk.Notebook(top_frame)
        notebook.pack(expand=True, fill='both', padx=10, pady=10)

        self.notebook_tabs = []

        single_frame = SingleGameFrame(self, notebook, app, player, gameid)
        notebook.add(single_frame, text=_('Current game'))
        self.notebook_tabs.append(single_frame._w)

        all_frame = AllGamesFrame(self, notebook, app, player)
        notebook.add(all_frame, text=_('All games'))
        self.all_games_frame = all_frame
        self.notebook_tabs.append(all_frame._w)

        top_frame = TopFrame(self, notebook, app, player, gameid)
        notebook.add(top_frame, text=TOP_TITLE)
        self.notebook_tabs.append(top_frame._w)

        if player is not None:
            progr_frame = ProgressionFrame(self, notebook, app, player, gameid)
            notebook.add(progr_frame, text=_('Progression'))
            self.notebook_tabs.append(progr_frame._w)

        if StatsDialog.SELECTED_TAB < len(self.notebook_tabs):
            notebook.select(StatsDialog.SELECTED_TAB)
        bind(notebook, '<<NotebookTabChanged>>', self.tabChanged)
        # notebook.enableTraversal()
        self.notebook = notebook

        focus = self.createButtons(bottom_frame, kw)
        self.tabChanged()               # configure buttons state
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(
            kw,
            strings=((_("&Play this game"), 401),
                     "sep", _("&OK"),
                     (_("&Reset..."), 500)),
            default=0,
            separator=False,
        )
        return MfxDialog.initKw(self, kw)

    def tabChanged(self, *args):
        w = self.notebook.select()
        run_button = self.buttons[0]
        indx = self.notebook_tabs.index(w)
        if indx == 1:                   # "All games"
            g = self.all_games_frame.getSelectedGame()
            if g is None:
                run_button.config(state='disabled')
            else:
                run_button.config(state='normal')
        else:
            run_button.config(state='disabled')
        reset_button = self.buttons[2]
        if indx in (0, 1):              # "Current game" or "All games"
            reset_button.config(state='normal')
        else:
            reset_button.config(state='disabled')

    def mDone(self, button):
        self.selected_game = self.all_games_frame.getSelectedGame()
        w = self.notebook.select()
        indx = self.notebook_tabs.index(w)
        StatsDialog.SELECTED_TAB = indx
        if button == 500:               # "Reset..."
            assert indx in (0, 1)
            if indx == 0:               # "Current game"
                button = 302
            else:                       # "All games"
                button = 301
        MfxDialog.mDone(self, button)


SingleGame_StatsDialog = AllGames_StatsDialog = Top_StatsDialog = \
        ProgressionDialog = StatsDialog


# ************************************************************************
# *
# ************************************************************************

class SingleGameFrame(ttk.Frame):
    def __init__(self, dialog, parent, app, player, gameid, **kw):
        ttk.Frame.__init__(self, parent)

        self.oval_width = 120
        self.oval_height = 60

        left_label = ttk.Label(self, image=app.gimages.logos[5])
        left_label.pack(side='left', expand=True, fill='both')
        self.right_frame = ttk.Frame(self)
        self.right_frame.pack(side='right', expand=True)

        self.dialog = dialog
        self.app = app
        self.parent = parent
        self.player = player or _("Demo games")
        #
        self._calc_tabs()
        #
        won, lost = app.stats.getStats(player, gameid)
        self.createPieChart(app, won, lost, _("Total"))
        won, lost = app.stats.getSessionStats(player, gameid)
        self.createPieChart(app, won, lost, _("Current session"))
        #

    #
    # helpers
    #

    def _calc_tabs(self):
        #
        font = self.dialog.tkfont
        t0 = self.oval_width+70
        t = ''
        for i in (_("Won:"),
                  _("Lost:"),
                  _("Total:")):
            if len(i) > len(t):
                t = i
        t1 = font.measure(t)
        #  t1 = max(font.measure(_("Won:")),
        #           font.measure(_("Lost:")),
        #           font.measure(_("Total:")))
        t1 += 10
        # t2 = font.measure('99999')+10
        t2 = 45
        # t3 = font.measure('100%')+10
        t3 = 45
        tx = (t0, t0+t1+t2, t0+t1+t2+t3, t0+t1+t2+t3+20)
        #
        ls = self.dialog.font_metrics['linespace']
        ls += 5
        # ls = max(ls, 20)
        ty = (5, 5+ls, 5+2*ls+15, max(85, 5+3*ls+15))
        #
        self.tab_x, self.tab_y = tx, ty

    def _getPwon(self, won, lost):
        pwon, plost = 0.0, 0.0
        if won + lost > 0:
            pwon = float(won) / (won + lost)
            pwon = min(max(pwon, 0.00001), 0.99999)
            plost = 1.0 - pwon
        return pwon, plost

    def _createChartInit(self, text):
        frame = ttk.LabelFrame(self.right_frame, text=text)
        frame.pack(side='top', fill='both', expand=False, padx=20, pady=10)
        style = ttk.Style(self.parent)
        fg = style.lookup('.', 'foreground') or None  # use default if fg == ''
        bg = style.lookup('.', 'background') or None
        self.fg = fg
        #
        w, h = self.tab_x[-1], max(self.tab_y[-1], self.oval_height+40)
        c = tkinter.Canvas(frame, width=w, height=h,
                           bg=bg, highlightthickness=0)
        c.pack(fill='both', expand=True)
        self.canvas = c

    def _createChartTexts(self, tx, ty, won, lost):
        c, tfont, fg = self.canvas, self.dialog.font, self.fg
        pwon, plost = self._getPwon(won, lost)
        #
        x = tx[0]
        dy = int(self.dialog.font_metrics['ascent']) - 10
        dy //= 2
        c.create_text(x, ty[0]-dy, text=_("Won:"),
                      anchor="nw", font=tfont, fill=fg)
        c.create_text(x, ty[1]-dy, text=_("Lost:"),
                      anchor="nw", font=tfont, fill=fg)
        c.create_text(x, ty[2]-dy, text=_("Total:"),
                      anchor="nw", font=tfont, fill=fg)
        x = tx[1] - 16
        c.create_text(x, ty[0]-dy, text="%d" % won,
                      anchor="ne", font=tfont, fill=fg)
        c.create_text(x, ty[1]-dy, text="%d" % lost,
                      anchor="ne", font=tfont, fill=fg)
        c.create_text(x, ty[2]-dy, text="%d" % (won + lost),
                      anchor="ne", font=tfont, fill=fg)
        y = ty[2] - 11
        c.create_line(tx[0], y, x, y, fill=fg)
        if won + lost > 0:
            x = tx[2]
            pw = int(round(100.0 * pwon))
            c.create_text(x, ty[0]-dy, text="%d%%" % pw,
                          anchor="ne", font=tfont, fill=fg)
            c.create_text(x, ty[1]-dy, text="%d%%" % (100-pw),
                          anchor="ne", font=tfont, fill=fg)

    def createPieChart(self, app, won, lost, text):
        # c, tfont, fg = self._createChartInit(frame, 300, 100, text)
        #
        self._createChartInit(text)
        c, tfont = self.canvas, self.dialog.font
        pwon, plost = self._getPwon(won, lost)
        #
        # tx = (160, 250, 280)
        # ty = (21, 41, 75)
        #
        tx, ty = self.tab_x, self.tab_y
        x0, y0 = 20, 10                 # base coords
        w = self.oval_width
        h = self.oval_height
        d = 9                           # delta
        if won + lost > 0:
            # s, ewon, elost = 90.0, -360.0 * pwon, -360.0 * plost
            s, ewon, elost = 0.0, 360.0 * pwon, 360.0 * plost
            c.create_arc(x0, y0+d, x0+w, y0+h+d, fill="#007f00",
                         start=s, extent=ewon)
            c.create_arc(x0, y0+d, x0+w, y0+h+d, fill="#7f0000",
                         start=s+ewon, extent=elost)
            c.create_arc(x0, y0,   x0+w, y0+h,   fill="#00ff00",
                         start=s, extent=ewon)
            c.create_arc(x0, y0,   x0+w, y0+h,   fill="#ff0000",
                         start=s+ewon, extent=elost)
            x, y = tx[0] - 25, ty[0]
            c.create_rectangle(x, y, x+10, y+10, fill="#00ff00")
            y = ty[1]
            c.create_rectangle(x, y, x+10, y+10, fill="#ff0000")
        else:
            c.create_oval(x0, y0+d, x0+w, y0+h+d, fill="#7f7f7f")
            c.create_oval(x0, y0,   x0+w, y0+h,   fill="#f0f0f0")
            c.create_text(x0+w//2, y0+h//2, text=_("No games"),
                          anchor="center", font=tfont, fill="#bfbfbf")
        #
        self._createChartTexts(tx, ty, won, lost)


# ************************************************************************
# *
# ************************************************************************

class TreeFormatter(PysolStatsFormatter):
    MAX_ROWS = 10000

    def __init__(self, app, tree, parent_window, font, w, h):
        self.app = app
        self.tree = tree
        self.parent_window = parent_window
        self.tkfont = font
        self.gameid = None
        self.gamenumber = None
        self._tabs = None
        self.w = w
        self.h = h

    def _calc_tabs(self, arg):
        if self.parent_window.tree_tabs:
            self._tabs = self.parent_window.tree_tabs
            return
        tw = 20*self.w
        # tw = 160
        self._tabs = [tw]
        measure = self.tkfont.measure
        for t in arg[1:]:
            tw = measure(t)+8
            self._tabs.append(tw)
        self._tabs.append(10)
        self.parent_window.tree_tabs = self._tabs

    def createHeader(self, player, header):
        i = 0
        for column in ('#0',) + self.parent_window.COLUMNS:
            text = header[i]
            self.tree.heading(
                column, text=text,
                command=lambda par=self.parent_window, col=column:
                    par.headerClick(col))
            self.tree.column(column, width=16)
            i += 1

    def resizeHeader(self, player, header, tree_width=0):
        if self._tabs is not None:
            return
        self._calc_tabs(header)
        # set first column width
        if tree_width != 0:
            tab = tree_width - sum(self._tabs[1:])
            tab = min(tree_width, self._tabs[0])
        else:
            tab = self._tabs[0]
        self.tree.column('#0', width=tab)
        # other column
        i = 1
        for column in self.parent_window.COLUMNS:
            tab = self._tabs[i]
            self.tree.column(column, width=tab)
            i += 1

    def writeStats(self, player, sort_by='name'):
        header = self.getStatHeader()
        tree_width = self.tree.winfo_width()
        self.resizeHeader(player, header, tree_width)

        for result in self.getStatResults(player, sort_by):
            # result == [name, won+lost, won, lost, time, moves, perc, id]
            t1, t2, t3, t4, t5, t6, t7, t8 = result
            id = self.tree.insert("", "end", text=t1,
                                  values=(t2, t3, t4, t5, t6, t7))
            self.parent_window.tree_items.append(id)
            self.parent_window.games[id] = t8

        total, played, won, lost, time_, moves, perc = self.getStatSummary()
        text = _("Total (%(played)d out of %(total)d games)") % {
            'played': played, 'total': total}
        id = self.tree.insert("", "end", text=text,
                              values=(won+lost, won, lost, time_, moves, perc))
        self.parent_window.tree_items.append(id)
        return 1

    def writeLog(self, player, prev_games):
        if not player or not prev_games:
            return 0
        num_rows = 0
        for result in self.getLogResults(player, prev_games):
            t1, t2, t3, t4, t5, t6 = result
            id = self.tree.insert("", "end", text=t1, values=(t2, t3, t4))
            self.parent_window.tree_items.append(id)
            num_rows += 1
            if num_rows > self.MAX_ROWS:
                break
        return 1

    def writeFullLog(self, player):
        prev_games = self.app.stats.prev_games.get(player)
        return self.writeLog(player, prev_games)

    def writeSessionLog(self, player):
        prev_games = self.app.stats.session_games.get(player)
        return self.writeLog(player, prev_games)


# ************************************************************************
# *
# ************************************************************************

class AllGamesFrame(ttk.Frame):

    COLUMNS = ('played', 'won', 'lost', 'time', 'moves', 'percent')

    def __init__(self, dialog, parent, app, player, **kw):
        ttk.Frame.__init__(self, parent)
        #
        self.dialog = dialog
        self.app = app
        self.CHAR_H = self.dialog.font_metrics['linespace']
        self.CHAR_W = self.dialog.tkfont.measure('M')
        #
        self.player = player
        self.sort_by = 'name'
        self.tree_items = []
        self.tree_tabs = None
        self.games = {}                 # tree_itemid: gameid
        #
        frame = ttk.Frame(self)
        frame.pack(fill='both', expand=True, padx=10, pady=10)
        vsb = ttk.Scrollbar(frame)
        vsb.grid(row=0, column=1, sticky='ns')
        self.tree = ttk.Treeview(frame, columns=self.COLUMNS,
                                 selectmode='browse')
        self.tree.grid(row=0, column=0, sticky='nsew')
        self.tree.config(yscrollcommand=vsb.set)
        vsb.config(command=self.tree.yview)
        frame.rowconfigure(0, weight=1)
        frame.columnconfigure(0, weight=1)
        hsb = ttk.Scrollbar(frame, orient='horizontal')
        hsb.grid(row=1, column=0, sticky='ew')
        self.tree.config(xscrollcommand=hsb.set)
        hsb.config(command=self.tree.xview)
        bind(self.tree, '<<TreeviewSelect>>', self.treeviewSelected)
        #
        self.formatter = TreeFormatter(self.app, self.tree, self,
                                       self.dialog.heading_tkfont,
                                       self.CHAR_W, self.CHAR_H)
        self.createHeader(player)
        bind(self.tree, '<Map>', self.mapEvent)

    def getSelectedGame(self):
        sel = self.tree.selection()
        if sel and len(sel) == 1:
            if sel[0] in self.games:
                return self.games[sel[0]]
        return None

    def treeviewSelected(self, *args):
        sel = self.tree.selection()
        run_button = self.dialog.buttons[0]
        if sel and len(sel) == 1:
            if sel[0] not in self.games:  # "Total"
                run_button.config(state='disabled')
            else:
                run_button.config(state='normal')
        else:
            run_button.config(state='disabled')

    def mapEvent(self, *args):
        if not self.tree_items:
            self.fillTreeview(self.player)

    def headerClick(self, column):
        if column == '#0':
            sort_by = 'name'
        else:
            sort_by = column
        if self.sort_by == sort_by:
            return
        self.sort_by = sort_by
        self.fillTreeview(self.player)

    def createHeader(self, player):
        header = self.formatter.getStatHeader()
        self.formatter.createHeader(player, header)

    def fillTreeview(self, player):
        if self.tree_items:
            self.tree.delete(tuple(self.tree_items))
            self.tree_items = []
        self.formatter.writeStats(player, sort_by=self.sort_by)
        if self.dialog.buttons:
            run_button = self.dialog.buttons[0]
            run_button.config(state='disabled')


# ************************************************************************
# *
# ************************************************************************

class LogDialog(MfxDialog):
    SELECTED_TAB = 0

    def __init__(self, parent, title, app, player, **kw):

        self.font = app.getFont('default')
        self.tkfont = tkinter_font.Font(parent, self.font)
        style = ttk.Style(parent)
        heading_font = style.lookup('Heading', 'font')  # treeview heading
        self.heading_tkfont = tkinter_font.Font(parent, heading_font)
        self.font_metrics = self.tkfont.metrics()

        self.CHAR_H = self.font_metrics['linespace']
        self.CHAR_W = self.tkfont.measure('M')

        kw = self.initKw(kw)
        title = _('Log')
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)

        # self.selected_game = None

        top_frame, bottom_frame = self.createFrames(kw)
        notebook = ttk.Notebook(top_frame)
        notebook.pack(expand=True, fill='both', padx=10, pady=10)

        self.notebook_tabs = []

        full_frame = FullLogFrame(self, notebook, app, player)
        notebook.add(full_frame, text=_('Full log'))
        self.notebook_tabs.append(full_frame._w)

        session_frame = SessionLogFrame(self, notebook, app, player)
        notebook.add(session_frame, text=_('Session log'))
        self.notebook_tabs.append(session_frame._w)

        notebook.select(LogDialog.SELECTED_TAB)
        #  bind(notebook, '<<NotebookTabChanged>>', self.tabChanged)

        self.notebook = notebook

        focus = self.createButtons(bottom_frame, kw)
        # self.tabChanged()               # configure buttons state
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"),
                               (_("&Save to file"), 500)),
                      default=0,
                      width=76*self.CHAR_W,
                      separator=False,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        # self.selected_game = self.all_games_frame.getSelectedGame()
        w = self.notebook.select()
        indx = self.notebook_tabs.index(w)
        LogDialog.SELECTED_TAB = indx
        if button == 500:               # "Save to file"
            assert indx in (0, 1)
            if indx == 0:               # "Full log"
                button = 203
            else:                       # "Session log"
                button = 204
        MfxDialog.mDone(self, button)


FullLog_StatsDialog = SessionLog_StatsDialog = LogDialog


# ************************************************************************
# *
# ************************************************************************

class FullLogFrame(AllGamesFrame):

    COLUMNS = ('gamenumber', 'date', 'status')

    def __init__(self, dialog, parent, app, player, **kw):
        AllGamesFrame.__init__(self, dialog, parent, app, player, **kw)
        header = ('', '99999999999999999999', '9999-99-99  99:99',
                  'XXXXXXXXXXXX')
        self.formatter.resizeHeader(player, header)

    def createHeader(self, player):
        header = self.formatter.getLogHeader()
        self.formatter.createHeader(player, header)

    def fillTreeview(self, player):
        if self.tree_items:
            return
        self.formatter.writeFullLog(player)

    def treeviewSelected(self, *args):
        pass

    def headerClick(self, column):
        pass


class SessionLogFrame(FullLogFrame):
    def fillTreeview(self, player):
        if self.tree_items:
            return
        self.formatter.writeSessionLog(player)


# ************************************************************************
# *
# ************************************************************************

class Status_StatsDialog(MfxMessageDialog):
    def __init__(self, parent, game):
        stats, gstats = game.stats, game.gstats
        w1 = w2 = ""
        n = 0
        for s in game.s.foundations:
            n = n + len(s.cards)
        w1 = (_("Highlight piles: ") + str(stats.highlight_piles) + "\n" +
              _("Highlight cards: ") + str(stats.highlight_cards) + "\n" +
              _("Highlight same rank: ") +
              str(stats.highlight_samerank) + "\n")
        if game.s.talon:
            if game.gameinfo.redeals != 0:
                w2 = w2 + _("\nRedeals: ") + str(game.s.talon.round - 1)
            w2 = w2 + _("\nCards in Talon: ") + str(len(game.s.talon.cards))
        if game.s.waste and game.s.waste not in game.s.foundations:
            w2 = w2 + _("\nCards in Waste: ") + str(len(game.s.waste.cards))
        if game.s.foundations:
            w2 = w2 + _("\nCards in Foundations: ") + str(n)
        #
        date = time.strftime(
            "%Y-%m-%d %H:%M", time.localtime(game.gstats.start_time))
        MfxMessageDialog.__init__(
            self, parent, title=_("Game status"),
            text=game.getTitleName() + "\n" +
            game.getGameNumber(format=1) + "\n" +
            _("Playing time: ") + game.getTime() + "\n" +
            _("Started at: ") + date + "\n\n" +
            _("Moves: ") + str(game.moves.index) + "\n" +
            _("Undo moves: ") + str(stats.undo_moves) + "\n" +
            _("Bookmark moves: ") + str(gstats.goto_bookmark_moves) + "\n" +
            _("Demo moves: ") + str(stats.demo_moves) + "\n" +
            _("Total player moves: ") + str(stats.player_moves) + "\n" +
            _("Total moves in this game: ") + str(stats.total_moves) + "\n" +
            _("Hints: ") + str(stats.hints) + "\n" +
            "\n" +
            w1 + w2,
            strings=((_("&Statistics..."), 101),
                     'sep',
                     _("&OK")),
            image=game.app.gimages.logos[3],
            image_side="left", image_padx=20,
            padx=20,
            )


# ************************************************************************
# *
# ************************************************************************

class _TopDialog(MfxDialog):
    def __init__(self, parent, title, app, gameid, top, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        cnf = {'master': top_frame,
               'padding': (4, 1),
               }
        frame = ttk.Frame(**cnf)
        frame.pack(expand=True, fill='both', padx=10, pady=10)
        frame.columnconfigure(0, weight=1)
        cnf['master'] = frame
        cnf['text'] = _('N')
        label = ttk.Label(**cnf)
        label.grid(row=0, column=0, sticky='ew')
        if gameid == 'all':
            cnf['text'] = _('Game')
            label = ttk.Label(**cnf)
            label.grid(row=0, column=1, sticky='ew')
        cnf['text'] = _('Game number')
        label = ttk.Label(**cnf)
        label.grid(row=0, column=2, sticky='ew')
        cnf['text'] = _('Started at')
        label = ttk.Label(**cnf)
        label.grid(row=0, column=3, sticky='ew')
        cnf['text'] = _('Result')
        label = ttk.Label(**cnf)
        label.grid(row=0, column=4, sticky='ew')

        row = 1
        for i in top:
            # N
            cnf['text'] = str(row)
            label = ttk.Label(**cnf)
            label.grid(row=row, column=0, sticky='ew')
            if gameid == 'all':
                name = app.getGameTitleName(i.gameid)
                if name is None:
                    name = _("** UNKNOWN %d **") % i.gameid
                cnf['text'] = name
                label = ttk.Label(**cnf)
                label.grid(row=row, column=1, sticky='ew')
            # Game number
            cnf['text'] = '#'+str(i.game_number)
            label = ttk.Label(**cnf)
            label.grid(row=row, column=2, sticky='ew')
            # Start time
            t = time.strftime(
                '%Y-%m-%d %H:%M', time.localtime(i.game_start_time))
            cnf['text'] = t
            label = ttk.Label(**cnf)
            label.grid(row=row, column=3, sticky='ew')
            # Result
            if isinstance(i.value, float):
                # time
                s = format_time(i.value)
            else:
                # moves
                s = str(i.value)
            cnf['text'] = s
            label = ttk.Label(**cnf)
            label.grid(row=row, column=4, sticky='ew')
            row += 1

        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw, strings=(_('&OK'),), default=0, separator=True)
        return MfxDialog.initKw(self, kw)


class TopFrame(ttk.Frame):
    def __init__(self, dialog, parent, app, player, gameid):
        ttk.Frame.__init__(self, parent)

        self.app = app
        self.dialog = dialog

        left_label = ttk.Label(self, image=app.gimages.logos[5])
        left_label.pack(side='left', expand=True, fill='both')

        frame = ttk.LabelFrame(self, text=_('Current game'),
                               padding=(10, 5, 10, 10))
        frame.pack(side='top', expand=True, fill='x', padx=10, pady=10)
        # frame.columnconfigure(0, weight=1)
        if not self.createTopFrame(frame, player, gameid):
            ttk.Label(frame, text=_('No TOP for this game')
                      ).pack(padx=10, pady=10)

        frame = ttk.LabelFrame(self, text=_('All games'),
                               padding=(10, 5, 10, 10))
        frame.pack(side='top', expand=True, fill='x', padx=10, pady=10)
        # frame.columnconfigure(0, weight=1)
        if not self.createTopFrame(frame, player, 'all'):
            ttk.Label(frame, text=_('No TOP for all games')
                      ).pack(padx=10, pady=10)

    def createTopFrame(self, frame, player, gameid):
        app = self.app

        cond = (player not in app.stats.games_stats or
                gameid not in app.stats.games_stats[player] or
                not app.stats.games_stats[player][gameid].time_result.top)
        if cond:
            return False

        ttk.Label(frame, text=_('Minimum')
                  ).grid(row=0, column=1, padx=5, pady=5)
        ttk.Label(frame, text=_('Maximum')
                  ).grid(row=0, column=2, padx=5, pady=5)
        ttk.Label(frame, text=_('Average')
                  ).grid(row=0, column=3, padx=5, pady=5)
        # ttk.Label(frame, text=_('Total')).grid(row=0, column=4)

        s = app.stats.games_stats[player][gameid]

        row = 1
        ll = [
            (_('Playing time:'),
             format_time(s.time_result.min),
             format_time(s.time_result.max),
             format_time(s.time_result.average),
             format_time(s.time_result.total),
             s.time_result.top,
             ),
            (_('Moves:'),
             s.moves_result.min,
             s.moves_result.max,
             round(s.moves_result.average, 2),
             s.moves_result.total,
             s.moves_result.top,
             ),
            (_('Total moves:'),
             s.total_moves_result.min,
             s.total_moves_result.max,
             round(s.total_moves_result.average, 2),
             s.total_moves_result.total,
             s.total_moves_result.top,
             ),
            ]
        #  if s.score_result.min:
        #      ll.append(('Score:',
        #                 s.score_result.min,
        #                 s.score_result.max,
        #                 round(s.score_result.average, 2),
        #                 s.score_result.top,
        #                 ))
        #  if s.score_casino_result.min:
        #      ll.append(('Casino Score:',
        #                 s.score_casino_result.min,
        #                 s.score_casino_result.max,
        #                 round(s.score_casino_result.average, 2), ))
        for l, min, max, avr, tot, top in ll:
            ttk.Label(frame, text=l
                      ).grid(row=row, column=0, padx=5, pady=5)
            ttk.Label(frame, text=str(min)
                      ).grid(row=row, column=1, padx=5, pady=5)
            ttk.Label(frame, text=str(max)
                      ).grid(row=row, column=2, padx=5, pady=5)
            ttk.Label(frame, text=str(avr)
                      ).grid(row=row, column=3, padx=5, pady=5)
            # ttk.Label(frame, text=str(tot)).grid(row=row, column=4)

            def command(gameid=gameid, top=top):
                self.showTop(gameid, top)
            b = ttk.Button(frame, text=TOP_TITLE+' ...',
                           width=10, command=command)
            b.grid(row=row, column=5)
            row += 1
        return True

    def showTop(self, gameid, top):
        _TopDialog(self.dialog.top, TOP_TITLE, self.app, gameid, top)


# ************************************************************************
# *
# ************************************************************************

class ProgressionFrame(ttk.Frame):

    def __init__(self, dialog, parent, app, player, gameid, **kw):
        ttk.Frame.__init__(self, parent)

        self.mapped = False

        self.dialog = dialog
        self.app = app
        self.player = player
        self.gameid = gameid
        self.items = []
        self.formatter = ProgressionFormatter(app, player, gameid)

        frame = ttk.Frame(self)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        # constants
        w = dialog.tkfont.measure('M') * 42
        w = max(w, 500)
        w = min(w, 600)
        self.canvas_width, self.canvas_height = w, 250
        cond = parent.winfo_screenwidth() < 800 or \
            parent.winfo_screenheight() < 600
        if cond:
            self.canvas_width, self.canvas_height = 400, 200
        self.xmargin, self.ymargin = 10, 10
        self.graph_dx, self.graph_dy = 10, 10
        self.played_color = '#ff7ee9'
        self.won_color = '#00dc28'
        self.percent_color = 'blue'
        # create canvas
        self.canvas = canvas = tkinter.Canvas(frame, bg='#dfe8ff', bd=0,
                                              highlightthickness=1,
                                              highlightbackground='black',
                                              width=self.canvas_width,
                                              height=self.canvas_height)
        canvas.pack(side='left', padx=5)

        # right frame
        right_frame = ttk.Frame(frame)
        right_frame.pack(side='left', fill='x', padx=5)
        self.all_games_variable = var = tkinter.StringVar()
        var.set('all')
        b = ttk.Radiobutton(right_frame, text=_('All games'),
                            variable=var, value='all',
                            command=self.updateGraph)
        b.pack(fill='x', expand=True, padx=3, pady=1)
        b = ttk.Radiobutton(right_frame, text=_('Current game'),
                            variable=var, value='current',
                            command=self.updateGraph)
        b.pack(fill='x', expand=True, padx=3, pady=1)
        label_frame = ttk.LabelFrame(right_frame, text=_('Statistics for'))
        label_frame.pack(side='top', fill='x', pady=10)
        self.variable = var = tkinter.StringVar()
        var.set('week')
        for v, t in (
            ('week',  _('Last 7 days')),
            ('month', _('Last month')),
            ('year',  _('Last year')),
            ('all',   _('All time')),
                ):
            b = ttk.Radiobutton(label_frame, text=t, variable=var,
                                value=v, command=self.updateGraph)
            b.pack(fill='x', expand=True, padx=3, pady=1)
        label_frame = ttk.LabelFrame(right_frame, text=_('Show graphs'))
        label_frame.pack(side='top', fill='x')
        self.played_graph_var = tkinter.BooleanVar()
        self.played_graph_var.set(True)
        b = ttk.Checkbutton(label_frame, text=_('Played'),
                            command=self.updateGraph,
                            variable=self.played_graph_var)
        b.pack(fill='x', expand=True, padx=3, pady=1)
        self.won_graph_var = tkinter.BooleanVar()
        self.won_graph_var.set(True)
        b = ttk.Checkbutton(label_frame, text=_('Won'),
                            command=self.updateGraph,
                            variable=self.won_graph_var)
        b.pack(fill='x', expand=True, padx=3, pady=1)
        self.percent_graph_var = tkinter.BooleanVar()
        self.percent_graph_var.set(True)
        b = ttk.Checkbutton(label_frame, text=_('% won'),
                            command=self.updateGraph,
                            variable=self.percent_graph_var)
        b.pack(fill='x', expand=True, padx=3, pady=1)

        # self.createGraph()
        bind(canvas, '<Map>', self.createGraph)

    def createGraph(self, event):
        if self.mapped:
            return
        self.mapped = True

        canvas = self.canvas

        self.text_height = self.dialog.font_metrics['linespace']
        measure = self.dialog.tkfont.measure
        self.text_width_1 = measure('XX.XX')
        self.text_width_2 = measure('XX.XX.XX')

        dir = os.path.join('images', 'stats')
        try:
            fn = self.app.dataloader.findImage('progression', dir)
            self.bg_image = loadImage(fn)
            canvas.create_image(0, 0, image=self.bg_image, anchor='nw')
        except Exception:
            pass
        #
        tw = max(measure(_('Games/day')),
                 measure(_('Games/week')),
                 measure(_('% won')))
        self.left_margin = self.xmargin+tw//2
        self.right_margin = self.xmargin+tw//2
        self.top_margin = 15+self.text_height
        self.bottom_margin = 15+self.text_height+10+self.text_height
        #
        x0, y0 = self.left_margin, self.canvas_height-self.bottom_margin
        x1, y1 = self.canvas_width-self.right_margin, self.top_margin
        canvas.create_rectangle(x0, y0, x1, y1, fill='white')
        # horizontal axis
        canvas.create_line(x0, y0, x1, y0, width=3)

        # left vertical axis
        canvas.create_line(x0, y0, x0, y1, width=3)
        t = _('Games/day')
        self.games_text_id = canvas.create_text(x0-4, y1-4, anchor='s', text=t)

        # right vertical axis
        canvas.create_line(x1, y0, x1, y1, width=3)
        canvas.create_text(x1+4, y1-4, anchor='s', text=_('% won'))

        # caption
        d = self.text_height
        x, y = self.xmargin, self.canvas_height-self.ymargin
        canvas.create_rectangle(x, y, x+d, y-d, outline='black',
                                fill=self.played_color)
        x += d+5
        canvas.create_text(x, y, anchor='sw', text=_('Played'))
        x += measure(_('Played'))+20
        canvas.create_rectangle(x, y, x+d, y-d, outline='black',
                                fill=self.won_color)
        x += d+5
        canvas.create_text(x, y, anchor='sw', text=_('Won'))
        x += measure(_('Won'))+20
        canvas.create_rectangle(x, y, x+d, y-d, outline='black',
                                fill=self.percent_color)
        x += d+5
        canvas.create_text(x, y, anchor='sw', text=_('% won'))

        self.updateGraph()

    def updateGraph(self, *args):
        interval = self.variable.get()
        canvas = self.canvas
        if self.items:
            canvas.delete(*self.items)
        self.items = []

        all_games = (self.all_games_variable.get() == 'all')
        result = self.formatter.getResults(interval, all_games)

        if interval in ('week', 'month'):
            t = _('Games/day')
        else:
            t = _('Games/week')
        canvas.itemconfig(self.games_text_id, text=t)

        graph_width = self.canvas_width-self.left_margin-self.right_margin
        graph_height = self.canvas_height-self.top_margin-self.bottom_margin
        dx = (graph_width-2*self.graph_dx)//(len(result)-1)
        graph_dx = (graph_width-(len(result)-1)*dx)//2
        dy = (graph_height-self.graph_dy)//5
        x0, y0 = self.left_margin, self.canvas_height-self.bottom_margin
        x1, y1 = self.canvas_width-self.right_margin, self.top_margin
        td = self.text_height//2

        # vertical scale
        x = x0+graph_dx
        xx = -100                       # coord. of prev. text
        for res in result:
            text = res[0]
            text_width = 0
            if text is not None:
                if len(text) == 5:      # day.month
                    text_width = self.text_width_1
                else:                   # day.month.year
                    text_width = self.text_width_2
            if text is not None and x > xx+text_width+4:
                # id = canvas.create_line(x, y0, x, y0-5, width=3)
                # self.items.append(id)
                id = canvas.create_line(x, y0, x, y1, stipple='gray50')
                self.items.append(id)
                id = canvas.create_text(x, y0+td, anchor='n', text=text)
                self.items.append(id)
                xx = x
            else:
                id = canvas.create_line(x, y0, x, y0-3, width=1)
                self.items.append(id)
            x += dx

        # horizontal scale
        max_games = max([i[1] for i in result])
        games_delta = max_games//5+1
        percent = 0
        games = 0
        for y in range(y0, y1, -dy):
            if y != y0:
                id = canvas.create_line(x0, y, x1, y, stipple='gray50')
                self.items.append(id)
            id = canvas.create_text(x0-td, y, anchor='e', text=str(games))
            self.items.append(id)
            id = canvas.create_text(x1+td, y, anchor='w', text=str(percent))
            self.items.append(id)
            games += games_delta
            percent += 20

        # draw result
        games_resolution = float(dy)/games_delta
        percent_resolution = float(dy)/20
        played_coords = []
        won_coords = []
        percent_coords = []
        x = x0+graph_dx
        for res in result:
            played, won = res[1], res[2]
            y = y0 - int(games_resolution*played)
            played_coords += [x, y]
            y = y0 - int(games_resolution*won)
            won_coords += [x, y]
            if played > 0:
                percent = int(100.*won/played)
            else:
                percent = 0
            y = y0 - int(percent_resolution*percent)
            percent_coords += [x, y]
            x += dx
        if self.played_graph_var.get():
            id = canvas.create_line(fill=self.played_color, width=3,
                                    *played_coords)
            self.items.append(id)
        if self.won_graph_var.get():
            id = canvas.create_line(fill=self.won_color, width=3,
                                    *won_coords)
            self.items.append(id)
        if self.percent_graph_var.get():
            id = canvas.create_line(fill=self.percent_color, width=3,
                                    *percent_coords)
            self.items.append(id)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os
import sys

from pysollib.mfxutil import Struct
from pysollib.mygettext import _
from pysollib.ui.tktile.tkhtml import Base_HTMLViewer

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .statusbar import HtmlStatusbar
from .tkwidget import MfxMessageDialog

if __name__ == '__main__':
    d = os.path.abspath(os.path.join(sys.path[0], '..', '..'))
    sys.path.append(d)
    import gettext
    gettext.install('pysol', d, unicode=True)

# ************************************************************************
# *
# ************************************************************************


class HTMLViewer(Base_HTMLViewer):
    symbols_fn = {}  # filenames, loaded in Application.loadImages3
    symbols_img = {}

    def _calc_MfxMessageDialog(self):
        return MfxMessageDialog

    def __init__(self, parent, app=None, home=None):
        self.parent = parent
        self.app = app
        self.home = home
        self.url = None
        self.history = Struct(
            list=[],
            index=0,
        )
        self.visited_urls = []
        # need to keep a reference because of garbage collection
        self.images = {}
        self.defcursor = parent["cursor"]
        # self.defcursor = 'xterm'
        self.handcursor = "hand2"

        frame = ttk.Frame(parent, width=640, height=440)
        frame.pack(expand=True, fill='both')
        frame.grid_propagate(False)

        # create buttons
        button_width = 8
        self.homeButton = ttk.Button(frame, text=_("Index"),
                                     width=button_width,
                                     command=self.goHome)
        self.homeButton.grid(row=0, column=0, sticky='w')
        self.backButton = ttk.Button(frame, text=_("Back"),
                                     width=button_width,
                                     command=self.goBack)
        self.backButton.grid(row=0, column=1, sticky='w')
        self.forwardButton = ttk.Button(frame, text=_("Forward"),
                                        width=button_width,
                                        command=self.goForward)
        self.forwardButton.grid(row=0, column=2, sticky='w')
        self.closeButton = ttk.Button(frame, text=_("Close"),
                                      width=button_width,
                                      command=self.destroy)
        self.closeButton.grid(row=0, column=3, sticky='e')

        # create text widget
        text_frame = ttk.Frame(frame)
        text_frame.grid(row=1, column=0, columnspan=4,
                        sticky='nsew', padx=1, pady=1)
        vbar = ttk.Scrollbar(text_frame)
        vbar.pack(side='right', fill='y')
        self.text = tkinter.Text(text_frame,
                                 fg='black', bg='white',
                                 bd=1, relief='sunken',
                                 cursor=self.defcursor,
                                 wrap='word', padx=10)
        self.text.pack(side='left', fill='both', expand=True)
        self.text["yscrollcommand"] = vbar.set
        vbar["command"] = self.text.yview

        # statusbar
        self.statusbar = HtmlStatusbar(frame, row=2, column=0, columnspan=4)

        frame.columnconfigure(2, weight=1)
        frame.rowconfigure(1, weight=1)

        # load images
        for name, fn in self.symbols_fn.items():
            self.symbols_img[name] = self.getImage(fn)

        self.initBindings()


# ************************************************************************
# *
# ************************************************************************


def tkhtml_main(args):
    try:
        url = args[1]
    except Exception:
        url = os.path.join(os.pardir, os.pardir, "data", "html", "index.html")
    top = tkinter.Tk()
    top.tk.call("package", "require", "tile")
    top.wm_minsize(400, 200)
    viewer = HTMLViewer(top)
    viewer.app = None
    viewer.display(url)
    top.mainloop()
    return 0


if __name__ == "__main__":
    sys.exit(tkhtml_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mygettext import _, n_
from pysollib.settings import TITLE
from pysollib.ui.tktile.findcarddialog import connect_game_find_card_dialog
from pysollib.ui.tktile.findcarddialog import destroy_find_card_dialog
from pysollib.ui.tktile.menubar import MfxMenu, PysolMenubarTkCommon
from pysollib.ui.tktile.solverdialog import connect_game_solver_dialog
from pysollib.util import CARDSET

from six.moves import tkinter_ttk as ttk

from .selectgame import SelectGameDialog, SelectGameDialogWithPreview
from .selecttile import SelectTileDialogWithPreview
from .soundoptionsdialog import SoundOptionsDialog
from .tkwidget import MfxMessageDialog

# ************************************************************************
# * - create menubar
# * - update menubar
# * - menu actions
# ************************************************************************


class PysolMenubarTk(PysolMenubarTkCommon):
    def __init__(self, app, top, progress=None):
        PysolMenubarTkCommon.__init__(self, app, top, progress)

    def _setOptions(self):
        PysolMenubarTkCommon._setOptions(self)
        tkopt, opt = self.tkopt, self.app.opt
        tkopt.theme.set(opt.tile_theme)

    def _connect_game_find_card_dialog(self, game):
        return connect_game_find_card_dialog(game)

    def _destroy_find_card_dialog(self):
        return destroy_find_card_dialog()

    def _connect_game_solver_dialog(self, game):
        return connect_game_solver_dialog(game)

    def _calcWizardDialog(self):
        from .wizarddialog import WizardDialog
        return WizardDialog

    def _calcSelectGameDialog(self):
        return SelectGameDialog

    def _calcSelectGameDialogWithPreview(self):
        return SelectGameDialogWithPreview

    def _calcSoundOptionsDialog(self):
        return SoundOptionsDialog

    def _calcSelectTileDialogWithPreview(self):
        return SelectTileDialogWithPreview

    def _calc_MfxMessageDialog(self):
        return MfxMessageDialog

    #
    # create the menubar
    #

    def mSelectCardsetDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        key = self.app.nextgame.cardset.index
        cs = self.app.selectCardset(_("Select ")+CARDSET, key)
        if not cs:
            return
        self.app.nextgame.cardset = cs
        self._cancelDrag()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    #
    # Tile (ttk)
    #

    def mOptTheme(self, *event):
        theme = self.tkopt.theme.get()
        self.app.opt.tile_theme = theme
        self._calc_MfxMessageDialog()(
            self.top, title=_("Change theme"),
            text=_("""\
These settings will take effect
the next time you restart %(app)s""") % {'app': TITLE},
            bitmap="warning",
            default=0, strings=(_("&OK"),))

    def createThemesMenu(self, menu):
        submenu = MfxMenu(menu, label=n_("Set t&heme"))
        all_themes = list(ttk.Style(self.top).theme_names())
        all_themes.sort()
        #
        tn = {
            'default':     n_('Default'),
            'classic':     n_('Classic'),
            'alt':         n_('Revitalized'),
            'winnative':   n_('Windows native'),
            'xpnative':    n_('XP Native'),
            'aqua':        n_('Aqua'),
            }
        for t in all_themes:
            try:
                n = tn[t]
            except KeyError:
                n = t.capitalize()
            submenu.add_radiobutton(label=n, variable=self.tkopt.theme,
                                    value=t, command=self.mOptTheme)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.ui.tktile.tkutil import bind

from six.moves import tkinter

from .tkwidget import MfxScrolledCanvas


class MfxTreeBaseNode:
    def __init__(self, tree, parent_node, text, key):
        self.tree = tree
        self.parent_node = parent_node
        self.text = text
        self.key = key
        # state
        self.selected = 0
        self.subnodes = None
        # canvas item ids
        self.symbol_id = None
        self.text_id = None
        self.textrect_id = None

    def registerKey(self):
        if self.key is not None:
            lst = self.tree.keys.get(self.key, [])
            lst.append(self)
            self.tree.keys[self.key] = lst

    def whoami(self):
        if self.parent_node is None:
            return (self.text, )
        else:
            return self.parent_node.whoami() + (self.text, )

    def draw(self, x, y, lastx=None, lasty=None):
        canvas, style = self.tree.canvas, self.tree.style
        topleftx = x + style.distx
        toplefty = y - style.height // 2  # +++
        # draw the horizontal line
        if lastx is not None:
            canvas.create_line(
                x, y, topleftx, y, stipple=style.linestyle,
                fill=style.linecolor)
        # draw myself - ugly, ugly...
        self.selected = 0
        self.symbol_id = -1
        self.drawSymbol(topleftx, toplefty)
        linestart = style.distx + style.width + 5
        self.text_id = -1
        self.drawText(x + linestart, y)
        return x, y, x, y + style.disty

    #
    #
    #

    def drawText(self, x, y):
        canvas, style = self.tree.canvas, self.tree.style
        if self.selected:
            fg, bg = style.text_selected_fg, style.text_selected_bg
        else:
            fg, bg = style.text_normal_fg, style.text_normal_bg
        #
        if self.tree.nodes.get(self.text_id) is self:
            canvas.itemconfig(self.text_id, fill=fg)
        else:
            # note: I don't use Label + canvas.create_window here
            #   because it doesn't propagate events to the canvas
            #   and has some other re-display annoyances
            # print 'style.font:', style.font
            self.text_id = canvas.create_text(x+1, y, text=self.text,
                                              anchor="w", justify="left",
                                              font=style.font,
                                              fill=fg)
            self.tree.nodes[self.text_id] = self
        #
        if self.tree.nodes.get(self.textrect_id) is self:
            try:
                # _tkinter.TclError: unknown option "-fill" ???
                canvas.itemconfig(self.textrect_id, fill=bg)
            except tkinter.TclError:
                pass
        elif self.selected:
            b = canvas.bbox(self.text_id)
            self.textrect_id = canvas.create_rectangle(
                b[0]-1, b[1]-1, b[2]+1, b[3]+1,
                fill=bg, outline="")
            canvas.tag_lower(self.textrect_id, self.text_id)
            self.tree.nodes[self.textrect_id] = self

    def updateText(self):
        if self.tree.nodes.get(self.text_id) is self:
            self.drawText(-1, -1)

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        canvas, style = self.tree.canvas, self.tree.style
        color = kw.get("color")
        if color is None:
            if self.selected:
                color = "darkgreen"
            else:
                color = "green"
        # note: rectangle outline is one pixel
        if self.tree.nodes.get(self.symbol_id) is self:
            canvas.itemconfig(self.symbol_id, fill=color)
        else:
            self.symbol_id = canvas.create_rectangle(
                x+1, y+1, x + style.width, y + style.height, fill=color)
            self.tree.nodes[self.symbol_id] = self

    def updateSymbol(self):
        if self.tree.nodes.get(self.symbol_id) is self:
            self.drawSymbol(-1, -1)


# ************************************************************************
# * Terminal and non-terminal nodes
# ************************************************************************

class MfxTreeLeaf(MfxTreeBaseNode):
    def drawText(self, x, y):
        if self.text_id < 0:
            self.registerKey()
        MfxTreeBaseNode.drawText(self, x, y)


class MfxTreeNode(MfxTreeBaseNode):
    def __init__(self, tree, parent_node, text, key, expanded=0):
        MfxTreeBaseNode.__init__(self, tree, parent_node, text, key)
        self.expanded = expanded

    def drawChildren(self, x, y, lastx, lasty):
        # get subnodes
        self.subnodes = self.tree.getContents(self)
        # draw subnodes
        lx, ly = lastx, lasty
        nx, ny = x, y
        for node in self.subnodes:
            # update tree
            node.tree = self.tree
            # draw node
            lx, ly, nx, ny = node.draw(nx, ny, lx, ly)
        # draw the vertical line
        if self.subnodes:
            style = self.tree.style
            dy = (style.disty-style.width)//2
            y = y-style.disty//2-dy
            self.tree.canvas.create_line(x, y, nx, ly,
                                         stipple=style.linestyle,
                                         fill=style.linecolor)
        return ny

    def draw(self, x, y, ilastx=None, ilasty=None):
        # draw myself
        lx, ly, nx, ny = MfxTreeBaseNode.draw(self, x, y, ilastx, ilasty)
        if self.expanded:
            style = self.tree.style
            childx = nx + style.distx + style.width // 2
            childy = ny
            clastx = nx + style.distx + style.width // 2
            clasty = ly + style.height // 2
            ny = self.drawChildren(childx, childy, clastx, clasty)
        return lx, ly, x, ny

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        color = kw.get("color")
        if color is None:
            if self.expanded:
                color = "red"
            else:
                color = "pink"
        MfxTreeBaseNode.drawSymbol(self, x, y, color=color)


# ************************************************************************
# *
# ************************************************************************

class MfxTreeInCanvas(MfxScrolledCanvas):
    class Style:
        def __init__(self):
            self.distx = 16
            self.disty = 18
            self.width = 16         # width of symbol
            self.height = 16        # height of symbol
            self.originx = 0
            self.originy = 0
            self.text_normal_fg = "black"
            self.text_normal_bg = "white"
            self.text_selected_fg = "white"
            self.text_selected_bg = "#00008b"       # "darkblue"
            self.font = None
            self.linestyle = "gray50"
            self.linecolor = "black"

    def __init__(self, parent, rootnodes, **kw):
        kw['bd'] = 0
        kw['bg'] = 'white'
        MfxScrolledCanvas.__init__(self, parent, **kw)
        #
        self.rootnodes = rootnodes
        self.updateNodesWithTree(self.rootnodes, self)
        self.selection_key = None
        self.nodes = {}
        self.keys = {}
        #
        self.style = self.Style()
        # self.style.text_normal_fg = self.canvas.cget("insertbackground")
        # self.style.text_normal_fg = \
        #   self.canvas.option_get('foreground', '') or \
        #   self.canvas.cget("insertbackground")
        # self.style.text_normal_bg = self.canvas.option_get(
        #   'background', self.canvas.cget("background"))
        #
        bind(self.canvas, "<ButtonPress-1>", self.singleClick)
        bind(self.canvas, "<Double-Button-1>", self.doubleClick)
        # bind(self.canvas, "<ButtonRelease-1>", xxx)
        self.pack(fill='both', expand=True)

    def destroy(self):
        for node in self.keys.get(self.selection_key, []):
            node.selected = 0
        MfxScrolledCanvas.destroy(self)

    def findNode(self, event=None):
        id = self.canvas.find_withtag('current')
        if id:
            return self.nodes.get(id[0])
        return None

    #
    # draw nodes
    #

    def draw(self):
        nx, ny = self.style.originx, self.style.originy
        # Account for initial offsets, see topleft[xy] in BaseNode.draw().
        # We do this so that our bounding box always starts at (0,0)
        # and the yscrollincrement works nicely.
        nx -= self.style.distx
        ny += self.style.height // 2
        for node in self.rootnodes:
            # update tree
            node.tree = self
            # draw
            try:
                lx, ly, nx, ny = node.draw(nx, ny, None, None)
            except tkinter.TclError:
                # FIXME: Tk bug ???
                raise
        # set scroll region
        bbox = self.canvas.bbox("all")
        # self.canvas.config(scrollregion=bbox)
        # self.canvas.config(scrollregion=(0,0,bbox[2],bbox[3]))
        dx, dy = 8, 0  # margins
        self.canvas.config(scrollregion=(-dx, -dy, bbox[2]+dx, bbox[3]+dy))
        self.canvas.config(yscrollincrement=self.style.disty)

    def clear(self):
        self.nodes = {}
        self.keys = {}
        self.canvas.delete("all")

    def redraw(self):
        oldcur = self.canvas["cursor"]
        self.canvas["cursor"] = "watch"
        self.canvas.update_idletasks()
        self.clear()
        self.draw()
        self.updateSelection(self.selection_key)
        self.canvas["cursor"] = oldcur

    #
    #
    #

    def getContents(self, node):
        # Overload this, supposed to return a list of subnodes of node.
        pass

    def singleClick(self, event=None):
        # Overload this if you want to know when a node is clicked on.
        pass

    def doubleClick(self, event=None):
        # Overload this if you want to know when a node is d-clicked on.
        self.singleClick(event)

    #
    #
    #

    def updateSelection(self, key):
        l1 = self.keys.get(self.selection_key, [])
        l2 = self.keys.get(key, [])
        for node in l1:
            if node.selected and node not in l2:
                node.selected = 0
                node.updateSymbol()
                node.updateText()
        for node in l2:
            if not node.selected:
                node.selected = 1
                node.updateSymbol()
                node.updateText()
        self.selection_key = key

    def updateNodesWithTree(self, nodes, tree):
        for node in nodes:
            node.tree = tree
            if node.subnodes:
                self.updateNodesWithTree(node.subnodes, tree)


# ************************************************************************
# *
# ************************************************************************


class DirectoryBrowser(MfxTreeInCanvas):
    def __init__(self, parent, dirs):
        nodes = []
        if isinstance(dirs, str):
            dirs = (dirs,)
        for dir in dirs:
            self.addNode(nodes, None, dir, dir)
        # note: best results if height is a multiple of style.disty
        MfxTreeInCanvas.__init__(self, parent, nodes, height=25*18)
        self.draw()

    def addNode(self, list, node, filename, text):
        try:
            if os.path.isdir(filename):
                list.append(MfxTreeNode(self, node, text, key=filename))
            else:
                list.append(MfxTreeLeaf(self, node, text, key=filename))
        except EnvironmentError:
            pass

    def getContents(self, node):
        # use cached values
        if node.subnodes is not None:
            return node.subnodes
        #
        dir = node.key
        print("Getting %s" % dir)
        try:
            filenames = os.listdir(dir)
            filenames.sort()
        except EnvironmentError:
            return ()
        contents = []
        for filename in filenames:
            self.addNode(contents, node, os.path.join(dir, filename), filename)
        # print "gotten"
        return contents

    def singleClick(self, event=None):
        node = self.findNode(event)
        if not node:
            return
        print("Clicked node %s %s" % (node.text, node.key))
        if isinstance(node, MfxTreeLeaf):
            self.updateSelection(key=node.key)
        elif isinstance(node, MfxTreeNode):
            node.expanded = not node.expanded
            self.redraw()
        return "break"


if __name__ == "__main__":
    tk = tkinter.Tk()
    if os.name == "nt":
        app = DirectoryBrowser(tk, ("c:\\", "c:\\windows"))
    else:
        app = DirectoryBrowser(tk, ("/", "/home"))
    tk.mainloop()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.ui.tktile.tkutil import bind

from six.moves import tkinter
from six.moves import tkinter_font
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog
from .tkwidget import PysolScale


# ************************************************************************
# *
# ************************************************************************

class FontChooserDialog(MfxDialog):
    def __init__(self, parent, title, init_font, **kw):
        # print init_font
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        self.font_family = 'Helvetica'
        self.font_size = 12
        self.font_weight = 'normal'
        self.font_slant = 'roman'

        if init_font is not None:
            assert 2 <= len(init_font) <= 4
            assert isinstance(init_font[1], int)
            self.font_family, self.font_size = init_font[:2]
            if len(init_font) > 2:
                if init_font[2] in ['bold', 'normal']:
                    self.font_weight = init_font[2]
                elif init_font[2] in ['italic', 'roman']:
                    self.font_slant = init_font[2]
                else:
                    raise ValueError('invalid font style: '+init_font[2])
                if len(init_font) > 3:
                    if init_font[3] in ['bold', 'normal']:
                        self.font_weight = init_font[3]
                    elif init_font[2] in ['italic', 'roman']:
                        self.font_slant = init_font[3]
                    else:
                        raise ValueError('invalid font style: '+init_font[3])

        # self.family_var = tkinter.StringVar()
        self.weight_var = tkinter.BooleanVar()
        self.weight_var.set(self.font_weight == 'bold')
        self.slant_var = tkinter.BooleanVar()
        self.slant_var.set(self.font_slant == 'italic')
        self.size_var = tkinter.IntVar()
        self.size_var.set(self.font_size)
        #
        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)
        # frame.rowconfigure(1, weight=1)
        self.entry = ttk.Entry(frame)
        self.entry.grid(row=0, column=0, columnspan=2, sticky='news')
        self.entry.insert('end', _('abcdefghABCDEFGH'))
        self.list_box = tkinter.Listbox(frame, width=36, exportselection=False)
        sb = ttk.Scrollbar(frame)
        self.list_box.configure(yscrollcommand=sb.set)
        sb.configure(command=self.list_box.yview)
        self.list_box.grid(row=1, column=0, sticky='news')  # rowspan=4
        sb.grid(row=1, column=1, sticky='ns')
        bind(self.list_box, '<<ListboxSelect>>', self.fontupdate)
        # self.list_box.focus()
        cb1 = ttk.Checkbutton(frame, text=_('Bold'),
                              command=self.fontupdate,
                              variable=self.weight_var)
        cb1.grid(row=2, column=0, columnspan=2, sticky='we')
        cb2 = ttk.Checkbutton(frame, text=_('Italic'),
                              command=self.fontupdate,
                              variable=self.slant_var)
        cb2.grid(row=3, column=0, columnspan=2, sticky='we')

        sc = PysolScale(frame, from_=6, to=40, resolution=1,
                        label=_('Size:'), orient='horizontal',
                        command=self.fontupdate, variable=self.size_var)
        sc.grid(row=4, column=0, columnspan=2, sticky='news')
        #
        font_families = list(tkinter_font.families())
        font_families.sort()
        selected = -1
        n = 0
        self.list_box.insert('end', *font_families)
        for font in font_families:
            if font.lower() == self.font_family.lower():
                selected = n
                break
            n += 1
        if selected >= 0:
            self.list_box.select_set(selected)
            self.list_box.see(selected)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

        self.font = (self.font_family, self.font_size,
                     self.font_slant, self.font_weight)

    def fontupdate(self, *args):
        if self.list_box.curselection():
            self.font_family = self.list_box.get(self.list_box.curselection())
        self.font_weight = self.weight_var.get() and 'bold' or 'normal'
        self.font_slant = self.slant_var.get() and 'italic' or 'roman'
        self.font_size = self.size_var.get()
        self.entry.configure(font=(self.font_family, self.font_size,
                                   self.font_slant, self.font_weight))

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")),
                      default=0,
                      )
        return MfxDialog.initKw(self, kw)

# ************************************************************************
# *
# ************************************************************************


class FontsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        self.fonts = {}
        row = 0
        for fn, title in (  # ('default',        _('Default')),
                          ('sans',           _('HTML: ')),
                          ('small',          _('Small: ')),
                          ('fixed',          _('Fixed: ')),
                          ('canvas_default', _('Tableau default: ')),
                          ('canvas_fixed',   _('Tableau fixed: ')),
                          ('canvas_large',   _('Tableau large: ')),
                          ('canvas_small',   _('Tableau small: ')),
                          ):
            font = app.opt.fonts[fn]
            self.fonts[fn] = font
            ttk.Label(frame, text=title, anchor='w'
                      ).grid(row=row, column=0, sticky='we')
            if font:
                title = ' '.join(
                    [str(i) for i in font if i not in ('roman', 'normal')])
            elif font is None:
                title = 'Default'
            label = ttk.Label(frame, font=font, text=title)
            label.grid(row=row, column=1, padx=8)
            b = ttk.Button(frame, text=_('Change...'), width=10,
                           command=lambda label=label,
                           fn=fn: self.selectFont(label, fn))
            b.grid(row=row, column=2)
            row += 1
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def selectFont(self, label, fn):
        d = FontChooserDialog(self.top, _('Select font'), self.fonts[fn])
        if d.status == 0 and d.button == 0:
            self.fonts[fn] = d.font
            title = ' '.join(
                [str(i) for i in d.font if i not in ('roman', 'normal')])
            label.configure(font=d.font, text=title)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_('&OK'), _('&Cancel')),
                      default=0,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.ui.tktile.selecttree import SelectDialogTreeData

import six
from six.moves import tkinter
from six.moves import tkinter_colorchooser
from six.moves import tkinter_ttk as ttk

from .selecttree import SelectDialogTreeCanvas
from .selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from .tkwidget import MfxDialog, MfxScrolledCanvas


# ************************************************************************
# * Nodes
# ************************************************************************

class SelectTileLeaf(SelectDialogTreeLeaf):
    pass


class SelectTileNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        for obj in self.tree.data.all_objects:
            if self.select_func(obj):
                node = SelectTileLeaf(
                    self.tree, self, text=obj.name, key=obj.index)
                contents.append(node)
        return contents or self.tree.data.no_contents


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectTileData(SelectDialogTreeData):
    def __init__(self, manager, key):
        SelectDialogTreeData.__init__(self)
        self.all_objects = manager.getAllSortedByName()
        self.all_objects = [obj for obj in self.all_objects if not obj.error]
        self.all_objects = [tile for tile in self.all_objects
                            if tile.index > 0 and tile.filename]
        self.no_contents = [SelectTileLeaf(
            None, None, _("(no tiles)"), key=None), ]
        e1 = isinstance(key, str) or len(self.all_objects) <= 17
        e2 = 1
        self.rootnodes = (
            SelectTileNode(None, _("Solid Colors"), (
                SelectTileLeaf(None, None, _("Blue"), key="#0082df"),
                SelectTileLeaf(None, None, _("Green"), key="#008200"),
                SelectTileLeaf(None, None, _("Navy"), key="#000086"),
                SelectTileLeaf(None, None, _("Olive"), key="#868200"),
                SelectTileLeaf(None, None, _("Orange"), key="#f79600"),
                SelectTileLeaf(None, None, _("Teal"), key="#008286"),
            ), expanded=e1),
            SelectTileNode(
                None, _("All Backgrounds"),
                lambda tile: 1, expanded=e2),
        )


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************

class SelectTileTree(SelectDialogTreeCanvas):
    data = None


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectTileDialogWithPreview(MfxDialog):
    Tree_Class = SelectTileTree
    TreeDataHolder_Class = SelectTileTree
    TreeData_Class = SelectTileData

    def __init__(self, parent, title, app, manager, key=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        if key is None:
            key = manager.getSelected()
        self.app = app
        self.manager = manager
        self.key = key
        self.table_color = app.opt.colors['table']
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(manager, key)
        #
        self.top.wm_minsize(400, 200)
        if self.top.winfo_screenwidth() >= 800:
            w1, w2 = 200, 400
        else:
            w1, w2 = 200, 300
        font = app.getFont("default")
        padx, pady = 4, 4
        frame = ttk.Frame(top_frame)
        frame.pack(fill='both', expand=True,
                   padx=kw.padx-padx, pady=kw.pady-pady)
        self.tree = self.Tree_Class(self, frame, key=key, default=kw.default,
                                    font=font, width=w1)
        self.tree.frame.pack(side="left", fill='both', expand=False,
                             padx=padx, pady=pady)
        self.preview = MfxScrolledCanvas(frame, width=w2, hbar=0, vbar=0)
        self.preview.pack(side="right", fill='both', expand=True,
                          padx=padx, pady=pady)
        self.preview.canvas.preview = 1
        # create a preview of the current state
        self.preview_key = -1
        self.updatePreview(key)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def destroy(self):
        self.tree.updateNodesWithTree(self.tree.rootnodes, None)
        self.tree.destroy()
        self.preview.unbind_all()
        MfxDialog.destroy(self)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=((_("&Solid color..."), 10),
                               'sep', _("&OK"), _("&Cancel"),),
                      default=0,
                      resizable=True,
                      font=None,
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if button == 0:        # "OK" or double click
            if isinstance(self.tree.selection_key, six.string_types):
                self.key = str(self.tree.selection_key)
            else:
                self.key = self.tree.selection_key
            self.tree.n_expansions = 1  # save xyview in any case
        if button == 10:        # "Solid color..."
            try:
                c = tkinter_colorchooser.askcolor(
                    master=self.top,
                    initialcolor=self.table_color,
                    title=_("Select table color"))
            except tkinter.TclError:
                pass
            else:
                if c and c[1]:
                    color = str(c[1])
                    self.key = color.lower()
                    self.table_color = self.key
                    self.tree.updateSelection(self.key)
                    self.updatePreview(self.key)
            return
        MfxDialog.mDone(self, button)

    def updatePreview(self, key):
        if key == self.preview_key:
            return
        canvas = self.preview.canvas
        canvas.deleteAllItems()
        if isinstance(key, six.string_types):
            # solid color
            canvas.config(bg=key)
            canvas.setTile(None)
            canvas.setTextColor(None)
            self.preview_key = key
            self.table_color = key
        else:
            # image
            tile = self.manager.get(key)
            if tile:
                if self.preview.setTile(self.app, key):
                    return
            self.preview_key = -1
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.ui.tktile.tkconst import EVENT_HANDLED
from pysollib.ui.tktile.tkutil import makeToplevel, setTransient

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

# ************************************************************************
# * a simple progress bar
# ************************************************************************


class PysolProgressBar:
    def __init__(self, app, parent, title=None, images=None, color="blue",
                 width=300, height=25, show_text=1, norm=1):
        self.parent = parent
        self.percent = 0
        self.top = makeToplevel(parent, title=title)
        self.top.wm_protocol("WM_DELETE_WINDOW", self.wmDeleteWindow)
        self.top.wm_group(parent)
        self.top.wm_resizable(False, False)
        self.top.config(cursor="watch")
        #
        self.frame = ttk.Frame(self.top, relief='flat', borderwidth=0)
        self.progress = ttk.Progressbar(self.frame, maximum=100, length=250)
        # style = ttk.Style(self.progress)
        # style.configure('TProgressbar', background=color)
        if images:
            self.f1 = ttk.Label(self.frame, image=images[0])
            self.f1.pack(side='left', ipadx=8, ipady=4)
            self.progress.pack(side='left', expand=True, fill='x')
            self.f2 = ttk.Label(self.frame, image=images[1])
            self.f2.pack(side='left', ipadx=8, ipady=4)
        else:
            self.progress.pack(expand=True, fill='x')
        self.frame.pack(expand=True, fill='both')
        if 1:
            setTransient(self.top, None, relx=0.5, rely=0.5)
        else:
            self.update(percent=0)
        self.norm = norm
        self.steps_sum = 0

    def wmDeleteWindow(self):
        return EVENT_HANDLED

    def destroy(self):
        if self.top is None:        # already destroyed
            return
        self.top.wm_withdraw()
        self.top.quit()
        self.top.destroy()
        self.top = None

    def reset(self, percent=0):
        self.percent = percent

    def update(self, percent=None, step=1):
        self.steps_sum += step
        # print self.steps_sum
        step = step/self.norm
        if self.top is None:        # already destroyed
            return
        if percent is None:
            self.percent = self.percent + step
        elif percent > self.percent:
            self.percent = percent
        else:
            return
        self.percent = min(100, max(0, self.percent))
        self.progress.config(value=self.percent)
        # self.top.update_idletasks()
        self.top.update()


# ************************************************************************
# *
# ************************************************************************


class TestProgressBar:
    def __init__(self, parent):
        self.parent = parent
        self.progress = PysolProgressBar(
            None, parent, title="Progress", color="#008200")
        self.progress.pack(ipadx=10, ipady=10)
        self.progress.frame.after(1000, self.update)

    def update(self, event=None):
        if self.progress.percent >= 100:
            self.parent.after_idle(self.progress.destroy)
            return
        self.progress.update(step=1)
        self.progress.frame.after(30, self.update)


def progressbar_main(args):
    from pysollib.ui.tktile.tkutil import wm_withdraw
    tk = tkinter.Tk()
    wm_withdraw(tk)
    TestProgressBar(tk)
    tk.mainloop()
    return 0


if __name__ == "__main__":
    import sys
    sys.exit(progressbar_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import locale
import os
import time
import traceback

from pysollib.mfxutil import KwStruct, destruct, kwdefault, openURL
from pysollib.mygettext import _
from pysollib.settings import WIN_SYSTEM
from pysollib.ui.tktile.tkcanvas import MfxCanvas
from pysollib.ui.tktile.tkutil import after, after_cancel
from pysollib.ui.tktile.tkutil import bind, unbind_destroy
from pysollib.ui.tktile.tkutil import makeToplevel, setTransient

import six
from six import PY2
from six.moves import tkinter
from six.moves import tkinter_font
from six.moves import tkinter_ttk as ttk

# ************************************************************************
# * abstract base class for the dialogs in this module
# ************************************************************************


class MfxDialog:  # ex. _ToplevelDialog
    img = {}
    button_img = {}

    def __init__(self, parent, title="", resizable=False, default=-1):
        self.parent = parent
        self.status = 0
        self.button = default
        self.timer = None
        self.buttons = []
        self.accel_keys = {}
        self.top = makeToplevel(parent, title=title)
        # self._frame = ttk.Frame(self.top)
        # self._frame.pack(expand=True, fill='both')
        self._frame = self.top
        self.top.wm_resizable(resizable, resizable)
        # w, h = self.top.winfo_screenwidth(), self.top.winfo_screenheight()
        # self.top.wm_maxsize(w-4, h-32)
        bind(self.top, "WM_DELETE_WINDOW", self.wmDeleteWindow)

    def mainloop(self, focus=None, timeout=0, transient=True):
        bind(self.top, "<Escape>", self.mCancel)
        bind(self.top, '<Alt-Key>', self.altKeyEvent)  # for accelerators
        if focus is not None:
            focus.focus()
        if transient:
            setTransient(self.top, self.parent)
            try:
                self.top.grab_set()
            except tkinter.TclError:
                if traceback:
                    traceback.print_exc()
                pass
            if timeout > 0:
                self.timer = after(self.top, timeout, self.mTimeout)
            try:
                self.top.mainloop()
            except SystemExit:
                pass
            self.destroy()

    def destroy(self):
        after_cancel(self.timer)
        unbind_destroy(self.top)
        self.top.destroy()
        self.top.update_idletasks()
        self.top = None
        self.parent = None

    def wmDeleteWindow(self, *event):
        self.status = 1
        raise SystemExit
        # return EVENT_HANDLED

    def mCancel(self, *event):
        self.status = 1
        raise SystemExit

    def mTimeout(self, *event):
        self.status = 2
        raise SystemExit

    def mDone(self, button):
        self.button = button
        raise SystemExit

    def altKeyEvent(self, event):
        widget = None
        if event.keysym in self.accel_keys:
            widget = self.accel_keys[event.keysym]
        else:
            key = event.char
            try:
                if os.name == 'nt':
                    key = six.text_type(key, locale.getpreferredencoding())
                else:
                    key = six.text_type(key, 'utf-8')
            except Exception:
                pass
            else:
                key = key.lower()
                widget = self.accel_keys.get(key)
        if widget is not None:
            widget.event_generate('<<Invoke>>')

    def initKw(self, kw):
        kw = KwStruct(kw,
                      timeout=0, resizable=False,
                      text="", justify="center",
                      strings=(_("&OK"),),
                      default=0,
                      width=0,
                      padx=20, pady=20,
                      bitmap=None, bitmap_side="left",
                      bitmap_padx=10, bitmap_pady=20,
                      image=None, image_side="left",
                      image_padx=10, image_pady=20,
                      )
        # default to separator if more than one button
        sep = len(kw.strings) > 1
        kwdefault(kw.__dict__, separator=sep)
        return kw

    def createFrames(self, kw):
        bottom_frame = ttk.Frame(self._frame, relief='flat', borderwidth=4)
        bottom_frame.pack(side='bottom', fill='both', expand=False)
        if kw.separator:
            separator = ttk.Separator(self._frame)
            separator.pack(side='bottom', fill='x')
        top_frame = ttk.Frame(self._frame)
        top_frame.pack(side='top', fill='both', expand=1)
        return top_frame, bottom_frame

    def createBitmaps(self, frame, kw):
        if kw.bitmap:  # in ("error", "info", "question", "warning")
            img = self.img.get(kw.bitmap)
            b = ttk.Label(frame, image=img)
            b.pack(side=kw.bitmap_side,
                   padx=kw.bitmap_padx, pady=kw.bitmap_pady)
        elif kw.image:
            b = ttk.Label(frame, image=kw.image)
            b.pack(side=kw.image_side, padx=kw.image_padx, pady=kw.image_pady)

    def createButtons(self, frame, kw):
        padx, pady = 4, 4
        xbutton = column = -1
        focus = None
        max_len = 0
        if 'sep' in kw.strings:
            sep_column = list(kw.strings).index('sep')
            strings = kw.strings[sep_column+1:]
        else:
            sep_column = 0
            strings = kw.strings
        for s in strings:
            if isinstance(s, tuple):
                s = s[0]
            if s:
                s = s.replace('&', '')
                max_len = max(max_len, len(s))
            # print s, len(s)
        if max_len > 12 and WIN_SYSTEM == 'x11':
            button_width = max_len
        elif max_len > 9:
            button_width = max_len+1
        elif max_len > 6:
            button_width = max_len+2
        else:
            button_width = 8
        #
        for s in kw.strings:
            if s is None:
                xbutton += 1
                continue
            if s == 'sep':
                column += 1
                continue
            if isinstance(s, tuple):
                assert len(s) == 2
                button = int(s[1])
                s = s[0]
            else:
                xbutton += 1
                button = xbutton
            accel_indx = s.find('&')
            button_img = None
            if MfxDialog.button_img:
                button_img = MfxDialog.button_img.get(s)
            s = s.replace('&', '')
            if button < 0:
                widget = ttk.Button(frame, text=s, state="disabled")
            else:
                widget = ttk.Button(
                    frame, text=s, default="normal",
                    command=lambda self=self, button=button:
                    self.mDone(button))
                if button == kw.default:
                    focus = widget
                    focus.config(default="active")
            self.buttons.append(widget)
            #
            column += 1
            if column >= sep_column:
                widget.config(width=button_width)
            else:
                widget.config(width=max(button_width, len(s)))
            if accel_indx >= 0:
                # key accelerator
                widget.config(underline=accel_indx)
                key = s[accel_indx]
                self.accel_keys[key.lower()] = widget
            #
            if button_img:
                widget.config(compound='left', image=button_img)
            widget.grid(
                column=column, row=0, sticky="nse", padx=padx, pady=pady)
        if focus is not None:
            def cb(event=None, w=focus):
                return w.event_generate('<<Invoke>>')
            bind(self.top, "<Return>", cb)
            bind(self.top, "<KP_Enter>", cb)
        # right justify
        frame.columnconfigure(sep_column, weight=1)
        return focus


# ************************************************************************
# * replacement for the tk_dialog script
# ************************************************************************

class MfxMessageDialog(MfxDialog):
    def __init__(self, parent, title, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.button = kw.default
        msg = ttk.Label(top_frame, text=kw.text, justify=kw.justify,
                        width=kw.width)
        msg.pack(fill='both', expand=True, padx=kw.padx, pady=kw.pady)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)


# ************************************************************************
# *
# ************************************************************************

class MfxExceptionDialog(MfxMessageDialog):
    def __init__(self, parent, ex, title="Error", **kw):
        kw = KwStruct(kw, bitmap="error")
        text = kw.get("text", "")
        if not text.endswith("\n"):
            text = text + "\n"
        text = text + "\n"
        if isinstance(ex, EnvironmentError) and ex.filename is not None:
            t = "[Errno %s] %s:\n%s" % \
                (ex.errno, ex.strerror, repr(ex.filename))
        else:
            t = str(ex)
        if PY2:
            t = six.text_type(t, errors='replace')
        kw.text = text + t
        MfxMessageDialog.__init__(self, parent, title, **kw.getKw())


# ************************************************************************
# *
# ************************************************************************

class PysolAboutDialog(MfxMessageDialog):
    def __init__(self, app, parent, title, **kw):
        self._url = kw['url']
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.button = kw.default
        frame = ttk.Frame(top_frame)
        frame.pack(fill='both', expand=True, padx=kw.padx, pady=kw.pady)
        msg = ttk.Label(frame, text=kw.text, justify=kw.justify,
                        width=kw.width)
        msg.pack(fill='both', expand=True)

        # font_name = msg.lookup('TLabel', 'font')
        font_name = 'TkDefaultFont'
        font = tkinter_font.Font(parent, name=font_name, exists=True)
        font = font.copy()
        font.configure(underline=True)
        url_label = ttk.Label(frame, text=kw.url, font=font,
                              foreground='blue', cursor='hand2')
        url_label.pack()
        url_label.bind('<1>', self._urlClicked)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def _urlClicked(self, event):
        openURL(self._url)


# ************************************************************************
# *
# ************************************************************************

class MfxSimpleEntry(MfxDialog):
    def __init__(self, parent, title, label, value, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.value = value
        if label:
            label = ttk.Label(top_frame, text=label, takefocus=0)
            label.pack(pady=5)
        w = kw.get("e_width", 0)    # width in characters
        self.var = ttk.Entry(top_frame, exportselection=1, width=w)
        self.var.insert(0, value)
        self.var.pack(side='top', padx=kw.padx, pady=kw.pady)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.var
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")), default=0,
                      separator=False,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        self.button = button
        self.value = self.var.get()
        raise SystemExit


# ************************************************************************
# * a simple tooltip
# ************************************************************************

class MfxTooltip:
    last_leave_time = 0

    def __init__(self, widget):
        # private vars
        self.widget = widget
        self.text = None
        self.timer = None
        self.cancel_timer = None
        self.tooltip = None
        self.label = None
        self.bindings = []
        self.bindings.append(self.widget.bind("<Enter>", self._enter))
        self.bindings.append(self.widget.bind("<Leave>", self._leave))
        self.bindings.append(self.widget.bind("<ButtonPress>", self._leave))
        # user overrideable settings
        self.timeout = 800                    # milliseconds
        self.cancel_timeout = 5000
        self.leave_timeout = 400
        self.relief = 'solid'
        self.justify = 'left'
        self.fg = "#000000"
        self.bg = "#ffffe0"
        self.xoffset = 0
        self.yoffset = 4

    def setText(self, text):
        self.text = text

    def _unbind(self):
        if self.bindings and self.widget:
            self.widget.unbind("<Enter>", self.bindings[0])
            self.widget.unbind("<Leave>", self.bindings[1])
            self.widget.unbind("<ButtonPress>", self.bindings[2])
            self.bindings = []

    def destroy(self):
        self._unbind()
        self._leave()

    def _enter(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.cancel_timer = None
        if time.time() - MfxTooltip.last_leave_time < self.leave_timeout/1000.:
            self._showTip()
        else:
            self.timer = after(self.widget, self.timeout, self._showTip)

    def _leave(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.timer = self.cancel_timer = None
        if self.tooltip:
            self.label.destroy()
            destruct(self.label)
            self.label = None
            self.tooltip.destroy()
            destruct(self.tooltip)
            self.tooltip = None
            MfxTooltip.last_leave_time = time.time()

    def _showTip(self):
        self.timer = None
        if self.tooltip or not self.text:
            return
        #  if isinstance(self.widget, (ttk.Button, ttk.Checkbutton)):
        #      if self.widget["state"] == 'disabled':
        #          return
        # x = self.widget.winfo_rootx()
        x = self.widget.winfo_pointerx()
        y = self.widget.winfo_rooty() + self.widget.winfo_height()
        x += self.xoffset
        y += self.yoffset
        self.tooltip = tkinter.Toplevel()
        self.tooltip.wm_iconify()
        self.tooltip.wm_overrideredirect(1)
        self.tooltip.wm_protocol("WM_DELETE_WINDOW", self.destroy)
        self.label = tkinter.Label(self.tooltip, text=self.text,
                                   relief=self.relief, justify=self.justify,
                                   fg=self.fg, bg=self.bg, bd=1, takefocus=0)
        self.label.pack(ipadx=1, ipady=1)
        self.tooltip.wm_geometry("%+d%+d" % (x, y))
        self.tooltip.wm_deiconify()
        self.cancel_timer = after(
            self.widget, self.cancel_timeout, self._leave)
        # self.tooltip.tkraise()


# ************************************************************************
# * A canvas widget with scrollbars and some useful bindings.
# ************************************************************************

class MfxScrolledCanvas:
    def __init__(self, parent, hbar=True, vbar=True, propagate=0, **kw):
        kwdefault(kw, highlightthickness=0, bd=1, relief='sunken')
        self.parent = parent
        self.createFrame(kw)
        self.canvas = None
        self.hbar = None
        self.vbar = None
        self.hbar_show = False
        self.vbar_show = False
        self.createCanvas(kw)
        self.frame.grid_rowconfigure(0, weight=1)
        self.frame.grid_columnconfigure(0, weight=1)
        self.frame.grid_propagate(propagate)
        if hbar:
            self.createHbar()
            self.bindHbar()
        if vbar:
            self.createVbar()
            self.bindVbar()
        # self.canvas.focus_set()

    #
    #
    #

    def destroy(self):
        self.unbind_all()
        self.canvas.destroy()
        self.frame.destroy()

    def pack(self, **kw):
        self.frame.pack(**kw)

    def grid(self, **kw):
        self.frame.grid(**kw)

    #
    #
    #

    def setTile(self, app, i, force=False):
        tile = app.tabletile_manager.get(i)
        if tile is None or tile.error:
            return False
        # print i, tile
        if i == 0:
            assert tile.color
            assert tile.filename is None
        else:
            assert tile.color is None
            assert tile.filename
            assert tile.basename
        if not force:
            if (i == app.tabletile_index and
                    tile.color == app.opt.colors['table']):
                return False
        #
        if not self.canvas.setTile(tile.filename, tile.stretch,
                                   tile.save_aspect):
            tile.error = True
            return False

        if i == 0:
            self.canvas.config(bg=tile.color)
            # app.top.config(bg=tile.color)
        else:
            self.canvas.config(bg=app.top_bg)
            # app.top.config(bg=app.top_bg)

        self.canvas.setTextColor(app.opt.colors['text'])

        return True

    #
    #
    #

    def unbind_all(self):
        unbind_destroy(self.hbar)
        unbind_destroy(self.vbar)
        unbind_destroy(self.canvas)
        unbind_destroy(self.frame)

    def createFrame(self, kw):
        width = kw.get("width")
        height = kw.get("height")
        self.frame = ttk.Frame(self.parent, width=width, height=height)

    def createCanvas(self, kw):
        bd = kw['bd']
        kw['bd'] = 0
        relief = kw['relief']
        del kw['relief']
        frame = tkinter.Frame(self.frame, bd=bd, relief=relief)
        frame.grid(row=0, column=0, sticky="news")
        self.canvas = MfxCanvas(frame, **kw)
        self.canvas.pack(expand=True, fill='both')

    def createHbar(self):

        self.hbar = ttk.Scrollbar(self.frame, takefocus=0,
                                  orient="horizontal")
        self.canvas["xscrollcommand"] = self._setHbar
        self.hbar["command"] = self.canvas.xview
        self.hbar.grid(row=1, column=0, sticky="we")
        self.hbar.grid_remove()

    def createVbar(self):
        self.vbar = ttk.Scrollbar(self.frame, takefocus=0)
        self.canvas["yscrollcommand"] = self._setVbar
        self.vbar["command"] = self.canvas.yview
        self.vbar.grid(row=0, column=1, sticky="ns")
        self.vbar.grid_remove()

    def bindHbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Left>", self.unit_left)
        bind(w, "<KeyPress-Right>", self.unit_right)

    def bindVbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Prior>", self.page_up)
        bind(w, "<KeyPress-Next>", self.page_down)
        bind(w, "<KeyPress-Up>", self.unit_up)
        bind(w, "<KeyPress-Down>", self.unit_down)
        bind(w, "<KeyPress-Begin>", self.scroll_top)
        bind(w, "<KeyPress-Home>", self.scroll_top)
        bind(w, "<KeyPress-End>", self.scroll_bottom)
        # mousewheel support
        if WIN_SYSTEM == 'x11':
            bind(w, '<4>', self.mouse_wheel_up)
            bind(w, '<5>', self.mouse_wheel_down)
        # don't work on Linux
        # bind(w, '<MouseWheel>', self.mouse_wheel)

    def mouse_wheel(self, *args):
        print('MfxScrolledCanvas.mouse_wheel', args)

    def _setHbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.hbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.hbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.hbar_show = True
        sb.set(first, last)

    def _setVbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.vbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.vbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.vbar_show = True
        sb.set(first, last)

    def _xview(self, *args):
        if self.hbar_show:
            self.canvas.xview(*args)
        return 'break'

    def _yview(self, *args):
        if self.vbar_show:
            self.canvas.yview(*args)
        return 'break'

    def page_up(self, *event):
        return self._yview('scroll', -1, 'page')

    def page_down(self, *event):
        return self._yview('scroll', 1, 'page')

    def unit_up(self, *event):
        return self._yview('scroll', -1, 'unit')

    def unit_down(self, *event):
        return self._yview('scroll', 1, 'unit')

    def mouse_wheel_up(self, *event):
        return self._yview('scroll', -5, 'unit')

    def mouse_wheel_down(self, *event):
        return self._yview('scroll', 5, 'unit')

    def page_left(self, *event):
        return self._xview('scroll', -1, 'page')

    def page_right(self, *event):
        return self._xview('scroll', 1, 'page')

    def unit_left(self, *event):
        return self._xview('scroll', -1, 'unit')

    def unit_right(self, *event):
        return self._xview('scroll', 1, 'unit')

    def scroll_top(self, *event):
        return self._yview('moveto', 0)

    def scroll_bottom(self, *event):
        return self._yview('moveto', 1)


# ************************************************************************
# *
# ************************************************************************

class StackDesc:

    def __init__(self, game, stack):
        self.game = game
        self.stack = stack
        self.canvas = game.canvas
        self.bindings = []

        font = game.app.getFont('canvas_small')
        # print self.app.cardset.CARDW, self.app.images.CARDW
        cardw = game.app.images.getSize()[0]
        x, y = stack.x+cardw//2, stack.y
        text = stack.getHelp()+'\n'+stack.getBaseCard()
        text = text.strip()
        if text:
            frame = tkinter.Frame(self.canvas)
            self.frame = frame
            label = tkinter.Message(frame, font=font, text=text,
                                    width=cardw-8, relief='solid',
                                    fg='#000000', bg='#ffffe0', bd=1)
            label.pack()
            self.label = label
            self.id = self.canvas.create_window(x, y, window=frame, anchor='n')
            self.bindings.append(label.bind('<ButtonPress>',
                                            self._buttonPressEvent))
            # self.bindings.append(label.bind('<Enter>', self._enterEvent))
        else:
            self.id = None

    def _buttonPressEvent(self, *event):
        # self.game.deleteStackDesc()
        self.frame.tkraise()

    def _enterEvent(self, *event):
        self.frame.tkraise()

    def delete(self):
        if self.id:
            self.canvas.delete(self.id)
            for b in self.bindings:
                self.label.unbind('<ButtonPress>', b)


# ************************************************************************
# * ttk.Scale workaround (label and resolution)
# ************************************************************************

class MyPysolScale:
    def __init__(self, parent, **kw):
        if 'resolution' in kw:
            self.resolution = kw['resolution']
            del kw['resolution']
        else:
            self.resolution = 1
        if 'from_' in kw:
            kw['from_'] //= self.resolution
        if 'to' in kw:
            kw['to'] //= self.resolution
        if 'variable' in kw:
            self.variable = kw['variable']
            del kw['variable']
        else:
            self.variable = None
        value = None
        if 'value' in kw:
            value = kw['value']
            del kw['value']
        elif self.variable:
            value = self.variable.get()
        self.value = value
        self.command = command = None
        if 'command' in kw:
            command = kw['command']
        kw['command'] = self._scale_command
        if 'label' in kw:
            self.label_text = kw['label']
            width = len(self.label_text)+4
            # width = None
            del kw['label']
        else:
            self.label_text = None
            width = 3

        # create widgets
        side = 'left'  # 'top'
        self.frame = ttk.Frame(parent)
        self.label = ttk.Label(self.frame, anchor='w',
                               width=width, padding=(5, 0))
        self.label.pack(side=side, expand=False, fill='x')
        self.scale = ttk.Scale(self.frame, **kw)
        self.scale.pack(side=side, expand=True, fill='both', pady=4)

        if self.variable:
            self.variable.trace('w', self._trace_var)
        if value is not None:
            self._set_text(self._round(value))
            if self.variable:
                self.variable.set(value)
        self.command = command

    def _round(self, value):
        return int(round(float(value)/self.resolution))*self.resolution

    def _trace_var(self, *args):
        self.scale.set(float(self.variable.get())/self.resolution)

    def _set_text(self, v):
        if self.label_text:
            t = self.label_text+' '+str(v)
        else:
            t = str(v)
        self.label.configure(text=t)

    def _scale_command(self, value):
        v = self._round(float(value)*self.resolution)
        self._set_text(v)
        self.variable.set(v)
        if value != self.value and self.command:
            self.command(value)
        self.value = value

    def pack(self, **kw):
        self.frame.pack(**kw)

    def grid(self, **kw):
        self.frame.grid(**kw)

    def configure(self, **kw):
        self.scale.configure(**kw)
    config = configure

    def state(self, v):
        self.scale.state(statespec=(v,))
        self.label.state(statespec=(v,))

    def get(self):
        return self.variable.get()

    def set(self, v):
        self.variable.set(v)


class TkinterScale(tkinter.Scale):
    def __init__(self, parent, **kw):
        if 'value' in kw:
            del kw['value']
        tkinter.Scale.__init__(self, parent, **kw)


PysolScale = MyPysolScale
# PysolScale = TkinterScale


# ************************************************************************
# * ttk.Combobox workaround (clear selection)
# ************************************************************************

class PysolCombo(ttk.Combobox):
    def __init__(self, master=None, **kw):
        self._command = None
        if 'selectcommand' in kw:
            self._command = kw['selectcommand']
            del kw['selectcommand']
        ttk.Combobox.__init__(self, master, **kw)
        self.bind('<<ComboboxSelected>>', self._callback)

    def _callback(self, *args):
        # self.selection_clear()
        self.selection_range(0, 0)
        if self._command is not None:
            return self._command(*args)
        return None
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog


class BaseTileMfxDialog(MfxDialog):
    def _calcToolkit(self):
        return ttk

    def _calc_MfxDialog(self):
        return MfxDialog
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.wizardpresets import presets
from pysollib.wizardutil import WizardWidgets

import six
from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog
from .tkwidget import PysolCombo, PysolScale


class WizardDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=10, pady=10)
        frame.columnconfigure(0, weight=1)

        notebook = ttk.Notebook(frame)
        notebook.pack(expand=True, fill='both')

        for w in WizardWidgets:
            if isinstance(w, six.string_types):
                frame = ttk.Frame(notebook)
                notebook.add(frame, text=w, sticky='nsew', padding=5)
                frame.columnconfigure(1, weight=1)
                row = 0
                continue

            ttk.Label(frame, text=w.label).grid(row=row, column=0)

            if w.widget == 'preset':
                if w.variable is None:
                    w.variable = tkinter.StringVar()
                values = [_(v) for v in w.values]
                default = _(w.default)
                values.remove(default)
                values.sort()
                values.insert(0, default)

                def callback(e, w=w):
                    self.presetSelected(e, w)
                cb = PysolCombo(frame, values=tuple(values),
                                textvariable=w.variable,
                                exportselection=False,
                                selectcommand=callback,
                                state='readonly', width=32)
                cb.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
            elif w.widget == 'entry':
                if w.variable is None:
                    w.variable = tkinter.StringVar()
                en = ttk.Entry(frame, textvariable=w.variable)
                en.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
            elif w.widget == 'menu':
                if w.variable is None:
                    w.variable = tkinter.StringVar()
                values = [_(v) for v in w.values]
                cb = PysolCombo(frame, values=tuple(values),
                                textvariable=w.variable,
                                exportselection=False,
                                state='readonly', width=32)
                cb.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
            elif w.widget == 'spin':
                if w.variable is None:
                    w.variable = tkinter.IntVar()
                else:
                    # delete all trace callbacks
                    for mod, cbname in w.variable.trace_vinfo():
                        w.variable.trace_vdelete(mod, cbname)
                from_, to = w.values
                # s = Spinbox(
                #   frame, textvariable=w.variable, from_=from_, to=to)
                s = PysolScale(frame, from_=from_, to=to, resolution=1,
                               orient='horizontal',
                               variable=w.variable)
                s.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
            elif w.widget == 'check':
                if w.variable is None:
                    w.variable = tkinter.BooleanVar()
                ch = ttk.Checkbutton(frame, variable=w.variable,
                                     takefocus=False)
                ch.grid(row=row, column=1, sticky='ew', padx=2, pady=2)

            if w.current_value is None:
                v = w.default
            else:
                v = w.current_value
            if w.widget in ('menu', 'preset'):
                v = _(v)
            w.variable.set(v)

            row += 1

        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def presetSelected(self, e, w):
        n = e.widget.get()
        n = w.translation_map[n]
        p = presets[n]
        for w in WizardWidgets:
            if isinstance(w, six.string_types):
                continue
            if w.var_name in p:
                v = p[w.var_name]
            else:
                v = w.default
            if w.widget in ('menu', 'preset', 'entry'):
                v = _(v)
            w.variable.set(v)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_('&OK'), _('&Cancel')),
                      default=0,
                      separator=False,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import pysollib.ui.tktile.gameinfodialog
from pysollib.tile.basetilemfxdialog import BaseTileMfxDialog


class GameInfoDialog(pysollib.ui.tktile.gameinfodialog.BaseGameInfoDialog,
                     BaseTileMfxDialog):
    True
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# imports

# Toolkit imports
from pysollib.tile.basetilemfxdialog import BaseTileMfxDialog
from pysollib.ui.tktile.edittextdialog import BaseEditTextDialog

# ************************************************************************
# *
# ************************************************************************


class EditTextDialog(BaseEditTextDialog, BaseTileMfxDialog):

    def _calc_Resizable(self):
        return False
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os

from pysollib.mfxutil import KwStruct, USE_PIL
from pysollib.mygettext import _
from pysollib.resource import CSI
from pysollib.ui.tktile.selecttree import SelectDialogTreeData
from pysollib.ui.tktile.tkcanvas import MfxCanvasImage
from pysollib.ui.tktile.tkutil import loadImage
from pysollib.util import CARDSET

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .selecttree import SelectDialogTreeCanvas
from .selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from .tkwidget import MfxDialog, MfxScrolledCanvas, PysolScale


# ************************************************************************
# * Nodes
# ************************************************************************

class SelectCardsetLeaf(SelectDialogTreeLeaf):
    pass


class SelectCardsetNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        for obj in self.tree.data.all_objects:
            if self.select_func(obj):
                node = SelectCardsetLeaf(
                    self.tree, self, text=obj.name, key=obj.index)
                contents.append(node)
        return contents or self.tree.data.no_contents


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectCardsetData(SelectDialogTreeData):
    def __init__(self, manager, key):
        SelectDialogTreeData.__init__(self)
        self.all_objects = manager.getAllSortedByName()
        self.all_objects = [obj for obj in self.all_objects if not obj.error]
        self.no_contents = [SelectCardsetLeaf(
            None, None, _("(no cardsets)"), key=None), ]
        #
        select_by_type = None
        items = list(CSI.TYPE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_types.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key == cs.si.type))
        if nodes:
            select_by_type = SelectCardsetNode(
                None, _("by Type"), tuple(nodes), expanded=1)
        #
        select_by_style = None
        items = list(CSI.STYLE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_styles.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key in cs.si.styles))
        if nodes:
            nodes.append(
                SelectCardsetNode(
                    None, _("Uncategorized"), lambda cs: not cs.si.styles))
            select_by_style = SelectCardsetNode(
                None, _("by Style"), tuple(nodes))
        #
        select_by_nationality = None
        items = list(CSI.NATIONALITY.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_nationalities.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name,
                        lambda cs, key=key: key in cs.si.nationalities))
        if nodes:
            nodes.append(
                SelectCardsetNode(
                    None, _("Uncategorized"),
                    lambda cs: not cs.si.nationalities))
            select_by_nationality = SelectCardsetNode(
                None, _("by Nationality"), tuple(nodes))
        #
        select_by_date = None
        items = list(CSI.DATE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_dates.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key in cs.si.dates))
        if nodes:
            nodes.append(
                SelectCardsetNode(
                    None, _("Uncategorized"), lambda cs: not cs.si.dates))
            select_by_date = SelectCardsetNode(
                None, _("by Date"), tuple(nodes))
        #
        self.rootnodes = [_f for _f in (
            SelectCardsetNode(
                None, _("All Cardsets"),
                lambda cs: 1, expanded=len(self.all_objects) <= 12),
            SelectCardsetNode(
                None, _("by Size"),
                (SelectCardsetNode(
                    None, _("Tiny cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_TINY),
                 SelectCardsetNode(
                    None, _("Small cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_SMALL),
                 SelectCardsetNode(
                    None, _("Medium cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_MEDIUM),
                 SelectCardsetNode(
                    None, _("Large cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_LARGE),
                 SelectCardsetNode(
                    None, _("XLarge cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_XLARGE),
                 ), expanded=1),
            select_by_type,
            select_by_style,
            select_by_date,
            select_by_nationality,
        ) if _f]


class SelectCardsetByTypeData(SelectDialogTreeData):
    def __init__(self, manager, key):
        SelectDialogTreeData.__init__(self)
        self.all_objects = manager.getAllSortedByName()
        self.no_contents = [SelectCardsetLeaf(None, None, _("(no cardsets)"),
                            key=None), ]
        #
        items = list(CSI.TYPE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_types.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key == cs.si.type))
        select_by_type = SelectCardsetNode(
            None, _("by Type"), tuple(nodes), expanded=1)
        #
        self.rootnodes = [_f for _f in (
            select_by_type,
        ) if _f]


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************

class SelectCardsetTree(SelectDialogTreeCanvas):
    data = None


class SelectCardsetByTypeTree(SelectDialogTreeCanvas):
    data = None


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectCardsetDialogWithPreview(MfxDialog):
    Tree_Class = SelectCardsetTree
    TreeDataHolder_Class = SelectCardsetTree
    TreeData_Class = SelectCardsetData

    def __init__(self, parent, title, app, manager, key=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        if key is None:
            key = manager.getSelected()
        self.manager = manager
        self.key = key
        self.app = app
        self.cardset_values = None
        # padx, pady = kw.padx, kw.pady
        padx, pady = 5, 5
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(manager, key)
        #
        self.top.wm_minsize(400, 200)
        if self.top.winfo_screenwidth() >= 800:
            w1, w2 = 240, 400
        else:
            w1, w2 = 200, 300
        paned_window = ttk.PanedWindow(top_frame, orient='horizontal')
        paned_window.pack(expand=True, fill='both')
        left_frame = ttk.Frame(paned_window)
        right_frame = ttk.Frame(paned_window)
        paned_window.add(left_frame)
        paned_window.add(right_frame)
        font = app.getFont("default")
        self.tree = self.Tree_Class(self, left_frame, key=key,
                                    default=kw.default,
                                    font=font, width=w1)
        self.tree.frame.grid(row=0, column=0, sticky='nsew',
                             padx=padx, pady=pady)
        if USE_PIL:
            #
            var = tkinter.DoubleVar()
            var.set(app.opt.scale_x)
            self.scale_x = PysolScale(
                left_frame, label=_('Scale X:'),
                from_=0.5, to=4.0, resolution=0.1,
                orient='horizontal', variable=var,
                value=app.opt.scale_x,
                command=self._updateScale)
            self.scale_x.grid(
                row=1, column=0, sticky='ew', padx=padx, pady=pady)
            #
            var = tkinter.DoubleVar()
            var.set(app.opt.scale_y)
            self.scale_y = PysolScale(
                left_frame, label=_('Scale Y:'),
                from_=0.5, to=4.0, resolution=0.1,
                orient='horizontal', variable=var,
                value=app.opt.scale_y,
                command=self._updateScale)
            self.scale_y.grid(
                row=2, column=0, sticky='ew', padx=padx, pady=pady)
            #
            self.auto_scale = tkinter.BooleanVar()
            self.auto_scale.set(app.opt.auto_scale)
            check = ttk.Checkbutton(
                left_frame, text=_('Auto scaling'),
                variable=self.auto_scale,
                takefocus=False,
                command=self._updateAutoScale
                )
            check.grid(row=3, column=0, columnspan=2, sticky='ew',
                       padx=padx, pady=pady)
            #
            self.preserve_aspect = tkinter.BooleanVar()
            self.preserve_aspect.set(app.opt.preserve_aspect_ratio)
            self.aspect_check = ttk.Checkbutton(
                left_frame, text=_('Preserve aspect ratio'),
                variable=self.preserve_aspect,
                takefocus=False,
                # command=self._updateScale
                )
            self.aspect_check.grid(row=4, column=0, sticky='ew',
                                   padx=padx, pady=pady)
            self._updateAutoScale()
        #
        left_frame.rowconfigure(0, weight=1)
        left_frame.columnconfigure(0, weight=1)
        #
        self.preview = MfxScrolledCanvas(right_frame, width=w2)
        self.preview.setTile(app, app.tabletile_index, force=True)
        self.preview.pack(fill='both', expand=True, padx=padx, pady=pady)
        self.preview.canvas.preview = 1
        # create a preview of the current state
        self.preview_key = -1
        self.preview_images = []
        self.scale_images = []
        self.updatePreview(key)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def destroy(self):
        self.tree.updateNodesWithTree(self.tree.rootnodes, None)
        self.tree.destroy()
        self.preview.unbind_all()
        self.preview_images = []
        MfxDialog.destroy(self)

    def initKw(self, kw):
        if USE_PIL:
            s = (_("&Info / Settings..."), 10)
        else:
            s = (_("&Info..."), 10)
        kw = KwStruct(kw,
                      strings=(s, 'sep',
                               _("&OK"), _("&Cancel"),),
                      default=0,
                      resizable=True,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if button in (0, 1):            # Load/Cancel
            self.key = self.tree.selection_key
            self.tree.n_expansions = 1  # save xyview in any case
            if USE_PIL:
                auto_scale = bool(self.auto_scale.get())
                if button == 1:
                    self.app.menubar.tkopt.auto_scale.set(auto_scale)
                if auto_scale:
                    self.scale_values = (self.app.opt.scale_x,
                                         self.app.opt.scale_y,
                                         auto_scale,
                                         bool(self.preserve_aspect.get()))
                else:
                    self.scale_values = (self.scale_x.get(),
                                         self.scale_y.get(),
                                         auto_scale,
                                         self.app.opt.preserve_aspect_ratio)
        if button == 10:                # Info
            cs = self.manager.get(self.tree.selection_key)
            if not cs:
                return
            # title = CARDSET+" "+cs.name
            title = CARDSET.capitalize()+" "+cs.name
            d = CardsetInfoDialog(self.top, title=title, cardset=cs,
                                  images=self.preview_images)
            self.cardset_values = d.cardset_values
            return
        MfxDialog.mDone(self, button)

    def _updateAutoScale(self, v=None):
        if self.auto_scale.get():
            self.aspect_check.config(state='normal')
            self.scale_x.state('disabled')
            self.scale_y.state('disabled')
        else:
            self.aspect_check.config(state='disabled')
            self.scale_x.state('!disabled')
            self.scale_y.state('!disabled')

    def _updateScale(self, v):
        self.updatePreview()

    def updatePreview(self, key=None):
        if key == self.preview_key:
            return
        if key is None:
            key = self.key
        canvas = self.preview.canvas
        canvas.deleteAllItems()
        self.preview_images = []
        cs = self.manager.get(key)
        if not cs:
            self.preview_key = -1
            return
        names, columns = cs.getPreviewCardNames()
        try:
            # ???names, columns = cs.getPreviewCardNames()
            for n in names:
                f = os.path.join(cs.dir, n + cs.ext)
                self.preview_images.append(loadImage(file=f))
        except Exception:
            self.preview_key = -1
            self.preview_images = []
            return
        i, x, y, sx, sy, dx, dy = 0, 10, 10, 0, 0, cs.CARDW + 10, cs.CARDH + 10
        if USE_PIL:
            xf = self.scale_x.get()
            yf = self.scale_y.get()
            dx = int(dx*xf)
            dy = int(dy*yf)
            self.scale_images = []
        for image in self.preview_images:
            if USE_PIL:
                image = image.resize(xf, yf)
                self.scale_images.append(image)
            MfxCanvasImage(canvas, x, y, anchor="nw", image=image)
            sx, sy = max(x, sx), max(y, sy)
            i = i + 1
            if i % columns == 0:
                x, y = 10, y + dy
            else:
                x = x + dx
        canvas.config(scrollregion=(0, 0, sx+dx, sy+dy),
                      width=sx+dx, height=sy+dy)
        # canvas.config(xscrollincrement=dx, yscrollincrement=dy)
        canvas.event_generate('<Configure>')  # update bg image
        self.preview_key = key
        self.key = key


class SelectCardsetByTypeDialogWithPreview(SelectCardsetDialogWithPreview):
    Tree_Class = SelectCardsetByTypeTree
    TreeDataHolder_Class = SelectCardsetByTypeTree
    TreeData_Class = SelectCardsetByTypeData

# ************************************************************************
# * Cardset Info
# ************************************************************************


class CardsetInfoDialog(MfxDialog):
    def __init__(self, parent, title, cardset, images, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        frame = ttk.Frame(top_frame)
        frame.pack(fill="both", expand=True, padx=5, pady=10)
        #
        #
        row = 0
        info_frame = ttk.LabelFrame(frame, text=_('About cardset'))
        info_frame.grid(row=row, column=0, columnspan=2, sticky='ew',
                        padx=0, pady=5, ipadx=5, ipady=5)
        row += 1
        styles = nationalities = year = None
        if cardset.si.styles:
            styles = '\n'.join([CSI.STYLE[i] for i in cardset.si.styles])
        if cardset.si.nationalities:
            nationalities = '\n'.join([CSI.NATIONALITY[i]
                                       for i in cardset.si.nationalities])
        if cardset.year:
            year = str(cardset.year)
        frow = 0
        for n, t in (
            # ('Version:', str(cardset.version)),
            (_('Type:'),          CSI.TYPE[cardset.type]),
            (_('Styles:'),        styles),
            (_('Nationality:'),   nationalities),
            (_('Year:'),          year),
            # (_('Number of cards:'), str(cardset.ncards)),
            (_('Size:'), '%d x %d' % (cardset.CARDW, cardset.CARDH)),
                ):
            if t is not None:
                label = ttk.Label(info_frame, text=n,
                                  anchor='w', justify='left')
                label.grid(row=frow, column=0, sticky='nw', padx=4)
                label = ttk.Label(info_frame, text=t,
                                  anchor='w', justify='left')
                label.grid(row=frow, column=1, sticky='nw', padx=4)
                frow += 1
        if images:
            try:
                from random import choice
                im = choice(images)
                f = os.path.join(cardset.dir, cardset.backname)
                self.back_image = loadImage(file=f)  # store the image
                label = ttk.Label(info_frame, image=im, padding=5)
                label.grid(row=0, column=2, rowspan=frow+1, sticky='ne')
                label = ttk.Label(info_frame, image=self.back_image,
                                  padding=(0, 5, 5, 5))  # left margin = 0
                label.grid(row=0, column=3, rowspan=frow+1, sticky='ne')

                info_frame.columnconfigure(2, weight=1)
                info_frame.rowconfigure(frow, weight=1)
            except Exception:
                pass
        if USE_PIL:
            padx = 4
            pady = 0
            settings_frame = ttk.LabelFrame(frame, text=_('Settings'))
            settings_frame.grid(row=row, column=0, columnspan=2, sticky='ew',
                                padx=0, pady=5, ipadx=5, ipady=5)
            row += 1
            var = tkinter.IntVar()
            self.x_offset = PysolScale(
                settings_frame, label=_('X offset:'),
                from_=5, to=40, resolution=1,
                orient='horizontal', variable=var,
                value=cardset.CARD_XOFFSET,
                # command=self._updateScale
                )
            self.x_offset.grid(row=0, column=0, sticky='ew',
                               padx=padx, pady=pady)
            var = tkinter.IntVar()
            self.y_offset = PysolScale(
                settings_frame, label=_('Y offset:'),
                from_=5, to=40, resolution=1,
                orient='horizontal', variable=var,
                value=cardset.CARD_YOFFSET,
                # command=self._updateScale
                )
            self.y_offset.grid(row=1, column=0, sticky='ew',
                               padx=padx, pady=pady)
            row += 1

        # bg = top_frame["bg"]
        bg = 'white'
        text_w = tkinter.Text(frame, bd=1, relief="sunken", wrap="word",
                              padx=4, width=64, height=16, bg=bg)
        text_w.grid(row=row, column=0, sticky='nsew')
        sb = ttk.Scrollbar(frame)
        sb.grid(row=row, column=1, sticky='ns')
        text_w.configure(yscrollcommand=sb.set)
        sb.configure(command=text_w.yview)
        frame.columnconfigure(0, weight=1)
        frame.rowconfigure(1, weight=1)
        #
        text = ''
        f = os.path.join(cardset.dir, "COPYRIGHT")
        try:
            text = open(f).read()
        except Exception:
            pass
        if text:
            text_w.config(state="normal")
            text_w.insert("insert", text)
        text_w.config(state="disabled")
        #
        focus = self.createButtons(bottom_frame, kw)
        # focus = text_w
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        if USE_PIL:
            strings = (_("&Save"), _("&Cancel"))
        else:
            strings = (_("&OK"),)
        kw = KwStruct(kw,
                      strings=strings,
                      default=0,
                      resizable=True,
                      separator=True,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if USE_PIL and button == 0:
            self.cardset_values = self.x_offset.get(), self.y_offset.get()
        else:
            self.cardset_values = None
        MfxDialog.mDone(self, button)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.gamedb import GI
from pysollib.mfxutil import KwStruct, Struct, destruct
from pysollib.mfxutil import format_time
from pysollib.mygettext import _
from pysollib.resource import CSI
from pysollib.ui.tktile.selecttree import SelectDialogTreeData
from pysollib.ui.tktile.tkutil import unbind_destroy

from six.moves import UserList
from six.moves import tkinter_ttk as ttk

from .selecttree import SelectDialogTreeCanvas
from .selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from .tkwidget import MfxDialog, MfxScrolledCanvas

# ************************************************************************
# * Nodes
# ************************************************************************


class SelectGameLeaf(SelectDialogTreeLeaf):
    pass


class SelectGameNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        if isinstance(self.select_func, UserList):
            # key/value pairs
            for id, name in self.select_func:
                if id and name:
                    node = SelectGameLeaf(self.tree, self, name, key=id)
                    contents.append(node)
        else:
            for gi in self.tree.data.all_games_gi:
                if gi and self.select_func is None:
                    # All games
                    # name = '%s (%s)' % (gi.name, CSI.TYPE_NAME[gi.category])
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
                elif gi and self.select_func(gi):
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
        return contents or self.tree.data.no_games


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectGameData(SelectDialogTreeData):
    def __init__(self, app):
        SelectDialogTreeData.__init__(self)
        self.all_games_gi = list(map(
            app.gdb.get,
            app.gdb.getGamesIdSortedByName()))
        self.no_games = [SelectGameLeaf(None, None, _("(no games)"), None), ]
        #
        s_by_type = s_oriental = s_special = s_original = s_contrib = \
            s_mahjongg = None
        g = []
        for data in (GI.SELECT_GAME_BY_TYPE,
                     GI.SELECT_ORIENTAL_GAME_BY_TYPE,
                     GI.SELECT_SPECIAL_GAME_BY_TYPE,
                     GI.SELECT_ORIGINAL_GAME_BY_TYPE,
                     GI.SELECT_CONTRIB_GAME_BY_TYPE,
                     ):
            gg = []
            for name, select_func in data:
                if name is None or not list(filter(
                        select_func, self.all_games_gi)):
                    continue
                gg.append(SelectGameNode(None, _(name), select_func))
            g.append(gg)

        def select_mahjongg_game(gi):
            return gi.si.game_type == GI.GT_MAHJONGG

        gg = None
        if list(filter(select_mahjongg_game, self.all_games_gi)):
            gg = SelectGameNode(None, _("Mahjongg Games"),
                                select_mahjongg_game)
        g.append(gg)
        if g[0]:
            s_by_type = SelectGameNode(None, _("French games"),
                                       tuple(g[0]), expanded=1)
        if g[1]:
            s_oriental = SelectGameNode(None, _("Oriental Games"),
                                        tuple(g[1]))
        if g[2]:
            s_special = SelectGameNode(None, _("Special Games"),
                                       tuple(g[2]))
        if g[3]:
            s_original = SelectGameNode(None, _("Original Games"),
                                        tuple(g[3]))
        # if g[4]:
        #   s_contrib = SelectGameNode(None, "Contributed Games", tuple(g[4]))
        if g[5]:
            s_mahjongg = g[5]
        #
        s_by_compatibility, gg = None, []
        for name, games in GI.GAMES_BY_COMPATIBILITY:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_compatibility = SelectGameNode(None, _("by Compatibility"),
                                                tuple(gg))
        #
        s_by_pysol_version, gg = None, []
        for name, games in GI.GAMES_BY_PYSOL_VERSION:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            name = _("New games in v. %(version)s") % {'version': name}
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_pysol_version = SelectGameNode(None, _("by PySol version"),
                                                tuple(gg))
        s_by_inventors, gg = None, []
        for name, games in GI.GAMES_BY_INVENTORS:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_inventors = SelectGameNode(None, _("by Inventors"),
                                            tuple(gg))
        #
        ul_alternate_names = UserList(
            list(app.gdb.getGamesTuplesSortedByAlternateName()))
        #
        self.rootnodes = [_f for _f in (
            SelectGameNode(None, _("All Games"), None, expanded=0),
            SelectGameNode(None, _("Alternate Names"), ul_alternate_names),
            SelectGameNode(None, _("Popular Games"),
                           lambda gi: gi.si.game_flags & GI.GT_POPULAR),
            s_by_type,
            s_mahjongg,
            s_oriental,
            s_special,
            SelectGameNode(None, _("Custom Games"),
                           lambda gi: gi.si.game_type == GI.GT_CUSTOM),
            SelectGameNode(None, _('by Skill Level'), (
                SelectGameNode(None, _('Luck only'),
                               lambda gi: gi.skill_level == GI.SL_LUCK),
                SelectGameNode(None, _('Mostly luck'),
                               lambda gi: gi.skill_level == GI.SL_MOSTLY_LUCK),
                SelectGameNode(None, _('Balanced'),
                               lambda gi: gi.skill_level == GI.SL_BALANCED),
                SelectGameNode(
                    None, _('Mostly skill'),
                    lambda gi: gi.skill_level == GI.SL_MOSTLY_SKILL),
                SelectGameNode(None, _('Skill only'),
                               lambda gi: gi.skill_level == GI.SL_SKILL),
                )),
            SelectGameNode(None, _("by Game Feature"), (
                SelectGameNode(None, _("by Number of Cards"), (
                    SelectGameNode(None, _("32 cards"),
                                   lambda gi: gi.si.ncards == 32),
                    SelectGameNode(None, _("48 cards"),
                                   lambda gi: gi.si.ncards == 48),
                    SelectGameNode(None, _("52 cards"),
                                   lambda gi: gi.si.ncards == 52),
                    SelectGameNode(None, _("64 cards"),
                                   lambda gi: gi.si.ncards == 64),
                    SelectGameNode(None, _("78 cards"),
                                   lambda gi: gi.si.ncards == 78),
                    SelectGameNode(None, _("104 cards"),
                                   lambda gi: gi.si.ncards == 104),
                    SelectGameNode(None, _("144 cards"),
                                   lambda gi: gi.si.ncards == 144),
                    SelectGameNode(
                        None, _("Other number"),
                        lambda gi: gi.si.ncards not in (32, 48, 52,
                                                        64, 78, 104, 144)),
                )),
                SelectGameNode(None, _("by Number of Decks"), (
                    SelectGameNode(None, _("1 deck games"),
                                   lambda gi: gi.si.decks == 1),
                    SelectGameNode(None, _("2 deck games"),
                                   lambda gi: gi.si.decks == 2),
                    SelectGameNode(None, _("3 deck games"),
                                   lambda gi: gi.si.decks == 3),
                    SelectGameNode(None, _("4 deck games"),
                                   lambda gi: gi.si.decks == 4),
                )),
                SelectGameNode(None, _("by Number of Redeals"), (
                    SelectGameNode(None, _("No redeal"),
                                   lambda gi: gi.si.redeals == 0),
                    SelectGameNode(None, _("1 redeal"),
                                   lambda gi: gi.si.redeals == 1),
                    SelectGameNode(None, _("2 redeals"),
                                   lambda gi: gi.si.redeals == 2),
                    SelectGameNode(None, _("3 redeals"),
                                   lambda gi: gi.si.redeals == 3),
                    SelectGameNode(None, _("Unlimited redeals"),
                                   lambda gi: gi.si.redeals == -1),
                    SelectGameNode(
                        None, _("Other number of redeals"),
                        lambda gi: gi.si.redeals not in (-1, 0, 1, 2, 3)),
                )),
                s_by_compatibility,
            )),
            s_by_pysol_version,
            s_by_inventors,
            SelectGameNode(None, _("Other Categories"), (
                SelectGameNode(None, _("Games for Children (very easy)"),
                               lambda gi: gi.si.game_flags & GI.GT_CHILDREN),
                SelectGameNode(None, _("Games with Scoring"),
                               lambda gi: gi.si.game_flags & GI.GT_SCORE),
                SelectGameNode(
                    None, _("Games with Separate Decks"),
                    lambda gi: gi.si.game_flags & GI.GT_SEPARATE_DECKS),
                SelectGameNode(None, _("Open Games (all cards visible)"),
                               lambda gi: gi.si.game_flags & GI.GT_OPEN),
                SelectGameNode(None, _("Relaxed Variants"),
                               lambda gi: gi.si.game_flags & GI.GT_RELAXED),
            )),
            s_original,
            s_contrib,
        ) if _f]


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************

class SelectGameTreeWithPreview(SelectDialogTreeCanvas):
    data = None


class SelectGameTree(SelectGameTreeWithPreview):
    def singleClick(self, event=None):
        self.doubleClick(event)


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectGameDialog(MfxDialog):
    Tree_Class = SelectGameTree
    TreeDataHolder_Class = SelectGameTreeWithPreview
    TreeData_Class = SelectGameData

    def __init__(self, parent, title, app, gameid, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.app = app
        self.gameid = gameid
        self.random = None
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(app)
        #
        self.top.wm_minsize(200, 200)
        font = app.getFont("default")
        self.tree = self.Tree_Class(self, top_frame, key=gameid,
                                    font=font, default=kw.default)
        self.tree.frame.pack(fill='both', expand=True,
                             padx=kw.padx, pady=kw.pady)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(None, None, _("&Cancel"),), default=0,
                      resizable=True,
                      separator=True,
                      )
        return MfxDialog.initKw(self, kw)

    def destroy(self):
        self.app = None
        self.tree.updateNodesWithTree(self.tree.rootnodes, None)
        self.tree.destroy()
        MfxDialog.destroy(self)

    def mDone(self, button):
        if button == 0:                 # Ok or double click
            self.gameid = self.tree.selection_key
            self.tree.n_expansions = 1  # save xyview in any case
        if button == 10:                # Rules
            doc = self.app.getGameRulesFilename(self.tree.selection_key)
            if not doc:
                return
            dir = os.path.join("html", "rules")
            from pysollib.help import help_html
            help_html(self.app, doc, dir, self.top)
            self.top.grab_release()  # Don't want the help window appear frozen
            return
        MfxDialog.mDone(self, button)


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectGameDialogWithPreview(SelectGameDialog):
    Tree_Class = SelectGameTreeWithPreview

    def __init__(self, parent, title, app, gameid, bookmark=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.app = app
        self.gameid = gameid
        self.bookmark = bookmark
        self.random = None
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(app)
        #
        self.top.wm_minsize(400, 200)
        sw = self.top.winfo_screenwidth()
        if sw >= 1100:
            w1, w2 = 250, 600
        elif sw >= 900:
            w1, w2 = 250, 500
        elif sw >= 800:
            w1, w2 = 220, 480
        else:
            w1, w2 = 200, 300
        # print sw, w1, w2
        w2 = max(200, min(w2, 10 + 12*(app.subsampled_images.CARDW+10)))
        # print sw, w1, w2
        # padx, pady = kw.padx, kw.pady
        # padx, pady = kw.padx/2, kw.pady/2
        padx, pady = 4, 4
        # PanedWindow
        paned_window = ttk.PanedWindow(top_frame, orient='horizontal')
        paned_window.pack(expand=True, fill='both', padx=8, pady=8)
        left_frame = ttk.Frame(paned_window)
        right_frame = ttk.Frame(paned_window)
        paned_window.add(left_frame)
        paned_window.add(right_frame)
        # Tree
        font = app.getFont("default")
        self.tree = self.Tree_Class(self, left_frame, key=gameid,
                                    default=kw.default, font=font, width=w1)
        self.tree.frame.pack(padx=padx, pady=pady, expand=True, fill='both')
        # LabelFrame
        info_frame = ttk.LabelFrame(right_frame, text=_('About game'))
        info_frame.grid(row=0, column=0, padx=padx, pady=pady,
                        ipadx=4, ipady=4, sticky='nws')
        stats_frame = ttk.LabelFrame(right_frame, text=_('Statistics'))
        stats_frame.grid(row=0, column=1, padx=padx, pady=pady,
                         ipadx=4, ipady=4, sticky='nws')
        # Info
        self.info_labels = {}
        for n, t, f, row in (
            ('name',        _('Name:'),             info_frame,   0),
            ('altnames',    _('Alternate names:'),  info_frame,   1),
            ('category',    _('Category:'),         info_frame,   2),
            ('type',        _('Type:'),             info_frame,   3),
            ('skill_level', _('Skill level:'),      info_frame,   4),
            ('decks',       _('Decks:'),            info_frame,   5),
            ('redeals',     _('Redeals:'),          info_frame,   6),
            #
            ('played',      _('Played:'),           stats_frame,  0),
            ('won',         _('Won:'),              stats_frame,  1),
            ('lost',        _('Lost:'),             stats_frame,  2),
            ('time',        _('Playing time:'),     stats_frame,  3),
            ('moves',       _('Moves:'),            stats_frame,  4),
            ('percent',     _('% won:'),            stats_frame,  5),
                ):
            title_label = ttk.Label(f, text=t, justify='left', anchor='w')
            title_label.grid(row=row, column=0, sticky='nw', padx=4)
            text_label = ttk.Label(f, justify='left', anchor='w')
            text_label.grid(row=row, column=1, sticky='nw', padx=4)
            self.info_labels[n] = (title_label, text_label)
        # info_frame.columnconfigure(1, weight=1)
        info_frame.rowconfigure(6, weight=1)
        stats_frame.rowconfigure(6, weight=1)
        # Canvas
        self.preview = MfxScrolledCanvas(right_frame, width=w2)
        self.preview.setTile(app, app.tabletile_index, force=True)
        self.preview.grid(row=1, column=0, columnspan=3,
                          padx=padx, pady=pady, sticky='nsew')
        right_frame.columnconfigure(1, weight=1)
        right_frame.rowconfigure(1, weight=1)
        #
        focus = self.createButtons(bottom_frame, kw)
        # set the scale factor
        self.preview.canvas.preview = 2
        # create a preview of the current game
        self.preview_key = -1
        self.preview_game = None
        self.preview_app = None
        self.updatePreview(gameid, animations=0)
        # focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=((_("&Rules"), 10), 'sep',
                               _("&Select"), _("&Cancel"),),
                      default=0,
                      )
        return SelectGameDialog.initKw(self, kw)

    def destroy(self):
        self.deletePreview(destroy=1)
        self.preview.unbind_all()
        SelectGameDialog.destroy(self)

    def deletePreview(self, destroy=0):
        self.preview_key = -1
        # clean up the canvas
        if self.preview:
            unbind_destroy(self.preview.canvas)
            self.preview.canvas.deleteAllItems()
            if destroy:
                self.preview.canvas.delete("all")
        #
        # for l in self.info_labels.values():
        #    l.config(text='')
        # destruct the game
        if self.preview_game:
            self.preview_game.endGame()
            self.preview_game.destruct()
            destruct(self.preview_game)
        self.preview_game = None
        # destruct the app
        if destroy:
            if self.preview_app:
                destruct(self.preview_app)
            self.preview_app = None

    def updatePreview(self, gameid, animations=10):
        if gameid == self.preview_key:
            return
        self.deletePreview()
        canvas = self.preview.canvas
        #
        gi = self.app.gdb.get(gameid)
        if not gi:
            self.preview_key = -1
            return
        #
        if self.preview_app is None:
            self.preview_app = Struct(
                # variables
                audio=self.app.audio,
                canvas=canvas,
                cardset=self.app.cardset.copy(),
                gamerandom=self.app.gamerandom,
                gdb=self.app.gdb,
                gimages=self.app.gimages,
                images=self.app.subsampled_images,
                menubar=None,
                miscrandom=self.app.miscrandom,
                opt=self.app.opt.copy(),
                startup_opt=self.app.startup_opt,
                stats=self.app.stats.new(),
                top=None,
                top_cursor=self.app.top_cursor,
                toolbar=None,
                # methods
                constructGame=self.app.constructGame,
                getFont=self.app.getFont,
            )
            self.preview_app.opt.shadow = 0
            self.preview_app.opt.shade = 0
        #
        self.preview_app.audio = None    # turn off audio for initial dealing
        if animations >= 0:
            self.preview_app.opt.animations = animations
        #
        if self.preview_game:
            self.preview_game.endGame()
            self.preview_game.destruct()
        # self.top.wm_title("Select Game - " +
        #   self.app.getGameTitleName(gameid))
        title = self.app.getGameTitleName(gameid)
        self.top.wm_title(_("Playable Preview - %(game)s") % {'game': title})
        #
        self.preview_game = gi.gameclass(gi)
        self.preview_game.createPreview(self.preview_app)
        #
        random = None
        if gameid == self.gameid:
            random = self.app.game.random.copy()
        if gameid == self.gameid and self.bookmark:
            self.preview_game.restoreGameFromBookmark(self.bookmark)
        else:
            self.preview_game.newGame(random=random, autoplay=1)
        gw, gh = self.preview_game.width, self.preview_game.height
        canvas.config(scrollregion=(0, 0, gw, gh))
        canvas.xview_moveto(0)
        canvas.yview_moveto(0)
        #
        self.preview_app.audio = self.app.audio
        if self.app.opt.animations:
            self.preview_app.opt.animations = 10
        else:
            self.preview_app.opt.animations = 0
        # save seed
        self.random = self.preview_game.random.copy()
        self.random.origin = self.random.ORIGIN_PREVIEW
        self.preview_key = gameid
        #
        self.updateInfo(gameid)
        #
        rules_button = self.buttons[0]
        if self.app.getGameRulesFilename(gameid):
            rules_button.config(state="normal")
        else:
            rules_button.config(state="disabled")

    def updateInfo(self, gameid):
        gi = self.app.gdb.get(gameid)
        # info
        name = gi.name
        altnames = '\n'.join(gi.altnames)
        category = _(CSI.TYPE[gi.category])
        type = ''
        if gi.si.game_type in GI.TYPE_NAMES:
            type = _(GI.TYPE_NAMES[gi.si.game_type])
        sl = {
            GI.SL_LUCK:         _('Luck only'),
            GI.SL_MOSTLY_LUCK:  _('Mostly luck'),
            GI.SL_BALANCED:     _('Balanced'),
            GI.SL_MOSTLY_SKILL: _('Mostly skill'),
            GI.SL_SKILL:        _('Skill only'),
            }
        skill_level = sl.get(gi.skill_level)
        if gi.redeals == -2:
            redeals = _('variable')
        elif gi.redeals == -1:
            redeals = _('unlimited')
        else:
            redeals = str(gi.redeals)
        # stats
        won, lost, time, moves = self.app.stats.getFullStats(
            self.app.opt.player, gameid)
        if won+lost > 0:
            percent = "%.1f" % (100.0*won/(won+lost))
        else:
            percent = "0.0"
        time = format_time(time)
        moves = str(round(moves, 1))
        for n, t in (
            ('name',        name),
            ('altnames',    altnames),
            ('category',    category),
            ('type',        type),
            ('skill_level', skill_level),
            ('decks',       gi.decks),
            ('redeals',     redeals),
            ('played',      won+lost),
            ('won',         won),
            ('lost',        lost),
            ('time',        time),
            ('moves',       moves),
            ('percent',     percent),
                ):
            title_label, text_label = self.info_labels[n]
            if t in ('', None):
                title_label.grid_remove()
                text_label.grid_remove()
            else:
                title_label.grid()
                text_label.grid()
            text_label.config(text=t)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
"""
A number of function that enhance PySol on MacOSX when it used as a normal
GUI application (as opposed to an X11 application).
"""
import sys

from six.moves.tkinter import TclError


def runningAsOSXApp():
    """ Returns True if-and-only-if running from the
    PySol.app bundle on OSX """
    return (sys.platform == 'darwin' and 'PySol.app' in sys.argv[0])


def hideTkConsole(root):
    try:
        root.tk.call('console', 'hide')
    except TclError:
        pass


def setupApp(app):
    """
    Perform setup for the OSX application bundle.
    """
    if not runningAsOSXApp():
        return
    hideTkConsole(app.top)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os
import traceback

from pysollib.settings import TITLE
from pysollib.settings import TOOLKIT, USE_TILE
from pysollib.winsystems.common import \
        BaseTkSettings, \
        base_init_root_window, \
        get_font_name

if TOOLKIT == 'tk':
    if USE_TILE:
        from six.moves import tkinter_ttk as ttk


# ************************************************************************
# * Init root window
# ************************************************************************

def init_root_window(root, app):

    base_init_root_window(root, app)

    # root.self.wm_maxsize(9999, 9999) # unlimited
    if TOOLKIT == 'gtk':
        pass
    elif TOOLKIT == 'kivy':
        pass
    elif USE_TILE:
        f = os.path.join(app.dataloader.dir, 'tcl', 'menu8.4.tcl')
        if os.path.exists(f):
            try:
                root.tk.evalfile(f)
            except Exception:
                traceback.print_exc()
        f = 'clrpick8.5.tcl'
        f = os.path.join(app.dataloader.dir, 'tcl', f)
        if os.path.exists(f):
            try:
                root.tk.evalfile(f)
            except Exception:
                traceback.print_exc()
        f = 'fsdialog8.5.tcl'
        f = os.path.join(app.dataloader.dir, 'tcl', f)
        if os.path.exists(f):
            try:
                root.tk.evalfile(f)
            except Exception:
                traceback.print_exc()
            else:
                from six.moves import tkinter_tkfiledialog
                tkinter_tkfiledialog.Open.command = 'ttk::getOpenFile'
                tkinter_tkfiledialog.SaveAs.command = 'ttk::getSaveFile'
                tkinter_tkfiledialog.Directory.command = 'ttk::chooseDirectory'

        style = ttk.Style(root)
        color = style.lookup('.', 'background')
        if color:
            root.tk_setPalette(color)

        root.option_add('*Menu.borderWidth', 1, 60)
        root.option_add('*Menu.activeBorderWidth', 1, 60)
        color = style.lookup('.', 'background', ['active'])
        if color:
            root.option_add('*Menu.activeBackground', color, 60)

        root.option_add('*Listbox.background', 'white', 60)
        root.option_add('*Listbox.foreground', 'black', 60)
        root.option_add('*Text.background', 'white', 60)
        root.option_add('*Text.foreground', 'black', 60)
        root.option_add('*selectForeground', 'white', 60)
        root.option_add('*selectBackground', '#0a5f89', 60)
        root.option_add('*inactiveSelectBackground', '#0a5f89', 60)  # Tk-8.5

        color = style.lookup('TEntry', 'selectbackground', ['focus'])
        if color:
            root.option_add('*selectBackground', color, 60)
            root.option_add('*inactiveSelectBackground', color, 60)
        color = style.lookup('TEntry', 'selectforeground', ['focus'])
        if color:
            root.option_add('*selectForeground', color, 60)

        root.option_add('*selectBorderWidth', 0, 60)

        font = root.option_get('font', TITLE)
        if font:
            # use font from xrdb
            fn = get_font_name(font)
            if fn:
                # root.option_add('*font', font)
                style.configure('.', font=font)
                app.opt.fonts['default'] = fn
                # treeview heading
                f = root.tk.splitlist(root.tk.call('font', 'actual', fn))
                root.tk.call('font', 'configure', 'TkHeadingFont', *f)
        else:
            # use font from ttk settings
            font = style.lookup('.', 'font')
            if font:
                fn = get_font_name(font)
                if fn:
                    root.option_add('*font', font)
                    app.opt.fonts['default'] = fn
        if app.opt.tile_theme == 'clam':
            style.configure('TLabelframe', labeloutside=False,
                            labelmargins=(8, 0, 8, 0))

    #
    else:
        root.option_add('*Entry.background', 'white', 60)
        root.option_add('*Entry.foreground', 'black', 60)
        root.option_add('*Listbox.background', 'white', 60)
        root.option_add('*Listbox.foreground', 'black', 60)
        root.option_add('*Text.background', 'white', 60)
        root.option_add('*Text.foreground', 'black', 60)
        root.option_add('*selectForeground', 'white', 60)
        root.option_add('*selectBackground', '#0a5f89', 60)
        root.option_add('*inactiveSelectBackground', '#0a5f89', 60)  # Tk-8.5
        root.option_add('*selectBorderWidth', 0, 60)
        # root.option_add('*borderWidth', '1', 50)
        # root.option_add('*Button.borderWidth', '1', 50)
        root.option_add('*Scrollbar.elementBorderWidth', 1, 60)
        root.option_add('*Scrollbar.borderWidth', 1, 60)
        root.option_add('*Menu.borderWidth', 1, 60)
        root.option_add('*Menu.activeBorderWidth', 1, 60)
        # root.option_add('*Button.HighlightBackground', '#595d59')
        # root.option_add('*Button.HighlightThickness', '1')
        font = root.option_get('font', TITLE)
        if font:
            fn = get_font_name(font)
            app.opt.fonts['default'] = fn
        else:
            root.option_add('*font', 'helvetica 12', 60)
            app.opt.fonts['default'] = ('helvetica', 12,
                                        'roman', 'normal')


class TkSettings(BaseTkSettings):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.settings import TOOLKIT, USE_TILE
from pysollib.winsystems.common import BaseTkSettings, base_init_root_window

if USE_TILE:
    from six.moves import tkinter_ttk as ttk


def init_root_window(root, app):
    base_init_root_window(root, app)
    if TOOLKIT == 'gtk':
        pass
    elif USE_TILE:
        theme = app.opt.tile_theme
        style = ttk.Style(root)
        if theme not in ('winnative', 'xpnative'):
            color = style.lookup('.', 'background')
            if color:
                root.tk_setPalette(color)
            # root.option_add('*Menu.foreground', 'black')
            root.option_add('*Menu.activeBackground', '#08246b')
            root.option_add('*Menu.activeForeground', 'white')
        if theme == 'winnative':
            style.configure('Toolbutton', padding=2)
    else:
        # root.option_add(...)
        pass


class TkSettings(BaseTkSettings):
    canvas_padding = (1, 1)
    horizontal_toolbar_padding = (1, 0)
    toolbar_relief = 'groove'
    toolbar_borderwidth = 2
    if USE_TILE:
        toolbar_button_padding = (2, 0)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.macosx.appSupport import hideTkConsole
from pysollib.settings import TOOLKIT, USE_TILE
from pysollib.winsystems.common import BaseTkSettings, base_init_root_window


def init_root_window(root, app):
    base_init_root_window(root, app)
    if TOOLKIT == 'tk':
        hideTkConsole(root)
    if TOOLKIT == 'gtk':
        pass
    elif USE_TILE:
        pass
    else:                               # pure Tk
        # root.option_add(...)
        pass


class TkSettings(BaseTkSettings):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os
import traceback

from pysollib.mfxutil import print_err
from pysollib.mygettext import _
from pysollib.settings import DEBUG
from pysollib.settings import TITLE
from pysollib.settings import TOOLKIT, USE_TILE
from pysollib.settings import VERSION

if TOOLKIT == 'tk':
    from pysollib.ui.tktile.tkutil import loadImage
    if USE_TILE:
        from six.moves import tkinter_ttk as ttk


def init_tile(app, top):
    # load available themes
    d = os.path.join(app.dataloader.dir, 'themes')
    if os.path.isdir(d):
        top.tk.eval('global auto_path; lappend auto_path {%s}' % d)
        for t in os.listdir(d):
            if os.path.exists(os.path.join(d, t, 'pkgIndex.tcl')):
                try:
                    top.tk.eval('package require ttk::theme::'+t)
                    # print 'load theme:', t
                except Exception:
                    traceback.print_exc()
                    pass


def set_theme(app, top, theme):
    # set theme
    style = ttk.Style(top)
    try:
        style.theme_use(theme)
    except Exception:
        print_err(_('invalid theme name: ') + theme)
        style.theme_use(app.opt.default_tile_theme)


def get_font_name(font):
    # create font name
    # i.e. "helvetica 12" -> ("helvetica", 12, "roman", "normal")

    if (TOOLKIT == 'kivy'):
        return "helvetica 12"

    from six.moves.tkinter_font import Font
    font_name = None
    try:
        f = Font(font=font)
    except Exception:
        print_err(_('invalid font name: ') + font)
        if DEBUG:
            traceback.print_exc()
    else:
        fa = f.actual()
        font_name = (fa['family'],
                     fa['size'],
                     fa['slant'],
                     fa['weight'])
    return font_name


def base_init_root_window(root, app):
    # root.wm_group(root)
    root.wm_title(TITLE + ' ' + VERSION)
    root.wm_iconname(TITLE + ' ' + VERSION)

    if TOOLKIT == 'tk':
        icons = [loadImage(img) for img in app.dataloader.findAllIconSizes()]
        if icons:
            try:
                root.wm_iconphoto(True, *icons)
            except AttributeError:
                root.tk.call('wm', 'iconphoto', root, '-default', *icons)

    # set minsize
    sw, sh = (root.winfo_screenwidth(), root.winfo_screenheight())
    if sw < 640 or sh < 480:
        root.wm_minsize(400, 300)
    else:
        root.wm_minsize(520, 360)

    if TOOLKIT == 'gtk':
        pass
    if TOOLKIT == 'kivy':
        pass
    elif USE_TILE:
        theme = app.opt.tile_theme
        init_tile(app, root)
        set_theme(app, root, theme)
    else:
        pass


class BaseTkSettings:
    canvas_padding = (0, 0)
    horizontal_toolbar_padding = (0, 0)
    vertical_toolbar_padding = (0, 1)
    toolbar_button_padding = (2, 2)
    toolbar_label_padding = (4, 4)
    if USE_TILE:
        toolbar_relief = 'flat'
        toolbar_borderwidth = 0
    else:
        toolbar_relief = 'raised'
        toolbar_button_relief = 'flat'
        toolbar_separator_relief = 'sunken'
        toolbar_borderwidth = 1
        toolbar_button_borderwidth = 1
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.settings import WIN_SYSTEM

if WIN_SYSTEM == 'win32':
    from pysollib.winsystems import win32 as gui
elif WIN_SYSTEM == 'aqua':
    from pysollib.winsystems import aqua as gui
else:                                   # 'x11'
    from pysollib.winsystems import x11 as gui

init_root_window = gui.init_root_window
TkSettings = gui.TkSettings
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports

# PySol imports
# from pysollib.mfxutil import KwStruct
# from pysollib.settings import TITLE

# Toolkit imports
# from tkconst import EVENT_HANDLED
# from tkwidget import MfxDialog

# ************************************************************************
# *
# ************************************************************************

solver_dialog = None


def create_solver_dialog(parent, game):
    pass


def connect_game_solver_dialog(game):
    pass


def destroy_solver_dialog():
    global solver_dialog
    solver_dialog = None


def reset_solver_dialog():
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
import os
import sys

if __name__ == '__main__':
    d = os.path.abspath(os.path.join(sys.path[0], os.pardir, os.pardir))
    sys.path.append(d)
    import gettext
    gettext.install('pysol', d, unicode=True)

# PySol imports

# Toolkit imports
# from pysollib.settings import WIN_SYSTEM

# ************************************************************************
# *
# ************************************************************************
# statusbar not used.


class MfxStatusbar:
    def __init__(self, top, row, column, columnspan):
        pass

    def _createLabel(self, name, expand=False, width=0, tooltip=None):
        pass

    def show(self, on):
        pass

    def updateText(self, **kw):
        pass

    def config(self, a, b):
        pass


class PysolStatusbar(MfxStatusbar):
    def __init__(self, top):
        pass


class HelpStatusbar(MfxStatusbar):
    def __init__(self, top):
        MfxStatusbar.__init__(self, top, row=4, column=0, columnspan=3)
        # l = self._createLabel('info', expand=True)
        # l.config(justify='left', anchor='w', padx=8)


class HtmlStatusbar(MfxStatusbar):
    def __init__(self, top, row, column, columnspan):
        MfxStatusbar.__init__(self, top, row=row,
                              column=column, columnspan=columnspan)
        # l = self._createLabel('url', expand=True)
        # l.config(justify='left', anchor='w', padx=8)


# ************************************************************************
# *
# ************************************************************************
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# *
# ************************************************************************
# not implemented with kivy.


class PlayerOptionsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        pass

# ************************************************************************
# *
# ************************************************************************
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
# Copyright (C) 2016-2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
import os

# PySol imports
from pysollib.mygettext import _, n_
from pysollib.settings import TITLE
from pysollib.util import IMAGE_EXTENSIONS
from pysollib.winsystems import TkSettings

# ************************************************************************
# *
# ************************************************************************


class AbstractToolbarButton:
    def __init__(self, parent, toolbar, toolbar_name, position):
        self.toolbar = toolbar
        self.toolbar_name = toolbar_name
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        padx, pady = 2, 2
        if orient == 'horizontal':
            self.grid(row=0,
                      column=self.position,
                      ipadx=padx, ipady=pady,
                      sticky='nsew')
        else:
            self.grid(row=self.position,
                      column=0,
                      ipadx=padx, ipady=pady,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()

# ************************************************************************


if True:
    from pysollib.kivy.LApp import LImage
    from pysollib.kivy.LApp import LBase
    # from LApp import LMainWindow
    from kivy.uix.boxlayout import BoxLayout
    # from kivy.uix.button import Button
    from kivy.uix.behaviors import ButtonBehavior
    # from kivy.uix.behaviors import ToggleButtonBehavior
    from kivy.uix.image import Image as KivyImage

# ************************************************************************


class MyButton(ButtonBehavior, KivyImage, LBase):
    def __init__(self, **kwargs):
        super(MyButton, self).__init__(**kwargs)
        # super(MyButton, self).__init__()
        self.src = None
        if ('image' in kwargs):
            self.src = kwargs['image'].source
        self.command = None
        if ('command' in kwargs):
            self.command = kwargs['command']
        self.source = self.src
        self.allow_stretch = True

    def on_press(self):
        self.allow_stretch = False

    def on_release(self):
        self.allow_stretch = True
        if (self.command is not None):
            self.command()


class MyCheckButton(ButtonBehavior, KivyImage, LBase):
    def __init__(self, **kwargs):
        super(MyCheckButton, self).__init__(**kwargs)
        # super(MyCheckButton, self).__init__()
        self.src = None
        if ('image' in kwargs):
            self.src = kwargs['image'].source
        self.command = None
        if ('command' in kwargs):
            self.command = kwargs['command']
        self.variable = None
        if ('variable' in kwargs):
            self.variable = kwargs['variable']
        self.win = None
        if ('win' in kwargs):
            self.win = kwargs['win']
        self.source = self.src
        self.allow_stretch = True
        self.checked = False

        # self.variable = self.win.app.menubar.tkopt.pause
        if self.variable:
            self.variable.bind(value=self.updateState)

    def updateState(self, obj, val):
        if (val):
            self.allow_stretch = False
        else:
            self.allow_stretch = True

    def isChecked(self):
        return self.checked

    def on_press(self):
        if self.win is None:
            return
        if self.win.app is None:
            return
        if self.win.app.game is None:
            return

        game = self.win.app.game
        if game.finished:
            return
        if game.demo:
            return

        # if self.win.app.menubar == None: return
        # mb = self.win.app.menubar

        if game.pause:
            self.allow_stretch = True
            self.checked = False
            if (self.command is not None):
                self.command()
        else:
            self.allow_stretch = False
            self.checked = True
            if (self.command is not None):
                self.command()

    def on_release(self):
        pass

# ************************************************************************
# * Note: Applications should call show/hide after constructor.
# ************************************************************************


class PysolToolbarTk(BoxLayout):
    def __init__(
            self,
            top,
            menubar,
            dir,
            size=0,
            relief='flat',
            compound='none'):

        super(PysolToolbarTk, self).__init__(orientation='vertical')
        self.size_hint = (0.05, 1.0)
        # self.size_hint=(None, 1.0)
        # self.width = 50
        self.win = top
        self.menubar = menubar
        self.dir = dir
        self.win.setTool(self, 3)

        for label, f, t in (
            (n_("New"),      self.mNewGame,   _("New game")),
            (n_("Restart"),  self.mRestart,   _("Restart the\ncurrent game")),
            (None,           None,            None),
            # (n_("Open"),     self.mOpen,      _("Open a\nsaved game")),
            # (n_("Save"),     self.mSave,      _("Save game")),
            (None,           None,            None),
            (n_("Undo"),     self.mUndo,      _("Undo last move")),
            (n_("Redo"),     self.mRedo,      _("Redo last move")),
            (n_("Autodrop"), self.mDrop,      _("Auto drop cards")),
            (n_("Shuffle"),  self.mShuffle,   _("Shuffle tiles")),
            (n_("Pause"),    self.mPause,     _("Pause game")),
            (None,           None,            None),
            # (n_("Statistics"), self.mPlayerStats, _("View statistics")),
            (n_("Rules"),    self.mHelpRules, _("Rules for this game")),
            (None,           None,            None),
            (n_("Quit"),     self.mHoldAndQuit,      _("Quit %s") % TITLE),
        ):
            if label is None:
                # sep = self._createSeparator()
                # sep.bind("<1>", self.clickHandler)
                # sep.bind("<3>", self.rightclickHandler)
                pass
            elif label == 'Pause':
                self._createButton(label, f, check=True, tooltip=t)
            else:
                self._createButton(label, f, tooltip=t)

            # hier gibt es noch ein 'player label' mit contextmenu, wo
            # der spielername gewählt und die spielstatistik etc.
            # angezeigt werden könnte (TBD):
            '''
        sep = self._createFlatSeparator()
        sep.bind("<1>", self.clickHandler)
        sep.bind("<3>", self.rightclickHandler)
        self._createLabel("player", label=n_('Player'),
                          tooltip=_("Player options"))
        #
        self.player_label.bind("<1>", self.mOptPlayerOptions)
        # self.player_label.bind("<3>", self.mOptPlayerOptions)
        self.popup = MfxMenu(master=None, label=n_('Toolbar'), tearoff=0)
        createToolbarMenu(menubar, self.popup)
        self.frame.bind("<1>", self.clickHandler)
        self.frame.bind("<3>", self.rightclickHandler)
        #
        self.setCompound(compound, force=True)
            '''

    def show(self, on, **kw):
        side = self.menubar.tkopt.toolbar.get()
        self.win.setTool(None, side)
        return False

    def mHoldAndQuit(self, *args):
        if not self._busy():
            self.menubar.mHoldAndQuit()
        return 1

    def getSize(self):
        return 0

    def updateText(self, **kw):
        pass

    def config(self, w, v):
        print('PysolToolbarTk: config %s, %s' % (w, v))
        # y = self.yy
        pass

    # Lokale.

    def _loadImage(self, name):
        file = os.path.join(self.dir, name)
        image = None
        for ext in IMAGE_EXTENSIONS:
            file = os.path.join(self.dir, name + ext)
            if os.path.isfile(file):
                image = LImage(source=file)
                # print('_loadImage: file=%s' % file)
                # image = Tkinter.PhotoImage(file=file)
                break
        return image

    def _createButton(self, label, command, check=False, tooltip=None):
        name = label.lower()
        image = self._loadImage(name)
        # position = len(self._widgets)
        button_relief = TkSettings.toolbar_button_relief
        bd = TkSettings.toolbar_button_borderwidth
        padx, pady = TkSettings.toolbar_button_padding
        kw = {
            'toolbar': self,
            'toolbar_name': name,
            'command': command,
            'takefocus': 0,
            'text': _(label),
            'bd': bd,
            'relief': button_relief,
            'padx': padx,
            'pady': pady,
            'overrelief': 'raised',
        }
        # print ('toolbar:  print %s' % self.win)
        # print ('toolbar:  print %s' % self.win.app)
        kw['win'] = self.win
        if image:
            kw['image'] = image
        if check:
            kw['offrelief'] = button_relief
            kw['indicatoron'] = False
            kw['selectcolor'] = ''

            button = MyCheckButton(**kw)
        else:
            button = MyButton(**kw)

        # button.show(orient=self.orient)
        setattr(self, name + "_image", image)
        setattr(self, name + "_button", button)
        # self._widgets.append(button)
        self.add_widget(button)

        # TBD: tooltip ev. auf basis einer statuszeile implementieren
        # if tooltip:
        #   b = MfxTooltip(button)
        #   self._tooltips.append(b)
        #   b.setText(tooltip)
        return button

    def _busy(self):
        # if not self.side or not self.game or not self.menubar:
        #   return 1
        if not self.game or not self.menubar:
            return 1
        print('_busy:')
        self.game.stopDemo()
        self.game.interruptSleep()
        return self.game.busy
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
# import tkFont

# Toolkit imports
from pysollib.kivy.tktree import MfxTreeInCanvas, MfxTreeLeaf, MfxTreeNode

# ************************************************************************
# * Nodes
# ************************************************************************


class SelectDialogTreeLeaf(MfxTreeLeaf):
    def drawSymbol(self, x, y, **kw):
        pass
        '''
        if self.tree.nodes.get(self.symbol_id) is not self:
            self.symbol_id = self.tree.canvas.create_image(x, y,
               image=self.tree.data.img[2 + (self.key is None)], anchor="nw")
            self.tree.nodes[self.symbol_id] = self
        '''


class SelectDialogTreeNode(MfxTreeNode):
    def __init__(self, tree, text, select_func, expanded=0, parent_node=None):
        MfxTreeNode.__init__(self, tree, parent_node,
                             text, key=None, expanded=expanded)
        # callable or a tuple/list of MfxTreeNodes
        self.select_func = select_func

    def drawSymbol(self, x, y, **kw):
        pass
        '''
        if self.tree.nodes.get(self.symbol_id) is not self:
            self.symbol_id = self.tree.canvas.create_image(x, y,
                image=self.tree.data.img[self.expanded], anchor="nw")
            self.tree.nodes[self.symbol_id] = self
        '''
    def getContents(self):
        # cached values
        if self.subnodes is not None:
            return self.subnodes
        # print self.whoami()
        if isinstance(self.select_func, (tuple, list)):
            return self.select_func
        return self._getContents()

    def _getContents(self):
        # subclass
        return []


# ************************************************************************
# * Tree database
# ************************************************************************


class SelectDialogTreeData():
    img = []  # loaded in Application.loadImages3

    def __init__(self):
        self.tree_xview = (0.0, 1.0)
        self.tree_yview = (0.0, 1.0)


# ************************************************************************
# * Canvas that shows the tree (left side)
# ************************************************************************


class SelectDialogTreeCanvas(MfxTreeInCanvas):
    def __init__(self, dialog, parent, key, default,
                 font=None, width=-1, height=-1, hbar=2, vbar=3):
        pass
    # not needed with kivy


'''
'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.kivy.tkwidget import MfxDialog

# ************************************************************************
# *
# ************************************************************************


class TimeoutsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# *
# ************************************************************************


class ColorsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        # not used in kivy version.
        return


'''end of file'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#
# imports
# import os
# import time

# Kivy
# from LApp import *
from kivy.graphics import Color
from kivy.graphics import Line
from kivy.uix.label import Label
from kivy.uix.widget import Widget

# PySol imports
# Toolkit imports
# from pysollib.mfxutil import format_time
# from pysollib.mfxutil import kwdefault, KwStruct
# from pysollib.mygettext import _, n_
# from pysollib.pysoltk import MfxScrolledCanvas
# from pysollib.stats import PysolStatsFormatter, ProgressionFormatter
# from pysollib.util import *
# from tkutil import bind, unbind_destroy, loadImage
from pysollib.kivy.LApp import LImage
from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.pysoltk import MfxDialog, MfxMessageDialog
from pysollib.settings import TOP_TITLE

# FIXME - this file a quick hack and needs a rewrite

# Note almoust not used in the kivy implementation. Only a simple text
# is displayed, for single user Statisics. The code from tk implementation was
# kept as an examlple what could eventually be done once ....

# ************************************************************************
# *
# ************************************************************************


class LPieChart(Widget):
    def __init__(self, prnt, args, **kw):
        super(LPieChart, self).__init__(**kw)
        self.prnt = prnt

        # print('width   %s' % kw['width'])
        # print('outline %s' % kw['outline'])
        # print('fill    %s' % kw['fill'])

        # width = 10.0
        # if ('width' in kw):
        #     width = float(kw['width'])

        bcolor = '#ffa000a0'
        if ('outline') in kw:
            bcolor = kw['outline']
        if (not bcolor or len(bcolor) < 7):
            bcolor = '#ffa000a0'

        fcolor = '#00aaff20'
        if ('fill') in kw:
            fcolor = kw['fill']
        if (not fcolor or len(fcolor) < 7):
            fcolor = '#00aaff20'

        self.group = None
        if 'group' in kw:
            self.group = kw['group']

        self.center = (0.0, 0.0)
        if ('center') in kw:
            self.center = kw['center']

        self.radius = (0.0, 0.0)
        if ('radius') in kw:
            self.radius = kw['radius']

        self.fcolor = (0.9, 0.1, 0.3, 0.5)
        self.bind(size=self.updateCanvas)
        self.bind(pos=self.updateCanvas)

    def updateCanvas(self, instance, value):

        self.canvas.clear()
        with self.canvas:
            Color(self.fcolor[0], self.fcolor[1],
                  self.fcolor[2], self.fcolor[3])

            center = (self.pos[0] + self.size[0] / 2.0,
                      self.pos[1] + self.size[1] / 2.0)
            radius = (self.size[0] * 0.45)
            radius2 = (self.size[1] * 0.45)
            if (radius > radius2):
                radius = radius2

            # Rectangle(pos=pos, size=size)
            Line(circle=(center[0], center[1], radius), width=2.0, close=True)

            # kreis kann nicht gefüllt werden !!! - man sollte eine Funktion
            # haben die einen geschlossenen pfad füllt.
            # TBD.vertices/Mesh. versuchen, kreis annähern.

            # Color(self.bcolor[0], self.bcolor[1],
            #    self.bcolor[2], self.bcolor[3])
            # Line(points=poly, width=border)


# ************************************************************************
# *
# ************************************************************************

class SingleGame_StatsDialog(MfxDialog):
    def __init__(self, parent, title, app, player, gameid, **kw):
        kw['size_hint'] = (0.5, 1)
        self.app = app
        self.selected_game = None
        kw = self.initKw(kw)
        print('SingleGame_StatsDialog: p=%s, g=%s, kw=%s' %
              (player, gameid, kw))
        if isinstance(kw, KwStruct):
            print('kw=%s' % kw.getKw())

        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.top_frame = top_frame

#        self.createBitmaps(top_frame, kw)
        #
        self.player = player or _("Demo games")
        self.top.wm_minsize(200, 200)
        self.button = kw.default
        #
        # createChart = self.create3DBarChart
        # createChart = self.createPieChart
        # createChart = self.createSimpleChart
        #         if parent.winfo_screenwidth() < 800
        #            or parent.winfo_screenheight() < 600:
        #             createChart = self.createPieChart
        #             createChart = self.createSimpleChart
        #
        self.font = self.app.getFont("default")
#        self.tk_font = tkFont.Font(self.top, self.font)
#        self.font_metrics = self.tk_font.metrics()
        self._calc_tabs()

        if (kw.image):
            image = LImage(texture=kw.image.texture, size_hint=(1, 1))
            self.top.add_widget(image)

        #
        won, lost = app.stats.getStats(player, gameid)
        pwon, plost = self._getPwon(won, lost)

        print('Stats(p): won=%s, lost=%s' % (won, lost))

        text1 = _('Total:\n' +
                  '   won: %(won)s ... %(percentwon)s%%\n' +
                  '   lost: %(lost)s ... %(percentlost)s%%\n\n') % dict(
            won=won, percentwon=int(round(100.0 * pwon)),
            lost=lost, percentlost=int(round(100.0 * plost)))

#        createChart(app, won, lost, _("Total"))
        won, lost = app.stats.getSessionStats(player, gameid)
        pwon, plost = self._getPwon(won, lost)

        print('Stats(s): won=%s, lost=%s' % (won, lost))

        text2 = _('Current Session:\n' +
                  '   won: %(won)s ... %(percentwon)s%%\n' +
                  '   lost: %(lost)s ... %(percentlost)s%%\n') % dict(
            won=won, percentwon=(round(100.0 * pwon)),
            lost=lost, percentlost=int(round(100.0 * plost)))
        # text2 = 'Current Session:\n   won=%s, lost=%s\n' % (won, lost)

#        createChart(app, won, lost, _("Current session"))

        self.top.add_widget(Label(text=text1 + text2))

        # self.top.add_widget(Button(text='reset', size_hint=(1, 0.15)))
        #
#        focus = self.createButtons(bottom_frame, kw)
#        self.mainloop(focus, kw.timeout)

    #
    # helpers
    #

    def _calc_tabs(self):
        return

    def _getPwon(self, won, lost):
        pwon, plost = 0.0, 0.0
        if won + lost > 0:
            pwon = float(won) / float(won + lost)
            pwon = min(max(pwon, 0.00001), 0.99999)
            plost = 1.0 - float(pwon)
        return pwon, plost

    def _createChartTexts(self, tx, ty, won, lost):
        c, tfont, fg = self.canvas, self.font, self.fg
        pwon, plost = self._getPwon(won, lost)
        #
        x = tx[0]
        dy = int(self.font_metrics['ascent']) - 10
        dy = dy / 2
        c.create_text(x, ty[0] - dy, text=_("Won:"),
                      anchor="nw", font=tfont, fill=fg)
        c.create_text(x, ty[1] - dy, text=_("Lost:"),
                      anchor="nw", font=tfont, fill=fg)
        c.create_text(x, ty[2] - dy, text=_("Total:"),
                      anchor="nw", font=tfont, fill=fg)
        x = tx[1] - 16
        c.create_text(x, ty[0] - dy, text="%d" %
                      won, anchor="ne", font=tfont, fill=fg)
        c.create_text(x, ty[1] - dy, text="%d" %
                      lost, anchor="ne", font=tfont, fill=fg)
        c.create_text(x, ty[2] - dy, text="%d" %
                      (won + lost), anchor="ne", font=tfont, fill=fg)
        y = ty[2] - 11
        c.create_line(tx[0], y, x, y, fill=fg)
        if won + lost > 0:
            x = tx[2]
            pw = int(round(100.0 * pwon))
            c.create_text(x, ty[0] - dy, text="%d%%" %
                          pw, anchor="ne", font=tfont, fill=fg)
            c.create_text(x, ty[1] - dy, text="%d%%" %
                          (100 - pw), anchor="ne", font=tfont, fill=fg)

    #
    # charts
    #

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"),
                               (_("&All games..."), 102),
                               (TOP_TITLE + "...", 105),
                               (_("&Reset..."), 302)), default=0,
                      image=self.app.gimages.logos[5],
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)

# ************************************************************************
# *
# ************************************************************************


class AllGames_StatsDialog(MfxDialog):

    YVIEW = 0
    FONT_TYPE = "default"

    def __init__(self, parent, title, app, player, **kw):
        self.status = 0
        print('AllGames_StatsDialog')
        pass

# ************************************************************************
# *
# ************************************************************************


class FullLog_StatsDialog(AllGames_StatsDialog):
    pass


class SessionLog_StatsDialog(FullLog_StatsDialog):
    pass

# ************************************************************************
# *
# ************************************************************************


class Status_StatsDialog(MfxMessageDialog):
    def __init__(self, parent, game):
        self.status = 0
        pass

# ************************************************************************
# *
# ************************************************************************


class Top_StatsDialog(MfxDialog):
    def __init__(self, parent, title, app, player, gameid, **kw):
        pass

# ************************************************************************
# *
# ************************************************************************


class ProgressionDialog(MfxDialog):
    def __init__(self, parent, title, app, player, gameid, **kw):
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

import formatter
import os
import sys

from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label

import pysollib.htmllib2 as htmllib
from pysollib.kivy.LApp import LPopCommander
from pysollib.kivy.LApp import LScrollView
from pysollib.kivy.LApp import LTopLevel
from pysollib.kivy.LApp import get_platform
from pysollib.mfxutil import Struct, openURL
from pysollib.mygettext import _
from pysollib.pysoltk import MfxMessageDialog
from pysollib.settings import TITLE

REMOTE_PROTOCOLS = ("ftp:", "gopher:", "http:", "mailto:", "news:", "telnet:")

# ************************************************************************
# *
# ************************************************************************


if get_platform() == 'android':
    from jnius import autoclass
    from jnius import cast

    def startAndroidBrowser(www):
        # init java classes
        PythonActivity = autoclass('org.kivy.android.PythonActivity')
        Intent = autoclass('android.content.Intent')
        Uri = autoclass('android.net.Uri')
        # String = autoclass('java.lang.String') # get the Java object

        # prepare activity
        # PythonActivity.mActivity is the instance of the current Activity
        # BUT, startActivity is a method from the Activity class, not from our
        # PythonActivity.
        # We need to cast our class into an activity and use it
        currentActivity = cast(
            'android.app.Activity', PythonActivity.mActivity)

        # create the intent
        intent = Intent()
        intent.setAction(Intent.ACTION_VIEW)
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        intent.setDataAndType(Uri.parse(www), "application/xhtml+xml")

        # start activity
        currentActivity.startActivity(intent)

# ************************************************************************
# *
# ************************************************************************


def cmp2(a, b):
    """python 3 replacement for python 2 cmp function"""
    return (a > b) - (a < b)


class tkHTMLWriter(formatter.NullWriter):
    def __init__(self, text, viewer, app):
        formatter.NullWriter.__init__(self)

        self.text = text
        self.viewer = viewer

        #
        if app:
            font = app.getFont("sans")
            fixed = app.getFont("fixed")
        else:
            font = ('helvetica', 12)
            fixed = ('courier', 12)
        size = font[1]
        sign = 1
        if size < 0:
            sign = -1
        self.fontmap = {
            "h1": (font[0], size + 12 * sign, "bold"),
            "h2": (font[0], size + 8 * sign, "bold"),
            "h3": (font[0], size + 6 * sign, "bold"),
            "h4": (font[0], size + 4 * sign, "bold"),
            "h5": (font[0], size + 2 * sign, "bold"),
            "h6": (font[0], size + 1 * sign, "bold"),
            "bold": (font[0], size, "bold"),
            "italic": (font[0], size, "italic"),
            "pre": fixed,
        }

        self.text.config(cursor=self.viewer.defcursor, font=font)
        for f in self.fontmap.keys():
            self.text.tag_config(f, font=self.fontmap[f])

        self.anchor = None
        self.anchor_mark = None
        self.font = None
        self.font_mark = None
        self.indent = ""
        self.text.label.bind(on_ref_press=self.refpress)

    '''
    def createCallback(self, href):
        class Functor:
            def __init__(self, viewer, arg):
                self.viewer = viewer
                self.arg = arg

            def __call__(self, *args):
                self.viewer.updateHistoryXYView()
                return self.viewer.display(self.arg)
        return Functor(self.viewer, href)
    '''

    def write(self, data):
        # print('writer: write %s' % data)
        self.text.insert("insert", data)

    def anchor_bgn(self, href, name, type):
        # print('writer: anchor_bgn %s - %s' % (href, name))
        if href:
            # self.text.update_idletasks()   # update display during parsing
            self.anchor = (href, name, type)
            self.anchor_mark = self.text.index("insert")
            self.write('[ref=' + href + ']')

            url = self.anchor[0]
            fg = '0000cc'
            u = self.viewer.normurl(url, with_protocol=False)
            if u in self.viewer.visited_urls:
                fg = '660099'
            self.write('[color=' + fg + '][i]')
            # self.text.tag_config(tag, foreground=fg, underline=1)

    def refpress(self, instance, value):
        # print('writer: refpress %s, %s' % (instance, value))
        pass

    def anchor_end(self):
        # print('writer: anchor_end')
        if self.anchor:

            self.anchor = None
            self.write('[/i][/color]')
            self.write('[/ref]')

    def anchor_enter(self, url):
        url = self.viewer.normurl(url)
        self.viewer.statusbar.updateText(url=url)
        self.text.config(cursor=self.viewer.handcursor)

    def anchor_leave(self, *args):
        self.viewer.statusbar.updateText(url='')
        self.text.config(cursor=self.viewer.defcursor)

    def new_font(self, font):
        # print('writer: new_font %s' % str(font))
        # end the current font
        if self.font:
            # print "end_font(%s)" % `self.font`
            self.text.tag_add(self.font, self.font_mark, "insert")
            self.font = None
        # start the new font
        if font:
            # print "start_font(%s)" % `font`
            self.font_mark = self.text.index("insert")
            if font[0] in self.fontmap:
                self.font = font[0]
            elif font[3]:
                self.font = "pre"
            elif font[2]:
                self.font = "bold"
            elif font[1]:
                self.font = "italic"
            else:
                self.font = None

    def new_margin(self, margin, level):
        # print('writer: new_margin %s, %s' % (margin, level))
        self.indent = "    " * level

    def send_label_data(self, data):
        # print('writer: send_label_data %s' % (data))
        # self.write(self.indent + data + " ")
        self.write(self.indent)
        if data == '*':  # <li>
            img = self.viewer.symbols_img.get('disk')
            if img:
                self.text.image_create(index='insert', image=img,
                                       padx=0, pady=0)
            else:
                self.write('*')
        else:
            self.write(data)
        self.write(' ')

    def send_paragraph(self, blankline):
        # print('writer: send_paragraph %s' % (blankline))
        self.write('\n' * blankline)

    def send_line_break(self):
        # print('writer: send_break')
        self.write('\n')

    def send_hor_rule(self, *args):
        if (args):
            pass
            # print('writer: send_hor_rule %s' % (args))
        # width = int(int(self.text["width"]) * 0.9)
        width = 20
        self.write("_" * width)
        self.write("\n")

    def send_literal_data(self, data):
        # print('writer: send_literal_data %s' % (data))
        self.write(data)

    def send_flowing_data(self, data):
        # print('writer: send_flowing_data %s' % (data))
        self.write(data)

# ************************************************************************
# *
# ************************************************************************


class tkHTMLParser(htmllib.HTMLParser):
    def anchor_bgn(self, href, name, type):
        self.formatter.flush_softspace()
        htmllib.HTMLParser.anchor_bgn(self, href, name, type)
        self.formatter.writer.anchor_bgn(href, name, type)

    def close(self):
        # print('tkHTMLParser1: close()')
        self.formatter.writer.text.applyBuffer()
        # label = self.formatter.writer.text.label
        # print('tkHTMLParser: label.refs %s' % str(label.refs))
        # print ('tkHTMLParser: label.refs %s' % str(Label.refs))

        # print('tkHTMLParser2: close()')
        htmllib.HTMLParser.close(self)

    def anchor_end(self):
        if self.anchor:
            self.anchor = None
        self.formatter.writer.anchor_end()

    def do_dt(self, attrs):
        self.formatter.end_paragraph(1)
        self.ddpop()

    def handle_image(self, src, alt, ismap, align, width, height):
        self.formatter.writer.viewer.showImage(
            src, alt, ismap, align, width, height)

# ************************************************************************
# *
# ************************************************************************


class HTMLButton(Button):
    def __init__(self, **kw):
        super(HTMLButton, self).__init__(**kw)

    def config(self, **kw):
        pass


class HTMLLabel(Label):
    def __init__(self, **kw):
        super(HTMLLabel, self).__init__(**kw)

        self.bind(size=self.onUpdate)
        self.bind(pos=self.onUpdate)
        self.bind(text=self.onUpdate)

    def onUpdate(self, instance, size):
        self.size_hint_y = None
        self.text_size = self.width, None
        self.texture_update()
        self.height = self.texture_size[1]


class HTMLText(LScrollView, LPopCommander):
    def __init__(self, **kw):
        super(HTMLText, self).__init__(**kw)

        self.label = HTMLLabel(text='', markup=True)
        self.tags = {}
        self.textbuffer = ''
        self.add_widget(self.label)

    def applyBuffer(self):
        # print('applybuffer:')
        self.label.text = self.textbuffer

    def config(self, **kw):
        # print('config: %s' % kw)
        pass

    def update_idletasks(self):
        pass

    def delete(self, val, val1):
        pass

    def insert(self, cmd, data):
        # print('insert text: %s' % data)
        self.textbuffer = self.textbuffer + data
        # self.label.text = self.textbuffer
        pass

    def index(self, cmd):
        # print('index: %s' % cmd)
        # was sollen wir hier zuruckgeben ?
        return 0

    def tag_add(self, font, fontmark, cmd):
        # print('tag_add: %s, %s, %s' % (font, fontmark, cmd))
        pass

    def tag_config(self, tag, **kw):
        # print('tag_config: %s, %s' % (tag, kw))
        # self.tags[tag] = kw

        # for t, k in self.tags:
        #    print('tagslist: %s, %s' % (t, k))

        pass

    def xview_moveto(self, xview):
        # print('xview_moveto: %s' % xview)
        pass

    def yview_moveto(self, yview):
        # print('yview_moveto: %s' % yview)
        pass


class HTMLViewer:
    symbols_fn = {}  # filenames, loaded in Application.loadImages3
    symbols_img = {}

    def make_pop_command(self, parent, title):
        def pop_command(event):
            if self.history.index > 1:
                self.goBack(event)
                return None
            del self.history.list
            self.history.index = 0
            parent.popWork(title)
        return pop_command

    def make_close_command(self, parent, title):
        def close_command(event):
            del self.history.list
            self.history.index = 0
            parent.popWork(title)
        return close_command

    def refpress(self, instance, value):
        # print('writer: refpress %s, %s' % (instance, value))
        self.updateHistoryXYView()
        return self.display(value)

    def __init__(self, parent, app=None, home=None):
        self.parent = parent
        self.app = app
        self.home = home
        self.url = None
        self.history = Struct(
            list=[],
            index=0,
        )
        self.visited_urls = []
        self.images = {}
        # need to keep a reference because of garbage collection
        self.defcursor = "default"
        # self.defcursor = parent["cursor"]
        # self.defcursor = 'xterm'
        self.handcursor = "hand2"

        self.title = _("Browser")
        self.window = None
        self.running = False

        # prüfen ob noch aktiv.

        if parent.workStack.peek(self.title) is not None:
            parent.popWork(self.title)

        pc = self.make_pop_command(parent, self.title)
        cc = self.make_close_command(parent, self.title)

        # neuen Dialog aufbauen.

        window = LTopLevel(app.top, self.title, size_hint=(1.8, 1.0))
        window.titleline.bind(on_press=cc)
        self.parent.pushWork(self.title, window)
        self.window = window
        self.running = True

        content = BoxLayout(orientation='vertical')
        # buttonline =
        #   BoxLayout(orientation='horizontal', size_hint=(1.0, 0.1))

        # create buttons
        self.homeButton = HTMLButton(text=_("Index"), on_release=self.goHome)
        self.backButton = HTMLButton(text=_("Back"), on_release=self.goBack)
        self.forwardButton = HTMLButton(
            text=_("Forward"), on_release=self.goForward)
        self.closeButton = HTMLButton(text=_("Close"), on_release=self.goHome)

        '''
        buttonline.add_widget(self.homeButton)
        buttonline.add_widget(self.backButton)
        buttonline.add_widget(self.forwardButton)
        buttonline.add_widget(self.closeButton)
        content.add_widget(buttonline)
        '''

        '''
        self.homeButton = Tkinter.Button(parent, text=_("Index"),
                                         width=button_width,
                                         command=self.goHome)
        self.homeButton.grid(row=0, column=0, sticky='w')
        self.backButton = Tkinter.Button(parent, text=_("Back"),
                                         width=button_width,
                                         command=self.goBack)
        self.backButton.grid(row=0, column=1, sticky='w')
        self.forwardButton = Tkinter.Button(parent, text=_("Forward"),
                                            width=button_width,
                                            command=self.goForward)
        self.forwardButton.grid(row=0, column=2, sticky='w')
        self.closeButton = Tkinter.Button(parent, text=_("Close"),
                                          width=button_width,
                                          command=self.destroy)
        self.closeButton.grid(row=0, column=3, sticky='e')
        '''

        # create text widget

        self.text = HTMLText(
            pop_command=pc, text="hallo", size_hint=(1.0, 1.0))
        self.text.label.bind(on_ref_press=self.refpress)
        content.add_widget(self.text)
        '''
        text_frame = Tkinter.Frame(parent)
        text_frame.grid(row=1, column=0, columnspan=4, sticky='nsew')
        text_frame.grid_propagate(False)
        vbar = Tkinter.Scrollbar(text_frame)
        vbar.pack(side='right', fill='y')
        self.text = Tkinter.Text(text_frame,
                                 fg='black', bg='white',
                                 bd=1, relief='sunken',
                                 cursor=self.defcursor,
                                 wrap='word', padx=10)
        self.text.pack(side='left', fill='both', expand=True)
        self.text["yscrollcommand"] = vbar.set
        vbar["command"] = self.text.yview
        '''

        self.window.content.add_widget(content)

        # statusbar
        # self.statusbar = HtmlStatusbar(parent, row=2, column=0, columnspan=4)

        # parent.columnconfigure(2, weight=1)
        # parent.rowconfigure(1, weight=1)

        # load images
        for name, fn in self.symbols_fn.items():
            self.symbols_img[name] = self.getImage(fn)

    def _yview(self, *args):
        self.text.yview(*args)
        return 'break'

    def page_up(self, *event):
        return self._yview('scroll', -1, 'page')

    def page_down(self, *event):
        return self._yview('scroll', 1, 'page')

    def unit_up(self, *event):
        return self._yview('scroll', -1, 'unit')

    def unit_down(self, *event):
        return self._yview('scroll', 1, 'unit')

    def scroll_top(self, *event):
        return self._yview('moveto', 0)

    def scroll_bottom(self, *event):
        return self._yview('moveto', 1)

    # locate a file relative to the current self.url
    def basejoin(self, url, baseurl=None, relpath=1):
        if baseurl is None:
            baseurl = self.url
        if 0:
            import urllib
            url = urllib.pathname2url(url)
            if relpath and self.url:
                url = urllib.basejoin(baseurl, url)
        else:
            url = os.path.normpath(url)
            if relpath and baseurl and not os.path.isabs(url):
                h1, t1 = os.path.split(url)
                h2, t2 = os.path.split(baseurl)
                if cmp2(h1, h2) != 0:
                    url = os.path.join(h2, h1, t1)
                url = os.path.normpath(url)
        return url

    def normurl(self, url, with_protocol=True):
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                break
        else:
            url = self.basejoin(url)
            if with_protocol:
                if os.name == 'nt':
                    url = url.replace('\\', '/')
                url = 'file://' + url
        return url

    def openfile(self, url):
        if url[-1:] == "/" or os.path.isdir(url):
            url = os.path.join(url, "index.html")
        url = os.path.normpath(url)
        if sys.version_info > (3,):
            import codecs
            return codecs.open(url, encoding='utf-8'), url
        return open(url, "rb"), url

    def display(self, url, add=1, relpath=1, xview=0, yview=0):
        # for some reason we have to stop the PySol demo
        # (is this a multithread problem with Tkinter ?)
        if self.app and self.app.game:
            self.app.game.stopDemo()
            # self.app.game._cancelDrag()
            # pass

        # ftp: and http: would work if we use urllib, but this widget is
        # far too limited to display anything but our documentation...
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                plat = get_platform()
                if plat == 'android':
                    print("Open url: %s (TBD)" % url)
                    startAndroidBrowser(url)
                elif not openURL(url):
                    return

        # locate the file relative to the current url
        url = self.basejoin(url, relpath=relpath)

        # read the file
        try:
            file = None
            if 0:
                import urllib
                file = urllib.urlopen(url)
            else:
                file, url = self.openfile(url)
            data = file.read()
            file.close()
            file = None
        except Exception:
            print("Open url(1) - Exception: %s" % url)
            if file:
                file.close()

            '''
            self.errorDialog(_("Unable to service request:\n") + url)
            '''
            return

        self.url = url
        if self.home is None:
            self.home = self.url
        if add:
            self.addHistory(self.url, xview=xview, yview=yview)

        # print self.history.index, self.history.list
        if self.history.index > 1:
            self.backButton.config(state="normal")
        else:
            self.backButton.config(state="disabled")
        if self.history.index < len(self.history.list):
            self.forwardButton.config(state="normal")
        else:
            self.forwardButton.config(state="disabled")

        old_c1, old_c2 = self.defcursor, self.handcursor
        self.defcursor = self.handcursor = "watch"
        self.text.config(cursor=self.defcursor)
        self.text.update_idletasks()
        # self.frame.config(cursor=self.defcursor)
        # self.frame.update_idletasks()
        self.text.config(state="normal")
        self.text.delete("1.0", "end")
        # self.images = {}
        self.text.textbuffer = ''
        writer = tkHTMLWriter(self.text, self, self.app)
        fmt = formatter.AbstractFormatter(writer)
        parser = tkHTMLParser(fmt)
        parser.feed(data)
        parser.close()
        self.text.config(state="disabled")
        if 0.0 <= xview <= 1.0:
            self.text.xview_moveto(xview)
        if 0.0 <= yview <= 1.0:
            self.text.yview_moveto(yview)
        # self.parent.wm_title(parser.title)
        self.window.titleline.text = parser.title
        self.parent.wm_iconname(parser.title)
        self.defcursor, self.handcursor = old_c1, old_c2
        self.text.config(cursor=self.defcursor)
        # self.frame.config(cursor=self.defcursor)

    def addHistory(self, url, xview=0, yview=0):
        if url not in self.visited_urls:
            self.visited_urls.append(url)
        if self.history.index > 0:
            u, xv, yv = self.history.list[self.history.index - 1]
            if cmp2(u, url) == 0:
                self.updateHistoryXYView()
                return
        del self.history.list[self.history.index:]
        self.history.list.append((url, xview, yview))
        self.history.index = self.history.index + 1

    def updateHistoryXYView(self):
        if self.history.index > 0:
            url, xview, yview = self.history.list[self.history.index - 1]
            self.history.list[self.history.index - 1] = (url, xview, yview)

    def goBack(self, *event):
        if self.history.index > 1:
            self.updateHistoryXYView()
            self.history.index = self.history.index - 1
            url, xview, yview = self.history.list[self.history.index - 1]
            self.display(url, add=0, relpath=0, xview=xview, yview=yview)

    def goForward(self, *event):
        if self.history.index < len(self.history.list):
            self.updateHistoryXYView()
            url, xview, yview = self.history.list[self.history.index]
            self.history.index = self.history.index + 1
            self.display(url, add=0, relpath=0, xview=xview, yview=yview)

    def goHome(self, *event):
        if self.home and cmp2(self.home, self.url) != 0:
            self.updateHistoryXYView()
            self.display(self.home, relpath=0)

    def errorDialog(self, msg):
        MfxMessageDialog(self.parent,
                         title=_("%s HTML Problem") % TITLE,
                         text=msg,
                         # bitmap="warning"
                         # FIXME: this interp don't have images
                         strings=(_("&OK"), ), default=0)

    def getImage(self, fn):
        if fn in self.images:
            return self.images[fn]
        else:
            return None

    def showImage(self, src, alt, ismap, align, width, height):
        url = self.basejoin(src)
        img = self.getImage(url)
        if img:
            self.text.image_create(index="insert", image=img, padx=0, pady=0)


# ************************************************************************
# *
# ************************************************************************

''
#!/usr/bin/python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from __future__ import division

import logging
import math
import traceback

from kivy.animation import Animation
from kivy.app import App
from kivy.base import EventLoop
from kivy.base import stopTouchApp
from kivy.cache import Cache
from kivy.clock import Clock
from kivy.config import Config
from kivy.core.audio import SoundLoader
from kivy.core.window import Window
from kivy.graphics import Color
from kivy.graphics import Line
from kivy.graphics import Rectangle
from kivy.graphics import Triangle
from kivy.properties import StringProperty
from kivy.uix.actionbar import ActionButton
from kivy.uix.actionbar import ActionPrevious
from kivy.uix.actionbar import ActionView
from kivy.uix.behaviors import ButtonBehavior
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.image import Image as KivyImage
from kivy.uix.label import Label
from kivy.uix.scrollview import ScrollView
from kivy.uix.treeview import TreeView
from kivy.uix.treeview import TreeViewLabel
from kivy.uix.widget import Widget
from kivy.utils import platform

from pysollib.kivy.androidperms import requestStoragePerm

if platform != 'android':
    Config.set('input', 'mouse', 'mouse,multitouch_on_demand')

# =============================================================================


def get_platform():
    return platform

# =============================================================================


def get_screen_ori():
    if get_platform() == 'android':
        from jnius import autoclass
        from jnius import cast
    else:
        logging.info("LApp: ori = unknown")
        return None

    PythonActivity = autoclass('org.kivy.android.PythonActivity')
    currentActivity = cast('android.app.Activity', PythonActivity.mActivity)

    # Display = autoclass('android.view.Display')
    # WindowManager = autoclass('android.view.WindowManager')

    wm = currentActivity.getWindowManager()
    d = wm.getDefaultDisplay()

    so = None
    if d.getWidth() > d.getHeight():
        so = 'landscape'
    else:
        so = 'portrait'

    logging.info("LApp: ori = %s" % so)
    return so

# =============================================================================
# kivy EventDispatcher passes keywords, that to not correspond to properties
# to the base classes. Finally they will reach 'object'. With python3 (but not
# python2) 'object' throws an exception 'takes no parameters' in that a
# situation. We therefore underlay a base class (right outside), which
# swallows up remaining keywords. Thus the keywords do not reach 'object' any
# more.


class LBase(object):
    def __init__(self, **kw):
        super(LBase, self).__init__()

# =============================================================================


class LPopCommander(LBase):
    def __init__(self, **kw):
        super(LPopCommander, self).__init__()
        self.pop_command = kw['pop_command']

    def pop(self):
        if self.pop_command is not None:
            self.pop_command(0)
            return True
        return False

# =============================================================================


class LAnimationMgr(object):
    def __init__(self, **kw):
        super(LAnimationMgr, self).__init__()
        self.animations = []
        self.widgets = {}

    def animEnd(self, anim, widget):
        # print('LAnimationMgr: animEnd = %s.%s' % (anim, widget))

        self.widgets[widget] = self.widgets[widget][1:]
        self.animations.remove(anim)
        if len(self.widgets[widget]) > 0:
            # start next animation on widget
            nanim = self.widgets[widget][0]
            self.animations.append(nanim)
            print('LAnimationMgr: animEnd, append = %s' % (nanim))
            nanim.start(widget)
        else:
            # no further animations for widget so stop
            del self.widgets[widget]

    def makeAnimStart(self, anim, spos, widget):
        def animStart(dt):
            widget.pos = spos
            # print('LAnimationMgr: animStart = %s ... %s' % (anim, dt))
            anim.start(widget)
        return animStart

    def checkRunning(self):
        return len(self.animations) > 0

    def create(self, spos, widget, **kw):
        x = 0.0
        y = 0.0
        duration = 0.2
        transition = 'in_out_quad'
        if 'x' in kw:
            x = kw['x']
        if 'y' in kw:
            y = kw['y']
        if 'duration' in kw:
            duration = kw['duration']
        if 'transition' in kw:
            transition = kw['transition']

        anim = Animation(x=x, y=y, duration=duration, transition=transition)
        anim.bind(on_complete=self.animEnd)
        if 'bindE' in kw:
            anim.bind(on_complete=kw['bindE'])
        if 'bindS' in kw:
            anim.bind(on_start=kw['bindS'])

        offset = duration / 3.0
        # offset = duration*1.2
        timedelay = offset * len(self.animations)
        # print('offset = %s'% offset)
        print('LAnimationMgr: timedelay = %s' % timedelay)

        if widget in self.widgets:
            # append additional animation to widget
            self.widgets[widget].append(anim)
        else:
            # setup first animation for widget
            self.animations.append(anim)
            self.widgets[widget] = [anim]
            Clock.schedule_once(self.makeAnimStart(
                anim, spos, widget), timedelay)


LAnimationManager = LAnimationMgr()

# =============================================================================

LSoundLoader = SoundLoader

# =============================================================================


class LBoxLayout(BoxLayout, LBase):
    def __init__(self, **kw):
        super(LBoxLayout, self).__init__(**kw)

    def winfo_screenwidth(self):
        return self.size[0]

    def winfo_screenheight(self):
        return self.size[1]

# =============================================================================


class LImage(KivyImage, LBase):

    def __init__(self, **kwargs):
        super(LImage, self).__init__(**kwargs)
        self.size = self.texture.size
        self.silent = False
        self.allow_stretch = True
        # self.keep_ratio = 0
        # self.size_hint = (1.0/9.0, 1.0/4.0)
        self.size_hint = (1.0, 1.0)
        # self.mipmap = True     # funktioniert nicht.

        self.corePos = None
        self.coreSize = None

        # logging.info('LImage: __init__() %s' % kwargs)

    def getHeight(self):
        return self.size[1]

    def getWidth(self):
        return self.size[0]

    def subsample(self, r):
        ''
        return LImage(texture=self.texture)
        '''
        if (self.source!=None):
            # logging.info("LImage: subsample, %d, %s " % (r , self.source))
            return LImage(source=self.source)
        elif (self.texture!=None):
            # logging.info("LImage: subsample, %d (texture) " % r)
            return LImage(texture=self.texture)
        '''
        return self

    def on_touch_down(self, touch):
        if self.silent:
            return False

        # print('LImage: touch_down on %s' % str(touch.pos))
        if self.collide_point(*touch.pos):
            if (self.source is not None):
                print('LImage match %s' % self.source)
            else:
                print('LImage match with texture')
            return True
        return False

    def on_touch_up(self, touch):
        if self.silent:
            return False

        # print('LImage: touch_up on %s' % str(touch.pos))
        if self.collide_point(*touch.pos):
            if (self.source is not None):
                print('LImage match %s' % self.source)
            else:
                print('LImage match with texture')
            return True
        return False

# =============================================================================


def addAnchorOffset(pos, size, anchor):
    # print ('MfxCanvas: anchor=%s' % (anchor))
    x = pos[0]
    y = pos[1]
    xa = 0
    ya = 0
    if anchor == "n":
        ya = -1
    elif anchor == "w":
        xa = -1
    elif anchor == "s":
        ya = 1
    elif anchor == "e":
        xa = 1
    elif anchor == "ne":
        ya = -1
        xa = 1
    elif anchor == "nw":
        ya = -1
        xa = -1
    elif anchor == "se":
        ya = 1
        xa = 1
    elif anchor == "sw":
        ya = 1
        xa = -1

    if xa == 0:
        x = x - size[0] / 2.0
    elif xa == 1:
        x = x - size[0]
    if ya == 0:
        y = y - size[1] / 2.0
    elif ya == 1:
        y = y - size[1]
    return (x, y)

# =============================================================================


def LColorToKivy(outline):
    if (outline[0] == '#'):
        outline = outline[1:]
    ou0 = float(int(outline[0:2], 16)) / 256.0
    ou1 = float(int(outline[2:4], 16)) / 256.0
    ou2 = float(int(outline[4:6], 16)) / 256.0
    ou3 = 1.0
    if len(outline) >= 8:
        ou3 = float(int(outline[6:8], 16)) / 256.0
    return ou0, ou1, ou2, ou3

# =============================================================================


class LText(Widget, LBase):
    text = StringProperty('')

    def __init__(self, canvas, x, y, **kwargs):
        super(LText, self).__init__(**kwargs)
        # super(LText, self).__init__()

        if 'text' not in kwargs:
            kwargs['text'] = 'X'

        font = 'helvetica'
        fontsize = 18.0
        if 'font' in kwargs:
            font = kwargs['font'][0]
            fontsize = kwargs['font'][1]
            del kwargs['font']

        self.anchor = 'nw'
        if 'anchor' in kwargs:
            self.anchor = kwargs['anchor']

        self.text = kwargs['text']
        self.coreFontSize = fontsize
        self.coreFont = font

        # print('LText: font = %s, font_size = %s' % (font, fontsize))
        # print('LText: text = %s' % (self.text))

        kwargs['font'] = font
        kwargs['font_size'] = fontsize

        class MyLabel(Label, LBase):
            pass

        self.label = MyLabel(**kwargs)
        self.label.texture_update()
        self.coreSize = self.label.texture_size
        self.corePos = (x, y)
        self.prnt = canvas

        # print('LText: corePos = %s, coreSize = %s'
        # % (self.corePos, self.coreSize))

        self.size = self.label.texture_size

        self.bind(size=self.updateCanvas)
        self.bind(pos=self.updateCanvas)
        self.bind(text=self.updateCanvas)

    def updateCanvas(self, inst, val):
        self.label.text = self.text
        self.label.texture_update()

        self.coreSize = self.label.texture_size
        cp = addAnchorOffset(self.corePos, self.coreSize, self.anchor)
        cs = self.coreSize

        pos, size = self.prnt.CoreToKivy(cp, cs)
        # print('LText: pos = %s, size = %s' % (pos, size))

        color = LColorToKivy(self.prnt._text_color)
        # print('LText: color = %s' % str(color))
        self.canvas.clear()
        with self.canvas:
            Color(color[0], color[1], color[2], color[3])
            Rectangle(texture=self.label.texture, pos=pos, size=size)

# =============================================================================


class LEvent(object):
    def __init__(self):
        self.x = 0
        self.y = 0
        self.cardid = -1
        self.char = False
        pass

# =============================================================================


class LLine(Widget, LBase):
    def __init__(self, canvas, args, **kw):
        super(LLine, self).__init__(**kw)

        print('kw = %s%s' % (args, kw))

        lwidth = 10
        fill = '#ee3344'
        ashape = ()
        arrow = 'none'

        self.prnt = canvas
        xmin = 100000
        ymin = 100000
        xmax = -100000
        ymax = -100000
        self.corePoly = []
        if isinstance(args[0], list):
            kww = args[1]
            if ('width' in kww):
                lwidth = kww['width']
            self.lwidth = lwidth
            if ('fill' in kww):
                fill = kww['fill']
            self.fill = fill
            if ('arrowshape' in kw):
                ashape = kw['arrowshape']
            self.ashape = ashape
            if ('arrow' in kw):
                arrow = kw['arrow']
            self.arrow = arrow

            pts = args[0]
            ipts = iter(pts)
            for x, y in zip(ipts, ipts):
                print('%s.%s' % (x, y))
                self.corePoly.append(x)
                self.corePoly.append(y)
                if x < xmin:
                    xmin = x
                if x > xmax:
                    xmax = x
                if y < ymin:
                    ymin = y
                if y > ymax:
                    ymax = y
        else:
            if ('width' in kw):
                lwidth = kw['width']
            self.lwidth = lwidth
            if ('fill' in kw):
                fill = kw['fill']
            self.fill = fill
            if ('arrowshape' in kw):
                ashape = kw['arrowshape']
            self.ashape = ashape
            if ('arrow' in kw):
                arrow = kw['arrow']
            self.arrow = arrow

            for i in range(0, 2):
                x = args[2 * i]
                y = args[2 * i + 1]
                self.corePoly.append(x)
                self.corePoly.append(y)
                if x < xmin:
                    xmin = x
                if x > xmax:
                    xmax = x
                if y < ymin:
                    ymin = y
                if y > ymax:
                    ymax = y

        print('width = %s' % self.lwidth)
        print('color = %s' % self.fill)
        print('arrow = %s' % self.arrow)
        print('ashape = %s' % str(self.ashape))

        self.alist = []
        if self.arrow == 'last':
            self.alist.append(self.corePoly[-2])
            self.alist.append(self.corePoly[-1])
            self.alist.append(self.corePoly[-4])
            self.alist.append(self.corePoly[-3])
        elif self.arrow != 'none':
            self.alist.append(self.corePoly[0])
            self.alist.append(self.corePoly[1])
            self.alist.append(self.corePoly[2])
            self.alist.append(self.corePoly[3])

        self.corePos = (xmin, ymin)
        self.coreSize = (xmax - xmin, ymax - ymin)
        self.pos = self.corePos
        self.size = self.coreSize

        self.bcolor = LColorToKivy(self.fill)

        self.bind(size=self.updateCanvas)
        self.bind(pos=self.updateCanvas)

    def updateCanvas(self, instance, value):
        # size = self.size
        # pos = self.pos

        # Linie:
        poly = None
        poly = []
        dmy, sxy = self.prnt.CoreToKivy(
            (0.0, 0.0), (self.lwidth, self.lwidth))
        wpoly = sxy[1]
        ipts = iter(self.corePoly)
        for x, y in zip(ipts, ipts):
            print('%s.%s' % (x, y))
            xy, dmy = self.prnt.CoreToKivy((x, y))
            poly.append(xy[0])
            poly.append(xy[1])

        def rot(x, y, a):
            x1 = x * math.cos(a) + y * math.sin(a)
            y1 = y * math.cos(a) - x * math.sin(a)
            return (x1, y1)

        # Pfeil:
        PI = 3.1415926
        atrio = None
        atrio = []
        if (len(self.ashape) > 2):
            dx = (self.alist[0] - self.alist[2])
            dy = (self.alist[1] - self.alist[3])
            if (dx == 0.0):
                if (dy > 0.0):
                    ang = -PI / 2.0
                else:
                    ang = PI / 2.0
            else:
                ang = math.atan(dy / dx)
            if (dx > 0.0):
                ang = ang + PI

            # (kante, winkel?)
            x = self.ashape[0] * math.cos(self.ashape[1] * PI / 360.0)
            y = 2.0 * self.ashape[0] * math.sin(self.ashape[1] * PI / 360.0)
            # (länge, breite?)
            # x = self.ashape[0]
            # y = self.ashape[1]
            o = self.ashape[2]
            axy, dmy = self.prnt.CoreToKivy((self.alist[0], self.alist[1]))
            dmy, asxy = self.prnt.CoreToKivy((0, 0), (x, y))
            dmy, aoff = self.prnt.CoreToKivy((0, 0), (o, o))
            print('asxy=%s' % str(asxy))

            x1, y1 = rot(-aoff[0], 0.0, ang)
            atrio.append(x1 + axy[0])
            atrio.append(y1 + axy[1])
            x1, y1 = rot(asxy[0] - aoff[0], asxy[1], ang)
            atrio.append(x1 + axy[0])
            atrio.append(y1 + axy[1])
            x1, y1 = rot(asxy[0] - aoff[0], -asxy[1], ang)
            atrio.append(x1 + axy[0])
            atrio.append(y1 + axy[1])

        self.canvas.clear()
        with self.canvas:
            Color(self.bcolor[0], self.bcolor[1],
                  self.bcolor[2], self.bcolor[3])
            Line(points=poly, width=wpoly, cap='none', joint='bevel')
            if (len(atrio) > 2):
                Triangle(points=atrio)

# =============================================================================


class LRectangle(Widget, LBase):
    def __init__(self, prnt, args, **kw):
        super(LRectangle, self).__init__(**kw)
        self.prnt = prnt

        # print('width   %s' % kw['width'])
        # print('outline %s' % kw['outline'])
        # print('fill    %s' % kw['fill'])

        width = 10.0
        if ('width' in kw):
            width = float(kw['width'])

        bcolor = '#ffa000a0'
        if ('outline') in kw:
            bcolor = kw['outline']
        if (not bcolor or len(bcolor) < 7):
            bcolor = '#ffa000a0'

        fcolor = '#00aaff20'
        if ('fill') in kw:
            fcolor = kw['fill']
        if (not fcolor or len(fcolor) < 7):
            fcolor = '#00aaff20'

        self.group = None
        if 'group' in kw:
            self.group = kw['group']

        xmin = float(args[0])
        ymin = float(args[1])
        xmax = float(args[2])
        ymax = float(args[3])

        # print ('LRectangle: min = %s.%s' % (xmin, ymin))
        # print ('LRectangle: max = %s.%s' % (xmax, ymax))
        # print ('LRectangle: border = %s' % (width))

        self.border = width
        self.fcolor = LColorToKivy(fcolor)
        self.bcolor = LColorToKivy(bcolor)

        self.corePos = (xmin, ymin)
        self.coreSize = (xmax - xmin, ymax - ymin)
        self.pos = self.corePos
        self.size = self.coreSize
        self.topleft = (xmin + width / 2.0, ymin + width / 2.0)
        self.bottomright = (xmax - width / 2.0, ymax - width / 2.0)
        self.poly = None

        self.bind(size=self.updateCanvas)
        self.bind(pos=self.updateCanvas)

    def updateCanvas(self, instance, value):
        # print('LRectangle: updateCanvas')

        pos, size = self.prnt.CoreToKivy(self.corePos, self.coreSize)
        bpos, dmy = self.prnt.CoreToKivy(self.topleft)
        tpos, dmy = self.prnt.CoreToKivy(self.bottomright)

        poly = [bpos[0], bpos[1],
                tpos[0], bpos[1],
                tpos[0], tpos[1],
                bpos[0], tpos[1],
                bpos[0], bpos[1]]

        dmy, brd = self.prnt.CoreToKivy(
            (0.0, 0.0), (self.border, self.border))
        border = brd[1]

        self.canvas.clear()
        with self.canvas:
            Color(self.fcolor[0], self.fcolor[1],
                  self.fcolor[2], self.fcolor[3])
            Rectangle(pos=pos, size=size)
            Color(self.bcolor[0], self.bcolor[1],
                  self.bcolor[2], self.bcolor[3])
            Line(points=poly, width=border)

    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos):
            if self.group is not None:
                logging.info('LRectangle: self=%s group=%s' %
                             (self, self.group))
                if '<1>' in self.group.bindings:
                    # logging.info('LRectangle: size=%s' % (self.size))
                    ppos, psize = self.group.canvas.KivyToCore(touch.pos)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    if touch.is_double_tap:
                        self.group.bindings['<Double-1>'](event)
                    else:
                        self.group.bindings['<1>'](event)
                    return True
        return False

    def on_touch_up(self, touch):
        if self.collide_point(*touch.pos):
            if self.group is not None:
                logging.info('LRectangle: self=%s group=%s' %
                             (self, self.group))
                if '<ButtonRelease-1>' in self.group.bindings:
                    ppos, psize = self.group.canvas.KivyToCore(touch.pos)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    self.group.bindings['<ButtonRelease-1>'](event)
                    return True
        return False

# =============================================================================


class LImageItem(BoxLayout, LBase):
    def __init__(self, **kw):
        super(LImageItem, self).__init__(**kw)
        self.game = None
        self.card = None
        self.group = None
        if 'game' in kw:
            self.game = kw['game']
        if 'card' in kw:
            self.card = kw['card']
        if 'group' in kw:
            self.group = kw['group']
        self.dragstart = None
        # ev. noch globales cache für stacks->game und cards->stack
        # einrichten. Aber: stacks hängt vom jeweiligen spiel ab.

    def send_event_pressed_n(self, event, n):
        if self.group and n in self.group.bindings:
            self.group.bindings[n](event)

    def send_event_pressed(self, touch, event):

        if touch.is_double_tap:
            self.send_event_pressed_n(event, '<Double-1>')
        else:
            button = 'left'
            if 'button' in touch.profile:
                button = touch.button
            if button == 'left':
                self.send_event_pressed_n(event, '<1>')
                return
            if button == 'middle':
                self.send_event_pressed_n(event, '<2>')
                return
            if button == 'right':
                self.send_event_pressed_n(event, '<3>')
                return

    def on_touch_down(self, touch):

        if self.collide_point(*touch.pos):

            for c in self.children:
                # print('child at %s' % c)
                if (c.on_touch_down(touch) and self.game):
                    for stack in self.game.allstacks:
                        for i in range(len(stack.cards)):
                            if stack.cards[i] == self.card:
                                print('LCardImage: stack = %s' % stack)
                                print('LCardImage: touch = %s' % str(touch))
                                print('grab')
                                # grab the touch!
                                touch.grab(self)
                                ppos, psize = self.game.canvas.KivyToCore(
                                    touch.pos, self.size)
                                event = LEvent()
                                event.x = ppos[0]
                                event.y = ppos[1]
                                self.dragstart = touch.pos
                                event.cardid = i
                                self.send_event_pressed(touch, event)
                                return True

            if self.group is not None:
                print('LCardImage: self=%s group=%s' % (self, self.group))
                if '<1>' in self.group.bindings:
                    ppos, psize = self.group.canvas.KivyToCore(
                        touch.pos, self.size)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    self.group.bindings['<1>'](event)
                    return True

            if self.card is None:
                return False
            if self.game is None:
                return False

        # print('LCardImage: touch_down on %s' % str(touch.pos))
        return False

    def send_event_released_1(self, event):
        if self.group and '<ButtonRelease-1>' in self.group.bindings:
            self.group.bindings['<ButtonRelease-1>'](event)

    def on_touch_up(self, touch):
        if touch.grab_current is self:
            # release my grabbed touch!
            print('ungrab')
            touch.ungrab(self)
            return True

        if self.collide_point(*touch.pos):

            for c in self.children:
                # print('child at %s' % c)

                if (c.on_touch_up(touch) and self.game):
                    for stack in self.game.allstacks:
                        for i in range(len(stack.cards)):
                            if stack.cards[i] == self.card:
                                print('LCardImage: stack = %s' % stack)
                                ppos, psize = self.game.canvas.KivyToCore(
                                    touch.pos, self.size)
                                event = LEvent()
                                event.x = ppos[0]
                                event.y = ppos[1]
                                event.cardid = i
                                self.send_event_released_1(event)
                                return True

            if self.group is not None:
                print('LCardImage: self=%s group=%s' % (self, self.group))
                if '<ButtonRelease-1>' in self.group.bindings:
                    ppos, psize = self.group.canvas.KivyToCore(
                        touch.pos, self.size)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    self.group.bindings['<ButtonRelease-1>'](event)
                    return True

            if self.card is None:
                return False
            if self.game is None:
                return False

        # print('LCardImage: touch_up on %s' % str(touch.pos))
        return False

    def on_touch_move(self, touch):
        # behandeln nur wenn grabbed
        if touch.grab_current is not self:
            return False
        if 'pos' not in touch.profile:
            return False

        print('LCardImage: touch_move on %s' % str(touch.pos))

        for stack in self.game.allstacks:
            for i in range(len(stack.cards)):
                if stack.cards[i] == self.card:
                    print('LCardImage: stack = %s/%s' % (stack, touch))
                    ppos, psize = self.game.canvas.KivyToCore(
                        touch.pos, self.size)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    event.cardid = i
                    stack._motionEventHandler(event)
                    return True

        # print('LCardImage: touch_move on %s' % str(touch.pos))
        return False

# =============================================================================
# Treeview


class LTreeRoot(TreeView, LBase):
    def __init__(self, **kw):
        super(LTreeRoot, self).__init__(**kw)
        self.kw = kw

    def closeLastNode(self):
        ret = False
        lastopen = None
        for ti in reversed(self.children):
            if isinstance(ti, LTreeNode):
                if ti.is_open:
                    lastopen = ti

        if lastopen is not None:
            self.toggle_node(lastopen)
            self.select_node(lastopen)
            ret = True

        return ret


class LTreeNode(ButtonBehavior, TreeViewLabel, LBase):

    # def __init__(self, gameview, **kw):
    def __init__(self, **kw):
        self.command = None
        if 'command' in kw:
            self.command = kw['command']
        self.variable = None
        if 'variable' in kw:
            self.variable = kw['variable']
        if 'value' in kw:
            self.value = kw['value']
        if ('text' in kw):
            self.title = kw['text']

        super(LTreeNode, self).__init__(markup=True, **kw)

        if self.variable:
            self.variable.bind(value=self.onVarChange)
            self.onVarChange(self.variable, self.variable.get())

        # self.gameview = gameview
        self.coreFont = self.font_size
        # self.scaleFont(self.gameview.size[1])
        # self.gameview.bind(size=self.scaleFontCB)
        # nicht skalieren!

        self.bind(on_release=self.on_released)
        self.bind(is_selected=self.onSelect)
        self.bind(is_open=self.onOpen)

    def onVarChange(self, instance, value):
        # print('LTreeNode: onVarChange(%s, %s, %s)'
        # % (instance, value, type(value)))
        if type(value) is bool:
            self.setCheck(value)
        if type(value) is int:
            self.setVal(value)
        if type(value) is str:
            self.setVal(value)
        # if type(value) is unicode:
        #     self.setVal(value)

    def setCheck(self, value):
        # print('LTreeNode: setCheck(%s)' % value)
        if value:
            # self.text = '+ '+self.title
            self.text = '[b]+[/b] ' + self.title
        else:
            self.text = '- ' + self.title
        self.texture_update()

    def setVal(self, value):
        # print('LTreeNode: setVal(%s)' % value)
        if value == self.value:
            # fs = str(int(self.font_size+2))
            # print ('%s.%s' % (self.font_size, fs))
            # self.text = '[size='+fs+'][b]'+self.title+'[/b][/size]'
            # self.text = 'o '+self.title
            self.text = '[b]o[/b] ' + self.title
            # self.text = u'\u25cf '+self.title  # unicode filled circle
        else:
            self.text = self.title
            self.text = u'    ' + self.title
            # self.text = u'\u25cb  '+self.title # unicode open circle
        self.texture_update()

    # font skalierung.

    def scaleFont(self, value):
        self.font_size = int(self.coreFont * value / 550.0)

    def scaleFontCB(self, instance, value):
        self.scaleFont(value[1])

    # benutzer interaktion.

    def onSelect(self, instance, val):
        if val:
            print('select %s' % self.title)
        else:
            print('deselect %s' % self.title)
        pass

    def collapseChildren(self, deep=False):

        def cc(p, n):
            for c in n.nodes:
                if c.is_open:
                    cc(p, c)
                    p.toggle_node(c)

        p = self.parent
        if p and isinstance(p, LTreeRoot):
            for n in self.nodes:
                if n.is_open:
                    # n.collapseChildren()   # ginge nur mit LTreeNode!
                    if deep:
                        cc(p, n)            # geht mit allen TreeViewNode
                    p.toggle_node(n)

    def collapseSiblings(self, deep=True):

        def cc(p, n):
            for c in n.nodes:
                if c.is_open:
                    cc(p, c)
                    p.toggle_node(c)

        p = self.parent
        if p and isinstance(p, LTreeRoot):
            # print('expand: LTreeRoot')
            for n in p.root.nodes:
                # print('expand: -> check %s' % n.title)
                if n != self and n.is_open and n.level >= self.level:
                    # print('expand: -> close %s' % n.title)
                    if deep:
                        cc(p, n)
                    p.toggle_node(n)

            pn = self.parent_node
            if pn and isinstance(pn, LTreeNode):
                # print('expand: LTreeNode')
                for n in pn.nodes:
                    # print('expand: -> check %s' % n.title)
                    if n != self and n.is_open and n.level >= self.level:
                        # print('expand: -> close %s' % n.title)
                        if deep:
                            cc(p, n)
                        p.toggle_node(n)

    def onOpen(self, instance, val):
        if val:
            # print('expand %s, %s' % (self.level, self.title))
            self.collapseSiblings(deep=False)
        else:
            # print('collapse %s, %s' % (self.level, self.title))
            pass

    def on_released(self, v):
        if self.command:
            Clock.schedule_once(self.commandCB, 0.1)
        else:
            Clock.schedule_once(self.toggleCB, 0.1)

    def commandCB(self, d):
        self.command()

    def toggleCB(self, d):
        # hier könnte der knoten ev. auch neu aufgebaut werden ?!
        self.parent.toggle_node(self)

# =============================================================================


class LTopLevelContent(BoxLayout, LBase):
    def __init__(self, **kw):
        super(LTopLevelContent, self).__init__(**kw)

        # beispiel zu canvas (hintergrund)
        with self.canvas.before:
            Color(0.45, 0.5, 0.5, 1.0)
            self.rect = Rectangle(pos=self.pos, size=self.size)
        self.bind(pos=self.update_rect)
        self.bind(size=self.update_rect)

    def update_rect(self, *args):
        self.rect.pos = self.pos
        self.rect.size = self.size

    def wm_minsize(self, w, h):
        pass

# =============================================================================


class LTopLine(ButtonBehavior, Label, LBase):

    def __init__(self, **kw):
        super(LTopLine, self).__init__(**kw)
        with self.canvas.before:
            Color(0.45, 0.3, 0.3, 1.0)
            self.rect = Rectangle(pos=self.pos, size=self.size)
        self.bind(pos=self.update_rect)
        self.bind(size=self.update_rect)

    def update_rect(self, *args):
        self.rect.pos = self.pos
        self.rect.size = self.size

    def on_press(self):
        print('press')

    def on_release(self):
        print('release')

# =============================================================================


class LTopLevel0(BoxLayout, LBase):
    def __init__(self, top, title=None, **kw):
        self.main = top
        super(LTopLevel0, self).__init__(
            orientation="vertical", **kw)

        # self.canvas.add(Color(0, 1, 0, 0.4))
        # self.canvas.add(Rectangle(pos=(100, 100), size=(100, 100)))

        self.size_hint = (0.5, 1.0)
        '''
        self.titleline = BoxLayout(
            orientation="horizontal", size_hint=[1.0, 0.15], **kw)
        self.button = Button(text="X", size_hint=[0.15, 1.0], **kw)
        if not title:
            title = '<>'
        self.title = Label(text=title, **kw)
        self.titleline.add_widget(self.title)
        self.titleline.add_widget(self.button)
        '''
        self.titleline = LTopLine(text=title, size_hint=[1.0, 0.15])
        self.title = title

        # self.content = BoxLayout(orientation="vertical", **kw)
        self.content = LTopLevelContent(orientation="vertical", **kw)
        self.add_widget(self.titleline)
        self.add_widget(self.content)
        '''
        self.button.bind(on_press=self.onClick)
        '''
        self.titleline.bind(on_press=self.onClick)
        self.main.pushWork(self.title, self)

    def onClick(self, event):
        print('LTopLevel: onClick')
        self.main.popWork(self.title)

# =============================================================================


class LTopLevel(BoxLayout, LBase):
    def __init__(self, parent, title=None, **kw):
        self.mainwindow = parent
        super(LTopLevel, self).__init__(
            orientation="vertical", **kw)

        if ('size_hint' not in kw):
            self.size_hint = (0.5, 1.0)
        else:
            del kw['size_hint']
        self.titleline = LTopLine(text=title, size_hint=(1.0, 0.10))

        self.content = LTopLevelContent(orientation="vertical", **kw)
        self.add_widget(self.titleline)
        self.add_widget(self.content)

    def processAndroidBack(self):
        ret = False
        # try to collapse the last open tree node
        # the treeview will be located inside of a scrollview
        # (-> menubar.py)
        for c in self.content.children:
            # print("childitem: %s" % str(c))
            if isinstance(c, LScrollView):
                for t in reversed(c.children):
                    # print("  childitem: %s" % str(t))
                    if isinstance(t, LTreeRoot):
                        ret = t.closeLastNode()
            if isinstance(c, BoxLayout):
                for t in reversed(c.children):
                    # print("  childitem: %s" % str(t))
                    if isinstance(t, LPopCommander):
                        ret = t.pop()
                    pass
        return ret


# =============================================================================


class LMenuBar(BoxLayout, LBase):
    def __init__(self, **kw):
        super(LMenuBar, self).__init__(**kw)
        self.menu = None
        self.size_hint = (1.0, 0.08)

    def setMenu(self, menu):
        print('LMenuBar: setMenu %s, %s' % (self, menu))

        # Letztes Menu entfernen
        last = self.menu
        if (last is not None):
            self.remove_widget(last)
            self.menu = None

        # Neues Menu einfügen
        if (menu is not None):
            self.add_widget(menu)
            self.menu = menu
            menu.setBar(self)

    def getMenu(self):
        return self.menu

# =============================================================================


class LMenu(ActionView, LBase):
    def __init__(self, prev, **kw):
        super(LMenu, self).__init__(**kw)

        class MyActionPrev(ActionPrevious, LBase):
            pass

        kw['app_icon'] = 'data/images/icons/48x48/pysol.png'
        kw['with_previous'] = prev
        kw['size_hint'] = (.01, 1)
        self.ap = MyActionPrev(**kw)
        self.add_widget(self.ap)
        self.bar = None
        self.uppermenu = None

    def addItem(self, mi):
        # print ('LMenu: addItem '+str(mi)+' '+str(self.bar))
        mi.setBar(self.bar)
        self.add_widget(mi)

    def setBar(self, bar):
        # print ('LMenu: setBar %s, %s' % (self, bar))
        self.bar = bar

    def prev(self, menu):
        # print ('LMenu: prev = %s' % menu)
        self.uppermenu = menu
        self.ap.bind(on_release=self.upper)
        pass

    def upper(self, event):
        print('upper')
        self.bar.setMenu(self.uppermenu)

    def delete(self, pos, mode):
        # print ('LMenu(%s): delete(%s, %s)' % (self, pos, mode))

        items = []
        menues = []
        for c in self.children:
            if (type(c) is LMenuItem):
                # print ('LMenu: to delete child %s' % c)
                items.append(c)
            elif (type(c) is LMenu):
                # print ('LMenu: to delete child %s' % c)
                menues.append(c)
            else:
                # print ('LMenu: unknown child %s' % c)
                pass

        for c in items:
            # print ('LMenu: delete child %s' % c)
            self.clear_widgets([c])
        for c in menues:
            # print ('LMenu: delete child %s' % c)
            self.clear_widgets([c])
            c.delete(pos, mode)

    # def __str__(self):
    #   return hex(id(self))

# =============================================================================


class LMenuItem(ActionButton, LBase):

    def __init__(self, menu, **kw):
        super(LMenuItem, self).__init__(**kw)
        # super(LMenuItem, self).__init__()
        self.bar = None
        self.submenu = None
        self.menu = menu
        self.menu.addItem(self)
        self.minimum_width = '200sp'
        if 'command' in kw:
            self.setCommand(kw['command'])
        if 'submenu' in kw:
            self.setSubMenu(kw['submenu'])

    def setBar(self, bar):
        # print ('LMenuItem: setBar %s, %s' % (self, bar))
        self.bar = bar

    def onClick(self, event):
        # print('LMenuItem: onClick')
        # print('LMenuItem: submenu vorh: '+str(self.submenu))
        self.bar.setMenu(self.submenu)
        return True

    def setSubMenu(self, submenu):
        # print('LMenuItem: setSubMenu')
        self.submenu = submenu
        # print('LMenuItem: setSubMenu: '+str(self.submenu))
        self.submenu.prev(self.menu)
        self.submenu.setBar(self.bar)
        self.bind(on_release=self.onClick)
        pass

    def setCommand(self, cmd):
        # print('LMenuItem: setCommand')
        self.bind(on_release=cmd)

    # def __str__(self):
    #   return hex(id(self))

# =============================================================================


class LScrollView(ScrollView, LBase):
    def __init__(self, **kw):
        super(LScrollView, self).__init__(**kw)
        self.delayDown = False
        self.touch = None

    def delayReset(self, dt):
        if not self.delayDown:
            return
        self.delayDown = False
        ScrollView.on_touch_down(self, self.touch)

    # Scroll ist original viel zu flink auf den Touchgeräten.
    # Wir versuchen das hier etwas abzuschwächen.

    def on_touch_down(self, touch):
        self.delayDown = True
        self.touch = touch
        Clock.schedule_once(self.delayReset, 0.15)

    def on_touch_up(self, touch):
        if self.delayDown:
            ScrollView.on_touch_down(self, self.touch)
        self.delayDown = False
        return ScrollView.on_touch_up(self, touch)

    def on_touch_move(self, touch):
        return ScrollView.on_touch_move(self, touch)

# =============================================================================


class LWorkWindow(Widget):
    def __init__(self):
        super(LWorkWindow, self).__init__()

        # beispiel zu canvas (hintergrund)
        with self.canvas.before:
            Color(0, 1, 1, 0.4)
            self.rect = Rectangle(pos=self.pos, size=self.size)
        self.bind(pos=self.update_rect)
        self.bind(size=self.update_rect)

    def update_rect(self, *args):
        self.rect.pos = self.pos
        self.rect.size = self.size

    def on_touch_down(self, touch):
        print('LWorkWindow: touch_down on %s' % str(touch.pos))
        # return True

# =============================================================================


class LTkBase:
    # Tk Emulation needs.
    def __init__(self):
        self.title = "default title"
        self.icontitle = "default title"
        logging.info("LTkBase: __init__()")
        self.sleeping = False
        self.in_loop = False
        self.screenSize = (1000, 1000)

    def cget(self, strg):
        return False

    def wm_title(self, strg):
        self.title = strg
        logging.info("LTkBase: wm_title %s" % strg)
        if (self.app):
            # self.app.top.topLine.text = strg
            self.app.top.getMenu().ap.title = strg

    def wm_iconname(self, strg):
        self.icontitle = strg
        logging.info("LTkBase: wm_iconname %s" % strg)

    def eval_screen_dim(self, size):
        self.screenSize = size
        if get_platform() == 'android':
            from jnius import autoclass
            from jnius import cast
        else:
            return

        PythonActivity = autoclass('org.kivy.android.PythonActivity')
        currentActivity = cast(
            'android.app.Activity', PythonActivity.mActivity)
        wm = currentActivity.getWindowManager()
        d = wm.getDefaultDisplay()

        self.screenSize = (d.getWidth(), d.getHeight())

    def winfo_screenwidth(self):
        logging.info("LTkBase: winfo_screenwidth %s" % str(self.size[0]))
        return self.size[0]

    def winfo_screenheight(self):
        logging.info("LTkBase: winfo_screenheight %s" % str(self.size[1]))
        return self.size[1]

    def winfo_screendepth(self):
        return 32

    def wm_minsize(self, x, y):
        pass

    def option_add(self, a, b, c):
        pass

    def option_get(self, a, b):
        return 0

    def wm_withdraw(self):
        logging.info("LTkBase: wm_withdraw")
        pass

    def busyUpdate(self):
        print('LTkBase: busyUpdate()')
        pass

    def grid_columnconfigure(self, a, weight):
        pass

    def grid_rowconfigure(self, a, weight):
        pass

    def connectApp(self, app):
        logging.info("LTkBase: connectApp %s" % str(app))
        self.app = app
        pass

    def wm_geometry(self, val):
        logging.info("LTkBase: wm_geometry %s" % str(val))
        pass

    def update_idletasks(self):
        logging.info("LTkBase: update_idletasks")
        try:
            if len(EventLoop.event_listeners) > 0:
                self.in_loop = True
                EventLoop.idle()
                self.in_loop = False
            else:
                logging.info("LTkBase: update_idletasks: terminating")
        except Exception:
            self.in_loop = False
            logging.info("LTkBase: update_idletasks: exception")

    def wm_state(self):
        return ""

    def wm_deiconify(self):
        pass

    def mainloop(self):
        logging.info("LTkBase: mainloop")
        pass

    def quit(self):
        logging.info("LTkBase: quit")
        stopTouchApp()

    def interruptSleep(self):
        logging.info('LTkBase: interruptSleep')
        self.update_idletasks()
        # self.sleep_var = 1
        return

    def mainquit(self):
        logging.info('LTkBase: mainquit')
        lapp = App.get_running_app()
        lapp.mainloop.send(None)    # Spielprozess verlassen
        return

    def onWakeUp(self, dt):
        self.sleeping = False

    def sleep(self, seconds):
        logging.info('LTkBase: sleep %s seconds' % seconds)
        self.sleeping = True
        Clock.schedule_once(self.onWakeUp, seconds)
        while self.sleeping:
            # time.sleep(0.05)
            self.in_loop = True
            EventLoop.idle()
            self.in_loop = False

    def waitCondition(self, condition):
        logging.info('LTkBase: wait condition start')
        while condition():
            self.in_loop = True
            EventLoop.idle()
            self.in_loop = False
        logging.info('LTkBase: wait condition end')

    def waitAnimation(self):
        self.waitCondition(LAnimationManager.checkRunning)

    def tkraise(self):
        pass

    def winfo_ismapped(self):
        return True
        # ???

# =============================================================================


class LStack:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def push(self, key, item):
        self.items.append((key, item))

    def pop(self, key):
        for i in range(len(self.items)):
            t = self.items[i]
            if (t[0] == key):
                self.items.pop(i)
                return t[1]
        return None

    def peek(self, key):
        for i in range(len(self.items)):
            t = self.items[i]
            if (t[0] == key):
                return t
        return None

    def size(self):
        return len(self.items)

# =============================================================================


class LMainWindow(BoxLayout, LTkBase):
    def __init__(self, **kw):
        super(LMainWindow, self).__init__(orientation='vertical')
        LTkBase.__init__(self)
        self.menuArea = LMenuBar()
        self.workContainer = LBoxLayout(orientation='horizontal')
        self.workContainerO = LBoxLayout(orientation='horizontal')
        self.workArea = None
        self.toolBar = None
        self.toolBarPos = 0
        self.bindings = {}
        self._w = '.'
        self.topLine = Button(
            size_hint=(1.0, 0.01),
            background_down='atlas:'
                            '//data/images/defaulttheme/action_item_down',
            background_normal='atlas:'
                              '//data/images/defaulttheme/action_item',
            border=(0, 0, 0, 0))
        self.topLine1 = Label(size_hint=(1.0, 0.01))

        self.add_widget(self.topLine)
        self.add_widget(self.menuArea)
        self.add_widget(self.topLine1)
        self.add_widget(self.workContainerO)
        self.workContainerO.add_widget(self.workContainer)
        # self.add_widget(Button(size_hint = (1.0, 0.01)))

        self.workStack = LStack()
        self.app = None

        '''
        from kivy.graphics import opengl_utils
        print('OPENGL support:')
        print(opengl_utils.gl_get_extensions())
        '''

        # self.touches = []

        # beispiel zu canvas (hintergrund)
        # with self.canvas.before:
        #   Color(0, 1, 0.7, 0.5)
        #   self.rect = Rectangle(pos=self.pos, size=self.size)
        # self.bind(pos=self.update_rect)
        # self.bind(size=self.update_rect)

    # def update_rect(self, *args):
    #   self.rect.pos = self.pos
    #   self.rect.size = self.size

    def on_motion(self, m):
        print('on_motion', m)
        pass

    # Events.

    def on_touch_down(self, touch):
        ret = False

        # print(dir(touch))

        # multitouch detection
        '''
        #print("MainWindow touch_down",touch.ox,touch.oy)
        #print("MainWindow touch_down",touch.sx,touch.sy)
        #print("MainWindow touch_down",touch.px,touch.py)
        self.touches.append(touch)
        print("touches cnt = ",len(self.touches))
        '''
        # multiclick detection
        '''
        if touch.is_double_tap:
            # print('Touch is a double tap !')
            # print(' - interval is', touch.double_tap_time)
            # print(' - distance betw. previous is', touch.double_tap_distance)
            # test the functions of Android back key
            ret = self.processAndroidBack()
            if (ret):
                return ret
        '''
        '''
        if touch.is_triple_tap:
            print('Touch is a triple tap !')
            print(' - interval is', touch.triple_tap_time)
            print(' - distance between previous is', touch.triple_tap_distance)
        '''
        # (Eventloop reentrancy check)
        if self.in_loop:
            return ret

        # (demo mode stop - nur auf spielfläche)
        if '<KeyPress>' in self.bindings:
            pgs = self.workStack.peek('playground')
            if pgs:
                pg = pgs[1]
                if pg.collide_point(*touch.pos):
                    event = LEvent()
                    event.char = True
                    self.bindings['<KeyPress>'](event)

        # standard notifikation:
        for c in self.children:
            ret = c.on_touch_down(touch)
            if ret:
                break
        return ret

    def on_touch_up(self, touch):
        ret = False
        # standard notifikation:
        for c in self.children:
            ret = c.on_touch_up(touch)
            if ret:
                break

        # multitouch support
        '''
        self.touches = [xx for xx in self.touches if xx != touch]
        print("touches cnt = ",len(self.touches))
        '''
        return ret

    # Menubar:

    def setMenu(self, menu):
        self.menuArea.setMenu(menu)

    def getMenu(self):
        return self.menuArea.getMenu()

    # Toolbar:

    def setTool(self, toolbar, pos=0):
        if (toolbar is not None):
            self.toolBar = toolbar
        self.toolBarPos = pos
        self.rebuildContainer()

    # Workarea:

    def removeContainer(self):
        self.workContainer.clear_widgets()
        self.workContainerO.clear_widgets()

    def buildContainer(self):
        if self.toolBar is not None and self.toolBarPos == 3:
            self.workContainerO.add_widget(self.toolBar)
        self.workContainerO.add_widget(self.workContainer)
        if self.toolBar is not None and self.toolBarPos == 4:
            self.workContainerO.add_widget(self.toolBar)
        for w in self.workStack.items:
            self.workContainer.add_widget(w[1])

    def rebuildContainer(self):
        self.removeContainer()
        self.buildContainer()

    def pushWork(self, key, widget):
        if (widget):
            self.workStack.push(key, widget)
            self.rebuildContainer()

    def popWork(self, key):
        w = None
        if self.workStack.size() > 0:
            w = self.workStack.pop(key)
            self.rebuildContainer()
        return w

    def setWork(self, key, widget):
        self.pushWork(key, widget)

    def getWork(self, key):
        return self.workStack.peek(key)

    def processAndroidBack(self):
        ret = False
        # try to close currently open popup windows, one by one
        r = range(len(self.workStack.items))
        rr = reversed(r)
        for i in rr:
            t = self.workStack.items[i]
            # print("stackkey:  %s" % str(t[0]))
            # print("stackitem: %s" % str(t[1]))
            if t[0] == 'playground':
                pass
            else:
                if isinstance(t[1], LTopLevel):
                    ret = t[1].processAndroidBack()
                if not ret:
                    self.popWork(t[0])
                    ret = True
            if ret:
                break
        return ret

# =============================================================================


class LApp(App):

    # Handling of android return key
    def key_input(self, window, key, scancode, codepoint, modifier):
        if key == 27:
            # Back key of Android.
            lapp = App.get_running_app()
            app = lapp.app
            if app is None:
                return False  # delegate

            # redirect to mainwindow to close popups, tree nodes
            # and html pages.
            if (self.mainWindow.processAndroidBack()):
                return True  # consumed

            # redirect to game to undo last step
            app.menubar.mUndo()
            return True     # consumed
        else:
            return False    # delegate

    def __init__(self):
        super(LApp, self).__init__()

        # Config.set('input', 'multitouchscreen1', 'tuio,0.0.0.0:3333')

        self.mainWindow = LMainWindow()
        logging.info('top = %s' % str(self.mainWindow))
        Cache.register('LAppCache', limit=10)
        Cache.append('LAppCache', 'mainWindow', self.mainWindow, timeout=0)
        Cache.append('LAppCache', 'mainApp', self, timeout=0)
        self.startCode = 0

    # Es gibt hier offensichtlich nur einen Bilschirm mit Höhe und Breite.
    # Alles andere stellt das Betriebssystem zur Verfügung. Wir wissen auch
    # nicht, wie das Gerät gerade orientiert ist, ist nicht unsere Sache.
    # Alles was wir tun können ist Höhe und Breite zu verfolgen, sobald wir
    # dazu informiert werden. (Android informiert leider nicht immer, wenn
    # es nötig wäre).
    # Update:
    # Nachdem im Manifest nun steht 'configChange=...|screenSize' bekommen
    # wir auch nach dem on_resume ein Signal.

    def delayedRebuild(self, dt):
        logging.info("LApp: delayedRebuild")
        self.mainWindow.rebuildContainer()

    def makeDelayedRebuild(self):
        def delayedRebuild(dt):
            # Clock.schedule_once(self.delayedRebuild, 0.01)
            Clock.schedule_once(self.delayedRebuild, 0.5)
        return delayedRebuild

    def doSize(self, obj, val):
        mval = self.mainWindow.size
        if (val[0] != mval[0] and val[1] != mval[1]):
            logging.info("LApp: size changed %s - %s (%s)" % (obj, val, mval))
            Clock.schedule_once(self.makeDelayedRebuild(), 0.01)
        pass

    def on_start(self):
        logging.info('mw = %s,  w = %s' % (self.mainWindow, Window))

        Window.bind(on_keyboard=self.key_input)
        Window.bind(size=self.doSize)

        if self.startCode > 0:
            logging.info("LApp: on_start fails")
            return

        logging.info("LApp: on_start")
        self.mainloop = self.app.mainproc()  # Einrichten
        self.mainloop.send(None)                # Spielprozess starten
        logging.info("LApp: on_start processed")
        # Android: Request missing android permissions.
        requestStoragePerm()

    def on_stop(self):
        # Achtung wird u.U. 2 mal aufgerufen !!!
        logging.info("LApp: on_stop")
        if self.startCode > 0:
            return
        # lapp: erweiterte klasse dieser (mit pysolfc app members).
        lapp = App.get_running_app()
        lapp.app.menubar.mHoldAndQuit()

    def on_pause(self):
        logging.info("LApp: on_pause")
        # return True: wenn wir wirklich in pause gehen. Dann wird auch
        # resume aufgerufen falls die app wieder aktiviert wird.
        # return False: app wird gestoppt (on_stop wird aufgerufen)
        if self.startCode > 0:
            return False

        pauseSupport = True
        # True ist die bessere Variante.

        lapp = App.get_running_app()
        app = lapp.app
        if app is None:
            return

        logging.info("LApp: on_pause - pause on")
        # set pause
        if not app.game.pause:
            app.game.doPause()

        logging.info("LApp: on_pause - savegame")
        # save game
        try:
            app.game.gstats.holded = 1
            app.game._saveGame(app.fn.holdgame)
            app.opt.game_holded = app.game.id
            app.opt.last_gameid = app.game.id
        except Exception:
            traceback.print_exc()
            pass
        # save options
        try:
            app.saveOptions()
        except Exception:
            traceback.print_exc()
            pass
        # save statistics
        try:
            app.saveStatistics()
        except Exception:
            traceback.print_exc()
            pass
        logging.info("LApp: on_pause - gamesaved")

        logging.info("LApp: on_pause, Window.size=%s" % str(Window.size))

        return pauseSupport

    def on_resume(self):
        logging.info("LApp: on_resume")

        lapp = App.get_running_app()
        app = lapp.app
        if app is None:
            return

        so = get_screen_ori()
        go = so  # flake8: F841 nonsense!
        so = go
        logging.info("LApp: on_resume, Window.size=%s" % str(Window.size))
        # ANM:
        # kivy.core.window.Window hat hier u.U. eine falsche dimension
        # und unterscheidet sich vom display (-> in get_screen_ori).
        # Eine korrektur der Parameter von Window kann hier wie skizziert
        # durchgeführt werden und führt auch zu den korrekten 'on_size'
        # Notifikationen. Allerdings wird später (nach diesem Aufruf)
        # eine weitere Notifikation erhalten, welche das Fenster u.U.
        # wieder falsch aufstellt. (woher kommt die und warum ist sie
        # oft falsch ?)

        if app.game.pause:
            Clock.schedule_once(self.makeEndPauseCmd(app), 3.0)

    def makeEndPauseCmd(self, app):
        def endPauseCmd(dt):
            if app.game.pause:
                logging.info("LApp: on_resume - pause off")
                app.game.doPause()
        return endPauseCmd
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
# Copyright (C) 2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

import math
import os
import re

from kivy.event import EventDispatcher
from kivy.properties import BooleanProperty
from kivy.properties import NumericProperty
from kivy.properties import StringProperty

from pysollib.gamedb import GI
from pysollib.kivy.LApp import LMenu
from pysollib.kivy.LApp import LMenuItem
from pysollib.kivy.LApp import LScrollView
from pysollib.kivy.LApp import LTopLevel
from pysollib.kivy.LApp import LTreeNode
from pysollib.kivy.LApp import LTreeRoot
from pysollib.kivy.findcarddialog import destroy_find_card_dialog
from pysollib.kivy.selectcardset import SelectCardsetDialogWithPreview
from pysollib.kivy.selectgame import SelectGameDialog
from pysollib.kivy.solverdialog import connect_game_solver_dialog
from pysollib.kivy.tkconst import CURSOR_WATCH, EVENT_HANDLED, EVENT_PROPAGATE
from pysollib.kivy.tkconst import TOOLBAR_BUTTONS
from pysollib.kivy.tkutil import after_idle
from pysollib.kivy.tkutil import bind
from pysollib.mfxutil import Struct
from pysollib.mygettext import _
from pysollib.pysoltk import MfxMessageDialog
from pysollib.pysoltk import connect_game_find_card_dialog
from pysollib.settings import SELECT_GAME_MENU
from pysollib.settings import TITLE


# ************************************************************************
# * tk emuls:
# ************************************************************************


class TkVarObj(EventDispatcher):
    def __init(self):
        self.value = None

    def set(self, v):
        if v is None:
            if type(self.value) is str:
                v = ''
        self.value = v

    def get(self):
        return self.value


class BooleanVar(TkVarObj):
    value = BooleanProperty(False)


class IntVar(TkVarObj):
    value = NumericProperty(0)


class StringVar(TkVarObj):
    value = StringProperty('')

# ************************************************************************
# * Menu Dialogs
# ************************************************************************


class LMenuDialog(object):

    dialogCache = {}

    def make_pop_command(self, parent, title):
        def pop_command(event):
            print('event = %s' % event)
            parent.popWork(title)
        return pop_command

    def __init__(self, menubar, parent, title, app, **kw):
        super(LMenuDialog, self).__init__()

        self.menubar = menubar
        self.parent = parent
        self.app = app
        self.title = title
        self.window = None
        self.running = False
        self.persist = False
        if 'persist' in kw:
            self.persist = kw['persist']

        # prüfen ob noch aktiv - toggle.

        if parent.workStack.peek(title) is not None:
            parent.popWork(title)
            return

        if self.persist and title in self.dialogCache:
            parent.pushWork(title, self.dialogCache[title])
            return

        pc = self.closeWindow = self.make_pop_command(parent, title)

        # neuen Dialog aufbauen.

        window = LTopLevel(parent, title, **kw)
        window.titleline.bind(on_press=pc)
        self.parent.pushWork(title, window)
        self.window = window
        self.running = True

        if self.persist:
            self.dialogCache[title] = window

        # Tree skelett.

        tv = self.tvroot = LTreeRoot(root_options=dict(text='EditTree'))
        tv.hide_root = True
        tv.size_hint = 1, None
        tv.bind(minimum_height=tv.setter('height'))

        # menupunkte aufbauen.

        self.buildTree(tv, None)

        # tree in einem Scrollwindow präsentieren.

        root = LScrollView(pos=(0, 0))
        root.add_widget(tv)
        self.window.content.add_widget(root)

    def buildTree(self, tree, node):
        print('buildTree base')
        # to implement in dervied class
        pass

# ************************************************************************


class MainMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.2, 1)
        kw['persist'] = True
        super(MainMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_game_command(self, command):
        def game_command():
            command()
            self.closeWindow(0)
        return game_command

    def buildTree(self, tv, node):
        rg = tv.add_node(
            LTreeNode(
                text=_("File"),
                command=self.make_game_command(self.menubar.mFileMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Games"),
                command=self.make_game_command(
                    self.menubar.mSelectGameDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Tools"),
                command=self.make_game_command(self.menubar.mEditMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Statistics"),
                command=self.make_game_command(self.menubar.mGameMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Assist"),
                command=self.make_game_command(
                    self.menubar.mAssistMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Options"),
                command=self.make_game_command(
                    self.menubar.mOptionsMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Help"),
                command=self.make_game_command(self.menubar.mHelpMenuDialog)))
        del rg

# ************************************************************************


class FileMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.3, 1)
        super(FileMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_game_command(self, key, command):
        def game_command():
            command(key)
        return game_command

    def buildTree(self, tv, node):
        rg = tv.add_node(
            LTreeNode(text=_('Recent games')))
        # Recent Liste
        recids = self.app.opt.recent_gameid
        # recgames = []
        for rid in recids:
            gi = self.app.getGameInfo(rid)
            if gi:
                command = self.make_game_command(
                    rid, self.menubar._mSelectGame)
                tv.add_node(
                    LTreeNode(text=gi.name, command=command), rg)

        rg = tv.add_node(
            LTreeNode(text=_('Favorite games')))
        if rg:
            tv.add_node(LTreeNode(
                text=_('<Add>'), command=self.menubar.mAddFavor), rg)
            tv.add_node(LTreeNode(
                text=_('<Remove>'), command=self.menubar.mDelFavor), rg)

            # Recent Liste
            favids = self.app.opt.favorite_gameid
            # favgames = []
            for fid in favids:
                gi = self.app.getGameInfo(fid)
                if gi:
                    command = self.make_game_command(
                        fid, self.menubar._mSelectGame)
                    tv.add_node(
                        LTreeNode(text=gi.name, command=command), rg)

        tv.add_node(LTreeNode(
            text=_('Load'), command=self.menubar.mOpen))
        tv.add_node(LTreeNode(
            text=_('Save'), command=self.menubar.mSaveAs))

        tv.add_node(LTreeNode(
            text=_('Quit'), command=self.menubar.mHoldAndQuit))

# ************************************************************************


class EditMenuDialog(LMenuDialog):  # Tools

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.2, 1)
        kw['persist'] = True
        super(EditMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_auto_command(self, variable, command):
        def auto_command():
            variable.set(not variable.get())
            command()
        return auto_command

    def addCheckNode(self, tv, rg, title, auto_var, auto_com):
        command = self.make_auto_command(auto_var, auto_com)
        rg1 = tv.add_node(
            LTreeNode(text=title, command=command, variable=auto_var), rg)
        return rg1

    def buildTree(self, tv, node):
        tv.add_node(LTreeNode(
            text=_('New game'), command=self.menubar.mNewGame))
        tv.add_node(LTreeNode(
            text=_('Restart game'), command=self.menubar.mRestart))

        tv.add_node(LTreeNode(
            text=_('Undo'), command=self.menubar.mUndo))
        tv.add_node(LTreeNode(
            text=_('Redo'), command=self.menubar.mRedo))
        tv.add_node(LTreeNode(
            text=_('Redo all'), command=self.menubar.mRedoAll))

        tv.add_node(LTreeNode(
            text=_('Auto drop'), command=self.menubar.mDrop))
        tv.add_node(LTreeNode(
            text=_('Shuffle tiles'), command=self.menubar.mShuffle))
        tv.add_node(LTreeNode(
            text=_('Deal cards'), command=self.menubar.mDeal))

        self.addCheckNode(tv, None,
                          _('Pause'),
                          self.menubar.tkopt.pause,
                          self.menubar.mPause)

        tv.add_node(LTreeNode(
            text=_('Load game'), command=self.menubar.mOpen))
        tv.add_node(LTreeNode(
            text=_('Save game'), command=self.menubar.mSaveAs))

        tv.add_node(LTreeNode(
            text=_('Help'), command=self.menubar.mHelpRules))

        # -------------------------------------------
        # TBD ?
        '''
        menu.add_separator()
        submenu = MfxMenu(menu, label=n_("&Set bookmark"))
        for i in range(9):
            label = _("Bookmark %d") % (i + 1)
            submenu.add_command(
                label=label, command=lambda i=i: self.mSetBookmark(i))
        submenu = MfxMenu(menu, label=n_("Go&to bookmark"))
        for i in range(9):
            label = _("Bookmark %d") % (i + 1)
            acc = m + "%d" % (i + 1)
            submenu.add_command(
                label=label,
                command=lambda i=i: self.mGotoBookmark(i),
                accelerator=acc)
        menu.add_command(
            label=n_("&Clear bookmarks"), command=self.mClearBookmarks)
        menu.add_separator()
        '''
        # und solitär wizard (-> custom games).
        '''
        tv.add_node(LTreeNode(
            text='Solitaire &Wizard', command=self.menubar.mWizard))
        tv.add_node(LTreeNode(
                text='Edit current game', command=self.menubar.mWizardEdit))
        '''

# ************************************************************************


class GameMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.2, 1)
        kw['persist'] = True
        super(GameMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_command(self, key, command):
        def stats_command():
            kw = {}
            kw['mode'] = key
            command(**kw)
        return stats_command

    def buildTree(self, tv, node):
        tv.add_node(LTreeNode(
            text=_('Current game...'),
            command=self.make_command(101, self.menubar.mPlayerStats)), None)

        # tv.add_node(LTreeNode(
        #   text='All games ...',
        #   command=self.make_command(102, self.menubar.mPlayerStats)), None)

    # -------------------------------------------
    # TBD ? - just to remember original tk code.
    '''
        menu.add_command(
            label=n_("S&tatus..."),
            command=lambda x: self.mPlayerStats(mode=100), accelerator=m+"Y")
        menu.add_checkbutton(
            label=n_("&Comments..."), variable=self.tkopt.comment,
            command=self.mEditGameComment)
    '''
    '''
        menu.add_separator()
        submenu = MfxMenu(menu, label=n_("&Statistics"))
        submenu.add_command(
            label=n_("Current game..."),
            command=lambda x: self.mPlayerStats(mode=101))
        submenu.add_command(
            label=n_("All games..."),
            command=lambda x: self.mPlayerStats(mode=102))
        submenu.add_separator()
        submenu.add_command(
            label=n_("Session log..."),
            command=lambda x: self.mPlayerStats(mode=104))
        submenu.add_command(
            label=n_("Full log..."),
            command=lambda x: self.mPlayerStats(mode=103))
        submenu.add_separator()
        submenu.add_command(
            label=TOP_TITLE+"...",
            command=lambda x: self.mPlayerStats(mode=105),
            accelerator=m+"T")
        submenu.add_command(
            label=n_("Progression..."),
            command=lambda x: self.mPlayerStats(mode=107))
        submenu = MfxMenu(menu, label=n_("D&emo statistics"))
        submenu.add_command(
            label=n_("Current game..."),
            command=lambda x: self.mPlayerStats(mode=1101))
        submenu.add_command(
            label=n_("All games..."),
            command=lambda x: self.mPlayerStats(mode=1102))
    '''

# ************************************************************************


class AssistMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.2, 1)
        kw['persist'] = True
        super(AssistMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def buildTree(self, tv, node):
        tv.add_node(LTreeNode(
            text=_('Hint'), command=self.menubar.mHint))

        tv.add_node(LTreeNode(
            text=_('Highlight piles'), command=self.menubar.mHighlightPiles))

        # tv.add_node(LTreeNode(
        #   text='Find Card', command=self.menubar.mFindCard))

        tv.add_node(LTreeNode(
            text=_('Demo'), command=self.menubar.mDemo))

        # -------------------------------------------
        # TBD. How ?

        '''
        menu.add_command(
            label=n_("Demo (&all games)"), command=self.mMixedDemo)
        if USE_FREECELL_SOLVER:
            menu.add_command(label=n_("&Solver"), command=self.mSolver)
        else:
            menu.add_command(label=n_("&Solver"), state='disabled')
        menu.add_separator()
        menu.add_command(
            label=n_("&Piles description"),
            command=self.mStackDesk, accelerator="F2")
        '''

# ************************************************************************


class OptionsMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.5, 1)
        kw['persist'] = True
        super(OptionsMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_auto_command(self, variable, command):
        def auto_command():
            variable.set(not variable.get())
            command()
        return auto_command

    def addCheckNode(self, tv, rg, title, auto_var, auto_com):
        command = self.make_auto_command(auto_var, auto_com)
        rg1 = tv.add_node(
            LTreeNode(text=title, command=command, variable=auto_var), rg)
        return rg1

    def make_val_command(self, variable, value, command):
        def val_command():
            variable.set(value)
            command()
        return val_command

    def make_vars_command(self, command, key):
        def vars_command():
            command(key)
        return vars_command

    def addRadioNode(self, tv, rg, title, auto_var, auto_val, auto_com):
        command = self.make_val_command(auto_var, auto_val, auto_com)
        rg1 = tv.add_node(
            LTreeNode(text=title,
                      command=command,
                      variable=auto_var, value=auto_val), rg)
        return rg1

    def buildTree(self, tv, node):

        # -------------------------------------------
        # Automatic play settings

        rg = tv.add_node(
            LTreeNode(text=_('Automatic play')))
        if rg:
            self.addCheckNode(tv, rg,
                              _('Auto face up'),
                              self.menubar.tkopt.autofaceup,
                              self.menubar.mOptAutoFaceUp)

            self.addCheckNode(tv, rg,
                              _('Auto drop'),
                              self.menubar.tkopt.autodrop,
                              self.menubar.mOptAutoDrop)

            self.addCheckNode(tv, rg,
                              _('Auto deal'),
                              self.menubar.tkopt.autodeal,
                              self.menubar.mOptAutoDeal)

            # submenu.add_separator()

            self.addCheckNode(tv, rg,
                              _('Quick play'),
                              self.menubar.tkopt.quickplay,
                              self.menubar.mOptQuickPlay)

        # -------------------------------------------
        # Player assistance

        rg = tv.add_node(
            LTreeNode(text=_('Assist level')))
        if rg:
            self.addCheckNode(tv, rg,
                              _('Enable undo'),
                              self.menubar.tkopt.undo,
                              self.menubar.mOptEnableUndo)

            self.addCheckNode(tv, rg,
                              _('Enable bookmarks'),
                              self.menubar.tkopt.bookmarks,
                              self.menubar.mOptEnableBookmarks)

            self.addCheckNode(tv, rg,
                              _('Enable hint'),
                              self.menubar.tkopt.hint,
                              self.menubar.mOptEnableHint)

            self.addCheckNode(tv, rg,
                              _('Enable shuffle'),
                              self.menubar.tkopt.shuffle,
                              self.menubar.mOptEnableShuffle)

            self.addCheckNode(tv, rg,
                              _('Enable highlight piles'),
                              self.menubar.tkopt.highlight_piles,
                              self.menubar.mOptEnableHighlightPiles)

            self.addCheckNode(tv, rg,
                              _('Enable highlight cards'),
                              self.menubar.tkopt.highlight_cards,
                              self.menubar.mOptEnableHighlightCards)

            self.addCheckNode(tv, rg,
                              _('Enable highlight same rank'),
                              self.menubar.tkopt.highlight_samerank,
                              self.menubar.mOptEnableHighlightSameRank)

            self.addCheckNode(tv, rg,
                              _('Highlight no matching'),
                              self.menubar.tkopt.highlight_not_matching,
                              self.menubar.mOptEnableHighlightNotMatching)

            # submenu.add_separator()

            self.addCheckNode(tv, rg,
                              _('Show removed tiles (in Mahjongg games)'),
                              self.menubar.tkopt.mahjongg_show_removed,
                              self.menubar.mOptMahjonggShowRemoved)

            self.addCheckNode(tv, rg,
                              _('Show hint arrow (in Shisen-Sho games)'),
                              self.menubar.tkopt.shisen_show_hint,
                              self.menubar.mOptShisenShowHint)

            # submenu.add_separator()

        # -------------------------------------------
        # Language options

        rg = tv.add_node(
            LTreeNode(text=_('Language')))
        if rg:
            self.addRadioNode(tv, rg,
                              _('Default'),
                              self.menubar.tkopt.language, '',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('English'),
                              self.menubar.tkopt.language, 'en',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('German'),
                              self.menubar.tkopt.language, 'de',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('Italian'),
                              self.menubar.tkopt.language, 'it',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('Polish'),
                              self.menubar.tkopt.language, 'pl',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('Russian'),
                              self.menubar.tkopt.language, 'ru',
                              self.menubar.mOptLanguage)

        # -------------------------------------------
        # Sound options

        rg = tv.add_node(
            LTreeNode(text=_('Sound')))
        if rg:
            self.addCheckNode(tv, rg,
                              _('Enable'),
                              self.menubar.tkopt.sound,
                              self.menubar.mOptSoundDialog)

            rg1 = tv.add_node(
                LTreeNode(text=_('Volume')), rg)
            if rg1:
                self.addRadioNode(tv, rg1,
                                  _('100%'),
                                  self.menubar.tkopt.sound_sample_volume, 100,
                                  self.menubar.mOptSoundSampleVol)
                self.addRadioNode(tv, rg1,
                                  _('75%'),
                                  self.menubar.tkopt.sound_sample_volume, 75,
                                  self.menubar.mOptSoundSampleVol)
                self.addRadioNode(tv, rg1,
                                  _('50%'),
                                  self.menubar.tkopt.sound_sample_volume, 50,
                                  self.menubar.mOptSoundSampleVol)
                self.addRadioNode(tv, rg1,
                                  _('25%'),
                                  self.menubar.tkopt.sound_sample_volume, 25,
                                  self.menubar.mOptSoundSampleVol)

            rg1 = tv.add_node(
                LTreeNode(text=_('Samples')), rg)
            if rg1:
                key = 'areyousure'
                self.addCheckNode(
                    tv, rg1,
                    _('are you sure'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'autodrop'
                self.addCheckNode(
                    tv, rg1,
                    _('auto drop'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'autoflip'
                self.addCheckNode(
                    tv, rg1,
                    _('auto flip'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'autopilotlost'
                self.addCheckNode(
                    tv, rg1,
                    _('auto pilot lost'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'autopilotwon'
                self.addCheckNode(
                    tv, rg1,
                    _('auto pilot won'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'deal'
                self.addCheckNode(
                    tv, rg1,
                    _('deal'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'dealwaste'
                self.addCheckNode(
                    tv, rg1,
                    _('deal waste'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'droppair'
                self.addCheckNode(
                    tv, rg1,
                    _('drop pair'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'drop'
                self.addCheckNode(
                    tv, rg1,
                    _('drop'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'flip'
                self.addCheckNode(
                    tv, rg1,
                    _('flip'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'move'
                self.addCheckNode(
                    tv, rg1,
                    _('move'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'nomove'
                self.addCheckNode(
                    tv, rg1,
                    _('no move'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'redo'
                self.addCheckNode(
                    tv, rg1,
                    _('redo'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'startdrag'
                self.addCheckNode(
                    tv, rg1,
                    _('start drag'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'turnwaste'
                self.addCheckNode(
                    tv, rg1,
                    _('turn waste'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'undo'
                self.addCheckNode(
                    tv, rg1,
                    _('undo'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'gamefinished'
                self.addCheckNode(
                    tv, rg1,
                    _('game finished'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'gamelost'
                self.addCheckNode(
                    tv, rg1,
                    _('game lost'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'gameperfect'
                self.addCheckNode(
                    tv, rg1,
                    _('game perfect'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'gamewon'
                self.addCheckNode(
                    tv, rg1,
                    _('game won'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))

        # -------------------------------------------
        # Cardsets and card backside options

        rg = tv.add_node(
            LTreeNode(text=_('Cardsets')))
        if rg:
            self.menubar.tkopt.cardset.set(self.app.cardset.index)

            csm = self.app.cardset_manager
            # cnt = csm.len()
            i = 0
            while 1:
                cs = csm.get(i)
                if cs is None:
                    break
                rg1 = self.addRadioNode(tv, rg,
                                        cs.name,
                                        self.menubar.tkopt.cardset, i,
                                        self.menubar.mOptCardset)
                if rg1:
                    cbs = cs.backnames
                    self.menubar.tkopt.cardbacks[i] = IntVar()
                    self.menubar.tkopt.cardbacks[i].set(cs.backindex)

                    bcnt = len(cbs)
                    bi = 0
                    while 1:
                        if bi == bcnt:
                            break
                        cb = cbs[bi]
                        self.addRadioNode(
                            tv, rg1,
                            cb,
                            self.menubar.tkopt.cardbacks[i], bi,
                            self.make_vars_command(
                                self.menubar.mOptSetCardback, i))
                        bi += 1

                i += 1

        # -------------------------------------------
        # Table background settings

        rg = tv.add_node(
            LTreeNode(text=_('Table')))
        if rg:
            rg1 = tv.add_node(
                LTreeNode(text=_('Solid colors')), rg)
            if rg1:
                key = 'table'
                self.addRadioNode(
                    tv, rg1,
                    _('Blue'),
                    self.menubar.tkopt.color_vars[key], '#0082df',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Green'),
                    self.menubar.tkopt.color_vars[key], '#008200',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Navy'),
                    self.menubar.tkopt.color_vars[key], '#000086',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Olive'),
                    self.menubar.tkopt.color_vars[key], '#868200',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Orange'),
                    self.menubar.tkopt.color_vars[key], '#f79600',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Teal'),
                    self.menubar.tkopt.color_vars[key], '#008286',
                    self.menubar.mOptTableColor)

            rg1 = tv.add_node(
                LTreeNode(text=_('Tiles and Images')), rg)

            if rg1:
                tm = self.app.tabletile_manager
                # cnt = tm.len()
                i = 1
                while True:
                    ti = tm.get(i)
                    if ti is None:
                        break
                    self.addRadioNode(tv, rg1,
                                      ti.name,
                                      self.menubar.tkopt.tabletile, i,
                                      self.menubar.mOptTileSet)
                    i += 1

        # -------------------------------------------
        # Card view options

        rg = tv.add_node(
            LTreeNode(text=_('Card view')))
        if rg:
            self.addCheckNode(tv, rg,
                              _('Card shadow'),
                              self.menubar.tkopt.shadow,
                              self.menubar.mOptShadow)

            self.addCheckNode(tv, rg,
                              _('Shade legal moves'),
                              self.menubar.tkopt.shade,
                              self.menubar.mOptShade)

            self.addCheckNode(tv, rg,
                              _('Negative cards bottom'),
                              self.menubar.tkopt.negative_bottom,
                              self.menubar.mOptNegativeBottom)

            self.addCheckNode(tv, rg,
                              _('Shrink face-down cards'),
                              self.menubar.tkopt.shrink_face_down,
                              self.menubar.mOptShrinkFaceDown)

            self.addCheckNode(tv, rg,
                              _('Shade filled stacks'),
                              self.menubar.tkopt.shade_filled_stacks,
                              self.menubar.mOptShadeFilledStacks)

        # -------------------------------------------
        # Animation settins

        rg = tv.add_node(
            LTreeNode(text=_('Animations')))
        if rg:
            self.addRadioNode(tv, rg,
                              _('None'),
                              self.menubar.tkopt.animations, 0,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Very fast'),
                              self.menubar.tkopt.animations, 1,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Fast'),
                              self.menubar.tkopt.animations, 2,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Medium'),
                              self.menubar.tkopt.animations, 3,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Slow'),
                              self.menubar.tkopt.animations, 4,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Very slow'),
                              self.menubar.tkopt.animations, 5,
                              self.menubar.mOptAnimations)

            # submenu.add_separator()

            self.addCheckNode(tv, rg,
                              _('Redeal animation'),
                              self.menubar.tkopt.redeal_animation,
                              self.menubar.mRedealAnimation)

            self.addCheckNode(tv, rg,
                              _('Winning animation'),
                              self.menubar.tkopt.win_animation,
                              self.menubar.mWinAnimation)

        # -------------------------------------------
        # Touch mode settings

        rg = tv.add_node(
            LTreeNode(text=_('Touch mode')))
        if rg:
            self.addRadioNode(tv, rg,
                              _('Drag-and-Drop'),
                              self.menubar.tkopt.mouse_type, 'drag-n-drop',
                              self.menubar.mOptMouseType)

            self.addRadioNode(tv, rg,
                              _('Point-and-Click'),
                              self.menubar.tkopt.mouse_type, 'point-n-click',
                              self.menubar.mOptMouseType)

            # sinnlos mit touch-device:
            # self.addRadioNode(tv, rg,
            #   'Sticky mouse',
            #   self.menubar.tkopt.mouse_type, u'sticky-mouse',
            #   self.menubar.mOptMouseType)

            # submenu.add_separator()

            # sinnlos mit touch-device:
            # self.addCheckNode(tv, rg,
            #   'Use mouse for undo/redo',
            #   self.menubar.tkopt.mouse_undo,
            #   self.menubar.mOptMouseUndo)

        # submenu.add_separator()

        # -------------------------------------------
        # TBD ?

        '''
        menu.add_command(label=n_("&Fonts..."), command=self.mOptFonts)
        menu.add_command(label=n_("&Colors..."), command=self.mOptColors)
        menu.add_command(label=n_("Time&outs..."), command=self.mOptTimeouts)
        menu.add_separator()
        '''

        # -------------------------------------------
        # Toolbar options

        rg = tv.add_node(
            LTreeNode(text=_('Toolbar')))
        if rg:
            self.addRadioNode(tv, rg,
                              _('Hide'),
                              self.menubar.tkopt.toolbar, 0,
                              self.menubar.mOptToolbar)

            # not supported: Top, Bottom
            # self.addRadioNode(tv, rg,
            #   'Top',
            #   self.menubar.tkopt.toolbar, 1,
            #   self.menubar.mOptToolbar)
            # self.addRadioNode(tv, rg,
            #   'Bottom',
            #   self.menubar.tkopt.toolbar, 2,
            #   self.menubar.mOptToolbar)

            self.addRadioNode(tv, rg,
                              _('Left'),
                              self.menubar.tkopt.toolbar, 3,
                              self.menubar.mOptToolbar)
            self.addRadioNode(tv, rg,
                              _('Right'),
                              self.menubar.tkopt.toolbar, 4,
                              self.menubar.mOptToolbar)

        # -------------------------------------------
        # Statusbar - not implemented

        '''
        submenu = MfxMenu(menu, label=n_("Stat&usbar"))
        submenu.add_checkbutton(
             label=n_("Show &statusbar"),
             variable=self.tkopt.statusbar,
             command=self.mOptStatusbar)
        submenu.add_checkbutton(
            label=n_("Show &number of cards"),
            variable=self.tkopt.num_cards,
            command=self.mOptNumCards)
        submenu.add_checkbutton(
            label=n_("Show &help bar"),
            variable=self.tkopt.helpbar,
            command=self.mOptHelpbar)
        '''

        # -------------------------------------------
        # general options

        # self.addCheckNode(tv, None,
        #   'Save games geometry',
        #   self.menubar.tkopt.save_games_geometry,
        #   self.menubar.mOptSaveGamesGeometry)

        # self.addCheckNode(tv, None,
        #   'Demo logo',
        #   self.menubar.tkopt.demo_logo,
        #   self.menubar.mOptDemoLogo)

        self.addCheckNode(tv, None,
                          _('Startup splash screen'),
                          self.menubar.tkopt.splashscreen,
                          self.menubar.mOptSplashscreen)

        self.addCheckNode(tv, None,
                          _('Winning splash'),
                          self.menubar.tkopt.display_win_message,
                          self.menubar.mWinDialog)


# ************************************************************************


class HelpMenuDialog(LMenuDialog):
    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.3, 1)
        kw['persist'] = True
        super(HelpMenuDialog, self).__init__(menubar, parent, title, app, **kw)

    def make_help_command(self, command):
        def help_command():
            command()
            self.closeWindow(0)
        return help_command

    def buildTree(self, tv, node):
        tv.add_node(
            LTreeNode(
                text=_('Contents'),
                command=self.make_help_command(self.menubar.mHelp)))
        tv.add_node(
            LTreeNode(
                text=_('How to play'),
                command=self.make_help_command(self.menubar.mHelpHowToPlay)))
        tv.add_node(
            LTreeNode(
                text=_('Rules for this game'),
                command=self.make_help_command(self.menubar.mHelpRules)))
        tv.add_node(
            LTreeNode(
                text=_('License terms'),
                command=self.make_help_command(self.menubar.mHelpLicense)))
        tv.add_node(
            LTreeNode(
                text=_('About %s...') % TITLE,
                command=self.make_help_command(self.menubar.mHelpAbout)))

        # tv.add_node(LTreeNode(
        #   text='AboutKivy ...',
        #   command=self.makeHtmlCommand(self.menubar, "kivy.html")))

    def makeHtmlCommand(self, bar, htmlfile):
        def htmlCommand():
            bar.mHelpHtml(htmlfile)

        return htmlCommand


# ************************************************************************
# *
# ************************************************************************


class EmulTkMenu(object):

    def __init__(self, master, **kw):

        self.name = kw["name"]
        self.n = 0
        self._w = None
        if (self.name):
            if master._w == '.':
                self._w = '.' + self.name
            else:
                self._w = master._w + '.' + self.name
        else:
            self.name = "<>"

    def labeltoname(self, label):
        name = re.sub(r"[^0-9a-zA-Z]", "", label).lower()
        label = _(label)
        underline = label.find('&')
        if underline >= 0:
            label = label.replace('&', '')
        return name, label, underline

    def add_cascade(self, cnf={}, **kw):
        self.add('cascade', cnf or kw)
        pass

    def add(self, itemType, cnf={}):
        label = cnf.get("label")
        if label:
            name = cnf.get('name')
            if name:
                name, label, underline = self.labeltoname(label)
                cnf["underline"] = cnf.get("underline", underline)
                cnf["label"] = label
                if name and self.addPath:
                    path = str(self._w) + "." + name
                    self.addPath(path, self, self.n, cnf.get("menu"))

    def cget(self, key):
        return key

# ************************************************************************


class MfxMenubar(EmulTkMenu):
    addPath = None

    def __init__(self, master, **kw):
        super(MfxMenubar, self).__init__(master, **kw)
        topmenu = self.name == 'menubar'

        self.menu = LMenu(not topmenu, text=self.name)
        if topmenu:
            master.setMenu(self.menu)

# ************************************************************************
# * - create menubar
# * - update menubar
# * - menu actions
# ************************************************************************


class PysolMenubarTk:
    def __init__(self, app, top, progress=None):
        self._createTkOpt()
        self._setOptions()
        # init columnbreak
#        self.__cb_max = int(self.top.winfo_screenheight()/23)
        self.__cb_max = 8
#         sh = self.top.winfo_screenheight()
#         self.__cb_max = 22
#         if sh >= 600: self.__cb_max = 27
#         if sh >= 768: self.__cb_max = 32
#         if sh >= 1024: self.__cb_max = 40
        self.progress = progress
        # create menus
        self.__menubar = None
        self.__menupath = {}
        self.__keybindings = {}
        self._createMenubar()
        self.top = top

        if self.progress:
            self.progress.update(step=1)

        # set the menubar
        # self.updateBackgroundImagesMenu()
        # self.top.config(menu=self.__menubar)

    def _createTkOpt(self):
        # structure to convert menu-options to Toolkit variables
        self.tkopt = Struct(
            gameid=IntVar(),
            gameid_popular=IntVar(),
            comment=BooleanVar(),
            autofaceup=BooleanVar(),
            autodrop=BooleanVar(),
            autodeal=BooleanVar(),
            quickplay=BooleanVar(),
            undo=BooleanVar(),
            bookmarks=BooleanVar(),
            hint=BooleanVar(),
            shuffle=BooleanVar(),
            highlight_piles=BooleanVar(),
            highlight_cards=BooleanVar(),
            highlight_samerank=BooleanVar(),
            highlight_not_matching=BooleanVar(),
            mahjongg_show_removed=BooleanVar(),
            shisen_show_hint=BooleanVar(),
            sound=BooleanVar(),
            sound_sample_volume=IntVar(),
            sound_music_volume=IntVar(),
            cardback=IntVar(),
            tabletile=IntVar(),
            animations=IntVar(),
            redeal_animation=BooleanVar(),
            win_animation=BooleanVar(),
            shadow=BooleanVar(),
            shade=BooleanVar(),
            shade_filled_stacks=BooleanVar(),
            shrink_face_down=BooleanVar(),
            toolbar=IntVar(),
            toolbar_style=StringVar(),
            toolbar_relief=StringVar(),
            toolbar_compound=StringVar(),
            toolbar_size=IntVar(),
            statusbar=BooleanVar(),
            num_cards=BooleanVar(),
            helpbar=BooleanVar(),
            save_games_geometry=BooleanVar(),
            splashscreen=BooleanVar(),
            demo_logo=BooleanVar(),
            mouse_type=StringVar(),
            mouse_undo=BooleanVar(),
            negative_bottom=BooleanVar(),
            display_win_message=BooleanVar(),
            pause=BooleanVar(),
            cardset=IntVar(),
            cardbacks={},
            toolbar_vars={},
            sound_sample_vars={},
            color_vars={},
            language=StringVar(),
        )
        for w in TOOLBAR_BUTTONS:
            self.tkopt.toolbar_vars[w] = BooleanVar()
        for k in self.app.opt.sound_samples:
            self.tkopt.sound_sample_vars[k] = BooleanVar()
        for k in self.app.opt.colors:
            self.tkopt.color_vars[k] = StringVar()

    def _setOptions(self):
        tkopt, opt = self.tkopt, self.app.opt
        # set state of the menu items
        tkopt.autofaceup.set(opt.autofaceup)
        tkopt.autodrop.set(opt.autodrop)
        tkopt.autodeal.set(opt.autodeal)
        tkopt.quickplay.set(opt.quickplay)
        tkopt.undo.set(opt.undo)
        tkopt.hint.set(opt.hint)
        tkopt.shuffle.set(opt.shuffle)
        tkopt.bookmarks.set(opt.bookmarks)
        tkopt.highlight_piles.set(opt.highlight_piles)
        tkopt.highlight_cards.set(opt.highlight_cards)
        tkopt.highlight_samerank.set(opt.highlight_samerank)
        tkopt.highlight_not_matching.set(opt.highlight_not_matching)
        tkopt.shrink_face_down.set(opt.shrink_face_down)
        tkopt.shade_filled_stacks.set(opt.shade_filled_stacks)
        tkopt.mahjongg_show_removed.set(opt.mahjongg_show_removed)
        tkopt.shisen_show_hint.set(opt.shisen_show_hint)
        tkopt.sound.set(opt.sound)
        tkopt.sound_sample_volume.set(opt.sound_sample_volume)
        tkopt.sound_music_volume.set(opt.sound_music_volume)
        tkopt.cardback.set(self.app.cardset.backindex)
        tkopt.tabletile.set(self.app.tabletile_index)
        tkopt.animations.set(opt.animations)
        tkopt.redeal_animation.set(opt.redeal_animation)
        tkopt.win_animation.set(opt.win_animation)
        tkopt.shadow.set(opt.shadow)
        tkopt.shade.set(opt.shade)
        tkopt.toolbar.set(opt.toolbar)
        tkopt.toolbar_style.set(opt.toolbar_style)
        tkopt.toolbar_relief.set(opt.toolbar_relief)
        tkopt.toolbar_compound.set(opt.toolbar_compound)
        tkopt.toolbar_size.set(opt.toolbar_size)
        tkopt.toolbar_relief.set(opt.toolbar_relief)
        tkopt.statusbar.set(opt.statusbar)
        tkopt.num_cards.set(opt.num_cards)
        tkopt.helpbar.set(opt.helpbar)
        tkopt.save_games_geometry.set(opt.save_games_geometry)
        tkopt.demo_logo.set(opt.demo_logo)
        tkopt.splashscreen.set(opt.splashscreen)
        tkopt.mouse_type.set(opt.mouse_type)
        tkopt.mouse_undo.set(opt.mouse_undo)
        tkopt.negative_bottom.set(opt.negative_bottom)
        tkopt.display_win_message.set(opt.display_win_message)
        tkopt.cardset.set(self.app.cardset_manager.getSelected())
        tkopt.language.set(opt.language)

        for w in TOOLBAR_BUTTONS:
            tkopt.toolbar_vars[w].set(opt.toolbar_vars.get(w, False))
        for k in self.app.opt.sound_samples:
            self.tkopt.sound_sample_vars[k].set(
                opt.sound_samples.get(k, False))
        for k in self.app.opt.colors:
            self.tkopt.color_vars[k].set(opt.colors.get(k, '#000000'))

    def connectGame(self, game):
        self.game = game
        if game is None:
            return
        assert self.app is game.app
        tkopt = self.tkopt
        # opt = self.app.opt
        tkopt.gameid.set(game.id)
        tkopt.gameid_popular.set(game.id)
        tkopt.comment.set(bool(game.gsaveinfo.comment))
        tkopt.pause.set(self.game.pause)
        if game.canFindCard():
            connect_game_find_card_dialog(game)
        else:
            destroy_find_card_dialog()
        connect_game_solver_dialog(game)

    # create a GTK-like path
    def _addPath(self, path, menu, index, submenu):
        # print ('MfxMenubar: _addPath %s, %s' % (path, menu))
        # y = self.yy
        if path not in self.__menupath:
            # print path, menu, index, submenu
            self.__menupath[path] = (menu, index, submenu)

    def _getEnabledState(self, enabled):
        print('_getEnabledState: %s' % enabled)
        if enabled:
            return "normal"
        return "disabled"

    def updateProgress(self):
        if self.progress:
            self.progress.update(step=1)

    #
    # create the menubar
    #

    def _createMenubar(self):
        MfxMenubar.addPath = self._addPath
        kw = {"name": "menubar"}
        self.__menubar = MfxMenubar(self.top, **kw)

        # init keybindings
        bind(self.top, "<KeyPress>", self._keyPressHandler)

        # LMainMenuDialog()
        LMenuItem(self.__menubar.menu,
                  text=_("Menu"), command=self.mMainMenuDialog)

        MfxMenubar.addPath = None

    #
    # key binding utility
    #

    def _bindKey(self, modifier, key, func):
        #         if 0 and not modifier and len(key) == 1:
        #             self.__keybindings[key.lower()] = func
        #             self.__keybindings[key.upper()] = func
        #             return
        if not modifier and len(key) == 1:
            # ignore Ctrl/Shift/Alt
            # but don't ignore NumLock (state == 16)
            def lfunc(e, func=func):
                return e.state in (0, 16) and func(e)
            func = lfunc
            # func = lambda e, func=func: e.state in (0, 16) and func(e)
        sequence = "<" + modifier + "KeyPress-" + key + ">"
        bind(self.top, sequence, func)
        if len(key) == 1 and key != key.upper():
            key = key.upper()
            sequence = "<" + modifier + "KeyPress-" + key + ">"
            bind(self.top, sequence, func)

    def _keyPressHandler(self, event):
        r = EVENT_PROPAGATE
        if event and self.game:
            # print event.__dict__
            if self.game.demo:
                # stop the demo by setting self.game.demo.keypress
                if event.char:    # ignore Ctrl/Shift/etc.
                    self.game.demo.keypress = event.char
                    r = EVENT_HANDLED
#             func = self.__keybindings.get(event.char)
#             if func and (event.state & ~2) == 0:
#                 func(event)
#                 r = EVENT_HANDLED
        return r

    #
    # Select Game menu creation
    #
    '''
    def _addSelectGameMenu(self, menu):
        games = map(self.app.gdb.get, self.app.gdb.getGamesIdSortedByName())
        m = "Ctrl-"
        if sys.platform == "darwin":
            m = "Cmd-"
        menu.add_command(label=n_("All &games..."), accelerator=m + "W",
                         command=self.mSelectGameDialog)

    def _addSelectGameSubMenu(self, games, menu, select_data,
                              command, variable):
        # print select_data
        need_sep = 0
        for label, select_func in select_data:
            if label is None:
                need_sep = 1
                continue
            g = filter(select_func, games)
            if not g:
                continue
            if need_sep:
                menu.add_separator()
                need_sep = 0
            submenu = MfxMenu(menu, label=label)
            self._addSelectGameSubSubMenu(g, submenu, command, variable)

    def _getNumGames(self, games, select_data):
        ngames = 0
        for label, select_func in select_data:
            ngames += len(filter(select_func, games))
        return ngames

    def _addSelectMahjonggGameSubMenu(self, games, menu, command, variable):
        def select_func(gi): return gi.si.game_type == GI.GT_MAHJONGG
        mahjongg_games = filter(select_func, games)
        if len(mahjongg_games) == 0:
            return
        #
        menu = MfxMenu(menu, label=n_("&Mahjongg games"))

        def add_menu(games, c0, c1, menu=menu,
                     variable=variable, command=command):
            if not games:
                return
            label = c0 + ' - ' + c1
            if c0 == c1:
                label = c0
            submenu = MfxMenu(menu, label=label, name=None)
            self._addSelectGameSubSubMenu(games, submenu, command,
                                          variable, short_name=True)

        games = {}
        for gi in mahjongg_games:
            c = gi.short_name.strip()[0]
            if c in games:
                games[c].append(gi)
            else:
                games[c] = [gi]
        games = games.items()
        games.sort()
        g0 = []
        c0 = c1 = games[0][0]
        for c, g1 in games:
            if len(g0) + len(g1) >= self.__cb_max:
                add_menu(g0, c0, c1)
                g0 = g1
                c0 = c1 = c
            else:
                g0 += g1
                c1 = c
        add_menu(g0, c0, c1)

    def _addSelectPopularGameSubMenu(self, games, menu, command, variable):
        def select_func(gi): return gi.si.game_flags & GI.GT_POPULAR
        if len(filter(select_func, games)) == 0:
            return
        data = (n_("&Popular games"), select_func)
        self._addSelectGameSubMenu(games, menu, (data, ),
                                   self.mSelectGamePopular,
                                   self.tkopt.gameid_popular)

    def _addSelectFrenchGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&French games"))
        self._addSelectGameSubMenu(games, submenu, GI.SELECT_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectOrientalGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_ORIENTAL_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&Oriental games"))
        self._addSelectGameSubMenu(games, submenu,
                                   GI.SELECT_ORIENTAL_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectSpecialGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_ORIENTAL_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&Special games"))
        self._addSelectGameSubMenu(games, submenu,
                                   GI.SELECT_SPECIAL_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectCustomGameSubMenu(self, games, menu, command, variable):
        submenu = MfxMenu(menu, label=n_("&Custom games"))

        def select_func(gi): return gi.si.game_type == GI.GT_CUSTOM
        games = filter(select_func, games)
        self.updateGamesMenu(submenu, games)
    '''

    def _addSelectAllGameSubMenu(self, games, menu, command, variable):
        # LB
        # herausgenommen: zu aufwendig !
        return
        '''
        menu = MfxMenu(menu, label=n_("&All games by name"))
        n, d = 0, self.__cb_max
        i = 0
        while True:
            if self.progress:
                self.progress.update(step=1)
            columnbreak = i > 0 and (i % d) == 0
            i += 1
            if not games[n:n + d]:
                break
            m = min(n + d - 1, len(games) - 1)
            label = games[n].name[:3] + ' - ' + games[m].name[:3]

            submenu = MfxMenu(menu, label=label, name=None)
            self._addSelectGameSubSubMenu(games[n:n + d], submenu,
                                          command, variable)
            n += d
            # if columnbreak:
            #    menu.entryconfigure(i, columnbreak=columnbreak)
        '''

    # Eine 'closure' in Python? - voila!
    def make_gamesetter(self, n, variable, command):
        def gamesetter(x):
            variable.set(n)
            command()
        return gamesetter

    def _addSelectGameSubSubMenu(self, games, menu, command, variable,
                                 short_name=False):

        # cb = self.__cb_max
        for i in range(len(games)):
            gi = games[i]
            # columnbreak = i > 0 and (i % cb) == 0
            if short_name:
                label = gi.short_name
            else:
                label = gi.name

            # optimized by inlining

            # geht nicht mehr 'optimiert' mit kivy
            # die Funktionalität des tk.calls kann mit hilfe
            # einer 'closure' rekonstruiert werden (s.o).
            # LB

            gsetter = self.make_gamesetter(gi.id, variable, command)
            menu.add_command(label=label, command=gsetter)

            # menu.tk.call((menu._w, 'add', 'radiobutton') +
            #             menu._options({'command': command,
            #                            'variable': variable,
            #                            'columnbreak': columnbreak,
            #                            'value': gi.id,
            #                            'label': label}))

    def updateGamesMenu(self, menu, games):

        def cmp2(a, b):
            """python 3 replacement for python 2 cmp function"""
            return (a > b) - (a < b)

        menu.delete(0, 'last')

        if len(games) == 0:
            menu.add_radiobutton(label=_('<none>'), name=None,
                                 state='disabled')
        elif len(games) > self.__cb_max * 4:
            games.sort(lambda a, b: cmp2(a.name, b.name))
            self._addSelectAllGameSubMenu(games, menu,
                                          command=self.mSelectGame,
                                          variable=self.tkopt.gameid)
        else:
            self._addSelectGameSubSubMenu(games, menu,
                                          command=self.mSelectGame,
                                          variable=self.tkopt.gameid)

    def mMainMenuDialog(self, *event):
        MainMenuDialog(self, self.top, title=_("Main Menu"), app=self.app)
        return EVENT_HANDLED

    def mFileMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        FileMenuDialog(self, self.top, title=_("File Menu"), app=self.app)
        return EVENT_HANDLED

    def mEditMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        EditMenuDialog(self, self.top, title=_("Tools"), app=self.app)
        return EVENT_HANDLED

    def mGameMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        GameMenuDialog(self, self.top, title=_("Statistics"), app=self.app)
        return EVENT_HANDLED

    def mAssistMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        AssistMenuDialog(self, self.top, title=_("Assists"), app=self.app)
        return EVENT_HANDLED

    def mOptionsMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        OptionsMenuDialog(self, self.top, title=_("Options"), app=self.app)
        return EVENT_HANDLED

    def mHelpMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        HelpMenuDialog(self, self.top, title=_("Help"), app=self.app)
        return EVENT_HANDLED
    #
    # Select Game menu actions
    #

    def mSelectGame(self, *args):
        print('mSelectGame %s' % self)
        self._mSelectGame(self.tkopt.gameid.get())

    def mSelectGamePopular(self, *args):
        self._mSelectGame(self.tkopt.gameid_popular.get())

    def _mSelectGameDialog(self, d):
        if d.gameid != self.game.id:
            self.tkopt.gameid.set(d.gameid)
            self.tkopt.gameid_popular.set(d.gameid)
            self._cancelDrag()
            self.game.endGame()
            self.game.quitGame(d.gameid, random=d.random)
        return EVENT_HANDLED

    def __restoreCursor(self, *event):
        self.game.setCursor(cursor=self.app.top_cursor)

    def mSelectGameDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        d = SelectGameDialog(self.top, title=_("Select game"),
                             app=self.app, gameid=self.game.id)
        return self._mSelectGameDialog(d)

    #
    # menubar overrides
    #

    def updateFavoriteGamesMenu(self):
        return

        # TBD ?
        '''
        gameids = self.app.opt.favorite_gameid

        print('favorite_gameids = %s' % gameids)

        submenu = self.__menupath[".menubar.file.favoritegames"][2]
        games = []
        for id in gameids:
            gi = self.app.getGameInfo(id)
            if gi:
                games.append(gi)
        self.updateGamesMenu(submenu, games)

        # das folgende ist nur das enable/disable des add/remove buttons.
        # geht mit kivy nicht so.

#        state = self._getEnabledState
#        in_favor = self.app.game.id in gameids

# menu, index, submenu = self.__menupath[".menubar.file.addtofavorites"]
# menu.entryconfig(index, state=state(not in_favor))

# menu, index, submenu = self.__menupath[".menubar.file.removefromfavorites"]
# menu.entryconfig(index, state=state(in_favor))
        '''

    def updateRecentGamesMenu(self, gameids):
        return

        # TBD ?
        '''
        submenu = self.__menupath[".menubar.file.recentgames"][2]
        games = []
        for id in gameids:
            gi = self.app.getGameInfo(id)
            if gi:
                games.append(gi)
        self.updateGamesMenu(submenu, games)
        '''

    def updateBookmarkMenuState(self):
        # LB:
        print('updateBookmarkMenuState - fake')
        return

        state = self._getEnabledState
        mp1 = self.__menupath.get(".menubar.edit.setbookmark")
        mp2 = self.__menupath.get(".menubar.edit.gotobookmark")
        mp3 = self.__menupath.get(".menubar.edit.clearbookmarks")
        if mp1 is None or mp2 is None or mp3 is None:
            return
        x = self.app.opt.bookmarks and self.game.canSetBookmark()
        #
        menu, index, submenu = mp1
        for i in range(9):
            submenu.entryconfig(i, state=state(x))
        menu.entryconfig(index, state=state(x))
        #
        menu, index, submenu = mp2
        ms = 0
        for i in range(9):
            s = self.game.gsaveinfo.bookmarks.get(i) is not None
            submenu.entryconfig(i, state=state(s and x))
            ms = ms or s
        menu.entryconfig(index, state=state(ms and x))
        #
        menu, index, submenu = mp3
        menu.entryconfig(index, state=state(ms and x))

    def updateBackgroundImagesMenu(self):
        # LB:
        print('updateBackgroundImagesMenu - fake')
        return

        mp = self.__menupath.get(".menubar.options.cardbackground")
        # delete all entries
        submenu = mp[2]
        submenu.delete(0, "last")
        # insert new cardbacks
        mbacks = self.app.images.getCardbacks()
        cb = int(math.ceil(math.sqrt(len(mbacks))))
        for i in range(len(mbacks)):
            columnbreak = i > 0 and (i % cb) == 0
            submenu.add_radiobutton(
                    label=mbacks[i].name,
                    image=mbacks[i].menu_image,
                    variable=self.tkopt.cardback,
                    value=i,
                    command=self.mOptCardback,
                    columnbreak=columnbreak,
                    indicatoron=0,
                    hidemargin=0)
    #
    # menu updates
    #

    def setMenuState(self, state, path):
        # LB: not used
        return

    def setToolbarState(self, state, path):
        # LB: not used
        return

    def _setCommentMenu(self, v):
        self.tkopt.comment.set(v)

    def _setPauseMenu(self, v):
        self.tkopt.pause.set(v)

    #
    # menu actions
    #

    DEFAULTEXTENSION = ".pso"
    # TRANSLATORS: Usually, 'PySol files'
    FILETYPES = ((_("%s files") % TITLE, "*" + DEFAULTEXTENSION),
                 (_("All files"), "*"))

    def mAddFavor(self, *event):
        gameid = self.app.game.id
        if gameid not in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.append(gameid)
            self.updateFavoriteGamesMenu()

    def mDelFavor(self, *event):
        gameid = self.app.game.id
        if gameid in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.remove(gameid)
            self.updateFavoriteGamesMenu()

    def mOpen(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        # filename = self.game.filename
        filename = "lastgame.pso"
        if filename:
            idir, ifile = os.path.split(os.path.normpath(filename))
        else:
            idir, ifile = "", ""
        if not idir:
            idir = self.app.dn.savegames
#        d = tkFileDialog.Open()
#        filename = d.show(filetypes=self.FILETYPES,
#                          defaultextension=self.DEFAULTEXTENSION,
#                          initialdir=idir, initialfile=ifile)
        filename = idir + "/" + ifile

        print('filename = %s' % filename)
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            if os.path.isfile(filename):
                self.game.loadGame(filename)

    def mSaveAs(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.menustate.save_as:
            return
        # filename = self.game.filename
        filename = "lastgame.pso"
        if not filename:
            filename = self.app.getGameSaveName(self.game.id)
            if os.name == "posix":
                filename = filename + "-" + self.game.getGameNumber(format=0)
            elif os.path.supports_unicode_filenames:  # new in python 2.3
                filename = filename + "-" + self.game.getGameNumber(format=0)
            else:
                filename = filename + "-01"
            filename = filename + self.DEFAULTEXTENSION
        idir, ifile = os.path.split(os.path.normpath(filename))
        if not idir:
            idir = self.app.dn.savegames
        # print self.game.filename, ifile
        # d = tkFileDialog.SaveAs()
        # filename = d.show(filetypes=self.FILETYPES,
        #                  defaultextension=self.DEFAULTEXTENSION,
        #                  initialdir=idir, initialfile=ifile)
        filename = idir + "/" + ifile
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            self.game.saveGame(filename)
            self.updateMenus()

    def mPause(self, *args):
        if not self.game:
            return
        if not self.game.pause:
            if self._cancelDrag():
                return
        self.game.doPause()
        self.tkopt.pause.set(self.game.pause)

    def mOptLanguage(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.language = self.tkopt.language.get()
        MfxMessageDialog(
           self.app.top, title=_("Note"),
           text=_("""\
These settings will take effect
the next time you restart the %(app)s""") % {'app': TITLE})

    def mOptSoundDialog(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.sound = self.tkopt.sound.get()

    def mOptSoundSampleVol(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.sound_sample_volume = self.tkopt.sound_sample_volume.get()

    def mOptSoundMusicVol(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.sound_music_volume = self.tkopt.sound_music_volume.get()

    def mOptSoundSample(self, key, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.sound_samples[key] = \
            self.tkopt.sound_sample_vars[key].get()

    def mOptTableColor(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        nv = self.tkopt.color_vars['table'].get()
        ov = self.app.opt.colors['table']
        self.app.opt.colors['table'] = nv
        if ov != nv:
            self.app.top_bg = nv
            self.app.tabletile_index = 0
            self.app.setTile(0, force=True)
            self.tkopt.tabletile.set(0)

    def mOptTileSet(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        idx = self.tkopt.tabletile.get()
        if idx > 0 and idx != self.app.tabletile_index:
            self.app.setTile(idx)
            self.tkopt.color_vars['table'].set('#008285')

    def mOptAutoFaceUp(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autofaceup = self.tkopt.autofaceup.get()
        if self.app.opt.autofaceup:
            self.game.autoPlay()

    def mOptAutoDrop(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autodrop = self.tkopt.autodrop.get()
        if self.app.opt.autodrop:
            self.game.autoPlay()

    def mOptAutoDeal(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autodeal = self.tkopt.autodeal.get()
        if self.app.opt.autodeal:
            self.game.autoPlay()

    def mOptQuickPlay(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.quickplay = self.tkopt.quickplay.get()

    def mOptEnableUndo(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.undo = self.tkopt.undo.get()
        self.game.updateMenus()

    def mOptEnableBookmarks(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.bookmarks = self.tkopt.bookmarks.get()
        self.game.updateMenus()

    def mOptEnableHint(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.hint = self.tkopt.hint.get()
        self.game.updateMenus()

    def mOptEnableShuffle(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shuffle = self.tkopt.shuffle.get()
        self.game.updateMenus()

    def mOptEnableHighlightPiles(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_piles = self.tkopt.highlight_piles.get()
        self.game.updateMenus()

    def mOptEnableHighlightCards(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_cards = self.tkopt.highlight_cards.get()
        self.game.updateMenus()

    def mOptEnableHighlightSameRank(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_samerank = self.tkopt.highlight_samerank.get()
        # self.game.updateMenus()

    def mOptEnableHighlightNotMatching(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_not_matching = \
            self.tkopt.highlight_not_matching.get()
        # self.game.updateMenus()

    def mOptAnimations(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.animations = self.tkopt.animations.get()

    def mRedealAnimation(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.redeal_animation = self.tkopt.redeal_animation.get()

    def mWinAnimation(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.win_animation = self.tkopt.win_animation.get()

    def mWinDialog(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.display_win_message = self.tkopt.display_win_message.get()

    def mOptShadow(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shadow = self.tkopt.shadow.get()

    def mOptShade(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shade = self.tkopt.shade.get()

    def mOptShrinkFaceDown(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shrink_face_down = self.tkopt.shrink_face_down.get()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptShadeFilledStacks(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shade_filled_stacks = self.tkopt.shade_filled_stacks.get()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptMahjonggShowRemoved(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.mahjongg_show_removed = \
            self.tkopt.mahjongg_show_removed.get()
        # self.game.updateMenus()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptShisenShowHint(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shisen_show_hint = self.tkopt.shisen_show_hint.get()
        # self.game.updateMenus()

    def mOptCardset(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        idx = self.tkopt.cardset.get()
        cs = self.app.cardset_manager.get(idx)
        if cs is None or idx == self.app.cardset.index:
            return
        if idx >= 0:
            self.app.nextgame.cardset = cs
            self._cancelDrag()
            self.game.endGame(bookmark=1)
            self.game.quitGame(bookmark=1)

    def mSelectCardsetDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        # strings, default = ("&OK", "&Load", "&Cancel"), 0
        strings, default = (None, _("&Load"), _("&Cancel"), ), 1
        # if os.name == "posix":
        strings, default = (None, _("&Load"), _(
            "&Cancel"), _("&Info..."), ), 1
        key = self.app.nextgame.cardset.index
        d = SelectCardsetDialogWithPreview(
                self.top, title=_("Select cardset"),
                app=self.app, manager=self.app.cardset_manager, key=key,
                strings=strings, default=default)

        cs = self.app.cardset_manager.get(d.key)
        if cs is None or d.key == self.app.cardset.index:
            return
        if d.status == 0 and d.button in (0, 1) and d.key >= 0:
            self.app.nextgame.cardset = cs
            if d.button == 1:
                self._cancelDrag()
                self.game.endGame(bookmark=1)
                self.game.quitGame(bookmark=1)

    def mOptSetCardback(self, key, *event):
        val = self.tkopt.cardbacks[key].get()
        cs = self.app.cardset_manager.get(key)
        cs.updateCardback(backindex=val)
        # ANM: wir können den Background nur für das aktuell
        # selektierte Cardset wirklich ändern. Nur dieses wird
        # wird in den Optionen gespeichert.
        if (cs == self.app.cardset):
            self.app.updateCardset(self.game.id)
            self.app.cardset.backindex = val
            image = self.app.images.getBack(update=True)
            for card in self.game.cards:
                card.updateCardBackground(image=image)
            self.app.canvas.update_idletasks()

    def _mOptCardback(self, index):
        if self._cancelDrag(break_pause=False):
            return
        cs = self.app.cardset
        old_index = cs.backindex
        cs.updateCardback(backindex=index)
        if cs.backindex == old_index:
            return
        self.app.updateCardset(self.game.id)
        image = self.app.images.getBack(update=True)
        for card in self.game.cards:
            card.updateCardBackground(image=image)
        self.app.canvas.update_idletasks()
        self.tkopt.cardback.set(cs.backindex)

    def mOptCardback(self, *event):
        self._mOptCardback(self.tkopt.cardback.get())

    def mOptChangeCardback(self, *event):
        self._mOptCardback(self.app.cardset.backindex + 1)

    def mOptToolbar(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarSide(self.tkopt.toolbar.get())

    def mOptToolbarStyle(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarStyle(self.tkopt.toolbar_style.get())

    def mOptToolbarCompound(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarCompound(self.tkopt.toolbar_compound.get())

    def mOptToolbarSize(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarSize(self.tkopt.toolbar_size.get())

    def mOptToolbarRelief(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarRelief(self.tkopt.toolbar_relief.get())

    def mOptToolbarConfig(self, w):
        self.toolbarConfig(w, self.tkopt.toolbar_vars[w].get())

    def mOptStatusbar(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.app.statusbar:
            return
        side = self.tkopt.statusbar.get()
        self.app.opt.statusbar = side
        resize = not self.app.opt.save_games_geometry
        if self.app.statusbar.show(side, resize=resize):
            self.top.update_idletasks()

    def mOptNumCards(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.num_cards = self.tkopt.num_cards.get()

    def mOptHelpbar(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.app.helpbar:
            return
        show = self.tkopt.helpbar.get()
        self.app.opt.helpbar = show
        resize = not self.app.opt.save_games_geometry
        if self.app.helpbar.show(show, resize=resize):
            self.top.update_idletasks()

    def mOptSaveGamesGeometry(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.save_games_geometry = self.tkopt.save_games_geometry.get()

    def mOptDemoLogo(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.demo_logo = self.tkopt.demo_logo.get()

    def mOptSplashscreen(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.splashscreen = self.tkopt.splashscreen.get()

    def mOptMouseType(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.mouse_type = self.tkopt.mouse_type.get()

    def mOptMouseUndo(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.mouse_undo = self.tkopt.mouse_undo.get()

    def mOptNegativeBottom(self, *event):
        if self._cancelDrag():
            return
        self.app.opt.negative_bottom = self.tkopt.negative_bottom.get()
        self.app.updateCardset()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    #
    # toolbar support
    #

    def setToolbarSide(self, side):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar = side
        self.tkopt.toolbar.set(side)                    # update radiobutton
        resize = not self.app.opt.save_games_geometry
        if self.app.toolbar.show(side, resize=resize):
            self.top.update_idletasks()

    def setToolbarSize(self, size):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_size = size
        self.tkopt.toolbar_size.set(size)                # update radiobutton
        dir = self.app.getToolbarImagesDir()
        if self.app.toolbar.updateImages(dir, size):
            self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarStyle(self, style):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_style = style
        # update radiobutton
        self.tkopt.toolbar_style.set(style)
        dir = self.app.getToolbarImagesDir()
        size = self.app.opt.toolbar_size
        if self.app.toolbar.updateImages(dir, size):
            # self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarCompound(self, compound):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_compound = compound
        self.tkopt.toolbar_compound.set(
            compound)          # update radiobutton
        if self.app.toolbar.setCompound(compound):
            self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarRelief(self, relief):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_relief = relief
        self.tkopt.toolbar_relief.set(relief)           # update radiobutton
        self.app.toolbar.setRelief(relief)
        self.top.update_idletasks()

    def toolbarConfig(self, w, v):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_vars[w] = v
        self.app.toolbar.config(w, v)
        self.top.update_idletasks()

    #
    # stacks descriptions
    #

    def mStackDesk(self, *event):
        if self.game.stackdesc_list:
            self.game.deleteStackDesc()
        else:
            if self._cancelDrag(break_pause=True):
                return
            self.game.showStackDesc()

    def wizardDialog(self, edit=False):
        from pysollib.wizardutil import write_game, reset_wizard
        from wizarddialog import WizardDialog

        if edit:
            reset_wizard(self.game)
        else:
            reset_wizard(None)
        d = WizardDialog(self.top, _('Solitaire Wizard'), self.app)
        if d.status == 0 and d.button == 0:
            try:
                if edit:
                    gameid = write_game(self.app, game=self.game)
                else:
                    gameid = write_game(self.app)
            except Exception:
                return
            if SELECT_GAME_MENU:
                menu = self.__menupath[".menubar.select.customgames"][2]

                def select_func(gi): return gi.si.game_type == GI.GT_CUSTOM
                games = map(self.app.gdb.get,
                            self.app.gdb.getGamesIdSortedByName())
                games = filter(select_func, games)
                self.updateGamesMenu(menu, games)

            self.tkopt.gameid.set(gameid)
            self._mSelectGame(gameid, force=True)

    def mWizard(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.wizardDialog()

    def mWizardEdit(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.wizardDialog(edit=True)


'''
'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
# import os

# Toolkit imports
from pysollib.pysoltk import MfxScrolledCanvas


# ************************************************************************
# *
# ************************************************************************


class MfxTreeBaseNode:
    def __init__(self, tree, parent_node, text, key):
        self.tree = tree
        self.parent_node = parent_node
        self.text = text
        self.key = key
        # state
        self.selected = 0
        self.subnodes = None
        # canvas item ids
        self.symbol_id = None
        self.text_id = None
        self.textrect_id = None

    def registerKey(self):
        if self.key is not None:
            lk = self.tree.keys.get(self.key, [])
            lk.append(self)
            self.tree.keys[self.key] = lk

    def whoami(self):
        if self.parent_node is None:
            return (self.text, )
        else:
            return self.parent_node.whoami() + (self.text, )

    # drawing functions not used with kivy.
    '''
    def draw(self, x, y, lastx=None, lasty=None):
        canvas, style = self.tree.canvas, self.tree.style
        topleftx = x + style.distx
        toplefty = y - style.height / 2  # +++
        # draw the horizontal line
        if lastx is not None:
            canvas.create_line(x, y, topleftx, y,
                               stipple=style.linestyle, fill=style.linecolor)
        # draw myself - ugly, ugly...
        self.selected = 0
        self.symbol_id = -1
        self.drawSymbol(topleftx, toplefty)
        linestart = style.distx + style.width + 5
        self.text_id = -1
        self.drawText(x + linestart, y)
        return x, y, x, y + style.disty

    #
    #
    #

    def drawText(self, x, y):
        canvas, style = self.tree.canvas, self.tree.style
        if self.selected:
            fg, bg = style.text_selected_fg, style.text_selected_bg
        else:
            fg, bg = style.text_normal_fg, style.text_normal_bg
        #
        if self.tree.nodes.get(self.text_id) is self:
            canvas.itemconfig(self.text_id, fill=fg)
        else:
            # note: I don't use Label + canvas.create_window here
            #   because it doesn't propagate events to the canvas
            #   and has some other re-display annoyances
            # print 'style.font:', style.font
            self.text_id = canvas.create_text(x + 1, y, text=self.text,
                                              anchor="w", justify="left",
                                              font=style.font,
                                              fill=fg)
            self.tree.nodes[self.text_id] = self
        #
        if self.tree.nodes.get(self.textrect_id) is self:
            try:
                # _tkinter.TclError: unknown option "-fill" ???
                canvas.itemconfig(self.textrect_id, fill=bg)
            except Tkinter.TclError:
                pass
        elif self.selected:
            b = canvas.bbox(self.text_id)
            self.textrect_id = canvas.create_rectangle(
                b[0] - 1, b[1] - 1, b[2] + 1, b[3] + 1, fill=bg, outline="")
            canvas.tag_lower(self.textrect_id, self.text_id)
            self.tree.nodes[self.textrect_id] = self

    def updateText(self):
        if self.tree.nodes.get(self.text_id) is self:
            self.drawText(-1, -1)

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        canvas, style = self.tree.canvas, self.tree.style
        color = kw.get("color")
        if color is None:
            if self.selected:
                color = "darkgreen"
            else:
                color = "green"
        # note: rectangle outline is one pixel
        if self.tree.nodes.get(self.symbol_id) is self:
            canvas.itemconfig(self.symbol_id, fill=color)
        else:
            self.symbol_id = canvas.create_rectangle(
                x + 1, y + 1, x + style.width, y + style.height, fill=color)
            self.tree.nodes[self.symbol_id] = self

    def updateSymbol(self):
        if self.tree.nodes.get(self.symbol_id) is self:
            self.drawSymbol(-1, -1)
    '''

# ************************************************************************
# * Terminal and non-terminal nodes
# ************************************************************************


class MfxTreeLeaf(MfxTreeBaseNode):
    def drawText(self, x, y):
        if self.text_id < 0:
            self.registerKey()
        MfxTreeBaseNode.drawText(self, x, y)


class MfxTreeNode(MfxTreeBaseNode):
    def __init__(self, tree, parent_node, text, key, expanded=0):
        MfxTreeBaseNode.__init__(self, tree, parent_node, text, key)
        self.expanded = expanded

    def drawChildren(self, x, y, lastx, lasty):
        # get subnodes
        self.subnodes = self.tree.getContents(self)
        # draw subnodes
        lx, ly = lastx, lasty
        nx, ny = x, y
        for node in self.subnodes:
            # update tree
            node.tree = self.tree
            # draw node
            lx, ly, nx, ny = node.draw(nx, ny, lx, ly)
        # draw the vertical line
        if self.subnodes:
            style = self.tree.style
            dy = (style.disty - style.width) / 2
            y = y - style.disty / 2 - dy
            self.tree.canvas.create_line(x, y, nx, ly,
                                         stipple=style.linestyle,
                                         fill=style.linecolor)
        return ny

    def draw(self, x, y, ilastx=None, ilasty=None):
        # draw myself
        lx, ly, nx, ny = MfxTreeBaseNode.draw(self, x, y, ilastx, ilasty)
        if self.expanded:
            style = self.tree.style
            childx = nx + style.distx + style.width / 2
            childy = ny
            clastx = nx + style.distx + style.width / 2
            clasty = ly + style.height / 2
            ny = self.drawChildren(childx, childy, clastx, clasty)
        return lx, ly, x, ny

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        color = kw.get("color")
        if color is None:
            if self.expanded:
                color = "red"
            else:
                color = "pink"
        MfxTreeBaseNode.drawSymbol(self, x, y, color=color)


# ************************************************************************
# *
# ************************************************************************

class MfxTreeInCanvas(MfxScrolledCanvas):
    pass
    '''
    class Style:
        def __init__(self):
            self.distx = 16
            self.disty = 18
            self.width = 16         # width of symbol
            self.height = 16        # height of symbol
            self.originx = 0
            self.originy = 0
            self.text_normal_fg = "black"
            self.text_normal_bg = "white"
            self.text_selected_fg = "white"
            self.text_selected_bg = "#00008b"       # "darkblue"
            self.font = None
            self.linestyle = "gray50"
            self.linecolor = "black"

    def __init__(self, parent, rootnodes, **kw):
        # LB bg = kw["bg"] = kw.get("bg") or parent.cget("bg")
        kw['bd'] = 0
        MfxScrolledCanvas.__init__(self, parent, **kw)
        #
        self.rootnodes = rootnodes
        self.updateNodesWithTree(self.rootnodes, self)
        self.selection_key = None
        self.nodes = {}
        self.keys = {}
        #
        self.style = self.Style()
        # self.style.text_normal_fg = self.canvas.cget("insertbackground")
        self.style.text_normal_fg = self.canvas.option_get(
            'foreground', '') or self.canvas.cget("insertbackground")
        self.style.text_normal_bg = bg
        #
        bind(self.canvas, "<ButtonPress-1>", self.singleClick)
        bind(self.canvas, "<Double-Button-1>", self.doubleClick)
        # bind(self.canvas, "<ButtonRelease-1>", xxx)
        self.pack(fill='both', expand=True)

    def destroy(self):
        for node in self.keys.get(self.selection_key, []):
            node.selected = 0
        MfxScrolledCanvas.destroy(self)

    def findNode(self, event=None):
        id = self.canvas.find_withtag('current')
        if id:
            return self.nodes.get(id[0])
        return None

    #
    # draw nodes
    #

    def draw(self):
        nx, ny = self.style.originx, self.style.originy
        # Account for initial offsets, see topleft[xy] in BaseNode.draw().
        # We do this so that our bounding box always starts at (0, 0)
        # and the yscrollincrement works nicely.
        nx = nx - self.style.distx
        ny = ny + self.style.height / 2
        for node in self.rootnodes:
            # update tree
            node.tree = self
            # draw
            try:
                lx, ly, nx, ny = node.draw(nx, ny, None, None)
            except Tkinter.TclError:
                # FIXME: Tk bug ???
                raise
        # set scroll region
        bbox = self.canvas.bbox("all")
        # self.canvas.config(scrollregion=bbox)
        self.canvas.config(scrollregion=(0, 0, bbox[2], bbox[3]))
        self.canvas.config(yscrollincrement=self.style.disty)

    def clear(self):
        self.nodes = {}
        self.keys = {}
        self.canvas.delete("all")

    def redraw(self):
        oldcur = self.canvas["cursor"]
        self.canvas["cursor"] = "watch"
        self.canvas.update_idletasks()
        self.clear()
        self.draw()
        self.updateSelection(self.selection_key)
        self.canvas["cursor"] = oldcur

    #
    #
    #

    def getContents(self, node):
        # Overload this, supposed to return a list of subnodes of node.
        pass

    def singleClick(self, event=None):
        # Overload this if you want to know when a node is clicked on.
        pass

    def doubleClick(self, event=None):
        # Overload this if you want to know when a node is d-clicked on.
        self.singleClick(event)

    #
    #
    #

    def updateSelection(self, key):
        l1 = self.keys.get(self.selection_key, [])
        l2 = self.keys.get(key, [])
        for node in l1:
            if node.selected and node not in l2:
                node.selected = 0
                node.updateSymbol()
                node.updateText()
        for node in l2:
            if not node.selected:
                node.selected = 1
                node.updateSymbol()
                node.updateText()
        self.selection_key = key

    def updateNodesWithTree(self, nodes, tree):
        for node in nodes:
            node.tree = tree
            if node.subnodes:
                self.updateNodesWithTree(node.subnodes, tree)
    '''

# ************************************************************************
# *
# ************************************************************************


'''
class DirectoryBrowser(MfxTreeInCanvas):
    def __init__(self, parent, dirs):
        nodes = []
        if isinstance(dirs, str):
            dirs = (dirs, )
        for dir in dirs:
            self.addNode(nodes, None, dir, dir)
        # note: best results if height is a multiple of style.disty
        MfxTreeInCanvas.__init__(self, parent, nodes, height=25 * 18)
        self.draw()

    def addNode(self, list, node, filename, text):
        try:
            if os.path.isdir(filename):
                list.append(MfxTreeNode(self, node, text, key=filename))
            else:
                list.append(MfxTreeLeaf(self, node, text, key=filename))
        except EnvironmentError:
            pass

    def getContents(self, node):
        # use cached values
        if node.subnodes is not None:
            return node.subnodes
        #
        dir = node.key
        print "Getting %s" % dir
        try:
            filenames = os.listdir(dir)
            filenames.sort()
        except EnvironmentError:
            return ()
        contents = []
        for filename in filenames:
            self.addNode(contents, node, os.path.join(
                dir, filename), filename)
        # print "gotten"
        return contents

    def singleClick(self, event=None):
        node = self.findNode(event)
        if not node:
            return
        print "Clicked node %s %s" % (node.text, node.key)
        if isinstance(node, MfxTreeLeaf):
            self.updateSelection(key=node.key)
        elif isinstance(node, MfxTreeNode):
            node.expanded = not node.expanded
            self.redraw()
        return "break"
'''

if __name__ == "__main__":
    '''
    tk = Tkinter.Tk()
    if os.name == "nt":
        app = DirectoryBrowser(tk, ("c:\\", "c:\\windows"))
    else:
        app = DirectoryBrowser(tk, ("/", "/home"))
    tk.mainloop()
    '''
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
# import os
# import traceback

# PySol imports

# Toolkit imports
# from tkutil import after, after_cancel
# from tkutil import bind, unbind_destroy, makeImage
# from tkcanvas import MfxCanvas, MfxCanvasGroup
# from tkcanvas import MfxCanvasImage, MfxCanvasRectangle

# from pysollib.settings import TITLE

# ************************************************************************
# *
# ************************************************************************

LARGE_EMBLEMS_SIZE = (38, 34)
SMALL_EMBLEMS_SIZE = (31, 21)


find_card_dialog = None


def create_find_card_dialog(parent, game, dir):
    pass
    '''
    global find_card_dialog
    try:
        find_card_dialog.wm_deiconify()
        find_card_dialog.tkraise()
    except:
        # traceback.print_exc()
        find_card_dialog = FindCardDialog(parent, game, dir)
    '''


def connect_game_find_card_dialog(game):
    pass
    '''
    try:
        find_card_dialog.connectGame(game)
    except:
        pass
    '''


def destroy_find_card_dialog():
    pass
    '''
    global find_card_dialog
    try:
        find_card_dialog.destroy()
    except:
        # traceback.print_exc()
        pass
    find_card_dialog = None
    '''


'''
'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# *
# ************************************************************************
# not supported.


class FontsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from pysollib.acard import AbstractCard
from pysollib.kivy.LApp import LImage
from pysollib.kivy.LApp import LImageItem
from pysollib.kivy.tkcanvas import MfxCanvasGroup, MfxCanvasImage


class _HideableCard(AbstractCard):
    def hide(self, stack):
        if stack is self.hide_stack:
            return
        self.item.config(state="hidden")
        self.hide_stack = stack
        # print "hide:", self.id, self.item.coords()

    def unhide(self):
        if self.hide_stack is None:
            return 0
        # print "unhide:", self.id, self.item.coords()
        self.item.config(state="normal")
        self.hide_stack = None
        return 1

    # moveBy aus Basisklasse überschreiben.
    def moveBy(self, dx, dy):
        # wir verwenden direkt den float Wert.
        if dx or dy:
            self.x = self.x + dx
            self.y = self.y + dy
            self.item.move(dx, dy)


# ************************************************************************
# * New implemetation since 2.10
# *
# * We use a single CanvasImage and call CanvasImage.config() to
# * turn the card.
# * This makes turning cards a little bit slower, but dragging cards
# * around is noticeable faster as the total number of images is
# * reduced by half.
# ************************************************************************
# * Kivy Implementation
# * Wir verwenden ein BoxLayout und installieren je nach Status das
# * face oder das back Image.
# ************************************************************************


class _OneImageCard(_HideableCard):
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)

        fimage = game.getCardFaceImage(deck, suit, rank)
        bimage = game.getCardBackImage(deck, suit, rank)

        self._face_image = LImage(texture=fimage.texture)
        self._back_image = LImage(texture=bimage.texture)
        # self._face_image = Image(source=fimage.source)
        # self._back_image = Image(source=bimage.source)
        self._shade_image = game.getCardShadeImage()

        aimage = LImageItem(
            pos=(x, -y), size=self._face_image.size, game=game, card=self)
        aimage.add_widget(self._back_image)
        self._active_image = aimage

        self.item = MfxCanvasImage(
            game.canvas, self.x, self.y, image=aimage, anchor="nw")
        self.shade_item = None

        # print ('card: face = %s xy=%s/%s' % (self._face_image.source, x, y))
        # print ('card: back = %s xy=%s/%s' % (self._back_image.source, x, y))
        # y = self.yy

    def _setImage(self, image):
        self._active_image.clear_widgets()
        self._active_image.add_widget(image)

    def showFace(self, unhide=1):
        # print ('card: showFace = %s' % self._face_image.source)
        if not self.face_up:
            self._setImage(image=self._face_image)
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        # print ('card: showBack = %s' % self._back_image.source)
        if self.face_up:
            self._setImage(image=self._back_image)
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        print('card: updateCardBackground = %s' % image.source)
        self._back_image = LImage(texture=image.texture)
        if not self.face_up:
            self._setImage(image=self._back_image)

    def setSelected(self, s, group=None):
        print('card: setselected(%s, %s)' % (s, group))
        # wird nicht bedient.
        pass

    def animatedMove(self, dx, dy, duration=0.2):
        self.item.animatedMove(dx, dy, duration)

# ************************************************************************
# * New idea since 3.00
# *
# * Hide a card by configuring the canvas image to None.
# ************************************************************************


class _OneImageCardWithHideByConfig(_OneImageCard):
    def hide(self, stack):
        if stack is self.hide_stack:
            return
        self._setImage(image=None)
        self.hide_stack = stack

    def unhide(self):
        if self.hide_stack is None:
            return 0
        if self.face_up:
            self._setImage(image=self._face_image)
        else:
            self._setImage(image=self._back_image)
        self.hide_stack = None
        return 1

    #
    # much like in _OneImageCard
    #

    def showFace(self, unhide=1):
        if not self.face_up:
            if unhide:
                self._setImage(image=self._face_image)
            self.item.tkraise()
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            if unhide:
                self._setImage(image=self._back_image)
            self.item.tkraise()
            self.face_up = 0

    def updateCardBackground(self, image):
        self._back_image = image
        if not self.face_up and not self.hide_stack:
            self._setImage(image=image)


# ************************************************************************
# * Old implemetation prior to 2.10
# *
# * The card consists of two CanvasImages. To show the card face up,
# * the face item is placed in front of the back. To show it face
# * down, this is reversed.
# ************************************************************************


class _TwoImageCard(_HideableCard):
    # Private instance variables:
    #   __face, __back -- the canvas items making up the card
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self.item = MfxCanvasGroup(game.canvas)
        self.__face = MfxCanvasImage(
            game.canvas, self.x, self.y,
            image=game.getCardFaceImage(deck, suit, rank), anchor="nw")
        self.__back = MfxCanvasImage(
            game.canvas, self.x, self.y,
            image=game.getCardBackImage(deck, suit, rank), anchor="nw")
        self.__face.addtag(self.item)
        self.__back.addtag(self.item)

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__face.tkraise()
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__back.tkraise()
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back.config(image=image)


# ************************************************************************
# * New idea since 2.90
# *
# * The card consists of two CanvasImages. Instead of raising
# * one image above the other we move the inactive image out
# * of the visible canvas.
# ************************************************************************


class _TwoImageCardWithHideItem(_HideableCard):
    # Private instance variables:
    #   __face, __back -- the canvas items making up the card
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self.item = MfxCanvasGroup(game.canvas)
        self.__face = MfxCanvasImage(
            game.canvas, self.x, self.y + 11000,
            image=game.getCardFaceImage(deck, suit, rank), anchor="nw")
        self.__back = MfxCanvasImage(
            game.canvas, self.x, self.y,
            image=game.getCardBackImage(deck, suit, rank), anchor="nw")
        self.__face.addtag(self.item)
        self.__back.addtag(self.item)

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__back.move(0, 10000)
            # self.__face.tkraise()
            self.__face.move(0, -11000)
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__face.move(0, 11000)
            # self.__back.tkraise()
            self.__back.move(0, -10000)
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back.config(image=image)


# choose the implementation
# Card = _TwoImageCardWithHideItem
# Card = _TwoImageCard
# Card = _OneImageCardWithHideByConfig
Card = _OneImageCard


'''end of file'''
import logging
try:
    import jnius
except ImportError:
    jnius = None

# link address of related support library:
# https://maven.google.com/com/android/support/support-v4/24.1.1/support-v4-24.1.1.aar

# inspired by stackoverflow.com/questions/47510030/
# as functools (reduce,partial,map) do not seem to work in python3 on android,
# implemented in a classic functional way.
# LB190927.
# wait loop removed. (Implement it in external code if needed.)
# LB191011.


class AndroidPerms(object):
    def __init__(self):
        if jnius is None:
            return
        self.PythonActivity = jnius.autoclass(
            'org.kivy.android.PythonActivity')
        self.Compat = jnius.autoclass(
            'android.support.v4.content.ContextCompat')
        self.currentActivity = jnius.cast(
            'android.app.Activity', self.PythonActivity.mActivity)

    def getPerm(self, permission):
        if jnius is None:
            return True
        p = self.Compat.checkSelfPermission(self.currentActivity, permission)
        return p == 0

    # check actual permissions
    def getPerms(self, permissions):
        if jnius is None:
            return True
        haveperms = True
        for perm in permissions:
            haveperms = haveperms and self.getPerm(perm)
        return haveperms

    # invoke the permissions dialog
    def requestPerms(self, permissions):
        if jnius is None:
            return True
        logging.info("androidperms: invoke permission dialog")
        self.currentActivity.requestPermissions(permissions, 0)
        return


def getStoragePerm():
    ap = AndroidPerms()
    return ap.getPerms(
        ["android.permission.WRITE_EXTERNAL_STORAGE"])


def requestStoragePerm():
    ap = AndroidPerms()
    # ap.requestPerms(
    #    ["android.permission.READ_EXTERNAL_STORAGE","android.permission.WRITE_EXTERNAL_STORAGE"])
    ap.requestPerms(
        ["android.permission.WRITE_EXTERNAL_STORAGE"])
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from kivy.uix.popup import Popup

# ************************************************************************
# * a simple progress bar
# ************************************************************************
# not really supportable with kivy. dummy def.


class PysolProgressBar(Popup):
    def __init__(self, app, parent, title=None, images=None, color="blue",
                 width=300, height=25, show_text=1, norm=1):
        self.percent = 100
        return

    def update(self, **kw):
        return

    def destroy(self):
        return

    def reset(self, percent=0):
        return
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
# Copyright (C) 2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#
# Note:
# Many classes or some methods of classes are dead code resulting from the tk
# implementation. If executed it would throw exceptions.
#
# Kivy Implementation used: MfxScrolledCanvas, MfxDialog (partly)

from __future__ import division

import logging

from kivy.clock import Clock
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.label import Label

from pysollib.kivy.LApp import LBoxLayout
from pysollib.kivy.LApp import LImage
from pysollib.kivy.LApp import LScrollView
from pysollib.kivy.LApp import LTopLevel
from pysollib.kivy.tkcanvas import MfxCanvas
from pysollib.kivy.tkutil import bind, unbind_destroy
from pysollib.kivy.tkutil import makeToplevel
from pysollib.mfxutil import KwStruct, kwdefault
from pysollib.mygettext import _
from pysollib.settings import WIN_SYSTEM

# ************************************************************************
# * abstract base class for the dialogs in this module
# ************************************************************************


class MfxDialog:  # ex. _ToplevelDialog
    img = {}
    button_img = {}

    def __init__(self, parent, title="", resizable=False, default=-1):
        self.parent = parent
        self.status = 0
        self.button = default
        self.timer = None
        self.buttons = []
        self.accel_keys = {}
        self.top = makeToplevel(parent, title=title)

    def wmDeleteWindow(self, *event):
        self.status = 1
        raise SystemExit
        # return EVENT_HANDLED

    def mCancel(self, *event):
        self.status = 1
        raise SystemExit

    def mTimeout(self, *event):
        self.status = 2
        raise SystemExit

    def mDone(self, button):
        self.button = button
        raise SystemExit

    def altKeyEvent(self, event):
        key = event.char
        # key = unicode(key, 'utf-8')
        key = key.lower()
        button = self.accel_keys.get(key)
        if button is not None:
            self.mDone(button)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      timeout=0, resizable=False,
                      text="", justify="center",
                      strings=(_("&OK"), ),
                      default=0,
                      width=0,
                      padx=20, pady=20,
                      bitmap=None, bitmap_side="left",
                      bitmap_padx=10, bitmap_pady=20,
                      image=None, image_side="left",
                      image_padx=10, image_pady=20,
                      )
        # default to separator if more than one button
        sep = len(kw.strings) > 1
        kwdefault(kw.__dict__, separator=sep)
        return kw

    def createFrames(self, kw):
        a = LBoxLayout(orientation="vertical")
        b = LBoxLayout(orientation="vertical")
        return a, b


# ************************************************************************
# Needed Labels.

class MfxSimpleEntry:
    pass


class MfxToolTip:
    pass

# ************************************************************************
# * replacement for the tk_dialog script
# ************************************************************************
# Kivy implementation helpers.


class FLabel(Label):
    def __init__(self, **kw):
        super(FLabel, self).__init__(**kw)

        self.bind(size=self.onUpdate)
        self.bind(pos=self.onUpdate)
        self.bind(text=self.onUpdate)

    def onUpdate(self, instance, size):
        self.size_hint_y = None
        self.text_size = self.width, None
        self.texture_update()
        self.height = self.texture_size[1]


class FText(LScrollView):
    def __init__(self, **kw):
        super(FText, self).__init__(**kw)

        self.label = FLabel(**kw)
        self.add_widget(self.label)


class MfxMessageDialog(MfxDialog):
    def __init__(self, parent, title, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)

        if (kw.image):
            image = LImage(texture=kw.image.texture, size_hint=(1, 1))
            self.top.add_widget(image)

        label = FText(text=kw.text, halign='center')
        self.top.add_widget(label)

        # LB
        # nicht automatisch ein neues spiel laden.
        if (title == _("Game won")):
            self.status = 1
            # self.button = 0
        if (title == _("Game finished")):
            self.status = 1
            # self.button =

# ************************************************************************
# *
# ************************************************************************


class MfxExceptionDialog(MfxMessageDialog):
    def __init__(self, parent, ex, title=_("Error"), **kw):
        kw = KwStruct(kw, bitmap="error")
        text = kw.get("text", "")
        if not text.endswith("\n"):
            text = text + "\n"
        text = text + "\n"
        if isinstance(ex, EnvironmentError) and ex.filename is not None:
            t = "[Errno %s] %s:\n%s" % (
                ex.errno, ex.strerror, repr(ex.filename))
        else:
            t = str(ex)
        kw.text = text + t
        MfxMessageDialog.__init__(self, parent, title, **kw.getKw())


# ************************************************************************
# *
# ************************************************************************

class PysolAboutDialog(object):

    # Die einzige Instanz.
    AboutDialog = None

    def onClick(self, event):
        print('LTopLevel: onClick')
        PysolAboutDialog.AboutDialog.parent.popWork('AboutDialog')
        PysolAboutDialog.AboutDialog.running = False

    def __init__(self, app, parent, title, **kw):
        logging.info('PysolAboutDialog:')
        super(PysolAboutDialog, self).__init__()

        self._url = kw['url']
        logging.info('PysolAboutDialog: txt=%s' % title)

        text = kw['text']
        text = text + '\n' + self._url
        logging.info('PysolAboutDialog: txt=%s' % text)

        text = text + '\n\n' + 'Adaptation to Kivy/Android\n' + \
            ' Copyright (C) (2016-19) LB'

        self.parent = parent
        self.app = app
        self.window = None
        self.running = False
        self.status = 1  # -> von help.py so benötigt
        self.button = 0  # -> von help.py so benötigt

        # bestehenden Dialog rezyklieren.

        logging.info('PysolAboutDialog: 1')
        onlyone = PysolAboutDialog.AboutDialog
        if (onlyone and onlyone.running):
            return
        if (onlyone):
            onlyone.parent.pushWork('AboutDialog', onlyone.window)
            onlyone.running = True
            return

        # neuen Dialog aufbauen.

        window = LTopLevel(parent, title, size_hint=(1.0, 1.0))
        window.titleline.bind(on_press=self.onClick)
        self.parent.pushWork('AboutDialog', window)
        self.window = window
        self.running = True
        PysolAboutDialog.AboutDialog = self

        if kw['image']:
            image = LImage(texture=kw['image'].texture)
            image.size_hint = (1, 0.8)
            al = AnchorLayout()
            al.add_widget(image)
            al.size_hint = (1, 0.3)
            window.content.add_widget(al)

        label = FText(text=text, halign='center', size_hint=(1, 1))
        window.content.add_widget(label)


# ************************************************************************
# * a simple tooltip
# ************************************************************************
# ToolTip - not used in Kivy - would not run without adaptations.


'''
class MfxTooltip:
    last_leave_time = 0

    def __init__(self, widget):
        # private vars
        self.widget = widget
        self.text = None
        self.timer = None
        self.cancel_timer = None
        self.tooltip = None
        self.label = None
        self.bindings = []
        self.bindings.append(self.widget.bind("<Enter>", self._enter))
        self.bindings.append(self.widget.bind("<Leave>", self._leave))
        self.bindings.append(self.widget.bind("<ButtonPress>", self._leave))
        # user overrideable settings
        self.timeout = 800                    # milliseconds
        self.cancel_timeout = 5000
        self.leave_timeout = 400
        self.relief = 'solid'
        self.justify = 'left'
        self.fg = "#000000"
        self.bg = "#ffffe0"
        self.xoffset = 0
        self.yoffset = 4

    def setText(self, text):
        self.text = text

    def _unbind(self):
        if self.bindings and self.widget:
            self.widget.unbind("<Enter>", self.bindings[0])
            self.widget.unbind("<Leave>", self.bindings[1])
            self.widget.unbind("<ButtonPress>", self.bindings[2])
            self.bindings = []

    def destroy(self):
        self._unbind()
        self._leave()

    def _enter(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.cancel_timer = None
        timediff = time.time() - MfxTooltip.last_leave_time
        if timediff < self.leave_timeout / 1000.:
            self._showTip()
        else:
            self.timer = after(self.widget, self.timeout, self._showTip)

    def _leave(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.timer = self.cancel_timer = None
        if self.tooltip:
            self.label.destroy()
            destruct(self.label)
            self.label = None
            self.tooltip.destroy()
            destruct(self.tooltip)
            self.tooltip = None
            MfxTooltip.last_leave_time = time.time()

    def _showTip(self):
        self.timer = None
        if self.tooltip or not self.text:
            return
#         if isinstance(self.widget, (Tkinter.Button, Tkinter.Checkbutton)):
#             if self.widget["state"] == 'disabled':
#                 return
        # x = self.widget.winfo_rootx()
        x = self.widget.winfo_pointerx()
        y = self.widget.winfo_rooty() + self.widget.winfo_height()
        x += self.xoffset
        y += self.yoffset
        self.tooltip = Tkinter.Toplevel()
        self.tooltip.wm_iconify()
        self.tooltip.wm_overrideredirect(1)
        self.tooltip.wm_protocol("WM_DELETE_WINDOW", self.destroy)
        self.label = Tkinter.Label(self.tooltip, text=self.text,
                                   relief=self.relief, justify=self.justify,
                                   fg=self.fg, bg=self.bg, bd=1, takefocus=0)
        self.label.pack(ipadx=1, ipady=1)
        self.tooltip.wm_geometry("%+d%+d" % (x, y))
        self.tooltip.wm_deiconify()
        self.cancel_timer = after(
            self.widget, self.cancel_timeout, self._leave)
        # self.tooltip.tkraise()
'''

# ************************************************************************
# * A canvas widget with scrollbars and some useful bindings.
# ************************************************************************
# Kivy implementation of MfxScrolledCanvas.


class LScrollFrame(BoxLayout):
    def __init__(self, **kw):
        super(LScrollFrame, self).__init__(orientation="vertical", **kw)


class MfxScrolledCanvas(object):
    def __init__(self, parent, hbar=True, vbar=True, propagate=False, **kw):
        kwdefault(kw, highlightthickness=0, bd=1, relief='sunken')
        self.parent = parent

        # workarea = parent.getWork()
        print('MfxScrolledCanvas: parent=%s' % (parent))

        super(MfxScrolledCanvas, self).__init__()
        self.createFrame(kw)
        self.canvas = None
        # do_scroll_x = None
        # do_scroll_y = None
        # self.hbar = None
        # self.vbar = None
        self.hbar_show = False
        self.vbar_show = False
        self.createCanvas(kw)
        # self.frame.grid_rowconfigure(0, weight=1)
        # self.frame.grid_columnconfigure(0, weight=1)
        # self.frame.grid_propagate(propagate)
        if hbar:
            self.createHbar()
            self.bindHbar()
        if vbar:
            self.createVbar()
            self.bindVbar()
        # self.canvas.focus_set()

    def destroy(self):
        logging.info('MfxRoot: destroy')
        self.unbind_all()
        self.canvas.destroy()
        self.frame.destroy()

    def pack(self, **kw):
        pass
        # self.frame.pack(**kw)

    def grid(self, **kw):
        pass
        # self.frame.grid(**kw)

    #
    #
    #

    def setTile(self, app, i, force=False):
        logging.info('MfxRoot: setTitle app=%s' % app)

        tile = app.tabletile_manager.get(i)

        print('setTile: (tile) %s, index=%s' % (tile, i))

        if tile is None or tile.error:
            return False

        # print i, tile
        if i == 0:
            assert tile.color
            assert tile.filename is None
        else:
            assert tile.color is None
            assert tile.filename
            assert tile.basename
        if not force:
            if (i == app.tabletile_index and
                    tile.color == app.opt.colors['table']):
                return False
        #
        print('setTile2: %s' % (tile.filename))

        if not self.canvas.setTile(
                tile.filename, tile.stretch, tile.save_aspect):
            tile.error = True
            return False

        print(
            'MfxScrolledCanvas: tile.color, app.top_bg %s, %s'
            % (tile.color, app.top_bg))
        if i == 0:
            if force:
                tile.color = app.opt.colors['table']
            self.canvas.config(bg=tile.color)
        else:
            if type(app.top_bg) is str:
                self.canvas.config(bg=app.top_bg)

        self.canvas.setTextColor(app.opt.colors['text'])
        return True
    #
    #
    #

    def deleteAllItems(self):
        logging.info('MfxRoot: deleteAllItems')
        # self.parent.getWork()
        # self.parent.popWork()
        # self.frame.clear_widgets()
        self.canvas.clear_widgets()

    def update_idletasks(self):
        logging.info('MfxRoot: update_idletasks')
        Clock.schedule_once(lambda x: self.canvas.canvas.ask_update)

    def unbind_all(self):
        unbind_destroy(self.hbar)
        unbind_destroy(self.vbar)
        unbind_destroy(self.canvas)
        unbind_destroy(self.frame)

    def createFrame(self, kw):
        logging.info('MfxRoot: createFrame')
        # width = kw.get("width")
        # height = kw.get("height")
        print('createFrame: kw=%s' % kw)
        # self.frame = Tkinter.Frame(self.parent, width=width, height=height)

        self.frame = LScrollFrame(size_hint=(1, 1))

        print("createFrame: self.parent %s" % str(self.frame))

    def createCanvas(self, kw):
        logging.info('MfxRoot: createCanvas')
        # bd = kw['bd']
        kw['bd'] = 0
        # relief = kw['relief']
        del kw['relief']
        # frame = Tkinter.Frame(self.frame, bd=bd, relief=relief)
        # frame.grid(row=0, column=0, sticky="news")
        '''
        self.canvas = MfxCanvas(self.frame, **kw)
        self.frame.add_widget(self.canvas)
        self.parent.pushWork(self.frame)
        '''
        self.canvas = MfxCanvas(self.parent, **kw)
        self.frame = self.canvas
        self.parent.pushWork('playground', self.frame)
        ''
        # self.canvas.pack(expand=True, fill='both')

    def createHbar(self):
        pass
        '''
        self.hbar = Tkinter.Scrollbar(self.frame, takefocus=0,
                                      orient="horizontal")
        self.canvas["xscrollcommand"] = self._setHbar
        self.hbar["command"] = self.canvas.xview
        self.hbar.grid(row=1, column=0, sticky="we")
        self.hbar.grid_remove()
        '''

    def createVbar(self):
        pass
        '''
        self.vbar = Tkinter.Scrollbar(self.frame, takefocus=0)
        self.canvas["yscrollcommand"] = self._setVbar
        self.vbar["command"] = self.canvas.yview
        self.vbar.grid(row=0, column=1, sticky="ns")
        self.vbar.grid_remove()
        '''

    def bindHbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Left>", self.unit_left)
        bind(w, "<KeyPress-Right>", self.unit_right)

    def bindVbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Prior>", self.page_up)
        bind(w, "<KeyPress-Next>", self.page_down)
        bind(w, "<KeyPress-Up>", self.unit_up)
        bind(w, "<KeyPress-Down>", self.unit_down)
        bind(w, "<KeyPress-Begin>", self.scroll_top)
        bind(w, "<KeyPress-Home>", self.scroll_top)
        bind(w, "<KeyPress-End>", self.scroll_bottom)
        # mousewheel support
        if WIN_SYSTEM == 'x11':
            bind(w, '<4>', self.mouse_wheel_up)
            bind(w, '<5>', self.mouse_wheel_down)
        # don't work on Linux
        # bind(w, '<MouseWheel>', self.mouse_wheel)

    def mouse_wheel(self, *args):
        pass

    def _setHbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.hbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.hbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.hbar_show = True
        sb.set(first, last)

    def _setVbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.vbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.vbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.vbar_show = True
        sb.set(first, last)

    def _xview(self, *args):
        if self.hbar_show:
            self.canvas.xview(*args)
        return 'break'

    def _yview(self, *args):
        if self.vbar_show:
            self.canvas.yview(*args)
        return 'break'

    def page_up(self, *event):
        return self._yview('scroll', -1, 'page')

    def page_down(self, *event):
        return self._yview('scroll', 1, 'page')

    def unit_up(self, *event):
        return self._yview('scroll', -1, 'unit')

    def unit_down(self, *event):
        return self._yview('scroll', 1, 'unit')

    def mouse_wheel_up(self, *event):
        return self._yview('scroll', -5, 'unit')

    def mouse_wheel_down(self, *event):
        return self._yview('scroll', 5, 'unit')

    def page_left(self, *event):
        return self._xview('scroll', -1, 'page')

    def page_right(self, *event):
        return self._xview('scroll', 1, 'page')

    def unit_left(self, *event):
        return self._xview('scroll', -1, 'unit')

    def unit_right(self, *event):
        return self._xview('scroll', 1, 'unit')

    def scroll_top(self, *event):
        return self._yview('moveto', 0)

    def scroll_bottom(self, *event):
        return self._yview('moveto', 1)


# ************************************************************************
# *
# ************************************************************************
# not used witch kivy. would not nun as it refers TkInter.
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#


# PySol imports
# from pysollib.mfxutil import KwStruct
# from pysollib.gamedb import GI

# Toolkit imports
from pysollib.pysoltk import MfxDialog

__all__ = ['GameInfoDialog']

# ************************************************************************
# *
# ************************************************************************


class GameInfoDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        pass


'''
'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# *
# ************************************************************************


class EditTextDialog(MfxDialog):

    def __init__(self, parent, title, text, **kw):
        # not used with kivy.
        pass

    def initKw(self, kw):
        pass

    def destroy(self):
        pass

    def wmDeleteWindow(self, *event):   # ignore
        pass

    def mCancel(self, *event):          # ignore <Escape>
        pass


'''end of file'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

import logging

from kivy.cache import Cache

TclError = 0


def MfxRoot(**kw):
    mainWindow = Cache.get('LAppCache', 'mainWindow')
    logging.info('tkwrap: top = %s' % str(mainWindow))
    return mainWindow
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# * Dialog
# ************************************************************************
# not used with kivy. dummy def.


class SelectCardsetDialogWithPreview(MfxDialog):
    _cardset_store = None

    def __init__(self, parent, title, app, manager, key=None, **kw):
        if key is None:
            key = 1
        self.status = -1
        self.key = key
        self.app = app
        self.manager = manager
        return

    def getSelected(self):
        return None

    def showSelected(self, w):
        pass

    def updatePreview(self, key):
        pass

    def initKw(self, kw):
        kwdefault(kw,
                  strings=(_("&Load"), _("&Cancel"), _("&Info..."), ),
                  default=1,
                  resizable=1,
                  padx=10, pady=10,
                  width=600, height=400,
                  )
        return MfxDialog.initKw(self, kw)

    def createInfo(self):
        pass

    def done(self, button):
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ************************************************************************
# * constants
# ************************************************************************

EVENT_HANDLED = "break"
EVENT_PROPAGATE = None

CURSOR_DRAG = "hand1"
CURSOR_WATCH = "watch"
CURSOR_DOWN_ARROW = 'sb_down_arrow'

ANCHOR_CENTER = 'center'
ANCHOR_N = 'n'
ANCHOR_NW = 'nw'
ANCHOR_NE = 'ne'
ANCHOR_S = 's'
ANCHOR_SW = 'sw'
ANCHOR_SE = 'se'
ANCHOR_W = 'w'
ANCHOR_E = 'e'
'''
COMPOUNDS = (
    # (Tkinter.BOTTOM,  'bottom'),
    # (Tkinter.CENTER,  'center'),
    # (Tkinter.RIGHT,    'right'),
    (Tkinter.NONE,   n_('Icons only')),
    (Tkinter.TOP,    n_('Text below icons')),
    (Tkinter.LEFT,   n_('Text beside icons')),
    ('text',         n_('Text only')),
    )
'''
TOOLBAR_BUTTONS = (
    "new",
    "restart",
    "open",
    "save",
    "undo",
    "redo",
    "autodrop",
    "shuffle",
    "pause",
    "statistics",
    "rules",
    "quit",
    "player",
)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# kivy implementation:
# most of the code will not be used, but some important function have been
# emulated.

from __future__ import division

import logging
import os
from array import array

from kivy.clock import Clock
from kivy.core.image import Image as CoreImage
from kivy.core.text import Label as CoreLabel
from kivy.graphics.texture import Texture

from pysollib.kivy.LApp import LImage
from pysollib.kivy.LApp import LTopLevel0

# ************************************************************************
# * window manager util
# ************************************************************************


def wm_withdraw(window):
    window.wm_withdraw()


def wm_map(window, maximized=0):
    return


# ************************************************************************
# * window util
# ************************************************************************


def setTransient(window, parent, relx=None, rely=None, expose=1):
    # Make an existing toplevel window transient for a parent.
    #
    # The window must exist but should not yet have been placed; in
    # other words, this should be called after creating all the
    # subwidget but before letting the user interact.

    # not used in kivy (highly tk specific).
    return


def makeToplevel(parent, title=None):
    print('tkutil: makeTopLevel')

    # Create a Toplevel window.
    #
    window = LTopLevel0(parent, title)
    # window = LTopLevelPopup(parent, title)
    return window.content


def make_help_toplevel(app, title=None):
    # Create an independent Toplevel window.

    window = app.top

    # from pysollib.winsystems import init_root_window
    # window = Tkinter.Tk(className=TITLE)
    # init_root_window(window, app)
    return window


# ************************************************************************
# * bind wrapper - Tkinter doesn't properly delete all bindings
# ************************************************************************

__mfx_bindings = {}
__mfx_wm_protocols = ("WM_DELETE_WINDOW", "WM_TAKE_FOCUS", "WM_SAVE_YOURSELF")


def bind(widget, sequence, func, add=None):

    # logging.info('tkutil: bind  %s %s %s %s '
    #              % (widget, sequence, func, add))

    # logging.info('tkutil: bind canvas = ' % str(widget.canvas))

    if hasattr(widget, 'bindings'):
        # logging.info('tkutil: bind  %s %s %s %s '
        #              % (sequence, widget, func, add))
        widget.bindings[sequence] = func
    else:
        # logging.info('tkutil: bind failed %s %s' % (sequence, widget))
        pass

    if (sequence == '<KeyPress-Left>'):
        return
    if (sequence == '<KeyPress-Right>'):
        return
    if (sequence == '<KeyPress-Prior>'):
        return
    if (sequence == '<KeyPress-Next>'):
        return
    if (sequence == '<KeyPress-Up>'):
        return
    if (sequence == '<KeyPress-Down>'):
        return
    if (sequence == '<KeyPress-Begin>'):
        return
    if (sequence == '<KeyPress-Home>'):
        return
    if (sequence == '<KeyPress-End>'):
        return
    if (sequence == '<KeyPress-Down>'):
        return

    if (sequence == '<4>'):
        return
    if (sequence == '<5>'):
        return

    if (sequence == '<1>'):
        return
    if (sequence == '<Motion>'):
        return
    if (sequence == '<ButtonRelease-1>'):
        return
    if (sequence == '<Control-1>'):
        return
    if (sequence == '<Shift-1>'):
        return
    if (sequence == '<Double-1>'):
        return
    if (sequence == '<3>'):
        return
    if (sequence == '<2>'):
        return
    if (sequence == '<Control-3>'):
        return
    if (sequence == '<Enter>'):
        return
    if (sequence == '<Leave>'):
        return
    if (sequence == '<Unmap>'):
        return
    if (sequence == '<Configure>'):
        return
    pass


def unbind_destroy(widget):
    # logging.info('tkutil: unbind  %s' % (widget))
    widget.bindings = []
    pass


# ************************************************************************
# * timer wrapper - Tkinter doesn't properly delete all commands
# ************************************************************************


def after(widget, ms, func, *args):
    print('tkutil: after(%s, %s, %s, %s)' % (widget, ms, func, args))
    if (ms == 'idle'):
        print('demo use')
        Clock.schedule_once(lambda dt: func(), 1.0)
    elif (isinstance(ms, int)):
        # print('ms: play timer (accounting)')
        # Clock.schedule_once(lambda dt: func(), float(ms)/1000.0)
        # makes not sense, drains battery!
        pass


def after_idle(widget, func, *args):
    print('tkutil: after_idle()')
    return after(widget, "idle", func, *args)


def after_cancel(t):
    print('tkutil: after_cancel()')
    pass


# ************************************************************************
# * image handling
# ************************************************************************


def makeImage(file=None, data=None, dither=None, alpha=None):
    kw = {}
    if data is None:
        assert file is not None
        kw["source"] = file
        # print('makeImage: source = %s' % file)
        # if (file=='/home/lb/PRG/Python/Kivy/pysolfc/data/images/redeal.gif'):
        #    y = self.yy
    else:
        assert data is not None
        kw["texture"] = data
        # ob das geht ?? - kommt das vor ?
        # yy = self.yy
    '''
    if 'source' in kw:
        logging.info ("makeImage: " + kw["source"])
    if 'texture' in kw:
        logging.info ("makeImage: " + str(kw["texture"]))
    '''

    return LImage(**kw)


loadImage = makeImage


def copyImage(image, x, y, width, height):

    # return Image(source=image.source)
    # return Image(texture=image.texture)
    return image


def fillTexture(texture, fill, outline=None, owidth=1):

    # logging.info("fillImage: t=%s, f=%s o=%s, w=%s" %
    #              (texture, fill, outline, owidth))
    # O.K. Kivy

    if not fill and not outline:
        return

    width = texture.width
    height = texture.height

    ox = round(owidth)
    ow = int(ox)  # muss int sein!
    if width <= 2 * ow or height <= 2 * ow:
        fill = fill or outline
        outline = None

    if not fill:
        fi0 = 0
        fi1 = 0
        fi2 = 0
        fi3 = 0
    else:
        # wir erwarten Werte als '#xxxxxx' (color Werte in Tk notation)
        # (optional mit transparenz)
        if (fill[0] == '#'):
            fill = fill[1:]
        fi0 = int(fill[0:2], 16)
        fi1 = int(fill[2:4], 16)
        fi2 = int(fill[4:6], 16)
        fi3 = 255
        if len(fill) >= 8:
            fi3 = int(fill[6:8], 16)

    if not outline:
        f = (fi0, fi1, fi2, fi3) * width
        f = (f, ) * height
        assert len(f) == height
        f = sum(f, ())
        assert len(f) == height * width * 4
        arr = array('B', f)
        texture.blit_buffer(arr, colorfmt='rgba', bufferfmt='ubyte')
    else:
        if (outline[0] == '#'):
            outline = outline[1:]
        ou0 = int(outline[0:2], 16)
        ou1 = int(outline[2:4], 16)
        ou2 = int(outline[4:6], 16)
        ou3 = 255
        if len(outline) >= 8:
            ou3 = int(outline[6:8], 16)

        l1 = (
            ou0,
            ou1,
            ou2,
            ou3,
        ) * width
        l2 = (ou0, ou1, ou2, ou3, ) * ow + (fi0, fi1, fi2, fi3, ) * \
            (width - 2 * ow) + (ou0, ou1, ou2, ou3, ) * ow
        f = (l1, ) * ow + (l2, ) * (height - 2 * ow) + (l1, ) * ow
        assert len(f) == height
        f = sum(f, ())
        assert len(f) == height * width * 4
        arr = array('B', f)
        texture.blit_buffer(arr, colorfmt='rgba', bufferfmt='ubyte')


def createImage(width, height, fill, outline=None, outwidth=1):

    logging.info("createImage: w=%s, h=%s, f=%s, o=%s, ow=%s" %
                 (width, height, fill, outline, outwidth))

    # test stellungen:
    # if (fill==None):
    #   fill = '#00cc00'
    # if (outline==None):
    #   outline = '#ff00ff'

    # if (fill is None and (outline is None or outline == '')):
    #     outline = '#fff000'
    #     outwidth = 1

    texture = Texture.create(size=(width, height), colorfmt='rgba')
    fillTexture(texture, fill, outline, outwidth)
    image = LImage(texture=texture)
    # logging.info("createImage: LImage create %s" % image)
    return image


def shadowImage(image, color='#3896f8', factor=0.3):

    logging.info("shadowImage: ")
    # TBD.
    return None
    # Kivy nicht benötigt. aber - was tut das ?
    # wurde aufgerufen, als der erste König auf die Foundation
    # gezogen wurde. (möglicherweise eine Gewonnen! - Markierung).


def markImage(image):
    logging.info("markImage: ")
    return None


def _createImageMask(texture, color):

    col = 0
    if (color == 'black'):
        col = 0
    if (color == 'white'):
        col = 255

    g = texture.pixels
    arr = array('B', g)

    for mx in range(int(len(arr) / 4)):
        m = 4 * mx
        if arr[m + 3] < 128:
            arr[m + 3] = 0
            arr[m] = arr[m + 1] = arr[m + 2] = 0
        else:
            arr[m + 3] = 32
            arr[m] = arr[m + 1] = arr[m + 2] = col

    mask = Texture.create(size=texture.size, colorfmt='rgba')
    mask.blit_buffer(arr, colorfmt='rgba', bufferfmt='ubyte')
    return mask


def _scaleTextureToSize(texture, size):

    width = size[0]
    height = size[1]

    g = texture.pixels
    ag = array('B', g)
    gw, gh = texture.size

    # print('size:',width,height)
    # print('texture size:',gw,gh)

    bb = array('B', [0 for x in range(width * height * 4)])
    # print ('bb length: ',len(bb))
    # print ('gg length: ',gw*gh*4)

    scalex = width / gw
    scaley = height / gh

    # scale, x und y offset bestimmen.

    scale = scaley
    if (scalex < scaley):
        scale = scalex

    offx = (width - gw * scale) / 2
    offy = (height - gh * scale) / 2

    # print ('scale: ',scalex,'/',scaley,' -> ',scale)
    # print ('offs: ',offx,'/',offy)

    for bi in range(height):
        bline = bi * width
        if (bi >= offy) and (bi < (height - offy)):
            # transfer
            ai = gh - int((bi - offy) / scale) - 1
            aline = ai * gw
            for bk in range(width):
                bpos = (bline + bk) * 4
                if (bk >= offx) and (bk < (width - offx)):
                    # transfer
                    ak = int((bk - offx) / scale)
                    apos = (aline + ak) * 4
                    bb[bpos] = ag[apos]
                    bb[bpos + 1] = ag[apos + 1]
                    bb[bpos + 2] = ag[apos + 2]
                    bb[bpos + 3] = ag[apos + 3]
                else:
                    # transparent
                    bb[bpos + 3] = 0
        else:
            # transparent
            for bk in range(width):
                bb[(bline + bk) * 4 + 3] = 0

    stext = Texture.create(size=(width, height), colorfmt='rgba')
    stext.blit_buffer(bb, colorfmt='rgba', bufferfmt='ubyte')
    return stext


def _pasteTextureTo(texture, totexture):

    g = texture.pixels
    ag = array('B', g)
    gw, gh = texture.size

    t = totexture.pixels
    at = array('B', t)
    tw, th = totexture.size

    if (tw != gw) or (th != gh):
        return

    for i in range(int(len(ag) / 4)):
        i4 = i * 4
        if ag[i4 + 3] > 128:
            at[i4] = ag[i4]
            at[i4 + 1] = ag[i4 + 1]
            at[i4 + 2] = ag[i4 + 2]
            at[i4 + 3] = ag[i4 + 3]

    stext = Texture.create(size=(tw, th), colorfmt='rgba')
    stext.blit_buffer(at, colorfmt='rgba', bufferfmt='ubyte')
    return stext


def createBottom(image, color='white', backfile=None):

    backfilebase = None
    if backfile is not None:
        backfilebase = os.path.basename(backfile)

    logging.info("createBottom: %s | %s" % (color, backfilebase))
    # print('createBottom:',image)

    # th = 1                              # thickness
    # size = (w - th * 2, h - th * 2)
    # original: zeichnet noch eine outline um die karte - können wir nicht.

    tmp0 = _createImageMask(image.texture, color)
    if backfile:
        tmp1 = CoreImage(backfile)
        txtre = _scaleTextureToSize(tmp1.texture, image.texture.size)
        tmp = _pasteTextureTo(txtre, tmp0)
    else:
        tmp = tmp0

    img = LImage(texture=tmp)
    img.size[0] = image.getWidth()
    img.size[1] = image.getHeight()
    return img
    '''
    im = image._pil_image
    th = 1                              # thickness
    sh = Image.new('RGBA', im.size, color)
    out = Image.composite(sh, im, im)
    w, h = im.size
    size = (w - th * 2, h - th * 2)
    tmp = Image.new('RGBA', size, color)
    tmp.putalpha(60)
    mask = out.resize(size, Image.ANTIALIAS)
    out.paste(tmp, (th, th), mask)
    if backfile:
        back = Image.open(backfile).convert('RGBA')
        w0, h0 = back.size
        w1, h1 = im.size
        a = min(float(w1) / w0, float(h1) / h0)
        a = a * 0.9
        w0, h0 = int(w0 * a), int(h0 * a)
        back = back.resize((w0, h0), Image.ANTIALIAS)
        x, y = (w1 - w0) / 2, (h1 - h0) / 2
        out.paste(back, (x, y), back)
    return PIL_Image(image=out)
    '''


# ************************************************************************
# * font utils
# ************************************************************************


def get_text_width(text, font, root=None):

    logging.info("get_text_width: %s  %s" % (text, font))

    label = CoreLabel()
    label.text = text
    label.refresh()
    return label.content_width
    # return Font(root=root, font=font).measure(text)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
# Copyright (C) 2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from __future__ import division

import logging

from kivy.clock import Clock
from kivy.graphics import Color
from kivy.graphics import Rectangle
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.widget import Widget

from pysollib.kivy.LApp import LAnimationManager
from pysollib.kivy.LApp import LColorToKivy
from pysollib.kivy.LApp import LImage
from pysollib.kivy.LApp import LImage as Image
from pysollib.kivy.LApp import LImageItem
from pysollib.kivy.LApp import LLine
from pysollib.kivy.LApp import LRectangle
from pysollib.kivy.LApp import LText

# ************************************************************************
# * canvas items helpers
# ************************************************************************


def addAnchorOffset(pos, anchor, size):
    # print ('MfxCanvas: anchor=%s' % (anchor))
    x = pos[0]
    y = pos[1]
    xa = 0
    ya = 0
    if anchor == "n":
        ya = -1
    elif anchor == "w":
        xa = -1
    elif anchor == "s":
        ya = 1
    elif anchor == "e":
        xa = 1
    elif anchor == "ne":
        ya = -1
        xa = 1
    elif anchor == "nw":
        ya = -1
        xa = -1
    elif anchor == "se":
        ya = 1
        xa = 1
    elif anchor == "sw":
        ya = 1
        xa = -1

    if xa == 0:
        x = x - size[0] / 2.0
    elif xa == 1:
        x = x - size[0]
    if ya == 0:
        y = y - size[1] / 2.0
    elif ya == 1:
        y = y - size[1]
    return (x, y)


def subAnchorOffset(pos, anchor, size):
    # print ('MfxCanvas: anchor=%s' % (anchor))
    x = pos[0]
    y = pos[1]
    xa = 0
    ya = 0
    if anchor == "n":
        ya = -1
    elif anchor == "w":
        xa = -1
    elif anchor == "s":
        ya = 1
    elif anchor == "e":
        xa = 1
    elif anchor == "ne":
        ya = -1
        xa = 1
    elif anchor == "nw":
        ya = -1
        xa = -1
    elif anchor == "se":
        ya = 1
        xa = 1
    elif anchor == "sw":
        ya = 1
        xa = -1

    if xa == 0:
        x = x + size[0] / 2.0
    elif xa == 1:
        x = x + size[0]
    if ya == 0:
        y = y + size[1] / 2.0
    elif ya == 1:
        y = y + size[1]
    return (x, y)

# ************************************************************************
# * canvas items
# ************************************************************************


class MfxCanvasGroup():
    def __init__(self, canvas, tag=None):
        # logging.info('MfxCanvasGroup: __init__() %s - %s' %
        #  (str(canvas), str(tag)))
        self.canvas = canvas
        self.bindings = {}
        self.stack = None

    def tkraise(self):
        pass

    def addtag(self, tag, option="withtag"):
        # logging.info('MfxCanvasGroup: addtag(%s, %s)' % (tag, option))
        # self.canvas.addtag(tag, option, self.id)
        pass

    def delete(self):
        # logging.info('MfxCanvasGroup: delete()')
        # del self.canvas.items[self.id]
        pass

    def gettags(self):
        # logging.info('MfxCanvasGroup: gettags()')
        # return self.canvas.tk.splitlist(self._do("gettags"))
        return None


class MfxCanvasImage(object):
    def __init__(self, canvas, *args, **kwargs):

        # print ('MfxCanvasImage: %s | %s | %s' % (canvas, args, kwargs))

        group = None
        if 'group' in kwargs:
            group = kwargs['group']
            del kwargs['group']
        self._image = None
        if 'image' in kwargs:
            self._image = kwargs['image']
        self._anchor = None
        if 'anchor' in kwargs:
            self._anchor = kwargs['anchor']

        super(MfxCanvasImage, self).__init__()
        self.canvas = canvas
        self.animation = None

        ed = kwargs['image']
        size = ed.size

        if type(ed) is LImageItem:
            aimage = ed
        else:
            if (ed.source is None):
                image = LImage(texture=ed.texture)
                image.size = [ed.getWidth(), ed.getHeight()]
                aimage = LImageItem(size=image.size, group=group)
                aimage.add_widget(image)
                size = image.size
            else:
                image = LImage(texture=ed.texture)
                # image = LImage(source=ed.source)
                image.size = [ed.getWidth(), ed.getHeight()]
                aimage = LImageItem(size=ed.size, group=group)
                aimage.add_widget(image)
                size = image.size

        xy = addAnchorOffset(args, self._anchor, size)

        aimage.coreSize = (aimage.size[0], aimage.size[1])
        aimage.corePos = (xy[0], xy[1])

        aimage.pos, aimage.size = canvas.CoreToKivy(xy, aimage.size)
        self.canvas.add_widget(aimage)
        self.image = aimage
        self.widget = aimage

        if group:
            self.addtag(group)

    def __del__(self):
        print('MfxCanvasImage: __del__(%s)' % self.image)
        self.canvas.clear_widgets([self.image])

    def config(self, **kw):
        pass

    def tkraise(self, aboveThis=None):
        # print('MfxCanvasImage: tkraise')
        abitm = None
        if aboveThis:
            abitm = aboveThis.widget
        if not self.animation:
            self.canvas.tag_raise(self.image, abitm)
        pass

    def addtag(self, tag):
        # print('MfxCanvasImage: addtag %s' % tag)
        self.group = tag
        if (self.image):
            self.image.group = tag
        pass

    def dtag(self, tag):
        # print('MfxCanvasImage: remtag %s' % tag)
        self.group = None
        if (self.image):
            self.image.group = None
        pass

    def delete(self):
        # print('MfxCanvasImage: delete()')
        self.canvas.clear_widgets([self.image])

    def move(self, dx, dy):
        # print ('MfxCanvasImage: move %s, %s' % (dx, dy))
        image = self.image
        dsize = image.coreSize
        dpos = (image.corePos[0] + dx, image.corePos[1] + dy)
        image.corePos = dpos
        if not self.animation:
            image.pos, image.size = self.canvas.CoreToKivy(dpos, dsize)

    def makeAnimStart(self):
        def animStart(anim, widget):
            # print('MfxCanvasImage: animStart')
            image = self.image
            self.canvas.tag_raise(image, None)
            pass
        return animStart

    def makeAnimEnd(self, dpos, dsize):
        def animEnd(anim, widget):
            # print('MfxCanvasImage: animEnd %s' % self)
            self.animation = False
            image = self.image
            image.pos, image.size = self.canvas.CoreToKivy(dpos, dsize)
            pass
        return animEnd

    def animatedMove(self, dx, dy, duration=0.2):
        # print ('MfxCanvasImage: animatedMove %s, %s' % (dx, dy))

        image = self.image
        dsize = image.coreSize
        dpos = (image.corePos[0] + dx, image.corePos[1] + dy)
        pos, size = self.canvas.CoreToKivy(dpos, dsize)
        transition1 = 'out_expo'
        # transition2 = 'out_cubic'
        # transition3 = 'out_quad'
        # transition4 = 'out_quint'
        # transition5 = 'out_sine'
        transition6 = 'in_out_quad'
        # transition7 = 'in_bounce'
        # transition8 = 'in_elastic'
        transition = transition6
        if self.canvas.wmain.app.game.demo:
            transition = transition1

        self.animation = True
        ssize = image.coreSize
        spos = (image.corePos[0], image.corePos[1])
        spos, ssize = self.canvas.CoreToKivy(spos, ssize)
        LAnimationManager.create(
            spos,
            image,
            x=pos[0], y=pos[1],
            duration=duration, transition=transition,
            bindS=self.makeAnimStart(),
            bindE=self.makeAnimEnd(dpos, dsize))

    # def moveTo(self, x, y):
    #    c = self.coords()
    #    self.move(x - int(c[0]), y - int(c[1]))

    def show(self):
        self.config(state='normal')

    def hide(self):
        self.config(state='hidden')


class MfxCanvasLine(object):
    def __init__(self, canvas, *args, **kwargs):
        print('MfxCanvasLine: %s %s' % (args, kwargs))

        self.canvas = canvas
        line = LLine(canvas, args, **kwargs)
        line.pos, line.size = canvas.CoreToKivy(line.corePos, line.coreSize)
        canvas.add_widget(line)
        self.canvas = canvas
        self.line = line
        self.widget = line

    def delete_deferred(self, seconds):
        print('MfxCanvasLine: delete_deferred(%s)' % seconds)
        Clock.schedule_once(lambda dt: self.delete(), seconds)

    def delete(self):
        print('MfxCanvasLine: delete()')
        self.canvas.clear_widgets([self.line])


class MfxCanvasRectangle(object):
    def __init__(self, canvas, *args, **kwargs):

        # logging.info('MfxCanvasRectangle: %s %s' % (args, kwargs))

        rect = LRectangle(canvas, args, **kwargs)
        rect.pos, rect.size = canvas.CoreToKivy(rect.corePos, rect.coreSize)
        canvas.add_widget(rect)
        self.canvas = canvas
        self.rect = rect
        self.widget = rect

    def delete(self):
        # print('MfxCanvasRectangle: delete()')
        self.canvas.clear_widgets([self.rect])

    def __del__(self):
        # print('MfxCanvasRectangle: __del__()')
        self.delete()

    def delete_deferred_step(self, seconds):
        # print ('MfxCanvasRectangle: delete_deferred_step(%s)' % seconds)
        Clock.schedule_once(lambda dt: self.delete(), seconds)

    def delete_deferred(self, seconds):
        # self.canvas.canvas.ask_update()
        # print ('MfxCanvasRectangle: delete_deferred(%s)' % seconds)
        Clock.schedule_once(
            lambda dt: self.delete_deferred_step(seconds), 0.05)

    def addtag(self, tag):
        logging.info('MfxCanvasRectangle: addtag(%s) - fake' % tag)
        pass

    def tkraise(self, aboveThis=None):
        # logging.info('MfxCanvasRectangle: tkraise(%s) - fake' % item)
        abitm = None
        if aboveThis:
            abitm = aboveThis.widget
        self.canvas.tag_raise(self.rect, abitm)
        pass


class MfxCanvasText(object):
    def __init__(self, canvas, x, y, preview=-1, **kwargs):

        print(
            'MfxCanvasText: %s | %s, %s, %s | %s'
            % (canvas, x, y, preview, kwargs))

        if preview < 0:
            preview = canvas.preview
        if preview > 1:
            return
        if "fill" not in kwargs:
            kwargs["fill"] = canvas._text_color
        if 'group' in kwargs:
            del kwargs['group']

        super(MfxCanvasText, self).__init__()

        label = LText(canvas, x, y, **kwargs)
        label.pos, label.size = canvas.CoreToKivy(
            label.corePos, label.coreSize)
        canvas.add_widget(label)
        self.canvas = canvas
        self.label = label
        self.widget = label

    def config(self, **kw):
        print('MfxCanvasText: config %s' % kw)
        if ('text' in kw):
            self.label.text = kw['text']

    def tkraise(self, aboveThis=None):
        abitm = None
        if aboveThis:
            abitm = aboveThis.widget
        self.canvas.tag_raise(self.label, abitm)
        pass

    def bbox(self):
        # Dimensionen als 2x2 array zurückgeben.
        # (aufruf z.B. bei games/special/poker.py und bei Memory!)
        label = self.label
        canvas = self.canvas
        pos = label.pos
        size = label.size
        pos, size = canvas.KivyToCore(pos, size)
        ret = [[pos[0], pos[1]], [pos[0] + size[0], pos[1] + size[1]]]
        return ret

    def addtag(self, tag):
        pass

# ************************************************************************
# * canvas
# ************************************************************************


class MfxCanvas(Widget):

    def __init__(self, wmain, *args, **kw):
        # super(MfxCanvas, self).__init__(**kw)
        super(MfxCanvas, self).__init__()

        # self.tags = {}   # bei basisklasse widget (ev. nur vorläufig)

        self.wmain = wmain
        print('MfxCanvas: wmain = %s' % self.wmain)

        # Tkinter.Canvas.__init__(self, *args, **kw)
        self.preview = 0
        self.busy = False
        self._text_color = '#000000'
        self._bg_color = '#00ffff'
        self._stretch_bg_image = 0
        self._save_aspect_bg_image = 0
        #
        self.xmargin, self.ymargin = 0.0, 0.0
        self.topImage = None

        # Skalierung
        # self.lastsize = (self.size[0], self.size[1])
        # self.lastpos = (self.pos[0], self.pos[1])

        self.scale = 1.2
        self.r_width = None
        self.r_height = None

        self.bindings = {}
        self.bind(pos=self.pos_update_widget)
        self.bind(size=self.size_update_widget)

    def KivyToCoreP(self, pos, size, scale):
        cpos = pos
        cpos = (cpos[0] - self.pos[0], self.pos[1] +
                self.size[1] - cpos[1] - size[1])
        cpos = (1.0 * cpos[0] / scale, 1.0 * cpos[1] / scale)
        csize = (1.0 * size[0] / scale, 1.0 * size[1] / scale)
        return cpos, csize

    def CoreToKivyP(self, cpos, csize, scale):
        size = (1.0 * csize[0] * scale, 1.0 * csize[1] * scale)
        pos = (1.0 * cpos[0] * scale, 1.0 * cpos[1] * scale)
        pos = (self.pos[0] + pos[0], self.pos[1] +
               self.size[1] - pos[1] - size[1])
        return pos, size

    def KivyToCore(self, pos, size=(0.0, 0.0)):
        return self.KivyToCoreP(pos, size, self.scale)

    def CoreToKivy(self, cpos, csize=(0.0, 0.0)):
        return self.CoreToKivyP(cpos, csize, self.scale)

    def move(self, itm, dx, dy):
        # print ('MfxCanvas: move %s %s %s' % (itm, dx, dy))
        scale = self.scale
        dx = scale * dx
        dy = scale * dy
        itm.pos = (itm.pos[0] + dx, itm.pos[1] - dy)

    def scalefactor(self):
        if self.r_width is None:
            return self.scale
        if self.r_height is None:
            return self.scale

        # TBD (idee).
        # Hier ev. einen 2ten Modus zulassen, welche das Spielfeld
        # knapp auf die vorhandenen Karten/Anzeigeelemente bemisst.
        # Zur Optimierung der Sichtbarkeit auf kleinen Geräten.
        # Könnte z.B. über Doppelklick umgeschaltet werden. (Die
        # Skalierung müsste dann allerding nach jedem Zug dem ev.
        # veränderten Feld angepasst werden.)

        wid = self.size[0]
        hei = self.size[1]
        scfx = wid / self.r_width
        scfy = hei / self.r_height

        scf = scfx
        if (scfx < scfy):
            # print('scale factor by x = %s' % (scfx))
            scf = scfx
        else:
            # print('scale factor by y = %s' % (scfy))
            scf = scfy

        return scf

    def pos_update_widget(self, posorobj, size):
        # print('MfxCanvas: pos_update_widget size=(%s, %s)' %
        #       (self.size[0], self.size[1]))
        self.update_widget(posorobj, size)

    def size_update_widget(self, posorobj, size):
        # print('MfxCanvas: size_update_widget size=(%s, %s)' %
        #       (self.size[0], self.size[1]))
        self.update_widget(posorobj, size)

    def update_widget(self, posorobj, size):

        # print('MfxCanvas: update_widget size=(%s, %s)' %
        #       (self.size[0], self.size[1]))

        # Update Skalierungsparameter

        oldscale = self.scale
        newscale = self.scalefactor()
        print('MfxCanvas: scale factor old= %s, new=%s' %
              (oldscale, newscale))
        self.scale = newscale

        # Anpassung Skalierung.

        for c in self.children:
            if not hasattr(c, 'corePos'):
                continue
            if not hasattr(c, 'coreSize'):
                continue

            bpos = c.corePos
            bsiz = c.coreSize
            if bpos and bsiz:
                npos, nsiz = self.CoreToKivy(bpos, bsiz)
                c.pos = npos
                c.size = nsiz

        # Hintergrund update.

        self.canvas.before.clear()
        texture = None
        if self._bg_img:
            texture = self._bg_img.texture

            # Color only: Nur eine Hintergrundfarbe wird installiert.
        if texture is None:
            kc = LColorToKivy(self._bg_color)
            self.canvas.before.add(
                Color(kc[0], kc[1], kc[2], kc[3]))
            self.canvas.before.add(
                Rectangle(pos=self.pos, size=self.size))
            return

        # Image: Das Bild wird im Fenster expandiert.
        if self._stretch_bg_image:
            if self._save_aspect_bg_image == 0:
                self.canvas.before.add(
                    Rectangle(texture=texture, pos=self.pos, size=self.size))
            else:
                # TBD: gesucht: aspect erhaltende skalierung
                self.canvas.before.add(
                    Rectangle(texture=texture, pos=self.pos, size=self.size))
            return

            # Tiles: Die Kacheln werden im Fenster ausgelegt und minim
        # skaliert, damit sie genau passen.
        else:
            print('tiles !')
            stsize = (texture.size[0] * self.scale,
                      texture.size[1] * self.scale)
            stepsy = int(self.size[1] / stsize[1]) + 1
            stepsx = int(self.size[0] / stsize[0]) + 1

            scaley = 1.0 * self.size[1] / (stepsy * stsize[1])
            sy = scaley * stsize[1]
            scalex = 1.0 * self.size[0] / (stepsx * stsize[0])
            sx = scalex * stsize[0]
            tsize = (sx, sy)

            # print ('self.size = %s, %s' % (self.size[0], self.size[1]))
            # print ('sx, sy = %s, %s' % (stepsx, stepsy))
            for y in range(0, stepsy):
                py = y * sy
                for x in range(0, stepsx):
                    px = x * sx
                    tpos = (self.pos[0] + px, self.pos[1] + py)
                    self.canvas.before.add(
                        Rectangle(texture=texture, pos=tpos, size=tsize))

    def setBackgroundImage(self, event=None):

        print('setBackgroundImage', self._bg_img)

        if not self._bg_img:  # solid color
            return
        return 1

    # Funktionen, welche vom Core aufgerufen werden.

    def winfo_width(self):
        # return self.r_width
        cpos, csize = self.KivyToCoreP(self.pos, self.size, self.scale)
        print('MfxCanvas: winfo_width %s' % (csize[0]))
        return csize[0]

    def winfo_height(self):
        # return self.r_height
        cpos, csize = self.KivyToCoreP(self.pos, self.size, self.scale)
        print('MfxCanvas: winfo_height %s' % (csize[1]))
        return csize[1]

    def cget(self, f):
        print('MfxCanvas: cget %s -> %s, %s' % (f, self.pos, self.size))
        cpos, csize = self.KivyToCoreP(self.pos, self.size, self.scale)
        if f == 'width':
            print('MfxCanvas: cget %s -> x=%s' % (f, cpos[0]))
            return cpos[0]
        if f == 'height':
            print('MfxCanvas: cget %s -> y=%s' % (f, cpos[1]))
            return cpos[1]
        # if f=='bg':
        #    return background-color
        print('MfxCanvas: cget unsupported token')
        return 1

    def xview(self):
        print('MfxCanvas: xview')
        return [1, 1]
        pass

    def yview(self):
        print('MfxCanvas: yview')
        return [1, 1]
        pass

    #
    # top-image support
    #

    def tag_raise(self, itm, abitm=None):
        # print('MfxCanvas: tag_raise, itm=%s, aboveThis=%s' % (itm, abitm))
        if (itm is not None):
            if (abitm is None):
                # print('MfxCanvas: tag_raise: to top')
                self.clear_widgets([itm])
                self.add_widget(itm)
            else:
                print('MfxCanvas: tag_raise: to specified position')
                ws = []
                for c in reversed(self.children):   # reversed!
                    if c != itm and c != abitm:
                        ws.append(c)
                    if c == itm:
                        ws.append(abitm)
                        ws.append(itm)    # (~shadow image!)
                self.clear_widgets()
                for w in ws:
                    self.add_widget(w)

    def tag_lower(self, id, belowThis=None):
        print('MfxCanvas: tag_lower(%s, %s)' % (id, belowThis))
        # y = self.yy  # kommt das vor ?
        pass

    #
    #
    #
    def setInitialSize(self, width, height):
        print('MfxCanvas: setInitialSize request %s/%s' % (width, height))
        print(
            'MfxCanvas: setInitialSize actual  %s/%s'
            % (self.size[0], self.size[1]))
        self.r_width = width
        self.r_height = height

        # ev. update anstossen
        self.update_widget(self.pos, self.size)

        # self.size[0] = width
        # self.size[1] = height
        return

    # delete all CanvasItems, but keep the background and top tiles
    def deleteAllItems(self):
        print('MfxCanvas: deleteAllItems')
        self.clear_widgets()
        pass

    def findCard(self, stack, event):
        print('MfxCanvas: findCard(%s, %s)' % (stack, event))
        if (event.cardid > -1):
            return event.cardid

        print('MfxCanvas: findCard no cardid')
        return -1

    def setTextColor(self, color):
        print('MfxCanvas: setTextColor1 %s' % color)
        if color is None:
            c = self.cget("bg")
            if not isinstance(c, str) or c[0] != "#" or len(c) != 7:
                return
            v = []
            for i in (1, 3, 5):
                v.append(int(c[i:i + 2], 16))
            luminance = (0.212671 * v[0] + 0.715160 *
                         v[1] + 0.072169 * v[2]) / 255
            # print c, ":", v, "luminance", luminance
            color = ("#000000", "#ffffff")[luminance < 0.3]

        print('MfxCanvas: setTextColor2 %s' % color)
        if self._text_color != color:
            self._text_color = color

            # falls wir das wollen in kivy:
            # -> text_color als property deklarieren, und a.a.O binden.
            # for item in self._text_items:
            #    item.config(fill=self._text_color)

    def setTile(self, image, stretch=0, save_aspect=0):

        print('setTile: %s, %s' % (image, stretch))
        if image:
            try:
                # print ('setTile: image.open %s, %s' % (image, Image))
                bs = False
                if stretch > 0:
                    bs = True
                self._bg_img = Image(source=image, allow_stretch=bs)

                self._stretch_bg_image = stretch
                self._save_aspect_bg_image = save_aspect
                self.setBackgroundImage()
                self.update_widget(self.pos, self.size)
            except Exception:
                return 0
        else:
            # print ('setTile: no image!')
            self._bg_img = None
            self.update_widget(self.pos, self.size)
        return 1

    def setTopImage(self, image, cw=0, ch=0):
        print('MfxCanvas: setTopImage %s' % image)

        if self.topImage:
            self.clear_widgets([self.topImage])
            self.topImage = None

        if image:
            tex = LImage(texture=image.texture)
            tex.size_hint = (0.4, 0.4)
            lay = AnchorLayout(anchor_y='bottom')
            lay.size = self.size
            lay.add_widget(tex)

            self.topImage = lay
            self.add_widget(self.topImage)

        return 1
    #
    # Pause support
    #

    def hideAllItems(self):
        print('MfxCanvas: hideAllItems')
        # TBD
        # Wir lassen das. Das TopImage deckt alles ab. Spielen ist
        # nicht möglich.
        pass

    def showAllItems(self):
        print('MfxCanvas: showAllItems')
        # TBD
        pass

    # Erweiterungen fuer Tk Canvas (prüfen was noch nötig!!).

    def itemconfig(self, tagOrId, cnf=None, **kw):
        """Configure resources of an item TAGORID.

        The values for resources are specified as keyword
        arguments. To get an overview about
        the allowed keyword arguments call the method without arguments.
        """
        print(
            'MfxCanvas: itemconfigure tagOrId=%s, cnf=%s, kw=%s'
            % (tagOrId, cnf, kw))

        if 'image' in cnf:
            # tagOrId ist ein Image oder ein CardImage
            # self.clear_widgets([cnf['image']])
            # self.add_widget(cnf['image'])
            # y = self.yy
            pass
        if 'text' in cnf:
            # tagOrId ist das Label.
            tagOrId.text = cnf['text']
            pass

    def config(self, cnf={}, **kw):
        print('MfxCanvas: config %s %s' % (cnf, kw))
        if ('cursor' in kw):
            pass
        if ('width' in kw):
            self.size[0] = kw['width']
        if ('height' in kw):
            self.size[1] = kw['height']
        if ('bg' in kw):
            self._bg_color = kw['bg']
            self.update_widget(self.pos, self.size)

    def dtag(self, tag, b=None):
        # print ('Canvas: dtag %s %s' % (tag, b))
        # if (tag in self.tags):
        #  if (self.tags[tag]==b):
        #    del self.tags[tag]
        pass

    def addtag(self, tag, b, c):
        # print ('Canvas: addtag %s %s %s' % (tag, b, c))
        # self.tags[c] = tag
        # self.tags.append(tag)
        pass

    def delete(self, tag):
        # print ('MfxCanvas: delete tag=%s' % tag)
        # y = self.yy
        pass

    def update_idletasks(self):
        print('MfxCanvas: update_idletasks')
        self.wmain.update_idletasks()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from kivy.clock import Clock

from pysollib.gamedb import GI
from pysollib.kivy.LApp import LScrollView
from pysollib.kivy.LApp import LTopLevel
from pysollib.kivy.LApp import LTreeNode
from pysollib.kivy.LApp import LTreeRoot
from pysollib.kivy.selecttree import SelectDialogTreeData
from pysollib.kivy.selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from pysollib.mygettext import _

from six.moves import UserList


# ************************************************************************
# * Nodes
# ************************************************************************


class SelectGameLeaf(SelectDialogTreeLeaf):
    def getContents(self):
        return None


class SelectGameNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        if isinstance(self.select_func, UserList):
            # key/value pairs
            for id, name in self.select_func:
                if id and name:
                    node = SelectGameLeaf(self.tree, self, name, key=id)
                    contents.append(node)
        else:
            for gi in self.tree.all_games_gi:
                if gi and self.select_func is None:
                    # All games
                    # name = '%s (%s)' % (gi.name, CSI.TYPE_NAME[gi.category])
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
                elif gi and self.select_func(gi):
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
        return contents or self.tree.no_games


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectGameData(SelectDialogTreeData):
    def __init__(self, app):
        SelectDialogTreeData.__init__(self)

        # originale.
        self.all_games_gi = list(
            map(app.gdb.get, app.gdb.getGamesIdSortedByName()))
        self.no_games = [SelectGameLeaf(None, None, _("(no games)"), None), ]
        #
        s_by_type = s_oriental = s_special = None
        s_original = s_contrib = s_mahjongg = None
        g = []
        for data in (GI.SELECT_GAME_BY_TYPE,
                     GI.SELECT_ORIENTAL_GAME_BY_TYPE,
                     GI.SELECT_SPECIAL_GAME_BY_TYPE,
                     GI.SELECT_ORIGINAL_GAME_BY_TYPE,
                     GI.SELECT_CONTRIB_GAME_BY_TYPE,
                     ):
            gg = []
            for name, select_func in data:
                if name is None or not filter(select_func, self.all_games_gi):
                    continue
                gg.append(SelectGameNode(None, _(name), select_func))
            g.append(gg)

        def select_mahjongg_game(gi): return gi.si.game_type == GI.GT_MAHJONGG
        gg = None
        if filter(select_mahjongg_game, self.all_games_gi):
            gg = SelectGameNode(None, _("Mahjongg Games"),
                                select_mahjongg_game)
        g.append(gg)
        if g[0]:
            s_by_type = SelectGameNode(None, _("French games"),
                                       tuple(g[0]), expanded=1)
        if g[1]:
            s_oriental = SelectGameNode(None, _("Oriental Games"),
                                        tuple(g[1]))
        if g[2]:
            s_special = SelectGameNode(None, _("Special Games"),
                                       tuple(g[2]))
        if g[3]:
            s_original = SelectGameNode(None, _("Original Games"),
                                        tuple(g[3]))
#         if g[4]:
#           s_contrib = SelectGameNode(None, "Contributed Games", tuple(g[4]))
        if g[5]:
            s_mahjongg = g[5]
        #
        # all games sorted (in pieces).
        s_all_games, gg = None, []
        agames = self.all_games_gi
        n, d = 0, 17
        i = 0
        while True:
            # columnbreak = i > 0 and (i % d) == 0
            i += 1
            if not agames[n:n + d]:
                break
            m = min(n + d - 1, len(agames) - 1)
            label = agames[n].name[:4] + ' - ' + agames[m].name[:4]
            # print('label = %s' % label)

            ggg = []
            for ag in agames[n:n + d]:
                # print('game, id = %s, %s' % (ag.name, ag.id))
                ggg.append((ag.id, ag.name + ' (' + str(ag.id) + ')'))

            gg.append(SelectGameNode(None, label, UserList(ggg)))
            n += d
        if 1 and gg:
            s_all_games = SelectGameNode(None, _("All Games"), tuple(gg))
        #
        s_by_compatibility, gg = None, []
        for name, games in GI.GAMES_BY_COMPATIBILITY:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_compatibility = SelectGameNode(None, _("by Compatibility"),
                                                tuple(gg))
            pass
        #
        s_by_pysol_version, gg = None, []
        for name, games in GI.GAMES_BY_PYSOL_VERSION:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            name = _("New games in v. %(version)s") % {'version': name}
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_pysol_version = SelectGameNode(None, _("by PySol version"),
                                                tuple(gg))
        #
        s_by_inventors, gg = None, []
        for name, games in GI.GAMES_BY_INVENTORS:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_inventors = SelectGameNode(None, _("by Inventors"),
                                            tuple(gg))
        #
        ul_alternate_names = UserList(
            list(app.gdb.getGamesTuplesSortedByAlternateName()))
        #
        self.rootnodes = [_f for _f in (
            # SelectGameNode(None, _("All Games"), None),
            SelectGameNode(None, _("Popular Games"),
                           lambda gi: gi.si.game_flags & GI.GT_POPULAR),
            s_mahjongg,
            s_oriental,
            s_special,
            # SelectGameNode(None, _("Custom Games"),
            #               lambda gi: gi.si.game_type == GI.GT_CUSTOM),
            SelectGameNode(None, _("Alternate Names"), ul_alternate_names),
            s_by_type,
            s_all_games,
            SelectGameNode(None, _('by Skill Level'), (
                SelectGameNode(None, _('Luck only'),
                           lambda gi: gi.skill_level == GI.SL_LUCK),
                SelectGameNode(None, _('Mostly luck'),
                           lambda gi: gi.skill_level == GI.SL_MOSTLY_LUCK),
                SelectGameNode(None, _('Balanced'),
                           lambda gi: gi.skill_level == GI.SL_BALANCED),
                SelectGameNode(None, _('Mostly skill'),
                           lambda gi: gi.skill_level == GI.SL_MOSTLY_SKILL),
                SelectGameNode(None, _('Skill only'),
                           lambda gi: gi.skill_level == GI.SL_SKILL),
            )),
            SelectGameNode(None, _("by Game Feature"), (
                SelectGameNode(None, _("by Number of Cards"), (
                    SelectGameNode(None, _("32 cards"),
                                   lambda gi: gi.si.ncards == 32),
                    SelectGameNode(None, _("48 cards"),
                                   lambda gi: gi.si.ncards == 48),
                    SelectGameNode(None, _("52 cards"),
                                   lambda gi: gi.si.ncards == 52),
                    SelectGameNode(None, _("64 cards"),
                                   lambda gi: gi.si.ncards == 64),
                    SelectGameNode(None, _("78 cards"),
                                   lambda gi: gi.si.ncards == 78),
                    SelectGameNode(None, _("104 cards"),
                                   lambda gi: gi.si.ncards == 104),
                    SelectGameNode(None, _("144 cards"),
                                   lambda gi: gi.si.ncards == 144),
                    SelectGameNode(None, _("Other number"),
                                   lambda gi: gi.si.ncards not in
                                   (32, 48, 52, 64, 78, 104, 144)),
                )),
                SelectGameNode(None, _("by Number of Decks"), (
                    SelectGameNode(None, _("1 deck games"),
                                   lambda gi: gi.si.decks == 1),
                    SelectGameNode(None, _("2 deck games"),
                                   lambda gi: gi.si.decks == 2),
                    SelectGameNode(None, _("3 deck games"),
                                   lambda gi: gi.si.decks == 3),
                    SelectGameNode(None, _("4 deck games"),
                                   lambda gi: gi.si.decks == 4),
                )),
                SelectGameNode(None, _("by Number of Redeals"), (
                    SelectGameNode(None, _("No redeal"),
                               lambda gi: gi.si.redeals == 0),
                    SelectGameNode(None, _("1 redeal"),
                               lambda gi: gi.si.redeals == 1),
                    SelectGameNode(None, _("2 redeals"),
                               lambda gi: gi.si.redeals == 2),
                    SelectGameNode(None, _("3 redeals"),
                               lambda gi: gi.si.redeals == 3),
                    SelectGameNode(None, _("Unlimited redeals"),
                               lambda gi: gi.si.redeals == -1),
                    SelectGameNode(None, "Variable redeals",
                               lambda gi: gi.si.redeals == -2),
                    SelectGameNode(None, _("Other number of redeals"),
                               lambda gi: gi.si.redeals not in
                               (-1, 0, 1, 2, 3)),
                )),
                s_by_compatibility,
            )),
            s_by_pysol_version,
            s_by_inventors,
            SelectGameNode(None, _("Other Categories"), (
                SelectGameNode(None, _("Games for Children (very easy)"),
                               lambda gi: gi.si.game_flags & GI.GT_CHILDREN),
                SelectGameNode(None, _("Games with Scoring"),
                               lambda gi: gi.si.game_flags & GI.GT_SCORE),
                SelectGameNode(None, _("Games with Separate Decks"),
                           lambda gi: gi.si.game_flags & GI.GT_SEPARATE_DECKS),
                SelectGameNode(None, _("Open Games (all cards visible)"),
                               lambda gi: gi.si.game_flags & GI.GT_OPEN),
                SelectGameNode(None, _("Relaxed Variants"),
                               lambda gi: gi.si.game_flags & GI.GT_RELAXED),
            )),
            s_original,
            s_contrib,
        ) if _f]


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************
'''
class SelectGameTreeWithPreview(SelectDialogTreeCanvas):
    data = None


class SelectGameTree(SelectGameTreeWithPreview):
    def singleClick(self, event=None):
        self.doubleClick(event)
'''
# ************************************************************************
# * Kivy support
# ************************************************************************


class LGameRoot(LTreeRoot):
    def __init__(self, gametree, gameview, **kw):
        super(LGameRoot, self).__init__(**kw)
        self.gametree = gametree
        self.gameview = gameview
        self.kw = kw


class LGameNode(LTreeNode):
    def __init__(self, gamenode, gameview, **kw):

        self.lastpos = None
        self.gamenode = gamenode
        self.gameview = gameview
        super(LGameNode, self).__init__(**kw)

        self.coreFont = self.font_size
        # self.scaleFont(self.gameview.size[1])
        # self.gameview.bind(size=self.scaleFontCB)

        self.command = None
        if 'command' in kw:
            self.command = kw['command']
        self.bind(on_release=self.on_released)

    # font skalierung.

    def scaleFont(self, value):
        self.font_size = int(self.coreFont * value / 550.0)

    def scaleFontCB(self, instance, value):
        self.scaleFont(value[1])

    # benutzer interaktion.

    def on_released(self, v):
        if self.gamenode.key:
            if self.command:
                # print('game number = %s' % self.gamenode.key)
                Clock.schedule_once(self.commandCB, 0.1)
        else:
            # verzögert aufrufen, wegen user feedback.
            Clock.schedule_once(self.toggleCB, 0.1)
    '''
    def on_touch_move(self, touch):
        if self.collide_point(*touch.pos):
            if self.lastpos==None:
                self.lastpos = touch.pos
                print('touch.pos %s' % str(touch.pos))
                return

            print ('touch move on %s - %s' % (self.text, touch.profile))
            print('touch.pos(2) %s' % str(touch.pos))
            # tbd: nur wenn horizontal move !
            if (touch.pos[0]+2) < self.lastpos[0]:
                Clock.schedule_once(self.collapseParentCB, 0.1)
        pass
    '''

    def commandCB(self, d):
        self.command(self.gamenode.key)

    def toggleCB(self, d):
        self.parent.toggle_node(self)

    '''
    def collapseParentCB(self, d):
        if self.parent:
            if self.parent_node.is_open:
                self.parent.toggle_node(self.parent_node)
            self.lastpos = None
    '''
# ************************************************************************
# * Dialog
# ************************************************************************


class SelectGameDialog(object):

    # Dialog, einmal erzeugt, wird rezykliert.
    SingleInstance = None

    def onClick(self, event):
        print('LTopLevel: onClick')
        SelectGameDialog.SingleInstance.parent.popWork('SelectGame')
        SelectGameDialog.SingleInstance.running = False

    def selectCmd(self, gameid):
        self.app.menubar._mSelectGame(gameid)

    def __init__(self, parent, title, app, gameid, **kw):
        super(SelectGameDialog, self).__init__()

        self.parent = parent
        self.app = app
        self.gameid = gameid
        self.random = None
        self.running = False
        self.window = None

        # bestehenden Dialog rezyklieren.

        si = SelectGameDialog.SingleInstance
        # if (si and si.running): return
        if (si and si.running):
            si.parent.popWork('SelectGame')
            si.running = False
            return
        if (si):
            si.parent.pushWork('SelectGame', si.window)
            si.running = True
            return

        # neuen Dialog aufbauen.

        window = LTopLevel(parent, title)
        window.titleline.bind(on_press=self.onClick)
        self.parent.pushWork('SelectGame', window)
        self.window = window
        self.running = True
        SelectGameDialog.SingleInstance = self

        # Asynchron laden.

        def loaderCB(treeview, node):

            # Beispielcode aus doku:
            #
            # for name in ('Item 1', 'Item 2'):
            #   yield TreeViewLabel(text=name, parent=node)
            #
            # LGameNode ist ein Button. Es stellt sich heraus, dass
            # wir (ev. darum) parent=node NICHT setzen dürfen, da das
            # sonst zum versuchten doppelten einfügen des gleichen
            # widget im tree führt.

            if node:
                if not hasattr(node, "gamenode"):
                    # (das löst ein problem mit dem root knoten),
                    return

            v = treeview.gameview
            if node:
                n = node.gamenode
                n.tree = treeview.gametree

                nodes = n.getContents()
                if type(nodes) is list:
                    # Blaetter
                    for l in nodes:
                        # print ('**game=%s' % l.text)
                        yield LGameNode(
                            l, v, text=l.text,
                            is_leaf=True,
                            command=self.selectCmd)

                if type(nodes) is tuple:
                    # Knoten
                    for nn in nodes:
                        # print ('**node=%s' % nn.text)
                        newnode = LGameNode(
                            nn, v, text=nn.text, is_leaf=False)
                        yield newnode

                    print('all nodes done')
            else:
                # Knoten
                nodes = treeview.gametree.rootnodes[:]
                for n in nodes:
                    newnode = LGameNode(n, v, text=n.text, is_leaf=False)
                    # print ('**node=%s' % newnode)
                    yield newnode

        # treeview aufsetzen.

        tree = SelectGameData(app)
        tv = self.tvroot = LGameRoot(
            tree,
            self.app.canvas,
            root_options=dict(text='Tree One'))
        tv.size_hint = 1, None
        tv.hide_root = True
        tv.load_func = loaderCB
        tv.bind(minimum_height=tv.setter('height'))

        # tree in einem Scrollwindow präsentieren.

        root = LScrollView(pos=(0, 0))
        root.add_widget(tv)
        window.content.add_widget(root)

# ************************************************************************
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
from pysollib.mygettext import _
from pysollib.settings import TITLE
from pysollib.ui.tktile.tkconst import EVENT_HANDLED

from six.moves import tkinter


class BaseSolverDialog:
    def _ToggleShowProgressButton(self, *args):
        self.app.opt.solver_show_progress = self.progress_var.get()

    def _getMaxIters(self):
        try:
            i = self.max_iters_var.get()
        except Exception:
            i = 100000
        return i

    def _OnAssignToMaxIters(self, *args):
        self.app.opt.solver_max_iterations = self._getMaxIters()

    def _OnAssignToPreset(self, *args):
        self.app.opt.solver_preset = self.preset_var.get()

    def __init__(self, parent, app, **kw):
        self.parent = parent
        self.app = app
        title = _('%(app)s - FreeCell Solver') % {'app': TITLE}
        kw = self.initKw(kw)
        self._calc_MfxDialog().__init__(
            self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        self.games = {}                 # key: gamename; value: gameid

        #
        frame = self._calcToolkit().Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=4, pady=4)
        frame.columnconfigure(1, weight=1)

        #
        row = 0
        self._calcToolkit().Label(
            frame, text=_('Game:'), anchor='w').grid(
            row=row, column=0, sticky='ew', padx=2, pady=2)
        games = app.getGamesForSolver()
        gamenames = ['']
        for id in games:
            name = app.getGameTitleName(id)
            gamenames.append(name)
            self.games[name] = id
        gamenames.sort()
        self.gamenames = gamenames
        self.games_var = self._createGamesVar(frame, row)

        #
        row += 1
        self._calcToolkit().Label(
            frame, text=_('Preset:'), anchor='w').grid(
            row=row, column=0, sticky='ew', padx=2, pady=2)
        presets = app.opt.solver_presets
        self.presets = presets
        self.preset_var = self._createPresetVar(frame, row)
        self.preset_var.set(self.app.opt.solver_preset)

        #
        row += 1
        self.max_iters_var = tkinter.IntVar()
        self.max_iters_var.set(self.app.opt.solver_max_iterations)
        self._calcToolkit().Label(
            frame, text=_('Max iterations:'), anchor='w').grid(
            row=row, column=0, sticky='ew', padx=2, pady=2)
        spin = tkinter.Spinbox(frame, bg='white', from_=1000, to=10e6,
                               increment=1000, textvariable=self.max_iters_var)
        self.max_iters_var.trace('w', self._OnAssignToMaxIters)
        spin.grid(row=row, column=1, sticky='w', padx=2, pady=2)

        #
        row += 1
        self.progress_var = tkinter.BooleanVar()
        self.progress_var.set(self.app.opt.solver_show_progress)
        w = self._createShowProgressButton(frame)
        w.grid(row=row, column=0, columnspan=2, sticky='ew', padx=2, pady=2)
        w.config(command=self._ToggleShowProgressButton)

        #
        label_frame = self._calcToolkit().LabelFrame(
            top_frame, text=_('Progress'))
        label_frame.pack(expand=True, fill='both', padx=6, pady=2)
        # label_frame.columnconfigure(0, weight=1)
        label_frame.columnconfigure(1, weight=1)

        #
        frow = 0
        self._calcToolkit().Label(
            label_frame, text=_('Iteration:'), anchor='w').grid(
            row=frow, column=0, sticky='ew', padx=4, pady=2)
        lb = self._calcToolkit().Label(label_frame, anchor='w')
        lb.grid(row=frow, column=1, sticky='ew', padx=4, pady=2)
        self.iter_label = lb
        frow += 1
        self._calcToolkit().Label(
            label_frame, text=_('Depth:'), anchor='w').grid(
            row=frow, column=0, sticky='ew', padx=4, pady=2)
        lb = self._calcToolkit().Label(label_frame, anchor='w')
        lb.grid(row=frow, column=1, sticky='ew', padx=4, pady=2)
        self.depth_label = lb
        frow += 1
        self._calcToolkit().Label(
            label_frame, text=_('Stored-States:'), anchor='w').grid(
            row=frow, column=0, sticky='ew', padx=4, pady=2)
        lb = self._calcToolkit().Label(label_frame, anchor='w')
        lb.grid(row=frow, column=1, sticky='ew', padx=4, pady=2)
        self.states_label = lb

        #
        lb = self._calcToolkit().Label(top_frame, anchor='w')
        lb.pack(expand=True, fill='x', padx=6, pady=4)
        self.result_label = lb

        #
        focus = self.createButtons(bottom_frame, kw)
        self.start_button = self.buttons[0]
        self.play_button = self.buttons[1]
        self._reset()
        self.connectGame(self.app.game)
        self.mainloop(focus, kw.timeout, transient=False)

    def mDone(self, button):
        if button == 0:
            self.startSolving()
        elif button == 1:
            self.startPlay()
        elif button == 2:
            self.app.menubar.mNewGame()
        elif button == 3:
            global solver_dialog
            solver_dialog = None
            self.destroy()
        return EVENT_HANDLED

    def mCancel(self, *event):
        return self.mDone(3)

    def wmDeleteWindow(self, *event):
        return self.mDone(3)

    def gameSelected(self, *event):
        name = self.games_var.get()
        if not name:
            return
        id = self.games[name]
        self.app.menubar._mSelectGame(id)

    def _reset(self):
        self.play_button.config(state='disabled')
        self.setText(iter='', depth='', states='')
        self.result_label['text'] = ''
        self.top.update_idletasks()

    def reset(self):
        self.play_button.config(state='disabled')

    def startSolving(self):
        from pysollib.mygettext import ungettext

        self._reset()
        game = self.app.game
        solver = game.Solver_Class(game, self)  # create solver instance
        game.solver = solver
        preset = self.preset_var.get()
        max_iters = self._getMaxIters()
        progress = self.app.opt.solver_show_progress
        iters_step = self.app.opt.solver_iterations_output_step
        solver.config(preset=preset, max_iters=max_iters, progress=progress,
                      iters_step=iters_step)
        try:
            solver.computeHints()
        except RuntimeError:
            self.result_label['text'] = _('Solver not found in the PATH')
            return
        hints_len = len(solver.hints)-1
        if hints_len > 0:
            if solver.solver_state == 'intractable':
                t = ungettext('This game can be hinted in %d move.',
                              'This game can be hinted in %d moves.',
                              hints_len)
            else:
                t = ungettext('This game is solvable in %d move.',
                              'This game is solvable in %d moves.',
                              hints_len)
            t = t % hints_len
            self.result_label['text'] = t
            self.play_button.config(state='normal')
        else:
            self.result_label['text'] = \
                (_('I could not solve this game.')
                 if solver.solver_state == 'unsolved'
                 else _('Iterations count exceeded (Intractable)'))
            self.play_button.config(state='disabled')

    def startPlay(self):
        self.play_button.config(state='disabled')
        self.start_button.focus()
        if self.app.game.pause:
            self.app.menubar.mPause()
        self.app.top.tkraise()
        self.app.top.update_idletasks()
        self.app.top.update()
        self.app.top.after(200)
        self.app.game.startDemo(level=3)

    def setText(self, **kw):
        if 'iter' in kw:
            self.iter_label['text'] = kw['iter']
        if 'depth' in kw:
            self.depth_label['text'] = kw['depth']
        if 'states' in kw:
            self.states_label['text'] = kw['states']
        self.top.update_idletasks()


solver_dialog = None


def connect_game_solver_dialog(game):
    try:
        solver_dialog.connectGame(game)
    except Exception:
        pass


def destroy_solver_dialog():
    global solver_dialog
    try:
        solver_dialog.destroy()
    except Exception:
        # traceback.print_exc()
        pass
    solver_dialog = None


def reset_solver_dialog():
    if solver_dialog:
        try:
            solver_dialog.reset()
        except Exception:
            # traceback.print_exc()
            pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

# ************************************************************************
# * Nodes
# ************************************************************************

# imports
from six.moves import tkinter_font


class BaseSelectDialogTreeLeaf:
    def drawSymbol(self, x, y, **kw):
        if self.tree.nodes.get(self.symbol_id) is not self:
            self.symbol_id = self.tree.canvas.create_image(
                x, y,
                image=self.tree.data.img[2+(self.key is None)], anchor="nw")
            self.tree.nodes[self.symbol_id] = self


class BaseSelectDialogTreeNode:
    def __init__(self, tree, text, select_func, expanded=0, parent_node=None):
        self._calc_MfxTreeNode().__init__(
            self, tree, parent_node, text, key=None, expanded=expanded)
        # callable or a tuple/list of MfxTreeNodes
        self.select_func = select_func

    def drawSymbol(self, x, y, **kw):
        if self.tree.nodes.get(self.symbol_id) is not self:
            self.symbol_id = self.tree.canvas.create_image(
                x, y,
                image=self.tree.data.img[self.expanded], anchor="nw")
            self.tree.nodes[self.symbol_id] = self

    def getContents(self):
        # cached values
        if self.subnodes is not None:
            return self.subnodes
        # print self.whoami()
        if isinstance(self.select_func, (tuple, list)):
            return self.select_func
        return self._getContents()

    def _getContents(self):
        # subclass
        return []


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectDialogTreeData:
    img = []  # loaded in Application.loadImages3

    def __init__(self):
        self.tree_xview = (0.0, 1.0)
        self.tree_yview = (0.0, 1.0)


# ************************************************************************
# * Canvas that shows the tree (left side)
# ************************************************************************

class BaseSelectDialogTreeCanvas:
    def __init__(self, dialog, parent, key, default,
                 font=None, width=-1, height=-1, hbar=2, vbar=3):
        self.dialog = dialog
        self.default = default
        self.n_selections = 0
        self.n_expansions = 0
        #
        disty = 16
        if width < 0:
            width = 400
        if height < 0:
            height = 20 * disty
            if parent and parent.winfo_screenheight() >= 600:
                height = 25 * disty
            if parent and parent.winfo_screenheight() >= 800:
                height = 30 * disty
        self.lines = height // disty
        self._calc_MfxTreeInCanvas().__init__(
                self, parent, self.data.rootnodes,
                width=width, height=height,
                hbar=hbar, vbar=vbar)
        self.style.distx = 20
        self.style.disty = disty
        self.style.width = 16     # width of symbol
        self.style.height = 14    # height of symbol
        if font:
            self.style.font = font
            f = tkinter_font.Font(parent, font)
            h = f.metrics()["linespace"]
            self.style.disty = max(self.style.width, h)

        self.draw()
        self.updateSelection(key)
        if self.hbar:
            # print self.data.tree_yview
            # print self.canvas.xview()
            self.canvas.xview_moveto(self.data.tree_xview[0])
        if self.vbar:
            # print self.data.tree_yview
            # print self.canvas.yview()
            self.canvas.yview_moveto(self.data.tree_yview[0])

    def destroy(self):
        if self.n_expansions > 0:   # must save updated xyview
            self.data.tree_xview = self.canvas.xview()
            self.data.tree_yview = self.canvas.yview()
        self._calc_MfxTreeInCanvas().destroy(self)

    def getContents(self, node):
        return node.getContents()

    def singleClick(self, event=None):
        node = self.findNode()
        if isinstance(node, self._calc_MfxTreeLeaf()):
            if not node.selected and node.key is not None:
                oldcur = self.canvas["cursor"]
                self.canvas["cursor"] = "watch"
                self.canvas.update_idletasks()
                self.n_selections = self.n_selections + 1
                self.updateSelection(node.key)
                self.dialog.updatePreview(self.selection_key)
                self.canvas["cursor"] = oldcur
        elif isinstance(node, self._calc_MfxTreeNode()):
            self.n_expansions = self.n_expansions + 1
            node.expanded = not node.expanded
            self.redraw()
        return "break"

    def doubleClick(self, event=None):
        node = self.findNode()
        if isinstance(node, self._calc_MfxTreeLeaf()):
            if node.key is not None:
                self.n_selections = self.n_selections + 1
                self.updateSelection(node.key)
                self.dialog.mDone(self.default)
        elif isinstance(node, self._calc_MfxTreeNode()):
            self.n_expansions = self.n_expansions + 1
            node.expanded = not node.expanded
            self.redraw()
        return "break"
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _

from six.moves import tkinter
from six.moves.tkinter_colorchooser import askcolor


class BaseColorsDialog:
    def _calcFrame(self):
        return self._calcToolkit().Frame

    def _calcLabel(self):
        return self._calcToolkit().Label

    def _calcButton(self):
        return self._calcToolkit().Button

    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        self._calc_MfxDialog().__init__(
            self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = self._calcFrame()(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        self.text_var = tkinter.StringVar()
        self.text_var.set(app.opt.colors['text'])
        self.piles_var = tkinter.StringVar()
        self.piles_var.set(app.opt.colors['piles'])
        self.cards_1_var = tkinter.StringVar()
        self.cards_1_var.set(app.opt.colors['cards_1'])
        self.cards_2_var = tkinter.StringVar()
        self.cards_2_var.set(app.opt.colors['cards_2'])
        self.samerank_1_var = tkinter.StringVar()
        self.samerank_1_var.set(app.opt.colors['samerank_1'])
        self.samerank_2_var = tkinter.StringVar()
        self.samerank_2_var.set(app.opt.colors['samerank_2'])
        self.hintarrow_var = tkinter.StringVar()
        self.hintarrow_var.set(app.opt.colors['hintarrow'])
        self.not_matching_var = tkinter.StringVar()
        self.not_matching_var.set(app.opt.colors['not_matching'])
        #
        row = 0
        for title, var in (
            (_('Text foreground:'),        self.text_var),
            (_('Highlight piles:'),        self.piles_var),
            (_('Highlight cards 1:'),      self.cards_1_var),
            (_('Highlight cards 2:'),      self.cards_2_var),
            (_('Highlight same rank 1:'),  self.samerank_1_var),
            (_('Highlight same rank 2:'),  self.samerank_2_var),
            (_('Hint arrow:'),             self.hintarrow_var),
            (_('Highlight not matching:'), self.not_matching_var),
                ):
            self._calcLabel()(
                frame, text=title, anchor='w',).grid(
                row=row, column=0, sticky='we')
            label = tkinter.Label(frame, width=10, height=2,
                                  bg=var.get(), textvariable=var)
            label.grid(row=row, column=1, padx=5)
            b = self._calcButton()(
                frame, text=_('Change...'), width=10,
                command=lambda label=label: self.selectColor(label))
            b.grid(row=row, column=2)
            row += 1
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)
        #
        self.text_color = self.text_var.get()
        self.piles_color = self.piles_var.get()
        self.cards_1_color = self.cards_1_var.get()
        self.cards_2_color = self.cards_2_var.get()
        self.samerank_1_color = self.samerank_1_var.get()
        self.samerank_2_color = self.samerank_2_var.get()
        self.hintarrow_color = self.hintarrow_var.get()
        self.not_matching_color = self.not_matching_var.get()

    def selectColor(self, label):
        try:
            c = askcolor(parent=self.top, initialcolor=label.cget('bg'),
                         title=_("Select color"))
        except Exception:
            pass
        else:
            if c and c[1]:
                label.configure(bg=c[1])
                # label.configure(text=c[1]) # don't work
                label.setvar(label.cget('textvariable'), c[1])

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")),
                      default=0,
                      )
        return self._calc_MfxDialog().initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import formatter
import os
import sys

import pysollib.htmllib2 as htmllib
from pysollib.mfxutil import openURL
from pysollib.mygettext import _
from pysollib.settings import TITLE
from pysollib.ui.tktile.tkutil import bind, unbind_destroy

from six.moves import tkinter

REMOTE_PROTOCOLS = ("ftp:", "gopher:", "http:", "mailto:", "news:", "telnet:")

# ************************************************************************
# *
# ************************************************************************


class tkHTMLWriter(formatter.NullWriter):
    def __init__(self, text, viewer, app):
        formatter.NullWriter.__init__(self)

        self.text = text
        self.viewer = viewer

        if app:
            font = app.getFont("sans")
            fixed = app.getFont("fixed")
        else:
            font = ('helvetica', 12)
            fixed = ('courier', 12)
        size = font[1]
        sign = 1
        if size < 0:
            sign = -1
        self.fontmap = {
            "h1": (font[0], size + 12*sign, "bold"),
            "h2": (font[0], size + 8*sign, "bold"),
            "h3": (font[0], size + 6*sign, "bold"),
            "h4": (font[0], size + 4*sign, "bold"),
            "h5": (font[0], size + 2*sign, "bold"),
            "h6": (font[0], size + 1*sign, "bold"),
            "bold": (font[0], size, "bold"),
            "italic": (font[0], size, "italic"),
            "pre": fixed,
        }

        self.text.config(cursor=self.viewer.defcursor, font=font)
        for f in self.fontmap.keys():
            self.text.tag_config(f, font=self.fontmap[f])

        self.anchor = None
        self.anchor_mark = None
        self.font = None
        self.font_mark = None
        self.indent = ""

    def createCallback(self, href):
        class Functor:
            def __init__(self, viewer, arg):
                self.viewer = viewer
                self.arg = arg

            def __call__(self, *args):
                self.viewer.updateHistoryXYView()
                return self.viewer.display(self.arg)
        return Functor(self.viewer, href)

    def write(self, data):
        self.text.insert("insert", str(data))

    def anchor_bgn(self, href, name, type):
        if href:
            # self.text.update_idletasks()   # update display during parsing
            self.anchor = (href, name, type)
            self.anchor_mark = self.text.index("insert")

    def anchor_end(self):
        if self.anchor:
            url = self.anchor[0]
            tag = "href_" + url
            self.text.tag_add(tag, self.anchor_mark, "insert")
            self.text.tag_bind(tag, "<1>", self.createCallback(url))
            self.text.tag_bind(
                tag, "<Enter>", lambda e: self.anchor_enter(url))
            self.text.tag_bind(tag, "<Leave>", self.anchor_leave)
            fg = 'blue'
            u = self.viewer.normurl(url, with_protocol=False)
            if u in self.viewer.visited_urls:
                fg = '#660099'
            self.text.tag_config(tag, foreground=fg, underline=1)
            self.anchor = None

    def anchor_enter(self, url):
        url = self.viewer.normurl(url)
        self.viewer.statusbar.updateText(url=url)
        self.text.config(cursor=self.viewer.handcursor)

    def anchor_leave(self, *args):
        self.viewer.statusbar.updateText(url='')
        self.text.config(cursor=self.viewer.defcursor)

    def new_font(self, font):
        # end the current font
        if self.font:
            # print "end_font(%s)" % `self.font`
            self.text.tag_add(self.font, self.font_mark, "insert")
            self.font = None
        # start the new font
        if font:
            # print "start_font(%s)" % `font`
            self.font_mark = self.text.index("insert")
            if font[0] in self.fontmap:
                self.font = font[0]
            elif font[3]:
                self.font = "pre"
            elif font[2]:
                self.font = "bold"
            elif font[1]:
                self.font = "italic"
            else:
                self.font = None

    def new_margin(self, margin, level):
        self.indent = "    " * level

    def send_label_data(self, data):
        # self.write(self.indent + data + " ")
        self.write(self.indent)
        if data == '*':  # <li>
            img = self.viewer.symbols_img.get('disk')
            if img:
                self.text.image_create(index='insert', image=img,
                                       padx=0, pady=0)
            else:
                self.write('*')
        else:
            self.write(data)
        self.write(' ')

    def send_paragraph(self, blankline):
        self.write("\n" * blankline)

    def send_line_break(self):
        self.write("\n")

    def send_hor_rule(self, *args):
        width = int(int(self.text["width"]) * 0.9)
        self.write("_" * width)
        self.write("\n")

    def send_literal_data(self, data):
        self.write(data)

    def send_flowing_data(self, data):
        self.write(data)


# ************************************************************************
# *
# ************************************************************************

class tkHTMLParser(htmllib.HTMLParser):
    def anchor_bgn(self, href, name, type):
        self.formatter.flush_softspace()
        htmllib.HTMLParser.anchor_bgn(self, href, name, type)
        self.formatter.writer.anchor_bgn(href, name, type)

    def anchor_end(self):
        if self.anchor:
            self.anchor = None
        self.formatter.writer.anchor_end()

    def do_dt(self, attrs):
        self.formatter.end_paragraph(1)
        self.ddpop()

    def handle_image(self, src, alt, ismap, align, width, height):
        self.formatter.writer.viewer.showImage(
            src, alt, ismap, align, width, height)


class Base_HTMLViewer:
    def initBindings(self):
        w = self.parent
        bind(w, "WM_DELETE_WINDOW", self.destroy)
        bind(w, "<Escape>", self.destroy)
        bind(w, "<KeyPress-Prior>", self.page_up)
        bind(w, "<KeyPress-Next>", self.page_down)
        bind(w, "<KeyPress-Up>", self.unit_up)
        bind(w, "<KeyPress-Down>", self.unit_down)
        bind(w, "<KeyPress-Begin>", self.scroll_top)
        bind(w, "<KeyPress-Home>", self.scroll_top)
        bind(w, "<KeyPress-End>", self.scroll_bottom)
        bind(w, "<KeyPress-BackSpace>", self.goBack)

    def destroy(self, *event):
        unbind_destroy(self.parent)
        try:
            self.parent.wm_withdraw()
        except Exception:
            pass
        try:
            self.parent.destroy()
        except Exception:
            pass
        self.parent = None

    def _yview(self, *args):
        self.text.yview(*args)
        return 'break'

    def page_up(self, *event):
        return self._yview('scroll', -1, 'page')

    def page_down(self, *event):
        return self._yview('scroll', 1, 'page')

    def unit_up(self, *event):
        return self._yview('scroll', -1, 'unit')

    def unit_down(self, *event):
        return self._yview('scroll', 1, 'unit')

    def scroll_top(self, *event):
        return self._yview('moveto', 0)

    def scroll_bottom(self, *event):
        return self._yview('moveto', 1)

    # locate a file relative to the current self.url
    def basejoin(self, url, baseurl=None, relpath=1):
        if baseurl is None:
            baseurl = self.url
        if 0:
            import urllib.request
            import urllib.parse
            import urllib.error
            url = urllib.request.pathname2url(url)
            if relpath and self.url:
                url = urllib.basejoin(baseurl, url)
        else:
            url = os.path.normpath(url)
            if relpath and baseurl and not os.path.isabs(url):
                h1, t1 = os.path.split(url)
                h2, t2 = os.path.split(baseurl)
                if h1 != h2:
                    url = os.path.join(h2, h1, t1)
                url = os.path.normpath(url)
        return url

    def normurl(self, url, with_protocol=True):
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                break
        else:
            url = self.basejoin(url)
            if with_protocol:
                if os.name == 'nt':
                    url = url.replace('\\', '/')
                url = 'file://'+url
        return url

    def openfile(self, url):
        if url[-1:] == "/" or os.path.isdir(url):
            url = os.path.join(url, "index.html")
        url = os.path.normpath(url)

        def my_open(url):
            if sys.version_info > (3,):
                import codecs
                return codecs.open(url, encoding='utf-8')
            else:
                return open(url, "rb")
        return my_open(url), url

    def display(self, url, add=1, relpath=1, xview=0, yview=0):
        # for some reason we have to stop the PySol demo
        # (is this a multithread problem with tkinter ?)
        if self.app and self.app.game:
            self.app.game.stopDemo()
            # self.app.game._cancelDrag()
            # pass

        # ftp: and http: would work if we use urllib, but this widget is
        # far too limited to display anything but our documentation...
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                if not openURL(url):
                    self.errorDialog(_('''%(app)s HTML limitation:
The %(protocol)s protocol is not supported yet.

Please use your standard web browser
to open the following URL:
%(url)s
''') % {'app': TITLE, 'protocol': p, 'url': url})
                return

        # locate the file relative to the current url
        url = self.basejoin(url, relpath=relpath)

        # read the file
        try:
            file = None
            if 0:
                import urllib.request
                import urllib.parse
                import urllib.error
                file = urllib.request.urlopen(url)
            else:
                file, url = self.openfile(url)
            data = file.read()
            file.close()
            file = None
        except Exception as ex:
            if file:
                file.close()
            self.errorDialog(_("Unable to service request:\n") + url +
                             "\n\n" + str(ex))
            return
        except Exception:
            if file:
                file.close()
            self.errorDialog(_("Unable to service request:\n") + url)
            return

        self.url = url
        if self.home is None:
            self.home = self.url
        if add:
            self.addHistory(self.url, xview=xview, yview=yview)

        # print self.history.index, self.history.list
        if self.history.index > 1:
            self.backButton.config(state="normal")
        else:
            self.backButton.config(state="disabled")
        if self.history.index < len(self.history.list):
            self.forwardButton.config(state="normal")
        else:
            self.forwardButton.config(state="disabled")

        old_c1, old_c2 = self.defcursor, self.handcursor
        self.defcursor = self.handcursor = "watch"
        self.text.config(cursor=self.defcursor)
        self.text.update_idletasks()
        # self.frame.config(cursor=self.defcursor)
        # self.frame.update_idletasks()
        self.text.config(state="normal")
        self.text.delete("1.0", "end")
        # self.images = {}
        writer = tkHTMLWriter(self.text, self, self.app)
        fmt = formatter.AbstractFormatter(writer)
        parser = tkHTMLParser(fmt)
        parser.feed(data)
        parser.close()
        self.text.config(state="disabled")
        if 0.0 <= xview <= 1.0:
            self.text.xview_moveto(xview)
        if 0.0 <= yview <= 1.0:
            self.text.yview_moveto(yview)
        self.parent.wm_title(parser.title)
        self.parent.wm_iconname(parser.title)
        self.defcursor, self.handcursor = old_c1, old_c2
        self.text.config(cursor=self.defcursor)
        # self.frame.config(cursor=self.defcursor)

    def addHistory(self, url, xview=0, yview=0):
        if url not in self.visited_urls:
            self.visited_urls.append(url)
        if self.history.index > 0:
            u, xv, yv = self.history.list[self.history.index-1]
            if u == url:
                self.updateHistoryXYView()
                return
        del self.history.list[self.history.index:]
        self.history.list.append((url, xview, yview))
        self.history.index = self.history.index + 1

    def updateHistoryXYView(self):
        if self.history.index > 0:
            url, xview, yview = self.history.list[self.history.index-1]
            xview = self.text.xview()[0]
            yview = self.text.yview()[0]
            self.history.list[self.history.index-1] = (url, xview, yview)

    def goBack(self, *event):
        if self.history.index > 1:
            self.updateHistoryXYView()
            self.history.index = self.history.index - 1
            url, xview, yview = self.history.list[self.history.index-1]
            self.display(url, add=0, relpath=0, xview=xview, yview=yview)

    def goForward(self, *event):
        if self.history.index < len(self.history.list):
            self.updateHistoryXYView()
            url, xview, yview = self.history.list[self.history.index]
            self.history.index = self.history.index + 1
            self.display(url, add=0, relpath=0, xview=xview, yview=yview)

    def goHome(self, *event):
        if self.home and self.home != self.url:
            self.updateHistoryXYView()
            self.display(self.home, relpath=0)

    def errorDialog(self, msg):
        self._calc_MfxMessageDialog()(
            self.parent, title="%(app)s HTML Problem" % {'app': TITLE},
            text=msg,
            # bitmap="warning", # FIXME: this interp don't have images
            strings=(_("&OK"),), default=0)

    def getImage(self, fn):
        if fn in self.images:
            return self.images[fn]
        try:
            img = tkinter.PhotoImage(master=self.parent, file=fn)
        except Exception:
            img = None
        self.images[fn] = img
        return img

    def showImage(self, src, alt, ismap, align, width, height):
        url = self.basejoin(src)
        img = self.getImage(url)
        if img:
            self.text.image_create(index="insert", image=img, padx=0, pady=0)
import math
import os
import re
import sys

from pysollib.gamedb import GI
from pysollib.hint import PySolHintLayoutImportError
from pysollib.mfxutil import Image, USE_PIL
from pysollib.mfxutil import Struct, kwdefault
from pysollib.mygettext import _, n_
from pysollib.settings import SELECT_GAME_MENU
from pysollib.settings import TITLE, WIN_SYSTEM
from pysollib.settings import USE_FREECELL_SOLVER
from pysollib.ui.tktile.tkconst import COMPOUNDS, CURSOR_WATCH, EVENT_HANDLED
from pysollib.ui.tktile.tkconst import EVENT_PROPAGATE
from pysollib.ui.tktile.tkconst import TOOLBAR_BUTTONS
from pysollib.ui.tktile.tkutil import after_idle, bind

from six.moves import tkinter
from six.moves import tkinter_tkfiledialog


def createToolbarMenu(menubar, menu):
    tearoff = menu.cget('tearoff')
#     data_dir = os.path.join(menubar.app.dataloader.dir, 'images', 'toolbar')
#     submenu = MfxMenu(menu, label=n_('Style'), tearoff=tearoff)
#     for f in os.listdir(data_dir):
#         d = os.path.join(data_dir, f)
#         if os.path.isdir(d) and os.path.exists(os.path.join(d, 'small')):
#             name = f.replace('_', ' ').capitalize()
#             submenu.add_radiobutton(
#               label=name,
#               variable=menubar.tkopt.toolbar_style,
#               value=f, command=menubar.mOptToolbarStyle)
    submenu = MfxMenu(menu, label=n_('Compound'), tearoff=tearoff)
    for comp, label in COMPOUNDS:
        submenu.add_radiobutton(
            label=label, variable=menubar.tkopt.toolbar_compound,
            value=comp, command=menubar.mOptToolbarCompound)
    menu.add_separator()
    menu.add_radiobutton(label=n_("Hide"),
                         variable=menubar.tkopt.toolbar, value=0,
                         command=menubar.mOptToolbar)
    menu.add_radiobutton(label=n_("Top"),
                         variable=menubar.tkopt.toolbar, value=1,
                         command=menubar.mOptToolbar)
    menu.add_radiobutton(label=n_("Bottom"),
                         variable=menubar.tkopt.toolbar, value=2,
                         command=menubar.mOptToolbar)
    menu.add_radiobutton(label=n_("Left"),
                         variable=menubar.tkopt.toolbar, value=3,
                         command=menubar.mOptToolbar)
    menu.add_radiobutton(label=n_("Right"),
                         variable=menubar.tkopt.toolbar, value=4,
                         command=menubar.mOptToolbar)
    #  menu.add_separator()
    #  menu.add_radiobutton(label=n_("Small icons"),
    #                       variable=menubar.tkopt.toolbar_size, value=0,
    #                       command=menubar.mOptToolbarSize)
    #  menu.add_radiobutton(label=n_("Large icons"),
    #                       variable=menubar.tkopt.toolbar_size, value=1,
    #                       command=menubar.mOptToolbarSize)
    menu.add_separator()
    submenu = MfxMenu(menu, label=n_('Visible buttons'), tearoff=tearoff)
    for w in TOOLBAR_BUTTONS:
        submenu.add_checkbutton(
            label=_(w.capitalize()),
            variable=menubar.tkopt.toolbar_vars[w],
            command=lambda m=menubar, w=w: m.mOptToolbarConfig(w))


# ************************************************************************
# *
# ************************************************************************

class MfxMenubar(tkinter.Menu):
    addPath = None

    def __init__(self, master, **kw):
        self.name = kw["name"]
        tearoff = 0
        self.n = kw["tearoff"] = int(kw.get("tearoff", tearoff))
        tkinter.Menu.__init__(self, master, **kw)

    def labeltoname(self, label):
        # print label, type(label)
        name = re.sub(r"[^0-9a-zA-Z]", "", label).lower()
        label = _(label)
        underline = label.find('&')
        if underline >= 0:
            label = label.replace('&', '')
        return name, label, underline

    def add(self, itemType, cnf={}):
        label = cnf.get("label")
        if label:
            name = cnf.get('name')
            if name:
                del cnf['name']  # TclError: unknown option "-name"
            else:
                name, label, underline = self.labeltoname(label)
                cnf["underline"] = cnf.get("underline", underline)
            cnf["label"] = label
            if name and self.addPath:
                path = str(self._w) + "." + name
                self.addPath(path, self, self.n, cnf.get("menu"))
        tkinter.Menu.add(self, itemType, cnf)
        self.n = self.n + 1


class MfxMenu(MfxMenubar):
    def __init__(self, master, label, underline=None, **kw):
        if 'name' in kw:
            name, label_underline = kw['name'], -1
        else:
            name, label, label_underline = self.labeltoname(label)
        kwdefault(kw, name=name)
        MfxMenubar.__init__(self, master, **kw)
        if underline is None:
            underline = label_underline
        if master:
            master.add_cascade(
                menu=self, name=name, label=label, underline=underline)


class PysolMenubarTkCommon:
    def __init__(self, app, top, progress=None):
        self._createTkOpt()
        self._setOptions()
        # init columnbreak
        self.cb_max = int(self.top.winfo_screenheight()//23)
        #  sh = self.top.winfo_screenheight()
        #  self.cb_max = 22
        #  if sh >= 600: self.cb_max = 27
        #  if sh >= 768: self.cb_max = 32
        #  if sh >= 1024: self.cb_max = 40
        self.progress = progress
        # create menus
        self.menubar = None
        self.menupath = {}
        self.keybindings = {}
        self._createMenubar()
        self.top = top

        if self.progress:
            self.progress.update(step=1)

        # set the menubar
        self.updateBackgroundImagesMenu()
        self.top.config(menu=self.menubar)

    def _createTkOpt(self):
        # structure to convert menu-options to Toolkit variables
        self.tkopt = Struct(
            gameid=tkinter.IntVar(),
            gameid_popular=tkinter.IntVar(),
            comment=tkinter.BooleanVar(),
            autofaceup=tkinter.BooleanVar(),
            autodrop=tkinter.BooleanVar(),
            autodeal=tkinter.BooleanVar(),
            quickplay=tkinter.BooleanVar(),
            undo=tkinter.BooleanVar(),
            bookmarks=tkinter.BooleanVar(),
            hint=tkinter.BooleanVar(),
            shuffle=tkinter.BooleanVar(),
            highlight_piles=tkinter.BooleanVar(),
            highlight_cards=tkinter.BooleanVar(),
            highlight_samerank=tkinter.BooleanVar(),
            highlight_not_matching=tkinter.BooleanVar(),
            mahjongg_show_removed=tkinter.BooleanVar(),
            shisen_show_hint=tkinter.BooleanVar(),
            sound=tkinter.BooleanVar(),
            auto_scale=tkinter.BooleanVar(),
            cardback=tkinter.IntVar(),
            tabletile=tkinter.IntVar(),
            animations=tkinter.IntVar(),
            redeal_animation=tkinter.BooleanVar(),
            win_animation=tkinter.BooleanVar(),
            shadow=tkinter.BooleanVar(),
            shade=tkinter.BooleanVar(),
            shade_filled_stacks=tkinter.BooleanVar(),
            shrink_face_down=tkinter.BooleanVar(),
            toolbar=tkinter.IntVar(),
            toolbar_style=tkinter.StringVar(),
            toolbar_relief=tkinter.StringVar(),
            toolbar_compound=tkinter.StringVar(),
            toolbar_size=tkinter.IntVar(),
            statusbar=tkinter.BooleanVar(),
            num_cards=tkinter.BooleanVar(),
            helpbar=tkinter.BooleanVar(),
            save_games_geometry=tkinter.BooleanVar(),
            splashscreen=tkinter.BooleanVar(),
            demo_logo=tkinter.BooleanVar(),
            mouse_type=tkinter.StringVar(),
            mouse_undo=tkinter.BooleanVar(),
            negative_bottom=tkinter.BooleanVar(),
            pause=tkinter.BooleanVar(),
            theme=tkinter.StringVar(),
            toolbar_vars={},
        )
        for w in TOOLBAR_BUTTONS:
            self.tkopt.toolbar_vars[w] = tkinter.BooleanVar()

    def _setOptions(self):
        tkopt, opt = self.tkopt, self.app.opt
        # set state of the menu items
        tkopt.autofaceup.set(opt.autofaceup)
        tkopt.autodrop.set(opt.autodrop)
        tkopt.autodeal.set(opt.autodeal)
        tkopt.quickplay.set(opt.quickplay)
        tkopt.undo.set(opt.undo)
        tkopt.hint.set(opt.hint)
        tkopt.shuffle.set(opt.shuffle)
        tkopt.bookmarks.set(opt.bookmarks)
        tkopt.highlight_piles.set(opt.highlight_piles)
        tkopt.highlight_cards.set(opt.highlight_cards)
        tkopt.highlight_samerank.set(opt.highlight_samerank)
        tkopt.highlight_not_matching.set(opt.highlight_not_matching)
        tkopt.shrink_face_down.set(opt.shrink_face_down)
        tkopt.shade_filled_stacks.set(opt.shade_filled_stacks)
        tkopt.mahjongg_show_removed.set(opt.mahjongg_show_removed)
        tkopt.shisen_show_hint.set(opt.shisen_show_hint)
        tkopt.sound.set(opt.sound)
        tkopt.auto_scale.set(opt.auto_scale)
        tkopt.cardback.set(self.app.cardset.backindex)
        tkopt.tabletile.set(self.app.tabletile_index)
        tkopt.animations.set(opt.animations)
        tkopt.redeal_animation.set(opt.redeal_animation)
        tkopt.win_animation.set(opt.win_animation)
        tkopt.shadow.set(opt.shadow)
        tkopt.shade.set(opt.shade)
        tkopt.toolbar.set(opt.toolbar)
        tkopt.toolbar_style.set(opt.toolbar_style)
        tkopt.toolbar_relief.set(opt.toolbar_relief)
        tkopt.toolbar_compound.set(opt.toolbar_compound)
        tkopt.toolbar_size.set(opt.toolbar_size)
        tkopt.toolbar_relief.set(opt.toolbar_relief)
        tkopt.statusbar.set(opt.statusbar)
        tkopt.num_cards.set(opt.num_cards)
        tkopt.helpbar.set(opt.helpbar)
        tkopt.save_games_geometry.set(opt.save_games_geometry)
        tkopt.demo_logo.set(opt.demo_logo)
        tkopt.splashscreen.set(opt.splashscreen)
        tkopt.mouse_type.set(opt.mouse_type)
        tkopt.mouse_undo.set(opt.mouse_undo)
        tkopt.negative_bottom.set(opt.negative_bottom)
        for w in TOOLBAR_BUTTONS:
            tkopt.toolbar_vars[w].set(opt.toolbar_vars.get(w, False))

    def connectGame(self, game):
        self.game = game
        if game is None:
            return
        assert self.app is game.app
        tkopt = self.tkopt
        tkopt.gameid.set(game.id)
        tkopt.gameid_popular.set(game.id)
        tkopt.comment.set(bool(game.gsaveinfo.comment))
        tkopt.pause.set(self.game.pause)
        if game.canFindCard():
            self._connect_game_find_card_dialog(game)
        else:
            self._destroy_find_card_dialog()
        self._connect_game_solver_dialog(game)

    # create a GTK-like path
    def _addPath(self, path, menu, index, submenu):
        if path not in self.menupath:
            # print path, menu, index, submenu
            self.menupath[path] = (menu, index, submenu)

    def _getEnabledState(self, enabled):
        if enabled:
            return "normal"
        return "disabled"

    def updateProgress(self):
        if self.progress:
            self.progress.update(step=1)

    def _createMenubar(self):
        MfxMenubar.addPath = self._addPath
        kw = {"name": "menubar"}
        self.menubar = MfxMenubar(self.top, **kw)

        # init keybindings
        bind(self.top, "<KeyPress>", self._keyPressHandler)

        m = "Ctrl-"
        if sys.platform == "darwin":
            m = "Cmd-"

        if WIN_SYSTEM == "aqua":
            applemenu = MfxMenu(self.menubar, "apple")
            applemenu.add_command(
                label=_("&About %s") % TITLE, command=self.mHelpAbout)

        menu = MfxMenu(self.menubar, n_("&File"))
        menu.add_command(
            label=n_("&New game"), command=self.mNewGame, accelerator="N")
        submenu = MfxMenu(menu, label=n_("R&ecent games"))
        # menu.add_command(label=n_("Select &random game"),
        #   command=self.mSelectRandomGame, accelerator=m+"R")
        submenu = MfxMenu(menu, label=n_("Select &random game"))
        submenu.add_command(
            label=n_("&All games"), command=lambda:
            self.mSelectRandomGame('all'), accelerator=m+"R")
        submenu.add_command(
            label=n_("Games played and &won"),
            command=lambda: self.mSelectRandomGame('won'))
        submenu.add_command(
            label=n_("Games played and &not won"),
            command=lambda: self.mSelectRandomGame('not won'))
        submenu.add_command(
            label=n_("Games not &played"),
            command=lambda: self.mSelectRandomGame('not played'))
        menu.add_command(
            label=n_("Select game by nu&mber..."),
            command=self.mSelectGameById, accelerator=m+"M")
        menu.add_separator()
        submenu = MfxMenu(menu, label=n_("Fa&vorite games"))
        menu.add_command(label=n_("A&dd to favorites"), command=self.mAddFavor)
        menu.add_command(
            label=n_("Remove &from favorites"),
            command=self.mDelFavor)
        menu.add_separator()
        menu.add_command(
            label=n_("&Open..."),
            command=self.mOpen, accelerator=m+"O")
        menu.add_command(
            label=n_("&Save"),
            command=self.mSave, accelerator=m+"S")
        menu.add_command(label=n_("Save &as..."), command=self.mSaveAs)
        menu.add_command(
            label=n_("E&xport current layout..."),
            command=self.mExportCurrentLayout)
        menu.add_command(
            label=n_("&Import starting layout..."),
            command=self.mImportStartingLayout)
        menu.add_separator()
        menu.add_command(
            label=n_("&Hold and quit"),
            command=self.mHoldAndQuit, accelerator=m+"X")
        if WIN_SYSTEM != "aqua":
            menu.add_command(
                label=n_("&Quit"),
                command=self.mQuit, accelerator=m+"Q")

        if self.progress:
            self.progress.update(step=1)

        menu = MfxMenu(self.menubar, label=n_("&Select"))
        self._addSelectGameMenu(menu)

        if self.progress:
            self.progress.update(step=1)

        menu = MfxMenu(self.menubar, label=n_("&Edit"))
        menu.add_command(
            label=n_("&Undo"),
            command=self.mUndo, accelerator="Z")
        menu.add_command(
            label=n_("&Redo"),
            command=self.mRedo, accelerator="R")
        menu.add_command(label=n_("Redo &all"), command=self.mRedoAll)

        menu.add_separator()
        submenu = MfxMenu(menu, label=n_("&Set bookmark"))
        for i in range(9):
            label = _("Bookmark %d") % (i + 1)
            submenu.add_command(
                label=label,
                command=lambda i=i: self.mSetBookmark(i))
        submenu = MfxMenu(menu, label=n_("Go&to bookmark"))
        for i in range(9):
            label = _("Bookmark %d") % (i + 1)
            acc = m + "%d" % (i + 1)
            submenu.add_command(
                label=label,
                command=lambda i=i: self.mGotoBookmark(i), accelerator=acc)
        menu.add_command(
            label=n_("&Clear bookmarks"),
            command=self.mClearBookmarks)
        menu.add_separator()

        menu.add_command(
            label=n_("Restart"),
            command=self.mRestart, accelerator=m+"G")

        menu.add_separator()
        menu.add_command(label=n_("Solitaire &Wizard"), command=self.mWizard)
        menu.add_command(
            label=n_("&Edit current game"),
            command=self.mWizardEdit)

        menu = MfxMenu(self.menubar, label=n_("&Game"))
        menu.add_command(
            label=n_("&Deal cards"),
            command=self.mDeal, accelerator="D")
        menu.add_command(
            label=n_("&Auto drop"),
            command=self.mDrop, accelerator="A")
        menu.add_command(
            label=n_("Shu&ffle tiles"),
            command=self.mShuffle, accelerator="F")
        menu.add_checkbutton(
            label=n_("&Pause"), variable=self.tkopt.pause,
            command=self.mPause, accelerator="P")
        # menu.add_command(
        #    label=n_("&Pause"), command=self.mPause, accelerator="P")
        menu.add_separator()
        menu.add_command(
            label=n_("S&tatus..."),
            command=lambda: self.mPlayerStats(mode=100), accelerator=m+"Y")
        menu.add_checkbutton(
            label=n_("&Comments..."), variable=self.tkopt.comment,
            command=self.mEditGameComment)
        menu.add_separator()
        menu.add_command(
            label=n_("&Statistics..."),
            command=self.mPlayerStats, accelerator=m+"T")
        menu.add_command(
            label=n_("Log..."),
            command=lambda: self.mPlayerStats(mode=103))
        menu.add_separator()
        menu.add_command(
            label=n_("D&emo statistics"),
            command=lambda: self.mPlayerStats(mode=1101))

        menu = MfxMenu(self.menubar, label=n_("&Assist"))
        menu.add_command(
            label=n_("&Hint"),
            command=self.mHint, accelerator="H")
        menu.add_command(
            label=n_("Highlight p&iles"),
            command=self.mHighlightPiles, accelerator="I")
        menu.add_command(
            label=n_("&Find card"),
            command=self.mFindCard, accelerator="F3")
        menu.add_separator()
        menu.add_command(
            label=n_("&Demo"),
            command=self.mDemo, accelerator=m+"D")
        menu.add_command(
            label=n_("Demo (&all games)"),
            command=self.mMixedDemo)
        if USE_FREECELL_SOLVER:
            menu.add_command(label=n_("&Solver"), command=self.mSolver)
        else:
            menu.add_command(label=n_("&Solver"), state='disabled')
        menu.add_separator()
        menu.add_command(
            label=n_("&Piles description"),
            command=self.mStackDesk, accelerator="F2")

        if self.progress:
            self.progress.update(step=1)

        menu = MfxMenu(self.menubar, label=n_("&Options"))
        menu.add_command(
            label=n_("&Player options..."),
            command=self.mOptPlayerOptions)
        submenu = MfxMenu(menu, label=n_("&Automatic play"))
        submenu.add_checkbutton(
            label=n_("Auto &face up"), variable=self.tkopt.autofaceup,
            command=self.mOptAutoFaceUp)
        submenu.add_checkbutton(
            label=n_("A&uto drop"), variable=self.tkopt.autodrop,
            command=self.mOptAutoDrop)
        submenu.add_checkbutton(
            label=n_("Auto &deal"), variable=self.tkopt.autodeal,
            command=self.mOptAutoDeal)
        submenu.add_separator()
        submenu.add_checkbutton(
            label=n_("&Quick play"), variable=self.tkopt.quickplay,
            command=self.mOptQuickPlay)
        submenu = MfxMenu(menu, label=n_("Assist &level"))
        submenu.add_checkbutton(
            label=n_("Enable &undo"), variable=self.tkopt.undo,
            command=self.mOptEnableUndo)
        submenu.add_checkbutton(
            label=n_("Enable &bookmarks"), variable=self.tkopt.bookmarks,
            command=self.mOptEnableBookmarks)
        submenu.add_checkbutton(
            label=n_("Enable &hint"), variable=self.tkopt.hint,
            command=self.mOptEnableHint)
        submenu.add_checkbutton(
            label=n_("Enable shu&ffle"), variable=self.tkopt.shuffle,
            command=self.mOptEnableShuffle)
        submenu.add_checkbutton(
            label=n_("Enable highlight p&iles"),
            variable=self.tkopt.highlight_piles,
            command=self.mOptEnableHighlightPiles)
        submenu.add_checkbutton(
            label=n_("Enable highlight &cards"),
            variable=self.tkopt.highlight_cards,
            command=self.mOptEnableHighlightCards)
        submenu.add_checkbutton(
            label=n_("Enable highlight same &rank"),
            variable=self.tkopt.highlight_samerank,
            command=self.mOptEnableHighlightSameRank)
        submenu.add_checkbutton(
            label=n_("Highlight &no matching"),
            variable=self.tkopt.highlight_not_matching,
            command=self.mOptEnableHighlightNotMatching)
        submenu.add_separator()
        submenu.add_checkbutton(
            label=n_("&Show removed tiles (in Mahjongg games)"),
            variable=self.tkopt.mahjongg_show_removed,
            command=self.mOptMahjonggShowRemoved)
        submenu.add_checkbutton(
            label=n_("Show hint &arrow (in Shisen-Sho games)"),
            variable=self.tkopt.shisen_show_hint,
            command=self.mOptShisenShowHint)
        menu.add_separator()
        label = n_("&Sound...")
        if not self.app.audio.CAN_PLAY_SOUND:
            menu.add_checkbutton(
                label=label, variable=self.tkopt.sound,
                command=self.mOptSoundDialog, state='disabled')
        else:
            menu.add_checkbutton(
                label=label, variable=self.tkopt.sound,
                command=self.mOptSoundDialog)
        # cardsets
        if USE_PIL:
            submenu = MfxMenu(menu, label=n_("Card si&ze"))
            submenu.add_command(
                label=n_("&Increase the card size"),
                command=self.mIncreaseCardset, accelerator=m+"+")
            submenu.add_command(
                label=n_("&Decrease the card size"),
                command=self.mDecreaseCardset, accelerator=m+"-")
            submenu.add_checkbutton(
                label=n_("&Auto scaling"), variable=self.tkopt.auto_scale,
                command=self.mOptAutoScale, accelerator=m+'0')
        # manager = self.app.cardset_manager
        # n = manager.len()
        menu.add_command(
            label=n_("Cards&et..."),
            command=self.mSelectCardsetDialog, accelerator=m+"E")
        menu.add_command(
            label=n_("Table t&ile..."),
            command=self.mSelectTileDialog)
        # this submenu will get set by updateBackgroundImagesMenu()
        submenu = MfxMenu(menu, label=n_("Card &background"))
        submenu = MfxMenu(menu, label=n_("Card &view"))
        submenu.add_checkbutton(
            label=n_("Card shado&w"), variable=self.tkopt.shadow,
            command=self.mOptShadow)
        submenu.add_checkbutton(
            label=n_("Shade &legal moves"), variable=self.tkopt.shade,
            command=self.mOptShade)
        submenu.add_checkbutton(
            label=n_("&Negative cards bottom"),
            variable=self.tkopt.negative_bottom,
            command=self.mOptNegativeBottom)
        submenu.add_checkbutton(
            label=n_("Shrink face-down cards"),
            variable=self.tkopt.shrink_face_down,
            command=self.mOptShrinkFaceDown)
        submenu.add_checkbutton(
            label=n_("Shade &filled stacks"),
            variable=self.tkopt.shade_filled_stacks,
            command=self.mOptShadeFilledStacks)
        submenu = MfxMenu(menu, label=n_("A&nimations"))
        submenu.add_radiobutton(
            label=n_("&None"), variable=self.tkopt.animations, value=0,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("&Very fast"), variable=self.tkopt.animations, value=1,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("&Fast"), variable=self.tkopt.animations, value=2,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("&Medium"), variable=self.tkopt.animations, value=3,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("&Slow"), variable=self.tkopt.animations, value=4,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("V&ery slow"), variable=self.tkopt.animations, value=5,
            command=self.mOptAnimations)
        submenu.add_separator()
        submenu.add_checkbutton(
            label=n_("&Redeal animation"),
            variable=self.tkopt.redeal_animation,
            command=self.mRedealAnimation)
        if Image:
            submenu.add_checkbutton(
                label=n_("&Winning animation"),
                variable=self.tkopt.win_animation,
                command=self.mWinAnimation)
        submenu = MfxMenu(menu, label=n_("&Mouse"))
        submenu.add_radiobutton(
            label=n_("&Drag-and-Drop"), variable=self.tkopt.mouse_type,
            value='drag-n-drop',
            command=self.mOptMouseType)
        submenu.add_radiobutton(
            label=n_("&Point-and-Click"), variable=self.tkopt.mouse_type,
            value='point-n-click',
            command=self.mOptMouseType)
        submenu.add_radiobutton(
            label=n_("&Sticky mouse"), variable=self.tkopt.mouse_type,
            value='sticky-mouse',
            command=self.mOptMouseType)
        submenu.add_separator()
        submenu.add_checkbutton(
            label=n_("Use mouse for undo/redo"),
            variable=self.tkopt.mouse_undo,
            command=self.mOptMouseUndo)
        menu.add_separator()
        menu.add_command(label=n_("&Fonts..."), command=self.mOptFonts)
        menu.add_command(label=n_("&Colors..."), command=self.mOptColors)
        menu.add_command(label=n_("Time&outs..."), command=self.mOptTimeouts)
        menu.add_separator()
        self.createThemesMenu(menu)
        submenu = MfxMenu(menu, label=n_("&Toolbar"))
        createToolbarMenu(self, submenu)
        submenu = MfxMenu(menu, label=n_("Stat&usbar"))
        submenu.add_checkbutton(
            label=n_("Show &statusbar"), variable=self.tkopt.statusbar,
            command=self.mOptStatusbar)
        submenu.add_checkbutton(
            label=n_("Show &number of cards"), variable=self.tkopt.num_cards,
            command=self.mOptNumCards)
        submenu.add_checkbutton(
            label=n_("Show &help bar"), variable=self.tkopt.helpbar,
            command=self.mOptHelpbar)
        # if not USE_PIL:
        menu.add_checkbutton(
            label=n_("Save games &geometry"),
            variable=self.tkopt.save_games_geometry,
            command=self.mOptSaveGamesGeometry)
        menu.add_checkbutton(
            label=n_("&Demo logo"), variable=self.tkopt.demo_logo,
            command=self.mOptDemoLogo)
        menu.add_checkbutton(
            label=n_("Startup splash sc&reen"),
            variable=self.tkopt.splashscreen,
            command=self.mOptSplashscreen)
        #  menu.add_separator()
        #  menu.add_command(label="Save options", command=self.mOptSave)

        if self.progress:
            self.progress.update(step=1)

        menu = MfxMenu(self.menubar, label=n_("&Help"))
        menu.add_command(
            label=n_("&Contents"),
            command=self.mHelp, accelerator=m+"F1")
        menu.add_command(
            label=n_("&How to play"),
            command=self.mHelpHowToPlay)
        menu.add_command(
            label=n_("&Rules for this game"),
            command=self.mHelpRules, accelerator="F1")
        menu.add_command(
            label=n_("&License terms"),
            command=self.mHelpLicense)
        # menu.add_command(label=n_("What's &new ?"), command=self.mHelpNews)
        if WIN_SYSTEM != "aqua":
            menu.add_separator()
            menu.add_command(
                label=_("&About %s...") % TITLE,
                command=self.mHelpAbout)

        MfxMenubar.addPath = None

        # FIXME: all key bindings should be *added* to keyPressHandler
        ctrl = "Control-"
        if sys.platform == "darwin":
            ctrl = "Command-"
        self._bindKey("",   "n", self.mNewGame)
        self._bindKey(ctrl, "w", self.mSelectGameDialog)
        self._bindKey(ctrl, "v", self.mSelectGameDialogWithPreview)
        self._bindKey(ctrl, "r", lambda e: self.mSelectRandomGame())
        self._bindKey(ctrl, "m", self.mSelectGameById)
        self._bindKey(ctrl, "n", self.mNewGameWithNextId)
        self._bindKey(ctrl, "o", self.mOpen)
        self._bindKey(ctrl, "s", self.mSave)
        self._bindKey(ctrl, "x", self.mHoldAndQuit)
        self._bindKey(ctrl, "q", self.mQuit)
        self._bindKey(ctrl, "z", self.mUndo)
        self._bindKey("",   "z", self.mUndo)
        self._bindKey("",   "BackSpace", self.mUndo)    # undocumented
        self._bindKey("",   "KP_Enter", self.mUndo)     # undocumented
        self._bindKey("",   "r", self.mRedo)
        self._bindKey(ctrl, "g", self.mRestart)
        self._bindKey("",   "space", self.mDeal)        # undocumented
        self._bindKey(ctrl, "y", lambda e: self.mPlayerStats(mode=100))
        self._bindKey(ctrl, "t", lambda e: self.mPlayerStats(mode=105))
        self._bindKey("",   "h", self.mHint)
        self._bindKey(ctrl, "h", self.mHint1)           # undocumented
        # self._bindKey("",   "Shift_L", self.mHighlightPiles)
        # self._bindKey("",   "Shift_R", self.mHighlightPiles)
        self._bindKey("",   "i", self.mHighlightPiles)
        self._bindKey("",   "F3", self.mFindCard)
        self._bindKey(ctrl, "d", self.mDemo)
        self._bindKey(ctrl, "e", self.mSelectCardsetDialog)
        if USE_PIL:
            self._bindKey(ctrl, "plus", self.mIncreaseCardset)
            self._bindKey(ctrl, "equal", self.mIncreaseCardset)
            self._bindKey(ctrl, "minus", self.mDecreaseCardset)
            self._bindKey(ctrl, "0", self.mOptAutoScale)
        self._bindKey(ctrl, "b", self.mOptChangeCardback)  # undocumented
        self._bindKey(ctrl, "i", self.mOptChangeTableTile)  # undocumented
        self._bindKey(ctrl, "p", self.mOptPlayerOptions)   # undocumented
        self._bindKey(ctrl, "F1", self.mHelp)
        self._bindKey("",   "F1", self.mHelpRules)
        self._bindKey("",   "Print", self.mScreenshot)
        self._bindKey(ctrl, "u", self.mPlayNextMusic)   # undocumented
        self._bindKey("",   "p", self.mPause)
        self._bindKey("",   "Pause", self.mPause)       # undocumented
        self._bindKey("",   "Escape", self.mIconify)    # undocumented
        # ASD and LKJ
        self._bindKey("",   "a", self.mDrop)
        self._bindKey(ctrl, "a", self.mDrop1)
        self._bindKey("",   "s", self.mUndo)
        self._bindKey("",   "d", self.mDeal)
        self._bindKey("",   "l", self.mDrop)
        self._bindKey(ctrl, "l", self.mDrop1)
        self._bindKey("",   "k", self.mUndo)
        self._bindKey("",   "j", self.mDeal)

        self._bindKey("",   "F2", self.mStackDesk)
        #
        # undocumented, devel
        self._bindKey("", "slash", lambda e: self.mPlayerStats(mode=106))
        #
        self._bindKey("",   "f", self.mShuffle)

        for i in range(9):
            self._bindKey(
                ctrl, str(i+1),
                lambda e, i=i: self.mGotoBookmark(i, confirm=0))

        # undocumented, devel
        self._bindKey(ctrl, "End", self.mPlayNextMusic)
        self._bindKey(ctrl, "Prior", self.mSelectPrevGameByName)
        self._bindKey(ctrl, "Next", self.mSelectNextGameByName)
        self._bindKey(ctrl, "Up", self.mSelectPrevGameById)
        self._bindKey(ctrl, "Down", self.mSelectNextGameById)

    #
    # key binding utility
    #

    def _bindKey(self, modifier, key, func):
        #  if 0 and not modifier and len(key) == 1:
        #      self.keybindings[key.lower()] = func
        #      self.keybindings[key.upper()] = func
        #      return
        if not modifier and len(key) == 1:
            # ignore Ctrl/Shift/Alt
            # but don't ignore NumLock (state == 16)
            def func(e, f2=func):
                return e.state in (0, 16) and f2(e)
        sequence = "<" + modifier + "KeyPress-" + key + ">"
        bind(self.top, sequence, func)
        if len(key) == 1 and key != key.upper():
            key = key.upper()
            sequence = "<" + modifier + "KeyPress-" + key + ">"
            bind(self.top, sequence, func)

    def _keyPressHandler(self, event):
        r = EVENT_PROPAGATE
        if event and self.game:
            # print event.__dict__
            if self.game.demo:
                # stop the demo by setting self.game.demo.keypress
                if event.char:    # ignore Ctrl/Shift/etc.
                    self.game.demo.keypress = event.char
                    r = EVENT_HANDLED
                # func = self.keybindings.get(event.char)
                # if func and (event.state & ~2) == 0:
                #    func(event)
                #    r = EVENT_HANDLED
        return r

    #
    # Select Game menu creation
    #

    def _addSelectGameMenu(self, menu):
        # games = map(self.app.gdb.get,
        #   self.app.gdb.getGamesIdSortedByShortName())
        games = list(map(
            self.app.gdb.get, self.app.gdb.getGamesIdSortedByName()))
        # games = tuple(games)
        # menu = MfxMenu(menu, label="Select &game")
        m = "Ctrl-"
        if sys.platform == "darwin":
            m = "Cmd-"
        menu.add_command(label=n_("All &games..."), accelerator=m+"W",
                         command=self.mSelectGameDialog)
        menu.add_command(label=n_("Playable pre&view..."), accelerator=m+"V",
                         command=self.mSelectGameDialogWithPreview)
        if not SELECT_GAME_MENU:
            return
        menu.add_separator()
        self._addSelectPopularGameSubMenu(games, menu, self.mSelectGame,
                                          self.tkopt.gameid)
        self._addSelectFrenchGameSubMenu(games, menu, self.mSelectGame,
                                         self.tkopt.gameid)
        if self.progress:
            self.progress.update(step=1)
        self._addSelectMahjonggGameSubMenu(games, menu, self.mSelectGame,
                                           self.tkopt.gameid)
        self._addSelectOrientalGameSubMenu(games, menu, self.mSelectGame,
                                           self.tkopt.gameid)
        self._addSelectSpecialGameSubMenu(games, menu, self.mSelectGame,
                                          self.tkopt.gameid)
        self._addSelectCustomGameSubMenu(games, menu, self.mSelectGame,
                                         self.tkopt.gameid)
        menu.add_separator()
        if self.progress:
            self.progress.update(step=1)
        self._addSelectAllGameSubMenu(games, menu, self.mSelectGame,
                                      self.tkopt.gameid)

    def _addSelectGameSubMenu(self, games, menu, select_data,
                              command, variable):
        # print select_data
        need_sep = 0
        for label, select_func in select_data:
            if label is None:
                need_sep = 1
                continue
            g = list(filter(select_func, games))
            if not g:
                continue
            if need_sep:
                menu.add_separator()
                need_sep = 0
            submenu = MfxMenu(menu, label=label)
            self._addSelectGameSubSubMenu(g, submenu, command, variable)

    def _getNumGames(self, games, select_data):
        ngames = 0
        for label, select_func in select_data:
            ngames += len(list(filter(select_func, games)))
        return ngames

    def _addSelectMahjonggGameSubMenu(self, games, menu, command, variable):
        def select_func(gi):
            return gi.si.game_type == GI.GT_MAHJONGG
        mahjongg_games = list(filter(select_func, games))
        if len(mahjongg_games) == 0:
            return
        #
        menu = MfxMenu(menu, label=n_("&Mahjongg games"))

        def add_menu(games, c0, c1, menu=menu,
                     variable=variable, command=command):
            if not games:
                return
            label = c0 + ' - ' + c1
            if c0 == c1:
                label = c0
            submenu = MfxMenu(menu, label=label, name=None)
            self._addSelectGameSubSubMenu(games, submenu, command,
                                          variable, short_name=True)

        games = {}
        for gi in mahjongg_games:
            c = gi.short_name.strip()[0]
            if c in games:
                games[c].append(gi)
            else:
                games[c] = [gi]
        games = list(games.items())
        games.sort()
        g0 = []
        c0 = c1 = games[0][0]
        for c, g1 in games:
            if len(g0)+len(g1) >= self.cb_max:
                add_menu(g0, c0, c1)
                g0 = g1
                c0 = c1 = c
            else:
                g0 += g1
                c1 = c
        add_menu(g0, c0, c1)

    def _addSelectPopularGameSubMenu(self, games, menu, command, variable):
        def select_func(gi):
            return gi.si.game_flags & GI.GT_POPULAR
        if len(list(filter(select_func, games))) == 0:
            return
        data = (n_("&Popular games"), select_func)
        self._addSelectGameSubMenu(games, menu, (data, ),
                                   self.mSelectGamePopular,
                                   self.tkopt.gameid_popular)

    def _addSelectFrenchGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&French games"))
        self._addSelectGameSubMenu(games, submenu, GI.SELECT_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectOrientalGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_ORIENTAL_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&Oriental games"))
        self._addSelectGameSubMenu(games, submenu,
                                   GI.SELECT_ORIENTAL_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectSpecialGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_ORIENTAL_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&Special games"))
        self._addSelectGameSubMenu(games, submenu,
                                   GI.SELECT_SPECIAL_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectCustomGameSubMenu(self, games, menu, command, variable):
        submenu = MfxMenu(menu, label=n_("&Custom games"))

        def select_func(gi):
            return gi.si.game_type == GI.GT_CUSTOM
        games = list(filter(select_func, games))
        self.updateGamesMenu(submenu, games)

    def _addSelectAllGameSubMenu(self, games, menu, command, variable):
        menu = MfxMenu(menu, label=n_("&All games by name"))
        n, d = 0, self.cb_max
        i = 0
        while True:
            if self.progress:
                self.progress.update(step=1)
            columnbreak = i > 0 and (i % d) == 0
            i += 1
            if not games[n:n+d]:
                break
            m = min(n+d-1, len(games)-1)
            label = games[n].name[:3] + ' - ' + games[m].name[:3]
            submenu = MfxMenu(menu, label=label, name=None)
            self._addSelectGameSubSubMenu(games[n:n+d], submenu,
                                          command, variable)
            n += d
            if columnbreak:
                menu.entryconfigure(i, columnbreak=columnbreak)

    def _addSelectGameSubSubMenu(self, games, menu, command, variable,
                                 short_name=False):
        # cb = (25, self.cb_max) [ len(g) > 4 * 25 ]
        # cb = min(cb, self.cb_max)
        cb = self.cb_max
        for i in range(len(games)):
            gi = games[i]
            columnbreak = i > 0 and (i % cb) == 0
            if short_name:
                label = gi.short_name
            else:
                label = gi.name
            # optimized by inlining
            menu.tk.call((menu._w, 'add', 'radiobutton') +
                         menu._options({'command': command,
                                        'variable': variable,
                                        'columnbreak': columnbreak,
                                        'value': gi.id,
                                        'label': label}))

    def updateGamesMenu(self, menu, games):
        menu.delete(0, 'last')
        if len(games) == 0:
            menu.add_radiobutton(label=_('<none>'), name=None,
                                 state='disabled')
        elif len(games) > self.cb_max*4:
            games.sort(key=lambda x: x.name)
            self._addSelectAllGameSubMenu(games, menu,
                                          command=self.mSelectGame,
                                          variable=self.tkopt.gameid)
        else:
            self._addSelectGameSubSubMenu(games, menu,
                                          command=self.mSelectGame,
                                          variable=self.tkopt.gameid)

    #
    # Select Game menu actions
    #

    def mSelectGame(self, *args):
        self._mSelectGame(self.tkopt.gameid.get())

    def mSelectGamePopular(self, *args):
        self._mSelectGame(self.tkopt.gameid_popular.get())

    def _mSelectGameDialog(self, d):
        if d.status == 0 and d.button == 0 and d.gameid != self.game.id:
            self.tkopt.gameid.set(d.gameid)
            self.tkopt.gameid_popular.set(d.gameid)
            if 0:
                self._mSelectGame(d.gameid, random=d.random)
            else:
                # don't ask areYouSure()
                self._cancelDrag()
                self.game.endGame()
                self.game.quitGame(d.gameid, random=d.random)
        return EVENT_HANDLED

    def __restoreCursor(self, *event):
        self.game.setCursor(cursor=self.app.top_cursor)

    def mSelectGameDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        d = self._calcSelectGameDialog()(
            self.top, title=_("Select game"),
            app=self.app, gameid=self.game.id)
        return self._mSelectGameDialog(d)

    def mSelectGameDialogWithPreview(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        bookmark = None
        if 0:
            # use a bookmark for our preview game
            if self.game.setBookmark(-2, confirm=0):
                bookmark = self.game.gsaveinfo.bookmarks[-2][0]
                del self.game.gsaveinfo.bookmarks[-2]
        after_idle(self.top, self.__restoreCursor)
        d = self._calcSelectGameDialogWithPreview()(
            self.top, title=_("Select game"),
            app=self.app, gameid=self.game.id,
            bookmark=bookmark)
        return self._mSelectGameDialog(d)

    #
    # menubar overrides
    #

    def updateFavoriteGamesMenu(self):
        gameids = self.app.opt.favorite_gameid
        submenu = self.menupath[".menubar.file.favoritegames"][2]
        games = []
        for id in gameids:
            gi = self.app.getGameInfo(id)
            if gi:
                games.append(gi)
        self.updateGamesMenu(submenu, games)
        state = self._getEnabledState
        in_favor = self.app.game.id in gameids
        menu, index, submenu = self.menupath[".menubar.file.addtofavorites"]
        menu.entryconfig(index, state=state(not in_favor))
        menu, index, submenu = \
            self.menupath[".menubar.file.removefromfavorites"]
        menu.entryconfig(index, state=state(in_favor))

    def updateRecentGamesMenu(self, gameids):
        submenu = self.menupath[".menubar.file.recentgames"][2]
        games = []
        for id in gameids:
            gi = self.app.getGameInfo(id)
            if gi:
                games.append(gi)
        self.updateGamesMenu(submenu, games)

    def updateBookmarkMenuState(self):
        state = self._getEnabledState
        mp1 = self.menupath.get(".menubar.edit.setbookmark")
        mp2 = self.menupath.get(".menubar.edit.gotobookmark")
        mp3 = self.menupath.get(".menubar.edit.clearbookmarks")
        if mp1 is None or mp2 is None or mp3 is None:
            return
        x = self.app.opt.bookmarks and self.game.canSetBookmark()
        #
        menu, index, submenu = mp1
        for i in range(9):
            submenu.entryconfig(i, state=state(x))
        menu.entryconfig(index, state=state(x))
        #
        menu, index, submenu = mp2
        ms = 0
        for i in range(9):
            s = self.game.gsaveinfo.bookmarks.get(i) is not None
            submenu.entryconfig(i, state=state(s and x))
            ms = ms or s
        menu.entryconfig(index, state=state(ms and x))
        #
        menu, index, submenu = mp3
        menu.entryconfig(index, state=state(ms and x))

    def updateBackgroundImagesMenu(self):
        mp = self.menupath.get(".menubar.options.cardbackground")
        # delete all entries
        submenu = mp[2]
        submenu.delete(0, "last")
        # insert new cardbacks
        mbacks = self.app.images.getCardbacks()
        cb = int(math.ceil(math.sqrt(len(mbacks))))
        for i in range(len(mbacks)):
            columnbreak = i > 0 and (i % cb) == 0
            submenu.add_radiobutton(
                label=mbacks[i].name, image=mbacks[i].menu_image,
                variable=self.tkopt.cardback, value=i,
                command=self.mOptCardback, columnbreak=columnbreak,
                indicatoron=0, hidemargin=0)

    #
    # menu updates
    #

    def setMenuState(self, state, path):
        # print state, path
        path = ".menubar." + path
        mp = self.menupath.get(path)
        menu, index, submenu = mp
        s = self._getEnabledState(state)
        menu.entryconfig(index, state=s)

    def setToolbarState(self, state, path):
        # print state, path
        s = self._getEnabledState(state)
        w = getattr(self.app.toolbar, path + "_button")
        w["state"] = s

    def _setCommentMenu(self, v):
        self.tkopt.comment.set(v)

    def _setPauseMenu(self, v):
        self.tkopt.pause.set(v)

    #
    # menu actions
    #

    DEFAULTEXTENSION = ".pso"
    FILETYPES = ((_("%s files") % TITLE, "*" + DEFAULTEXTENSION),
                 (_("All files"), "*"))

    def mAddFavor(self, *event):
        gameid = self.app.game.id
        if gameid not in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.append(gameid)
            self.updateFavoriteGamesMenu()

    def mDelFavor(self, *event):
        gameid = self.app.game.id
        if gameid in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.remove(gameid)
            self.updateFavoriteGamesMenu()

    def mOpen(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        filename = self.game.filename
        if filename:
            idir, ifile = os.path.split(os.path.normpath(filename))
        else:
            idir, ifile = "", ""
        if not idir:
            idir = self.app.dn.savegames
        d = tkinter_tkfiledialog.Open()
        filename = d.show(filetypes=self.FILETYPES,
                          defaultextension=self.DEFAULTEXTENSION,
                          initialdir=idir, initialfile=ifile)
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            if os.path.isfile(filename):
                self.game.loadGame(filename)

    def mExportCurrentLayout(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        game = self.game
        if not self.menustate.save_as:
            return
        if not game.Solver_Class:
            d = self._calc_MfxMessageDialog()(
                self.top, title=_('Export game error'),
                text=_('''
Unsupported game for export.
'''),
                bitmap='error')
            return

        filename = game.filename
        if not filename:
            filename = self.app.getGameSaveName(self.game.id)
            if os.name == "posix" or os.path.supports_unicode_filenames:
                filename += "-" + self.game.getGameNumber(format=0)
            else:
                filename += "-01"
            filename += ".board"
        idir, ifile = os.path.split(os.path.normpath(filename))
        if not idir:
            idir = self.app.dn.savegames
        # print self.game.filename, ifile
        d = tkinter_tkfiledialog.SaveAs()
        filename = d.show(filetypes=self.FILETYPES,
                          defaultextension=self.DEFAULTEXTENSION,
                          initialdir=idir, initialfile=ifile)
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            with open(filename, 'w') as fh:
                game = self.game
                fh.write(game.Solver_Class(game, self).calcBoardString())
            self.updateMenus()

    def mImportStartingLayout(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        game = self.game
        if not game.Solver_Class:
            d = self._calc_MfxMessageDialog()(
                self.top, title=_('Import game error'),
                text=_('''
Unsupported game for import.
'''),
                bitmap='error')
            return

        filename = self.game.filename
        if filename:
            idir, ifile = os.path.split(os.path.normpath(filename))
        else:
            idir, ifile = "", ""
        if not idir:
            idir = self.app.dn.savegames
        d = tkinter_tkfiledialog.Open()
        key = 'PYSOL_DEBUG_IMPORT'
        if key not in os.environ:
            filename = d.show(filetypes=self.FILETYPES,
                              defaultextension=self.DEFAULTEXTENSION,
                              initialdir=idir, initialfile=ifile)
        else:
            filename = os.environ[key]
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            if os.path.isfile(filename):
                with open(filename, 'r+b') as fh:
                    game = self.game
                    try:
                        game.Solver_Class(game, self).importFile(
                            fh, game, self)
                    except PySolHintLayoutImportError as err:
                        self._calc_MfxMessageDialog()(
                            self.top,
                            title=_('Import game error'),
                            text=err.format(),
                            bitmap='error'
                        )
                        game.busy = False
                        game.endGame()
                        game.newGame()

    def mSaveAs(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.menustate.save_as:
            return
        filename = self.game.filename
        if not filename:
            filename = self.app.getGameSaveName(self.game.id)
            if os.name == "posix":
                filename = filename + "-" + self.game.getGameNumber(format=0)
            elif os.path.supports_unicode_filenames:  # new in python 2.3
                filename = filename + "-" + self.game.getGameNumber(format=0)
            else:
                filename = filename + "-01"
            filename = filename + self.DEFAULTEXTENSION
        idir, ifile = os.path.split(os.path.normpath(filename))
        if not idir:
            idir = self.app.dn.savegames
        # print self.game.filename, ifile
        d = tkinter_tkfiledialog.SaveAs()
        filename = d.show(filetypes=self.FILETYPES,
                          defaultextension=self.DEFAULTEXTENSION,
                          initialdir=idir, initialfile=ifile)
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            self.game.saveGame(filename)
            self.updateMenus()

    def mPause(self, *args):
        if not self.game:
            return
        if not self.game.pause:
            if self._cancelDrag():
                return
        self.game.doPause()
        self.tkopt.pause.set(self.game.pause)

    def mOptSoundDialog(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self._calcSoundOptionsDialog()(
            self.top, _("Sound settings"), self.app)
        self.tkopt.sound.set(self.app.opt.sound)

    def mOptAutoFaceUp(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autofaceup = self.tkopt.autofaceup.get()
        if self.app.opt.autofaceup:
            self.game.autoPlay()

    def mOptAutoDrop(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autodrop = self.tkopt.autodrop.get()
        if self.app.opt.autodrop:
            self.game.autoPlay()

    def mOptAutoDeal(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autodeal = self.tkopt.autodeal.get()
        if self.app.opt.autodeal:
            self.game.autoPlay()

    def mOptQuickPlay(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.quickplay = self.tkopt.quickplay.get()

    def mOptEnableUndo(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.undo = self.tkopt.undo.get()
        self.game.updateMenus()

    def mOptEnableBookmarks(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.bookmarks = self.tkopt.bookmarks.get()
        self.game.updateMenus()

    def mOptEnableHint(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.hint = self.tkopt.hint.get()
        self.game.updateMenus()

    def mOptEnableShuffle(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shuffle = self.tkopt.shuffle.get()
        self.game.updateMenus()

    def mOptEnableHighlightPiles(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_piles = self.tkopt.highlight_piles.get()
        self.game.updateMenus()

    def mOptEnableHighlightCards(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_cards = self.tkopt.highlight_cards.get()
        self.game.updateMenus()

    def mOptEnableHighlightSameRank(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_samerank = self.tkopt.highlight_samerank.get()
        # self.game.updateMenus()

    def mOptEnableHighlightNotMatching(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_not_matching = \
            self.tkopt.highlight_not_matching.get()
        # self.game.updateMenus()

    def mOptAnimations(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.animations = self.tkopt.animations.get()

    def mRedealAnimation(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.redeal_animation = self.tkopt.redeal_animation.get()

    def mWinAnimation(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.win_animation = self.tkopt.win_animation.get()

    def mOptShadow(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shadow = self.tkopt.shadow.get()

    def mOptShade(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shade = self.tkopt.shade.get()

    def mOptShrinkFaceDown(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shrink_face_down = self.tkopt.shrink_face_down.get()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptShadeFilledStacks(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shade_filled_stacks = self.tkopt.shade_filled_stacks.get()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptMahjonggShowRemoved(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.mahjongg_show_removed = \
            self.tkopt.mahjongg_show_removed.get()
        # self.game.updateMenus()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptShisenShowHint(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shisen_show_hint = self.tkopt.shisen_show_hint.get()
        # self.game.updateMenus()

    def _updateCardSize(self):
        geom = (self.app.canvas.winfo_width(),
                self.app.canvas.winfo_height())
        self.app.opt.game_geometry = geom
        self.app.game.resizeGame()
        if self.app.opt.auto_scale:
            w, h = self.app.opt.game_geometry
            self.app.canvas.setInitialSize(w, h, scrollregion=False)
        else:
            w = int(round(self.app.game.width * self.app.opt.scale_x))
            h = int(round(self.app.game.height * self.app.opt.scale_y))
            self.app.canvas.setInitialSize(w, h)
            self.app.top.wm_geometry("")    # cancel user-specified geometry
        # self.app.top.update_idletasks()

    def mIncreaseCardset(self, *event):
        if self._cancelDrag(break_pause=True):
            return
        if self.app.opt.scale_x < 4:
            self.app.opt.scale_x += 0.1
        else:
            return
        if self.app.opt.scale_y < 4:
            self.app.opt.scale_y += 0.1
        else:
            return
        self.app.opt.auto_scale = False
        self.tkopt.auto_scale.set(False)
        self._updateCardSize()

    def mDecreaseCardset(self, *event):
        if self._cancelDrag(break_pause=True):
            return
        if self.app.opt.scale_x > 0.5:
            self.app.opt.scale_x -= 0.1
        else:
            return
        if self.app.opt.scale_y > 0.5:
            self.app.opt.scale_y -= 0.1
        else:
            return
        self.app.opt.auto_scale = False
        self.tkopt.auto_scale.set(False)
        self._updateCardSize()

    def mOptAutoScale(self, *event):
        if self._cancelDrag(break_pause=True):
            return
        auto_scale = not self.app.opt.auto_scale
        self.app.opt.auto_scale = auto_scale
        self.tkopt.auto_scale.set(auto_scale)
        self._updateCardSize()

    def _mOptCardback(self, index):
        if self._cancelDrag(break_pause=False):
            return
        cs = self.app.cardset
        old_index = cs.backindex
        cs.updateCardback(backindex=index)
        if cs.backindex == old_index:
            return
        self.app.updateCardset(self.game.id)
        image = self.app.images.getBack(update=True)
        for card in self.game.cards:
            card.updateCardBackground(image=image)
        self.app.canvas.update_idletasks()
        self.tkopt.cardback.set(cs.backindex)

    def mOptCardback(self, *event):
        self._mOptCardback(self.tkopt.cardback.get())

    def mOptChangeCardback(self, *event):
        self._mOptCardback(self.app.cardset.backindex + 1)

    def mOptChangeTableTile(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        n = self.app.tabletile_manager.len()
        if n >= 2:
            i = (self.tkopt.tabletile.get() + 1) % n
            if self.app.setTile(i):
                self.tkopt.tabletile.set(i)

    def mSelectTileDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        key = self.app.tabletile_index
        if key <= 0:
            key = self.app.opt.colors['table']  # .lower()
        d = self._calcSelectTileDialogWithPreview()(
            self.top, app=self.app,
            title=_("Select table background"),
            manager=self.app.tabletile_manager,
            key=key)
        if d.status == 0 and d.button == 0:
            if isinstance(d.key, str):
                tile = self.app.tabletile_manager.get(0)
                tile.color = d.key
                if self.app.setTile(0):
                    self.tkopt.tabletile.set(0)
            elif d.key > 0 and d.key != self.app.tabletile_index:
                if self.app.setTile(d.key):
                    self.tkopt.tabletile.set(d.key)

    def mOptToolbar(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarSide(self.tkopt.toolbar.get())

    def mOptToolbarStyle(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarStyle(self.tkopt.toolbar_style.get())

    def mOptToolbarCompound(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarCompound(self.tkopt.toolbar_compound.get())

    def mOptToolbarSize(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarSize(self.tkopt.toolbar_size.get())

    def mOptToolbarConfig(self, w):
        self.toolbarConfig(w, self.tkopt.toolbar_vars[w].get())

    def mOptStatusbar(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.app.statusbar:
            return
        side = self.tkopt.statusbar.get()
        self.app.opt.statusbar = side
        resize = not self.app.opt.save_games_geometry
        if self.app.statusbar.show(side, resize=resize):
            self.top.update_idletasks()

    def mOptNumCards(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.num_cards = self.tkopt.num_cards.get()

    def mOptHelpbar(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.app.helpbar:
            return
        show = self.tkopt.helpbar.get()
        self.app.opt.helpbar = show
        resize = not self.app.opt.save_games_geometry
        if self.app.helpbar.show(show, resize=resize):
            self.top.update_idletasks()

    def mOptSaveGamesGeometry(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.save_games_geometry = self.tkopt.save_games_geometry.get()

    def mOptDemoLogo(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.demo_logo = self.tkopt.demo_logo.get()

    def mOptSplashscreen(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.splashscreen = self.tkopt.splashscreen.get()

    def mOptMouseType(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.mouse_type = self.tkopt.mouse_type.get()

    def mOptMouseUndo(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.mouse_undo = self.tkopt.mouse_undo.get()

    def mOptNegativeBottom(self, *event):
        if self._cancelDrag():
            return
        self.app.opt.negative_bottom = self.tkopt.negative_bottom.get()
        self.app.updateCardset()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    #
    # toolbar support
    #

    def setToolbarSide(self, side):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar = side
        self.tkopt.toolbar.set(side)                    # update radiobutton
        resize = not self.app.opt.save_games_geometry
        if self.app.toolbar.show(side, resize=resize):
            self.top.update_idletasks()

    def setToolbarSize(self, size):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_size = size
        self.tkopt.toolbar_size.set(size)                # update radiobutton
        dir = self.app.getToolbarImagesDir()
        if self.app.toolbar.updateImages(dir, size):
            self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarStyle(self, style):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_style = style
        self.tkopt.toolbar_style.set(style)                # update radiobutton
        dir = self.app.getToolbarImagesDir()
        size = self.app.opt.toolbar_size
        if self.app.toolbar.updateImages(dir, size):
            # self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarCompound(self, compound):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_compound = compound
        self.tkopt.toolbar_compound.set(compound)          # update radiobutton
        if self.app.toolbar.setCompound(compound):
            self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def wizardDialog(self, edit=False):
        from pysollib.wizardutil import write_game, reset_wizard
        WizardDialog = self._calcWizardDialog()

        if edit:
            reset_wizard(self.game)
        else:
            reset_wizard(None)
        d = WizardDialog(self.top, _('Solitaire Wizard'), self.app)
        if d.status == 0 and d.button == 0:
            try:
                if edit:
                    gameid = write_game(self.app, game=self.game)
                else:
                    gameid = write_game(self.app)
            except Exception as err:
                # if False:
                #    traceback.print_exc()
                self._calc_MfxMessageDialog()(
                    self.top, title=_('Save game error'),
                    text=_('''
Error while saving game.

%s
''') % str(err),
                    bitmap='error')
                return

            if SELECT_GAME_MENU:
                menu = self.menupath[".menubar.select.customgames"][2]

                def select_func(gi):
                    return gi.si.game_type == GI.GT_CUSTOM
                games = list(map(self.app.gdb.get,
                                 self.app.gdb.getGamesIdSortedByName()))
                games = list(filter(select_func, games))
                self.updateGamesMenu(menu, games)

            self.tkopt.gameid.set(gameid)
            self._mSelectGame(gameid, force=True)

    def mWizard(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.wizardDialog()

    def mWizardEdit(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.wizardDialog(edit=True)

    def toolbarConfig(self, w, v):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_vars[w] = v
        self.app.toolbar.config(w, v)
        self.top.update_idletasks()

    #
    # stacks descriptions
    #

    def mStackDesk(self, *event):
        if self.game.stackdesc_list:
            self.game.deleteStackDesc()
        else:
            if self._cancelDrag(break_pause=True):
                return
            self.game.showStackDesc()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.mygettext import _
from pysollib.settings import TITLE
from pysollib.ui.tktile.tkcanvas import MfxCanvas, MfxCanvasGroup
from pysollib.ui.tktile.tkcanvas import MfxCanvasImage, MfxCanvasRectangle
from pysollib.ui.tktile.tkutil import after, after_cancel
from pysollib.ui.tktile.tkutil import bind, makeImage, unbind_destroy

from six.moves import tkinter


LARGE_EMBLEMS_SIZE = (38, 34)
SMALL_EMBLEMS_SIZE = (31, 21)


class FindCardDialog(tkinter.Toplevel):
    CARD_IMAGES = {}  # key: (rank, suit)

    def __init__(self, parent, game, dir, size='large'):
        tkinter.Toplevel.__init__(self)
        title = TITLE + ' - ' + _('Find card')
        self.title(title)
        self.wm_resizable(False, False)
        #
        # self.images_dir = dir
        if size == 'large':
            self.images_dir = os.path.join(dir, 'large')
            self.label_width, self.label_height = LARGE_EMBLEMS_SIZE
        else:
            self.images_dir = os.path.join(dir, 'small')
            self.label_width, self.label_height = SMALL_EMBLEMS_SIZE
        self.canvas = MfxCanvas(self, bg='white')
        # self.canvas = MfxCanvas(self, bg='black')
        self.canvas.pack(expand=True, fill='both')
        #
        self.groups = []
        self.highlight_items = None
        self.busy = False
        self.connectGame(game)
        #
        bind(self, "WM_DELETE_WINDOW", self.destroy)
        bind(self, "<Escape>", self.destroy)
        #
        # self.normal_timeout = 400    # in milliseconds
        self.normal_timeout = int(
            1000*game.app.opt.timeouts['highlight_samerank'])
        self.hidden_timeout = 200
        self.timer = None

    def createCardLabel(self, suit, rank, x0, y0):
        dx, dy = self.label_width, self.label_height
        dir = self.images_dir
        canvas = self.canvas
        group = MfxCanvasGroup(canvas)
        #
        im = FindCardDialog.CARD_IMAGES.get((rank, suit))
        if im is None:
            r = '%02d' % (rank+1)
            s = 'cshd'[suit]
            fn = os.path.join(dir, r+s+'.gif')
            im = makeImage(file=fn)
            FindCardDialog.CARD_IMAGES[(rank, suit)] = im
        cim = MfxCanvasImage(canvas, x0, y0, image=im, anchor='nw')
        cim.addtag(group)
        cim.lower()
        #
        rect_width = 4
        x1, y1 = x0+dx, y0+dy
        rect = MfxCanvasRectangle(self.canvas, x0+1, y0+1, x1-1, y1-1,
                                  width=rect_width,
                                  fill=None,
                                  outline='red',
                                  state='hidden'
                                  )
        rect.addtag(group)
        #
        bind(group, '<Enter>',
             lambda e, suit=suit, rank=rank, rect=rect:
                 self.enterEvent(suit, rank, rect, group))
        bind(group, '<Leave>',
             lambda e, suit=suit, rank=rank, rect=rect:
                 self.leaveEvent(suit, rank, rect, group))
        self.groups.append(group)

    def connectGame(self, game):
        self.canvas.delete('all')
        self.game = game
        suits = game.gameinfo.suits
        ranks = game.gameinfo.ranks
        dx, dy = self.label_width, self.label_height
        uniq_suits = []
        i = 0
        for suit in suits:
            if suit in uniq_suits:
                continue
            uniq_suits.append(suit)
            j = 0
            for rank in ranks:
                x, y = dx*j+2, dy*i+2
                self.createCardLabel(suit=suit, rank=rank, x0=x, y0=y)
                j += 1
            i += 1
        w, h = dx*j+2, dy*i+2
        self.canvas.config(width=w, height=h)
        self.wm_iconname(TITLE + " - " + game.getTitleName())
        self.wm_geometry('')            # cancel user-specified geometry

    def enterEvent(self, suit, rank, rect, group):
        # print 'enterEvent', suit, rank, self.busy
        if self.busy:
            return
        if self.game.demo:
            return
        self.busy = True
        self.highlight_items = self.game.highlightCard(suit, rank)
        if not self.highlight_items:
            self.highlight_items = []
        if self.highlight_items:
            self.timer = after(self, self.normal_timeout, self.timeoutEvent)
        rect.config(state='normal')
        self.canvas.update_idletasks()
        self.busy = False

    def leaveEvent(self, suit, rank, rect, group):
        # print 'leaveEvent', suit, rank, self.busy
        if self.busy:
            return
        self.busy = True
        if self.highlight_items:
            for i in self.highlight_items:
                i.delete()
            self.highlight_items = []
        if self.timer:
            after_cancel(self.timer)
            self.timer = None
        rect.config(state='hidden')
        if self.game.canvas:
            self.game.canvas.update_idletasks()
        self.canvas.update_idletasks()
        self.busy = False

    def timeoutEvent(self, *event):
        if self.highlight_items:
            state = self.highlight_items[0].cget('state')
            if state in ('', 'normal'):
                state = 'hidden'
                self.timer = after(self, self.hidden_timeout,
                                   self.timeoutEvent)
            else:
                state = 'normal'
                self.timer = after(self, self.normal_timeout,
                                   self.timeoutEvent)
            for item in self.highlight_items:
                item.config(state=state)

    def destroy(self, *args):
        for l in self.groups:
            unbind_destroy(l)
        unbind_destroy(self)
        if self.timer:
            after_cancel(self.timer)
            self.timer = None
        self.wm_withdraw()
        if self.highlight_items:
            for i in self.highlight_items:
                i.delete()
        tkinter.Toplevel.destroy(self)


find_card_dialog = None


def create_find_card_dialog(parent, game, dir):
    global find_card_dialog
    try:
        find_card_dialog.wm_deiconify()
        find_card_dialog.tkraise()
    except Exception:
        # traceback.print_exc()
        find_card_dialog = FindCardDialog(parent, game, dir)


def connect_game_find_card_dialog(game):
    try:
        find_card_dialog.connectGame(game)
    except Exception:
        pass


def destroy_find_card_dialog():
    global find_card_dialog
    try:
        find_card_dialog.destroy()
    except Exception:
        # traceback.print_exc()
        pass
    find_card_dialog = None
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.acard import AbstractCard
from pysollib.ui.tktile.tkcanvas import MfxCanvasGroup, MfxCanvasImage


# ************************************************************************
# *
# ************************************************************************

class _HideableCard(AbstractCard):
    def hide(self, stack):
        if stack is self.hide_stack:
            return
        self.item.config(state="hidden")
        self.hide_stack = stack
        # print "hide:", self.id, self.item.coords()

    def unhide(self):
        if self.hide_stack is None:
            return 0
        # print "unhide:", self.id, self.item.coords()
        self.item.config(state="normal")
        self.hide_stack = None
        return 1


# ************************************************************************
# * New implementation since 2.10
# *
# * We use a single CanvasImage and call CanvasImage.config() to
# * turn the card.
# * This makes turning cards a little bit slower, but dragging cards
# * around is noticeable faster as the total number of images is
# * reduced by half.
# ************************************************************************

class _OneImageCard(_HideableCard):
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self._face_image = game.getCardFaceImage(deck, suit, rank)
        self._back_image = game.getCardBackImage(deck, suit, rank)
        self._shade_image = game.getCardShadeImage()
        self._active_image = self._back_image
        self.item = MfxCanvasImage(
            game.canvas, self.x, self.y, image=self._active_image, anchor="nw")
        self.shade_item = None
        # self._setImage = self.item.config

    def _setImage(self, image):
        if image is not self._active_image:
            self.item.config(image=image)
            self._active_image = image

    def showFace(self, unhide=1):
        if not self.face_up:
            self._setImage(image=self._face_image)
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self._setImage(image=self._back_image)
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self._back_image = image
        if not self.face_up:
            self._setImage(image=image)

    #
    # optimized by inlining
    #

    def moveBy(self, dx, dy):
        dx, dy = int(dx), int(dy)
        self.x = self.x + dx
        self.y = self.y + dy
        item = self.item
        item.canvas.tk.call(item.canvas._w, "move", item.id, dx, dy)

    # for resize
    def update(self, id, deck, suit, rank, game):
        self._face_image = game.getCardFaceImage(deck, suit, rank)
        self._back_image = game.getCardBackImage(deck, suit, rank)
        self._shade_image = game.getCardShadeImage()
        if self.face_up:
            img = self._face_image
        else:
            img = self._back_image
        self.item.config(image=img)
        self._active_image = img


# ************************************************************************
# * New idea since 3.00
# *
# * Hide a card by configuring the canvas image to None.
# ************************************************************************

class _OneImageCardWithHideByConfig(_OneImageCard):
    def hide(self, stack):
        if stack is self.hide_stack:
            return
        self._setImage(image=None)
        self.hide_stack = stack

    def unhide(self):
        if self.hide_stack is None:
            return 0
        if self.face_up:
            self._setImage(image=self._face_image)
        else:
            self._setImage(image=self._back_image)
        self.hide_stack = None
        return 1

    #
    # much like in _OneImageCard
    #

    def showFace(self, unhide=1):
        if not self.face_up:
            if unhide:
                self._setImage(image=self._face_image)
            self.item.tkraise()
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            if unhide:
                self._setImage(image=self._back_image)
            self.item.tkraise()
            self.face_up = 0

    def updateCardBackground(self, image):
        self._back_image = image
        if not self.face_up and not self.hide_stack:
            self._setImage(image=image)


# ************************************************************************
# * Old implementation prior to 2.10
# *
# * The card consists of two CanvasImages. To show the card face up,
# * the face item is placed in front of the back. To show it face
# * down, this is reversed.
# ************************************************************************

class _TwoImageCard(_HideableCard):
    # Private instance variables:
    #   __face, __back -- the canvas items making up the card
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self.item = MfxCanvasGroup(game.canvas)
        self.__face = MfxCanvasImage(
            game.canvas, self.x, self.y, image=game.getCardFaceImage(
                deck, suit, rank), anchor="nw")
        self.__back = MfxCanvasImage(
            game.canvas, self.x, self.y, image=game.getCardBackImage(
                deck, suit, rank), anchor="nw")
        self.__face.addtag(self.item)
        self.__back.addtag(self.item)

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__face.tkraise()
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__back.tkraise()
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back.config(image=image)


# ************************************************************************
# * New idea since 2.90
# *
# * The card consists of two CanvasImages. Instead of raising
# * one image above the other we move the inactive image out
# * of the visible canvas.
# ************************************************************************

class _TwoImageCardWithHideItem(_HideableCard):
    # Private instance variables:
    #   __face, __back -- the canvas items making up the card
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self.item = MfxCanvasGroup(game.canvas)
        self.__face = MfxCanvasImage(
            game.canvas, self.x, self.y + 11000, image=game.getCardFaceImage(
                deck, suit, rank), anchor="nw")
        self.__back = MfxCanvasImage(
            game.canvas, self.x, self.y, image=game.getCardBackImage(
                deck, suit, rank), anchor="nw")
        self.__face.addtag(self.item)
        self.__back.addtag(self.item)

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__back.move(0, 10000)
            # self.__face.tkraise()
            self.__face.move(0, -11000)
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__face.move(0, 11000)
            # self.__back.tkraise()
            self.__back.move(0, -10000)
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back.config(image=image)


# choose the implementation
Card = _TwoImageCardWithHideItem
Card = _TwoImageCard
Card = _OneImageCardWithHideByConfig
Card = _OneImageCard
# This module exports classes for the various canvas item types

# NOTE: This module was an experiment and is now obsolete.
# It's best to use the Tkinter.Canvas class directly.

from six.moves.tkinter import Canvas, _cnfmerge, _flatten  # noqa: F401


class CanvasItem:
    def __init__(self, canvas, itemType, *args, **kw):
        self.canvas = canvas
        self.id = canvas._create(itemType, args, kw)
        if not hasattr(canvas, 'items'):
            canvas.items = {}
        canvas.items[self.id] = self

    def __str__(self):
        return str(self.id)

    def __repr__(self):
        return '<%s, id=%d>' % (self.__class__.__name__, self.id)

    def delete(self):
        del self.canvas.items[self.id]
        self.canvas.delete(self.id)

    def __getitem__(self, key):
        v = self.canvas.tk.split(self.canvas.tk.call(
                self.canvas._w, 'itemconfigure',
                self.id, '-' + key))
        return v[4]
    cget = __getitem__

    def __setitem__(self, key, value):
        self.canvas.itemconfig(self.id, {key: value})

    def keys(self):
        if not hasattr(self, '_keys'):
            self._keys = map(lambda x, tk=self.canvas.tk:
                             tk.splitlist(x)[0][1:],
                             self.canvas.tk.splitlist(
                                     self.canvas._do(
                                             'itemconfigure',
                                             (self.id,))))
        return self._keys

    def has_key(self, key):
        return key in self.keys()

    def __contains__(self, key):
        return key in self.keys()

    def addtag(self, tag, option='withtag'):
        self.canvas.addtag(tag, option, self.id)

    def bbox(self):
        x1, y1, x2, y2 = self.canvas.bbox(self.id)
        return (x1, y1), (x2, y2)

    def bind(self, sequence=None, command=None, add=None):
        return self.canvas.tag_bind(self.id, sequence, command, add)

    def unbind(self, sequence, funcid=None):
        self.canvas.tag_unbind(self.id, sequence, funcid)

    def config(self, cnf={}, **kw):
        return self.canvas.itemconfig(self.id, _cnfmerge((cnf, kw)))

    def coords(self, pts=()):
        flat = ()
        for x, y in pts:
            flat += (x, y)
        return self.canvas.coords(self.id, *flat)

    def dchars(self, first, last=None):
        self.canvas.dchars(self.id, first, last)

    def dtag(self, ttd):
        self.canvas.dtag(self.id, ttd)

    def focus(self):
        self.canvas.focus(self.id)

    def gettags(self):
        return self.canvas.gettags(self.id)

    def icursor(self, index):
        self.canvas.icursor(self.id, index)

    def index(self, index):
        return self.canvas.index(self.id, index)

    def insert(self, beforethis, string):
        self.canvas.insert(self.id, beforethis, string)

    def lower(self, belowthis=None):
        self.canvas.tag_lower(self.id, belowthis)

    def move(self, xamount, yamount):
        self.canvas.move(self.id, xamount, yamount)

    def tkraise(self, abovethis=None):
        self.canvas.tag_raise(self.id, abovethis)
    raise_ = tkraise  # BW compat

    def scale(self, xorigin, yorigin, xscale, yscale):
        self.canvas.scale(self.id, xorigin, yorigin, xscale, yscale)

    def type(self):
        return self.canvas.type(self.id)


class Arc(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'arc', *args, **kw)


class Bitmap(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'bitmap', *args, **kw)


class ImageItem(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'image', *args, **kw)


class Line(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'line', *args, **kw)


class Oval(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'oval', *args, **kw)


class Polygon(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'polygon', *args, **kw)


class Rectangle(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'rectangle', *args, **kw)


# XXX "Text" is taken by the Text widget...
class CanvasText(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'text', *args, **kw)


class Window(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'window', *args, **kw)


class Group:
    def __init__(self, canvas, tag=None):
        if not tag:
            tag = 'Group%d' % id(self)
        self.tag = self.id = tag
        self.canvas = canvas
        self.canvas.dtag(self.tag)

    def str(self):
        return self.tag
    __str__ = str

    def _do(self, cmd, *args):
        return self.canvas._do(cmd, (self.tag,) + _flatten(args))

    def addtag_above(self, tagOrId):
        self._do('addtag', 'above', tagOrId)

    def addtag_all(self):
        self._do('addtag', 'all')

    def addtag_below(self, tagOrId):
        self._do('addtag', 'below', tagOrId)

    def addtag_closest(self, x, y, halo=None, start=None):
        self._do('addtag', 'closest', x, y, halo, start)

    def addtag_enclosed(self, x1, y1, x2, y2):
        self._do('addtag', 'enclosed', x1, y1, x2, y2)

    def addtag_overlapping(self, x1, y1, x2, y2):
        self._do('addtag', 'overlapping', x1, y1, x2, y2)

    def addtag_withtag(self, tagOrId):
        self._do('addtag', 'withtag', tagOrId)

    def bbox(self):
        return self.canvas._getints(self._do('bbox'))

    def bind(self, sequence=None, command=None, add=None):
        return self.canvas.tag_bind(self.id, sequence, command, add)

    def unbind(self, sequence, funcid=None):
        self.canvas.tag_unbind(self.id, sequence, funcid)

    def coords(self, *pts):
        return self._do('coords', pts)

    def dchars(self, first, last=None):
        self._do('dchars', first, last)

    def delete(self):
        self._do('delete')

    def dtag(self, tagToDelete=None):
        self._do('dtag', tagToDelete)

    def focus(self):
        self._do('focus')

    def gettags(self):
        return self.canvas.tk.splitlist(self._do('gettags', self.tag))

    def icursor(self, index):
        return self._do('icursor', index)

    def index(self, index):
        return self.canvas.tk.getint(self._do('index', index))

    def insert(self, beforeThis, string):
        self._do('insert', beforeThis, string)

    def config(self, cnf={}, **kw):
        return self.canvas.itemconfigure(self.tag, _cnfmerge((cnf, kw)))

    def lower(self, belowThis=None):
        self._do('lower', belowThis)

    def move(self, xAmount, yAmount):
        self._do('move', xAmount, yAmount)

    def tkraise(self, aboveThis=None):
        self._do('raise', aboveThis)
    lift = tkraise

    def scale(self, xOrigin, yOrigin, xScale, yScale):
        self._do('scale', xOrigin, yOrigin, xScale, yScale)

    def select_adjust(self, index):
        self.canvas._do('select', ('adjust', self.tag, index))

    def select_from(self, index):
        self.canvas._do('select', ('from', self.tag, index))

    def select_to(self, index):
        self.canvas._do('select', ('to', self.tag, index))

    def type(self):
        return self._do('type')
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.gamedb import GI
from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _


class BaseGameInfoDialog:
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        self._calc_MfxDialog().__init__(
            self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = self._calcToolkit().Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        game = app.game
        gi = game.gameinfo

        #
        if gi.redeals == -2:
            redeals = 'VARIABLE'
        elif gi.redeals == -1:
            redeals = 'UNLIMITED'
        else:
            redeals = str(gi.redeals)
        cat = '<none>'
        type = '<none>'
        flags = []
        for attr in dir(GI):
            if attr.startswith('GC_'):
                c = getattr(GI, attr)
                if gi.category == c:
                    cat = attr
            elif attr.startswith('GT_'):
                t = getattr(GI, attr)
                if t < (1 << 12)-1:
                    if gi.si.game_type == t:
                        type = attr
                else:
                    if gi.si.game_flags & t:
                        flags.append(attr)
        #
        version = None
        for t in GI.GAMES_BY_PYSOL_VERSION:
            if gi.id in t[1]:
                version = t[0]
                break
        sl = {
            1: 'SL_LUCK',
            2: 'SL_MOSTLY_LUCK',
            3: 'SL_BALANCED',
            4: 'SL_MOSTLY_SKILL',
            5: 'SL_SKILL',
            }
        skill_level = sl.get(gi.skill_level)
        if game.Hint_Class is None:
            hint = None
        else:
            hint = game.Hint_Class.__name__
        row = 0
        for n, t in (('Name:', gi.name),
                     ('Short name:', gi.short_name),
                     ('ID:', gi.id),
                     ('Alt names:', '\n'.join(gi.altnames)),
                     ('PySol version:', version),
                     ('Decks:', gi.decks),
                     ('Cards:', gi.ncards),
                     ('Redeals:', redeals),
                     ('Category:', cat),
                     ('Type:', type),
                     ('Flags:', '\n'.join(flags)),
                     ('Skill level:', skill_level),
                     ('Rules filename:', gi.rules_filename),
                     ('Module:', game.__module__),
                     ('Class:', game.__class__.__name__),
                     ('Hint:', hint),
                     ):
            if t:
                self._calcToolkit().Label(
                    frame, text=n, anchor='w').grid(
                    row=row, column=0, sticky='nw')
                self._calcToolkit().Label(
                    frame, text=t, anchor='w', justify='left').grid(
                    row=row, column=1, sticky='nw')
                row += 1

        if game.s.talon:
            self.showStacks(frame, row, 'Talon:', game.s.talon)
            row += 1
        if game.s.waste:
            self.showStacks(frame, row, 'Waste:', game.s.waste)
            row += 1
        for t, s in (
            ('Foundations:', game.s.foundations,),
            ('Rows:',        game.s.rows,),
            ('Reserves:',    game.s.reserves,),
                ):
            if s:
                self.showStacks(frame, row, t, s)
                row += 1

        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def showStacks(self, frame, row, title, stacks):
        self._calcToolkit().Label(
            frame, text=title, anchor='w').grid(
            row=row, column=0, sticky='nw')
        if isinstance(stacks, (list, tuple)):
            fs = {}
            for f in stacks:
                cn = f.__class__.__name__
                if cn in fs:
                    fs[cn] += 1
                else:
                    fs[cn] = 1
            t = '\n'.join(['%s (%d)' % (i[0], i[1]) for i in list(fs.items())])
        else:
            t = stacks.__class__.__name__
        self._calcToolkit().Label(
            frame, text=t, anchor='w', justify='left').grid(
            row=row, column=1, sticky='nw')

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"),),
                      default=0,
                      separator=True,
                      )
        return self._calc_MfxDialog().initKw(self, kw)

    # Requires implementing self._calcToolkit() self._calc_MfxDialog()
from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _

from six.moves import tkinter


class BaseEditTextDialog:
    def __init__(self, parent, title, text, **kw):
        kw = self.initKw(kw)
        self._calc_MfxDialog().__init__(
            self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.text_w = tkinter.Text(top_frame, bd=1, relief="sunken",
                                   wrap="word", width=64, height=16)
        self.text_w.pack(side='left', fill="both", expand=True)
        # self.text_w.pack(side='top', padx=kw.padx, pady=kw.pady)
        vbar = self._calcToolkit().Scrollbar(top_frame)
        vbar.pack(side='right', fill='y')
        self.text_w["yscrollcommand"] = vbar.set
        vbar["command"] = self.text_w.yview
        #
        self.text = ""
        if text:
            self.text = text
            old_state = self.text_w["state"]
            self.text_w.config(state="normal")
            self.text_w.insert("insert", self.text)
            self.text_w.config(state=old_state)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.text_w
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")),
                      default=-1,
                      resizable=self._calc_Resizable(),
                      separator=False,
                      )
        return self._calc_MfxDialog().initKw(self, kw)

    def destroy(self):
        self.text = self.text_w.get("1.0", "end")
        self._calc_MfxDialog().destroy(self)

    def wmDeleteWindow(self, *event):   # ignore
        pass

    def mCancel(self, *event):          # ignore <Escape>
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.ui.tktile.tkconst import EVENT_PROPAGATE

from six.moves import tkinter
TclError = tkinter.TclError


# ************************************************************************
# * Wrapper class for Tk.
# * Required so that a Game will get properly destroyed.
# ************************************************************************

class MfxRoot(tkinter.Tk):
    def __init__(self, **kw):
        tkinter.Tk.__init__(self, **kw)
        self.app = None
        self.wm_protocol('WM_DELETE_WINDOW', self.wmDeleteWindow)
        # for interruptible sleep
        # self.sleep_var = tkinter.IntVar(self)
        # self.sleep_var.set(0)
        self.sleep_var = 0
        self.after_id = None
        # self.bind('<ButtonPress>', self._sleepEvent, add=True)

    def connectApp(self, app):
        self.app = app

    # sometimes an update() is needed under Windows, whereas
    # under Unix an update_idletasks() would be enough...
    def busyUpdate(self):
        game = None
        if self.app:
            game = self.app.game
        if not game:
            self.update()
        else:
            old_busy = game.busy
            game.busy = 1
            if game.canvas:
                game.canvas.update()
            self.update()
            game.busy = old_busy

    def mainquit(self):
        self.after_idle(self.quit)

    def screenshot(self, filename):
        # print 'MfxRoot.screenshot not yet implemented'
        pass

    def setCursor(self, cursor):
        if 0:
            # FIXME: this causes ugly resizes !
            tkinter.Tk.config(self, cursor=cursor)
        elif 0:
            # and this is even worse
            # print self.children
            for v in self.children.values():
                v.config(cursor=cursor)
        else:
            pass

    #
    # sleep
    #

    def sleep(self, seconds):
        # time.sleep(seconds)
        self.after(int(seconds*1000))
        return
        print('sleep', seconds)
        timeout = int(seconds*1000)
        self.sleep_var = 0
        while timeout > 0:
            self.update()
            self.update_idletasks()
            if self.sleep_var:
                break
            self.after(100)
            timeout -= 100
        print('finish sleep')
        return
        if self.after_id:
            self.after_cancel(self.after_id)
        self.after_id = self.after(int(seconds*1000), self._sleepEvent)
        self.sleep_var.set(1)
        self.update()
        self.wait_variable(self.sleep_var)
        if self.after_id:
            self.after_cancel(self.after_id)
            self.after_id = None
        print('finish sleep')

    def _sleepEvent(self, *args):
        return
        print('_sleepEvent', args)
        self.interruptSleep()
        return EVENT_PROPAGATE

    def interruptSleep(self):
        return
        print('interruptSleep')
        self.update()
        self.update_idletasks()
        self.sleep_var = 1
        # self.sleep_var.set(0)
        # self.after_idle(self.sleep_var.set, 0)

    #
    #
    #

    def update(self):
        tkinter.Tk.update(self)

    def wmDeleteWindow(self):
        if self.app and self.app.menubar:
            self.app.menubar.mQuit()
        else:
            # self.after_idle(self.quit)
            pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mygettext import n_

from six.moves import tkinter

# ************************************************************************
# * constants
# ************************************************************************

EVENT_HANDLED = "break"
EVENT_PROPAGATE = None

CURSOR_DRAG = "hand1"
CURSOR_WATCH = "watch"
CURSOR_DOWN_ARROW = 'sb_down_arrow'

ANCHOR_CENTER = tkinter.CENTER
ANCHOR_N = tkinter.N
ANCHOR_NW = tkinter.NW
ANCHOR_NE = tkinter.NE
ANCHOR_S = tkinter.S
ANCHOR_SW = tkinter.SW
ANCHOR_SE = tkinter.SE
ANCHOR_W = tkinter.W
ANCHOR_E = tkinter.E

COMPOUNDS = (
    # (tkinter.BOTTOM,  'bottom'),
    # (tkinter.CENTER,  'center'),
    # (tkinter.RIGHT,    'right'),
    (tkinter.NONE,   n_('Icons only')),
    (tkinter.TOP,    n_('Text below icons')),
    (tkinter.LEFT,   n_('Text beside icons')),
    ('text',         n_('Text only')),
    )

TOOLBAR_BUTTONS = (
    "new",
    "restart",
    "open",
    "save",
    "undo",
    "redo",
    "autodrop",
    "shuffle",
    "pause",
    "statistics",
    "rules",
    "quit",
    "player",
    )
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import re

from pysollib.mfxutil import Image, ImageOps, ImageTk
from pysollib.settings import TITLE, WIN_SYSTEM

from six.moves import tkinter
from six.moves import tkinter_font


# ************************************************************************
# * window manager util
# ************************************************************************

def wm_withdraw(window):
    window.wm_withdraw()


def wm_deiconify(window):
    window.wm_deiconify()


def wm_map(window, maximized=0):
    if window.wm_state() != "iconic":
        if maximized and WIN_SYSTEM == "win32":
            window.wm_state("zoomed")
        else:
            wm_deiconify(window)


__wm_get_geometry_re = re.compile(r"^(\d+)x(\d+)\+([\-]?\d+)\+([\-]?\d+)$")


def wm_get_geometry(window):
    g = window.wm_geometry()
    m = __wm_get_geometry_re.search(g)
    if not m:
        raise tkinter.TclError("invalid geometry "+str(g))
    lst = list(map(int, m.groups()))
    if window.wm_state() == "zoomed":
        # workaround as Tk returns the "unzoomed" origin
        lst[2] = lst[3] = 0
    return lst


# ************************************************************************
# * window util
# ************************************************************************

def setTransient(window, parent, relx=None, rely=None, expose=1):
    # Make an existing toplevel window transient for a parent.
    #
    # The window must exist but should not yet have been placed; in
    # other words, this should be called after creating all the
    # subwidget but before letting the user interact.

    # remain invisible while we figure out the geometry
    window.wm_withdraw()
    window.wm_group(parent)
    if parent and parent.wm_state() != "withdrawn":
        window.wm_transient(parent)
    # actualize geometry information
    window.update_idletasks()
    # show
    x, y = __getWidgetXY(window, parent, relx=relx, rely=rely)
    window.wm_geometry("+%d+%d" % (x, y))
    if expose:
        window.wm_deiconify()


def makeToplevel(parent, title=None):
    # Create a Toplevel window.
    #
    # This is a shortcut for a Toplevel() instantiation plus calls to
    # set the title and icon name of the window.
    window = tkinter.Toplevel(parent)  # , class_=TITLE)
    # window.wm_group(parent)
    # window.wm_command("")
    if WIN_SYSTEM == "x11":
        window.wm_command("/bin/true")
    # window.wm_protocol("WM_SAVE_YOURSELF", None)
    if title:
        window.wm_title(title)
        window.wm_iconname(title)
    return window


def make_help_toplevel(app, title=None):
    # Create an independent Toplevel window.
    from pysollib.winsystems import init_root_window
    window = tkinter.Toplevel(class_=TITLE)
    init_root_window(window, app)
    return window


def __getWidgetXY(widget, parent, relx=None, rely=None,
                  w_width=None, w_height=None):
    if w_width is None:
        w_width = widget.winfo_reqwidth()
    if w_height is None:
        w_height = widget.winfo_reqheight()
    s_width = widget.winfo_screenwidth()
    s_height = widget.winfo_screenheight()
    m_x = m_y = 0
    m_width, m_height = s_width, s_height
    if parent and parent.winfo_ismapped():
        # print parent.wm_geometry()
        # print parent.winfo_geometry(), parent.winfo_x(), parent.winfo_y(), \
        #   parent.winfo_rootx(), parent.winfo_rooty(), parent.winfo_vrootx(),\
        #   parent.winfo_vrooty()
        m_x = m_y = None
        if WIN_SYSTEM == "win32":
            try:
                m_width, m_height, m_x, m_y = wm_get_geometry(parent)
            except Exception:
                pass
        if m_x is None:
            m_x = parent.winfo_x()
            m_y = parent.winfo_y()
            m_width = parent.winfo_width()
            m_height = parent.winfo_height()
            if relx is None:
                relx = 0.5
            if rely is None:
                rely = 0.3
        else:
            if relx is None:
                relx = 0.5
            if rely is None:
                rely = 0.5
        m_x = max(m_x, 0)
        m_y = max(m_y, 0)
    else:
        if relx is None:
            relx = 0.5
        if rely is None:
            rely = 0.3
    x = m_x + int((m_width - w_width) * relx)
    y = m_y + int((m_height - w_height) * rely)
    # print x, y, w_width, w_height, m_x, m_y, m_width, m_height
    # make sure the widget is fully on screen
    if x < 0:
        x = 0
    elif x + w_width + 32 > s_width:
        x = max(0, (s_width - w_width) // 2)
    if y < 0:
        y = 0
    elif y + w_height + 32 > s_height:
        y = max(0, (s_height - w_height) // 2)
    return x, y


# ************************************************************************
# * bind wrapper - tkinter doesn't properly delete all bindings
# ************************************************************************

__mfx_bindings = {}
__mfx_wm_protocols = ("WM_DELETE_WINDOW", "WM_TAKE_FOCUS", "WM_SAVE_YOURSELF")


def bind(widget, sequence, func, add=None):
    # assert callable(func) # XXX: removed in py3k
    if sequence in __mfx_wm_protocols:
        funcid = widget._register(func)
        widget.tk.call("wm", "protocol", widget._w, sequence, funcid)
    elif add is None:
        funcid = widget.bind(sequence, func)
    else:
        # add = add and "+" or ""
        funcid = widget.bind(sequence, func, add)
    k = id(widget)
    if k in __mfx_bindings:
        __mfx_bindings[k].append((sequence, funcid))
    else:
        __mfx_bindings[k] = [(sequence, funcid)]


def unbind_destroy(widget):
    if widget is None:
        return
    k = id(widget)
    if k in __mfx_bindings:
        for sequence, funcid in __mfx_bindings[k]:
            # print widget, sequence, funcid
            try:
                if sequence in __mfx_wm_protocols:
                    widget.tk.call("wm", "protocol", widget._w, sequence, "")
                    # widget.deletecommand(funcid)
                else:
                    widget.unbind(sequence, funcid)
            except tkinter.TclError:
                pass
        del __mfx_bindings[k]
    # for k in __mfx_bindings.keys(): print __mfx_bindings[k]
    # print len(__mfx_bindings.keys())


# ************************************************************************
# * timer wrapper - tkinter doesn't properly delete all commands
# ************************************************************************

def after(widget, ms, func, *args):
    timer = widget.after(ms, func, *args)
    command = widget._tclCommands[-1]
    return (timer, command, widget)


def after_idle(widget, func, *args):
    return after(widget, "idle", func, *args)


def after_cancel(t):
    if t is not None:
        t[2].after_cancel(t[0])
        try:
            t[2].deletecommand(t[1])
        except tkinter.TclError:
            pass


# ************************************************************************
# * image handling
# ************************************************************************

if Image:
    class PIL_Image(ImageTk.PhotoImage):
        def __init__(self, file=None, image=None, pil_image_orig=None):
            if file:
                image = Image.open(file).convert('RGBA')
            ImageTk.PhotoImage.__init__(self, image)
            self._pil_image = image
            if pil_image_orig:
                self._pil_image_orig = pil_image_orig
            else:
                self._pil_image_orig = image

        def subsample(self, r):
            im = self._pil_image
            w, h = im.size
            w, h = int(float(w)/r), int(float(h)/r)
            im = im.resize((w, h))
            im = PIL_Image(image=im)
            return im

        def resize(self, xf, yf):
            w, h = self._pil_image_orig.size
            w0, h0 = int(w*xf), int(h*yf)
            im = self._pil_image_orig.resize((w0, h0), Image.ANTIALIAS)
            return PIL_Image(image=im, pil_image_orig=self._pil_image_orig)


def makeImage(file=None, data=None, dither=None, alpha=None):
    kw = {}
    if data is None:
        assert file is not None
        kw["file"] = file
    else:
        # assert data is not None
        kw["data"] = data
    if Image:
        # use PIL
        if file:
            im = PIL_Image(file)
            return im
        # fromstring(mode, size, data, decoder_name='raw', *args)
        else:
            return tkinter.PhotoImage(data=data)
    return tkinter.PhotoImage(**kw)


loadImage = makeImage


def copyImage(image, x, y, width, height):
    if Image:
        if isinstance(image, PIL_Image):
            return ImageTk.PhotoImage(
                image._pil_image.crop((x, y, x+width, y+height)))
    dest = tkinter.PhotoImage(width=width, height=height)
    assert dest.width() == width
    assert dest.height() == height
    dest.blank()
    image.tk.call(dest, "copy", image.name, "-from", x, y, x+width, y+height)
    assert dest.width() == width
    assert dest.height() == height
    return dest


def fillImage(image, fill, outline=None):
    if not fill and not outline:
        return
    width = image.width()
    height = image.height()
    ow = 1                              # outline width
    if width <= 2*ow or height <= 2*ow:
        fill = fill or outline
        outline = None
    if not outline:
        f = (fill,) * width
        f = (f,) * height
        assert len(f) == height
        image.put(f)
    elif not fill:
        l1 = ((outline,) * width,)
        for y in range(0, ow):
            image.put(l1, (0, y))
        for y in range(height-ow, height):
            image.put(l1, (0, y))
        p = ((outline,) * ow,)
        for y in range(ow, height-ow):
            image.put(p, (0, y))
            image.put(p, (width-ow, y))
    else:
        l1 = (outline,) * width
        l2 = (outline,) * ow + (fill,) * (width-2*ow) + (outline,) * ow
        f = (l1,) * ow + (l2,) * (height-2*ow) + (l1,) * ow
        assert len(f) == height
        image.put(f)


def createImage(width, height, fill, outline=None):
    image = tkinter.PhotoImage(width=width, height=height)
    assert image.width() == width
    assert image.height() == height
    image.blank()
    fillImage(image, fill, outline)
    return image


def shadowImage(image, color='#3896f8', factor=0.3):
    if not hasattr(image, '_pil_image'):
        return None
    im = image._pil_image
    # use an alpha image
    sh = Image.new('RGBA', im.size, color)
    sh.putalpha(100)
    out = Image.composite(sh, im, im)
    return PIL_Image(image=out)


def markImage(image):
    assert Image
    if 1:                               # shadow
        color, factor = '#6ae400', 0.3
        sh = Image.new('RGBA', image.size, color)
        tmp = Image.blend(image, sh, factor)
    else:                               # negate
        tmp = ImageOps.invert(image.convert('RGB'))
    out = Image.composite(tmp, image, image)
    return out


def _createBottomImage(image, color='white', backfile=None):
    th = 1                              # thickness
    sh = Image.new('RGBA', image.size, color)
    out = Image.composite(sh, image, image)
    w, h = image.size
    size = (w-th*2, h-th*2)
    tmp = Image.new('RGBA', size, color)
    tmp.putalpha(60)
    mask = out.resize(size, Image.ANTIALIAS)
    out.paste(tmp, (th, th), mask)
    if backfile:
        back = Image.open(backfile).convert('RGBA')
        w0, h0 = back.size
        w1, h1 = w, h
        a = min(float(w1)/w0, float(h1)/h0)
        a = a*0.9
        w0, h0 = int(w0*a), int(h0*a)
        back = back.resize((w0, h0), Image.ANTIALIAS)
        x, y = (w1 - w0) // 2, (h1 - h0) // 2
        out.paste(back, (x, y), back)
    return out


def createBottom(maskimage, color='white', backfile=None):
    if not hasattr(maskimage, '_pil_image'):
        return None
    maskimage = maskimage._pil_image
    out = _createBottomImage(maskimage, color, backfile)
    return PIL_Image(image=out)


def resizeBottom(image, maskimage, color='white', backfile=None):
    maskimage = maskimage._pil_image
    out = _createBottomImage(maskimage, color, backfile)
    image['image'] = out


# ************************************************************************
# * font utils
# ************************************************************************

def get_text_width(text, font, root=None):
    return tkinter_font.Font(root=root, font=font).measure(text)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.mfxutil import Image, ImageTk
from pysollib.ui.tktile.Canvas2 import CanvasText, Group, Line, Rectangle
from pysollib.ui.tktile.Canvas2 import ImageItem as ImageItem2
from pysollib.ui.tktile.tkutil import loadImage, unbind_destroy

from six.moves import tkinter


# ************************************************************************
# * canvas items
# ************************************************************************

class MfxCanvasGroup(Group):
    def __init__(self, canvas, tag=None):
        Group.__init__(self, canvas=canvas, tag=tag)
        # register ourself so that we can unbind from the canvas
        assert self.id not in self.canvas.items
        self.canvas.items[self.id] = self

    def addtag(self, tag, option="withtag"):
        self.canvas.addtag(tag, option, self.id)

    def delete(self):
        del self.canvas.items[self.id]
        Group.delete(self)

    def gettags(self):
        return self.canvas.tk.splitlist(self._do("gettags"))


class MfxCanvasImage(ImageItem2):
    def __init__(self, canvas, x, y, **kwargs):
        self.init_coord = x, y
        group = None
        if 'group' in kwargs:
            group = kwargs['group']
            del kwargs['group']
        if 'image' in kwargs:
            self._image = kwargs['image']
        ImageItem2.__init__(self, canvas, x, y, **kwargs)
        if group:
            self.addtag(group)

    def moveTo(self, x, y):
        c = self.coords()
        self.move(x - int(c[0]), y - int(c[1]))

    def show(self):
        self.config(state='normal')

    def hide(self):
        self.config(state='hidden')


MfxCanvasLine = Line


class MfxCanvasRectangle(Rectangle):
    def __init__(self, canvas, *args, **kwargs):
        group = None
        if 'group' in kwargs:
            group = kwargs['group']
            del kwargs['group']
        Rectangle.__init__(self, canvas, *args, **kwargs)
        if group:
            self.addtag(group)


class MfxCanvasText(CanvasText):
    def __init__(self, canvas, x, y, preview=-1, **kwargs):
        self.init_coord = x, y
        self.x, self.y = x, y
        if preview < 0:
            preview = canvas.preview
        if preview > 1:
            return
        if "fill" not in kwargs:
            kwargs["fill"] = canvas._text_color
        group = None
        if 'group' in kwargs:
            group = kwargs['group']
            del kwargs['group']
        CanvasText.__init__(self, canvas, x, y, **kwargs)
        self.text_format = None
        canvas._text_items.append(self)
        if group:
            self.addtag(group)

    def moveTo(self, x, y):
        dx, dy = x - self.x, y - self.y
        self.x, self.y = x, y
        self.move(dx, dy)


# ************************************************************************
# * canvas
# ************************************************************************

class MfxCanvas(tkinter.Canvas):
    def __init__(self, *args, **kw):
        tkinter.Canvas.__init__(self, *args, **kw)
        self.preview = 0
        self.busy = False
        # this is also used by lib-tk/Canvas.py
        self.items = {}
        # private
        self.__tileimage = None
        self.__tiles = []           # id of canvas items
        self.__topimage = None
        self.__tops = []            # id of canvas items
        # friend MfxCanvasText
        self._text_color = "#000000"
        self._stretch_bg_image = 0
        self._save_aspect_bg_image = 0
        self._text_items = []
        #
        self.xmargin, self.ymargin = 10, 10
        # resize bg image
        self.bind('<Configure>', self.setBackgroundImage)

    def setBackgroundImage(self, event=None):
        # print 'setBackgroundImage', self._bg_img
        if not hasattr(self, '_bg_img'):
            return
        if not self._bg_img:  # solid color
            return
        stretch = self._stretch_bg_image
        save_aspect = self._save_aspect_bg_image
        if Image:
            if stretch:
                w, h = self._geometry()
                if save_aspect:
                    w0, h0 = self._bg_img.size
                    a = min(float(w0)/w, float(h0)/h)
                    w0, h0 = int(w0/a), int(h0/a)
                    im = self._bg_img.resize((w0, h0))
                else:
                    im = self._bg_img.resize((w, h))
                image = ImageTk.PhotoImage(im)
            else:
                image = ImageTk.PhotoImage(self._bg_img)
        else:  # not Image
            stretch = 0
            image = self._bg_img
        for id in self.__tiles:
            self.delete(id)
        self.__tiles = []
        # must keep a reference to the image, otherwise Python will
        # garbage collect it...
        self.__tileimage = image
        if stretch:
            #
            if self.preview:
                dx, dy = 0, 0
            else:
                dx, dy = -self.xmargin, -self.ymargin
            id = self._x_create("image", dx, dy, image=image, anchor="nw")
            self.tag_lower(id)          # also see tag_lower above
            self.__tiles.append(id)
        else:
            iw, ih = image.width(), image.height()
            sw, sh = self._geometry()
            for x in range(-self.xmargin, sw, iw):
                for y in range(-self.ymargin, sh, ih):
                    id = self._x_create(
                        "image", x, y, image=image, anchor="nw")
                    self.tag_lower(id)          # also see tag_lower above
                    self.__tiles.append(id)
        return 1

    def _geometry(self):
        w = max(self.winfo_width(), int(self.cget('width')))
        h = max(self.winfo_height(), int(self.cget('height')))
        scrollregion = self.cget('scrollregion')
        if not scrollregion:
            return w, h
        x, y, sw, sh = [int(i) for i in scrollregion.split()]
        sw -= x
        sh -= y
        w = max(w, sw)
        h = max(h, sh)
        return w, h

    #
    # top-image support
    #

    def _x_create(self, itemType, *args, **kw):
        return tkinter.Canvas._create(self, itemType, args, kw)

    def _create(self, itemType, args, kw):
        # print "_create:", itemType, args, kw
        id = tkinter.Canvas._create(self, itemType, args, kw)
        if self.__tops:
            self.tk.call(self._w, "lower", id, self.__tops[0])
        return id

    def tag_raise(self, id, aboveThis=None):
        # print "tag_raise:", id, aboveThis
        if aboveThis is None and self.__tops:
            self.tk.call(self._w, "lower", id, self.__tops[0])
        else:
            self.tk.call(self._w, "raise", id, aboveThis)

    def tag_lower(self, id, belowThis=None):
        # print "tag_lower:", id, belowThis
        if belowThis is None and self.__tiles:
            self.tk.call(self._w, "raise", id, self.__tiles[-1])
        else:
            self.tk.call(self._w, "lower", id, belowThis)

    def setInitialSize(self, width, height, margins=True, scrollregion=True):
        # print 'Canvas.setInitialSize:', width, height, scrollregion
        if self.preview:
            self.config(width=width, height=height,
                        scrollregion=(0, 0, width, height))
        else:
            # add margins
            dx, dy = self.xmargin, self.ymargin
            if margins:
                w, h = dx+width+dx, dy+height+dy
            else:
                w, h = width, height
            self.config(width=w, height=h)
            if scrollregion:
                self.config(scrollregion=(-dx, -dy, width+dx, height+dy))
            else:
                # no scrolls
                self.config(scrollregion=(-dx, -dy, dx, dy))

    # delete all CanvasItems, but keep the background and top tiles
    def deleteAllItems(self):
        self._text_items = []
        for id in list(self.items.keys()):
            assert id not in self.__tiles   # because the tile is created by id
            unbind_destroy(self.items[id])
            self.items[id].delete()
        assert self.items == {}

    def findCard(self, stack, event):
        if isinstance(stack.cards[0].item, Group):
            current = self.gettags("current")           # get tags
            for i in range(len(stack.cards)):
                if stack.cards[i].item.tag in current:
                    return i
        else:
            #  current = self.find("withtag", "current")   # get item ids
            #  for i in range(len(stack.cards)):
            #      if stack.cards[i].item.id in current:
            #          return i
            if self.preview:
                dx, dy = 0, 0
            else:
                dx, dy = -self.xmargin, -self.ymargin
            x = event.x+dx+self.xview()[0]*int(self.cget('width'))
            y = event.y+dy+self.yview()[0]*int(self.cget('height'))
            # x, y = event.x, event.y
            items = list(self.find_overlapping(x, y, x, y))
            items.reverse()
            for item in items:
                for i in range(len(stack.cards)):
                    if stack.cards[i].item.id == item:
                        return i
        return -1

    def setTextColor(self, color):
        if color is None:
            c = self.cget("bg")
            if not isinstance(c, str) or c[0] != "#" or len(c) != 7:
                return
            v = []
            for i in (1, 3, 5):
                v.append(int(c[i:i+2], 16))
            luminance = (0.212671 * v[0] + 0.715160 * v[1] + 0.072169 * v[2]) \
                / 255
            # print c, ":", v, "luminance", luminance
            color = ("#000000", "#ffffff")[luminance < 0.3]
        if self._text_color != color:
            self._text_color = color
            for item in self._text_items:
                item.config(fill=self._text_color)

    def setTile(self, image, stretch=0, save_aspect=0):
        # print 'setTile:', image, stretch
        if image:
            if Image:
                try:
                    self._bg_img = Image.open(image)
                except Exception:
                    return 0
            else:
                try:
                    self._bg_img = loadImage(file=image, dither=1)
                except Exception:
                    return 0
            self._stretch_bg_image = stretch
            self._save_aspect_bg_image = save_aspect
            self.setBackgroundImage()
        else:
            for id in self.__tiles:
                self.delete(id)
            self.__tiles = []
            self._bg_img = None
        return 1

    def setTopImage(self, image, cw=0, ch=0):
        try:
            if image and isinstance(image, str):
                image = loadImage(file=image)
        except tkinter.TclError:
            return 0
        if len(self.__tops) == 1 and image is self.__tops[0]:
            return 1
        for id in self.__tops:
            self.delete(id)
        self.__tops = []
        # must keep a reference to the image, otherwise Python will
        # garbage collect it...
        self.__topimage = image
        if image is None:
            return 1
        iw, ih = image.width(), image.height()
        if cw <= 0:
            # cw = max(int(self.cget("width")), self.winfo_width())
            cw = self.winfo_width()
        if ch <= 0:
            # ch = max(int(self.cget("height")),  self.winfo_height())
            ch = self.winfo_height()
        # print iw, ih, cw, ch
        x = (cw-iw)//2-self.xmargin+self.xview()[0]*int(self.cget('width'))
        y = (ch-ih)//2-self.ymargin+self.yview()[0]*int(self.cget('height'))
        id = self._x_create("image", x, y, image=image, anchor="nw")
        self.tk.call(self._w, "raise", id)
        self.__tops.append(id)
        return 1

    #
    # Pause support
    #

    def hideAllItems(self):
        for item in list(self.items.values()):
            item.config(state='hidden')

    def showAllItems(self):
        for item in list(self.items.values()):
            item.config(state='normal')

    #
    # restricted but fast _bind and _substitute
    #

    def _bind(self, what, sequence, func, add, needcleanup=1):
        funcid = self._register(func, self._substitute, needcleanup)
        cmd = ('%sif {"[%s %s]" == "break"} break\n' %
               (add and '+' or '', funcid, "%x %y"))
        self.tk.call(what + (sequence, cmd))
        return funcid

    def _substitute(self, *args):
        e = tkinter.Event()
        try:
            # Tk changed behavior in 8.4.2, returning "??" rather more often.
            e.x = int(args[0])
        except ValueError:
            e.x = args[0]
        try:
            e.y = int(args[1])
        except ValueError:
            e.y = args[1]
        return (e,)
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysol_tests.common_mocks1 import MockApp, MockCanvas, MockTalon

import pysollib.stack
from pysollib.hint import FreeCellSolver_Hint, PySolHintLayoutImportError


class MockGame:
    def __init__(self):
        self.app = MockApp()
        self.talon = MockTalon(self)

        self.allstacks = []
        self.stackmap = {}
        self.canvas = MockCanvas()
        self.foundations = [
            pysollib.stack.SS_FoundationStack(0, 0, self, s) for s in range(4)]
        self.rows = [pysollib.stack.AC_RowStack(0, 0, self) for s in range(8)]
        self.reserves = [
            pysollib.stack.AC_RowStack(0, 0, self) for s in range(4)]
        self.preview = 0


class Mock_S_Game:
    def __init__(self):
        self.s = MockGame()

    def flipMove(self, foo):
        pass

    def moveMove(self, cnt, frm, to, frames=0):
        c = frm.cards.pop()
        c.face_up = True
        to.addCard(c)
        pass


class MyTests(unittest.TestCase):
    def _calc_hint(self, fn):
        """docstring for _calc_hint"""
        s_game = Mock_S_Game()
        h = FreeCellSolver_Hint(s_game, None)
        fh = open(fn, 'r+b')
        h.importFileHelper(fh, s_game)
        return h

    def _successful_import(self, fn, want_s, blurb):
        self.assertEqual(self._calc_hint(fn).calcBoardString(), want_s, blurb)

    def test_import(self):
        return self._successful_import('tests/unit/data/with-10-for-rank.txt',
                                       '''FC: - - - -
4C 2C 9C 8C QS 4S 2H
5H QH 3C AC 3H 4H QD
QC 9S 6H 9H 3S KS 3D
5D 2S JC 5C JH 6D AS
2D KD TH TC TD 8D
7H JS KH TS KC 7C
AH 5S 6S AD 8H JD
7S 6C 7D 4D 8S 9D
''', 'import worked with "10"s as ranks')

    def test_import_2(self):
        return self._successful_import('tests/unit/data/624.board',
                                       '''FC: - - - -
KC 6H 4C QS 2D 4S AS
4H TH 2S JH 2H 9S AH
3S 6C 9H AD KH QD 7C
3C JS 5H KS TC 9C 8C
4D 9D 7S JC 5D TS
KD QC 5C QH 6S 3D
5S JD 8D 6D TD 8H
8S 7H 3H 2C AC 7D
''', 'import worked with Ts')

    def test_import_utf8_bom(self):
        return self._successful_import(
            'tests/unit/data/624-with-utf8-bom.board',
            '''FC: - - - -
KC 6H 4C QS 2D 4S AS
4H TH 2S JH 2H 9S AH
3S 6C 9H AD KH QD 7C
3C JS 5H KS TC 9C 8C
4D 9D 7S JC 5D TS
KD QC 5C QH 6S 3D
5S JD 8D 6D TD 8H
8S 7H 3H 2C AC 7D
''', 'import worked with utf-8 bom')

    def test_throw_error_on_duplicate_card(self):
        try:
            self._calc_hint('tests/unit/data/624-with-dup-card.board')
        except PySolHintLayoutImportError as err:
            self.assertEqual(err.msg, "Duplicate cards in input")
            self.assertEqual(err.cards, ["KC"])
            self.assertEqual(err.line_num, 1)
            self.assertEqual(err.format(), "Duplicate cards in input:\n\nKC")
            return
        self.fail("No exception thrown.")

    def test_throw_error_on_invalid_foundations_line(self):
        try:
            self._calc_hint(
                'tests/unit/data/624-invalid-foundations-line.board')
        except PySolHintLayoutImportError as err:
            self.assertEqual(err.msg, "Invalid Foundations line")
            self.assertEqual(err.cards, [])
            self.assertEqual(err.line_num, 1)
            return
        self.fail("No exception thrown.")

    def test_throw_error_on_missing_cards(self):
        try:
            self._calc_hint('tests/unit/data/624-missing-cards.board')
        except PySolHintLayoutImportError as err:
            self.assertEqual(err.msg, "Missing cards in input")
            self.assertEqual(err.cards, ["5H"])
            return
        self.fail("No exception thrown.")
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysollib.acard import AbstractCard
from pysollib.hint import Base_Solver_Hint


class MyTests(unittest.TestCase):
    def test_output(self):
        card = AbstractCard(1001, 0, 3, 7, 3001)
        h = Base_Solver_Hint(None, None, base_rank=0)

        got = h.card2str2(card)
        # TEST
        self.assertEqual(got, 'D-8', 'card2str2 works')
        # diag('got == ' + got)

        got = h.card2str1(card)
        # TEST
        self.assertEqual(got, '8D', 'card2str2 works')
        # diag('got == ' + got)
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysol_tests.common_mocks1 import MockApp, MockCanvas, MockItem, MockTalon

import pysollib.stack
from pysollib.acard import AbstractCard
from pysollib.games.spider import Scorpion_RowStack, Spider_RowStack


class MockGame:
    def __init__(self):
        self.app = MockApp()
        self.talon = MockTalon(self)

        self.allstacks = []
        self.stackmap = {}
        self.canvas = MockCanvas()
        self.foundations = [
            pysollib.stack.SS_FoundationStack(0, 0, self, s) for s in range(4)]
        self.rows = [pysollib.stack.Yukon_SS_RowStack(0, 0, self)
                     for s in range(8)]
        self.reserves = [
            pysollib.stack.Yukon_SS_RowStack(0, 0, self) for s in range(4)]
        self.preview = 0


class Mock_S_Game:
    def __init__(self):
        self.s = MockGame()

    def flipMove(self, foo):
        pass

    def moveMove(self, cnt, frm, to, frames=0):
        c = frm.cards.pop()
        c.face_up = True
        to.addCard(c)
        pass


class MyTests(unittest.TestCase):
    def _calc_Scorpion_stack(self):
        g = MockGame()
        stack = Scorpion_RowStack(0, 0, g)
        for s, r in [(2, 5), (3, 7), (2, 7), (2, 0), (2, 3), (2, 4), (1, 4)]:
            c = AbstractCard(1000+r*100+s*10, 0, s, r, g)
            c.face_up = True
            c.item = MockItem()
            stack.addCard(c)
        return stack

    def test_canMoveCards(self):
        stack = self._calc_Scorpion_stack()
        stack.canMoveCards(stack.cards[6:])
        self.assertTrue(stack)

    def test_canMoveCards_non_top(self):
        stack = self._calc_Scorpion_stack()
        self.assertTrue(stack.canMoveCards(stack.cards[4:]))
        self.assertTrue(stack)

    def _calc_Spider_stack(self):
        g = MockGame()
        stack = Spider_RowStack(0, 0, g)
        for s, r in [(2, 5), (3, 7), (2, 7), (2, 0), (2, 3), (2, 5), (1, 4)]:
            c = AbstractCard(1000+r*100+s*10, 0, s, r, g)
            c.face_up = True
            c.item = MockItem()
            stack.addCard(c)
        return stack

    def test_Spider_canMoveCards_non_top(self):
        stack = self._calc_Spider_stack()
        self.assertFalse(stack.canMoveCards(stack.cards[5:]))
        self.assertTrue(stack)
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysollib.game import GameDrag, GameStacks


class MyTests(unittest.TestCase):
    def test_shadows(self):
        d = GameDrag()
        d.shadows.append("test")
        self.assertTrue(len(d.shadows))

    def test_addattr(self):
        s = GameStacks()
        s.addattr(tableaux=[])
        s.tableaux.append("myval")
        self.assertEqual(s.tableaux, ["myval"])
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysollib.mfxutil import latin1_normalize


class MyTests(unittest.TestCase):
    def test_output(self):
        self.assertEqual(latin1_normalize('HELLO%%good'), 'hellogood')
#! /usr/bin/env python MockItem
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright © 2018 Shlomi Fish <shlomif@cpan.org>
#
# Distributed under terms of the MIT license.

import pysollib.stack
from pysollib.acard import AbstractCard

"""

"""


class MockItem:
    def __init__(self):
        pass

    def tkraise(self):
        return

    def addtag(self, nouse):
        return


class MockCanvas:
    def __init__(self):
        self.xmargin = self.ymargin = 50


class MockImages:
    def __init__(self):
        self.CARDW = self.CARDH = self.CARD_YOFFSET = 50


class MockOpt:
    def __init__(self):
        self.randomize_place = False


class MockApp:
    def __init__(self):
        self.images = MockImages()
        self.opt = MockOpt()


class MockTalon:
    def __init__(self, g):
        self.cards = [
            AbstractCard(1000+r*100+s*10, 0, s, r, g)
            for s in range(4) for r in range(13)]
        for c in self.cards:
            c.item = MockItem()


def _empty_override(*args):
    return True


pysollib.stack.MfxCanvasGroup = _empty_override
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysollib.acard import AbstractCard


class MyTests(unittest.TestCase):
    def test_cards(self):
        card1 = AbstractCard(1001, 0, 1, 2, 3001)
        # TEST
        self.assertEqual(card1.color, 0, 'card1.color is sane.')

        # TEST
        self.assertEqual(card1.rank, 2, 'card1.rank')

        card2 = AbstractCard(1001, 0, 3, 7, 3001)
        # TEST
        self.assertEqual(card2.color, 1, 'card2.color is sane.')

        # TEST
        self.assertEqual(card2.rank, 7, 'card2.rank')
# make_pysol_freecell_board.py - Program to generate the boards of
# PySol for input into Freecell Solver.
#
# Usage: make_pysol_freecell_board.py [board number] | fc-solve
#
# Or on non-UNIXes:
#
# python make_pysol_freecell_board.py [board number] | fc-solve
#
# This program is platform independent and will generate the same results
# on all architectures and operating systems.
#
# Based on the code by Markus Franz Xaver Johannes Oberhumer.
# Modified by Shlomi Fish, 2000
#
# Since much of the code here is ripped from the actual PySol code, this
# program is distributed under the GNU General Public License.
#
#
#
# vim:ts=4:et:nowrap
#
# ---------------------------------------------------------------------------##
#
# PySol -- a Python Solitaire game
#
# Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.
# If not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# Markus F.X.J. Oberhumer
# <markus.oberhumer@jk.uni-linz.ac.at>
# http://wildsau.idv.uni-linz.ac.at/mfx/pysol.html
#
# ---------------------------------------------------------------------------##


# imports
import unittest

from pysol_cards.cards import CardRenderer
from pysol_cards.deal_game import Game
from pysol_cards.random_base import RandomBase
from pysol_cards.random import random__int2str, random__str2int

# So the localpaths will be overrided.
from pysollib.pysolrandom import constructRandom

# PySol imports

# /***********************************************************************
# // Abstract PySol Random number generator.
# //
# // We use a seed of type long in the range [0, MAX_SEED].
# ************************************************************************/


ren = CardRenderer(True)


class MyTests(unittest.TestCase):
    def _cmp_board(self, got_s, expected_s, blurb):
        if not self.assertEqual(got_s, expected_s, blurb):
            return False
        return True

    def test_main(self):

        def test_24(blurb):
            game = Game("freecell", 24, RandomBase.DEALS_PYSOLFC)
            got_s = game.calc_layout_string(ren)
            self.assertEqual(got_s, '''4C 2C 9C 8C QS 4S 2H
5H QH 3C AC 3H 4H QD
QC 9S 6H 9H 3S KS 3D
5D 2S JC 5C JH 6D AS
2D KD TH TC TD 8D
7H JS KH TS KC 7C
AH 5S 6S AD 8H JD
7S 6C 7D 4D 8S 9D
''', blurb)

        # TEST
        test_24('Deal 24')

        game = Game("freecell", 123456, RandomBase.DEALS_MS)
        # TEST
        got_s = game.calc_layout_string(ren)
        self.assertEqual(got_s, '''QD TC AS KC AH KH 6H
6D TD 8D TH 7C 2H 9C
AC AD 5C 5H 8C 9H 9D
JS 8S 4D 4C 2S 7D 3C
7H 7S 9S 2C JC 5S
5D 3S 3D 3H KD JH
6C QS 4S 2D KS TS
JD QH 6S 4H QC 8H
''', 'Microsoft Deal 123456')

        game = Game("freecell", 123456, True)
        # TEST
        self._cmp_board(game.calc_layout_string(ren), '''3D 6C AS TS QC 8D 4D
2D TC 4H JD TD 2H 5C
2C 8S AH KD KH 5S 7C
9C 8C QH 3C 5D 9S QD
AC 9D 7H 6D KS JH
6H TH 8H QS 7D JC
4C 2S 3S 6S 5H 3H
KC JS 9H 4S 7S AD
''', 'PySolFC deal No. 123456')

        rand = constructRandom('ms3000000000')
        self.assertEqual(rand.getSeedAsStr(), 'ms3000000000')
        game = Game("freecell", 3000000000, RandomBase.DEALS_MS)
        # TEST
        self._cmp_board(game.calc_layout_string(ren), '''8D TS JS TD JH JD JC
4D QS TH AD 4S TC 3C
9H KH QH 4C 5C KD AS
9D 5D 8S 4H KS 6S 9S
6H 2S 7H 3D KC 2C
9C 7C QC 7S QD 7D
6C 3H 8H AC 6D 3S
8C AH 2H 5H 2D 5S
''', 'Microsoft Deal #3E9 - long seed.')

        rand = constructRandom('ms6000000000')
        game = Game("freecell", 6000000000, RandomBase.DEALS_MS)
        # TEST
        got_s = game.calc_layout_string(ren)
        self.assertEqual(got_s, '''2D 2C QS 8D KD 8C 4C
3D AH 2H 4H TS 6H QD
4D JS AD 6S JH JC JD
KH 3H KS AS TC 5D AC
TD 7C 9C 7H 3C 3S
QH 9H 9D 5S 7S 6C
5C 5H 2S KC 9S 4S
6D QC 8S TH 7D 8H
''', 'Microsoft Deal #6E9 - extra long seed.')

        inp = 'ms12345678'
        got = random__int2str(random__str2int(inp))

        # TEST
        self.assertEqual(got, inp, 'long2str ms roundtrip.')

        inp = '246007891097'
        got = random__int2str(random__str2int(inp))

        # TEST
        self.assertEqual(got, inp, 'long2str PySolFC roundtrip.')

        proto_inp = '246007891097'
        inp = random__str2int(proto_inp)
        got = random__str2int(random__int2str(inp))

        # TEST
        self.assertEqual(got, inp, 'str2long PySolFC roundtrip.')

        rand = constructRandom('ms100000')
        seed = rand.increaseSeed(rand.initial_seed)
        seed = rand.str(seed)
        # TEST
        self.assertEqual(seed, 'ms100001', 'increaseSeed for ms deals')
        rand = constructRandom(seed)
        game = Game("freecell", int(seed[2:]), RandomBase.DEALS_MS)
        # TEST
        self._cmp_board(game.calc_layout_string(ren), '''5S AH 4H TD 4S JD JS
3C 8C 4C AC JC AS QS
7C QH 2D QD 8S 9D AD
KS 7S 5H 3H TS 3S 5D
9S 7H KC TH 8D 6S
5C KD 9H 2H 2S 6D
9C JH 8H 3D 4D QC
KH 6H 6C TC 2C 7D
''', 'ms100001')

        seed = 24000024
        rand = constructRandom(str(seed))
        expected0 = rand.randint(0, 100)
        expected1 = rand.randint(0, 100)
        rand.reset()
        got0 = rand.randint(0, 100)
        got1 = rand.randint(0, 100)
        # TEST
        self.assertEqual(
            [got0, got1, ],
            [expected0, expected1, ],
            "same results after reset()",)
#!/usr/bin/env python3

import builtins
import os
import sys

from pysollib.gamedb import GAME_DB
from pysollib.gamedb import GI
from pysollib.mfxutil import latin1_normalize
from pysollib.mygettext import fix_gettext
# outdir = '../html'
pysollib_dir = '../'


builtins._ = lambda x: x
builtins.n_ = lambda x: x

import pysollib.games  # noqa: F402,I100,I202
import pysollib.games.mahjongg  # noqa: F402
import pysollib.games.special  # noqa: F401,F402
import pysollib.games.ultra  # noqa: F401,F402

try:
    os.mkdir('html')
except Exception:
    pass

try:
    os.mkdir('html/rules')
except Exception:
    pass


def merge_dicts(x, y):
    ret = x.copy()
    ret.update(y)
    return ret


pysollib_path = os.path.join(sys.path[0], pysollib_dir)
sys.path[0] = os.path.normpath(pysollib_path)
# print sys.path

fix_gettext()

files = [
    ('credits.html', 'PySol Credits'),
    ('ganjifa.html', 'PySol - General Ganjifa Card Rules'),
    ('general_rules.html', 'PySol - General Rules'),
    ('glossary.html', 'PySol - Glossary'),
    ('hanafuda.html', 'PySol - Rules for General Flower Card Rules'),
    ('hexadeck.html', 'PySol - General Hex A Deck Card Rules'),
    ('howtoplay.html', 'How to play PySol'),
    ('index.html', 'PySol - a Solitaire Game Collection'),
    ('install.html', 'PySol - Installation'),
    ('intro.html', 'PySol - Introduction'),
    ('license.html', 'PySol Software License'),
    ('news.html', 'PySol - a Solitaire Game Collection'),
    # ('rules_alternate.html', 'PySol - a Solitaire Game Collection'),
    # ('rules.html', 'PySol - a Solitaire Game Collection'),
    ]

rules_files = [
    # ('hanoipuzzle.html', ),
    ('mahjongg.html', 'PySol - Rules for Mahjongg'),
    ('matrix.html', 'PySol - Rules for Matrix'),
    ('pegged.html', 'PySol - Rules for Pegged'),
    ('shisensho.html', 'PySol - Rules for Shisen-Sho'),
    ('spider.html', 'PySol - Rules for Spider'),
    ('freecell.html', 'PySol - Rules for FreeCell'),
    ]
wikipedia_files = [
    ('houseinthewood.html', 'PySol - Rules for House in the Woods'),
    ('fourseasons.html', 'PySol - Rules for Four Seasons'),
    ]


def _fmt(fmt, params):
    return fmt % merge_dicts(params, {'logo_url': "images/pysollogo03.png",
                                      'logo_alt': "PySol FC Logo"})


main_header = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>%(title)s</title>
<meta name="license" content="GNU General Public License">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>
<body text="#000000" bgcolor="#F7F3FF" link="#0000FF" vlink="#660099"
alink="#FF0000">
<img src="%(logo_url)s" alt="%(logo_alt)s">
<br>
'''
main_footer = '''
<p>
<br>
%(back_to_index_link)s
</body>
</html>'''

rules_header = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>%(title)s</title>
<meta name="license" content="GNU General Public License">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>
<body text="#000000" bgcolor="#F7F3FF" link="#0000FF" vlink="#660099"
link="#FF0000">
<img src="../%(logo_url)s" alt="%(logo_alt)s">
<br>
'''
rules_footer = '''
<p>
%(footer)s
<br>
<a href="../glossary.html">Glossary</a>
<br>
<a href="../general_rules.html">General rules</a>

<p>
<a href="../index.html">Back to the index</a>
</body>
</html>'''

wikipedia_header = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>%(title)s</title>
<meta name="license" content="GNU General Public License">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>
<body text="#000000" bgcolor="#F7F3FF" link="#0000FF" vlink="#660099"
alink="#FF0000">
<img src="../%(logo_url)s" alt="%(logo_alt)s">
<br>
'''


def getGameRulesFilename(n):
    if n.startswith('Mahjongg'):
        return 'mahjongg.html'
    return latin1_normalize(n) + '.html'


def gen_main_html():
    for infile, title in files:
        outfile = open(os.path.join('html', infile), 'w')
        print(_fmt(main_header, {'title': title}), file=outfile)
        with open(infile, 'r') as file:
            print(file.read(), file=outfile)
        s = '<a href="index.html">Back to the index</a>'
        if infile == 'index.html':
            s = ''
        print(_fmt(main_footer, {'back_to_index_link': s}), file=outfile)
        outfile.close()


def gen_rules_html():
    # ls = glob(os.path.join('rules', '*.html'))
    rules_ls = os.listdir('rules')
    rules_ls.sort()
    wikipedia_ls = os.listdir('wikipedia')
    wikipedia_ls.sort()

    games = GAME_DB.getGamesIdSortedByName()
    rules_list = []
    files_list = []
    for fn, tt in rules_files:
        rules_list.append(('rules', fn, tt, ''))
        files_list.append(fn)
    for fn, tt in wikipedia_files:
        rules_list.append(('wikipedia', fn, tt, ''))
        files_list.append(fn)
    altnames = []

    # open file of list of all rules
    out_rules = open(os.path.join('html', 'rules.html'), 'w')
    print(_fmt(main_header, {'title': 'PySol - a Solitaire Game Collection'}),
          file=out_rules)
    with open('rules.html', 'r') as file:
        print(file.read(), file=out_rules)

    for id in games:
        # create list of rules

        gi = GAME_DB.get(id)

        rules_fn = gi.rules_filename
        if not rules_fn:
            rules_fn = getGameRulesFilename(gi.name)

        if rules_fn in files_list:
            continue

        if rules_fn in rules_ls:
            rules_dir = 'rules'
        elif rules_fn in wikipedia_ls:
            rules_dir = 'wikipedia'
        else:
            print('missing rules for %s (file: %s)'
                  % (gi.name, rules_fn))
            continue

        # print '>>>', rules_fn

        title = 'PySol - Rules for ' + gi.name
        s = ''
        if gi.si.game_type == GI.GT_HANAFUDA:
            s = '<a href="../hanafuda.html">General Flower Card rules</a>'
        elif gi.si.game_type == GI.GT_DASHAVATARA_GANJIFA:
            s = '<a href="../ganjifa.html">About Ganjifa</a>'
        elif gi.si.game_type == GI.GT_HEXADECK:
            s = '<a href="../hexadeck.html">General Hex A Deck rules</a>'
        elif gi.si.game_type == GI.GT_MUGHAL_GANJIFA:
            s = '<a href="../ganjifa.html">About Ganjifa</a>'
            # print '***', gi.name, '***'

        rules_list.append((rules_dir, rules_fn, title, s))
        files_list.append(rules_fn)
        # rules_list.append((rules_fn, gi.name))
        print('<li><a href="rules/%s">%s</a>'
              % (rules_fn, gi.name), file=out_rules)
        for n in gi.altnames:
            altnames.append((n, rules_fn))

    print('</ul>\n' + _fmt(main_footer,
          {'back_to_index_link':
           '<a href="index.html">Back to the index</a>'}),
          file=out_rules)

    out_rules.close()

    # create file of altnames
    out_rules_alt = open(os.path.join('html', 'rules_alternate.html'), 'w')
    print(_fmt(main_header, {'title': 'PySol - a Solitaire Game Collection'}),
          file=out_rules_alt)
    with open('rules_alternate.html', 'r') as file:
        print(file.read(), file=out_rules_alt)
    altnames.sort()
    for name, fn in altnames:
        print('<li> <a href="rules/%s">%s</a>'
              % (fn, name), file=out_rules_alt)
    print('</ul>\n' + _fmt(main_footer,
          {'back_to_index_link':
           '<a href="index.html">Back to the index</a>'}),
          file=out_rules_alt)
    out_rules_alt.close()

    # create rules
    for dir, filename, title, footer in rules_list:
        outfile = open(
            os.path.join('html', 'rules', filename), 'w', encoding='utf-8')
        if dir == 'rules':
            print(_fmt(rules_header, {'title': title}), file=outfile)
        else:  # d == 'wikipedia'
            print(_fmt(wikipedia_header, {'title': title}), file=outfile)
        with open(os.path.join(dir, filename), 'r', encoding='utf-8') as file:
            print(file.read(), file=outfile)
        print(_fmt(rules_footer, {'footer': footer}), file=outfile)
        outfile.close()


gen_main_html()
gen_rules_html()
#!/usr/bin/env python3
# ---------------------------------------------------------------------------
#
# PySol -- a Python Solitaire game
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.
# If not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# ---------------------------------------------------------------------------

# Starter for kivy/android using buildozer: Needs an explizitly
# named main.py as startpoint.

import sys
if '--kivy' not in sys.argv:
    sys.argv.append('--kivy')

runmain = True
if runmain:
    from pysollib.init import init
init()

if runmain:
    from pysollib.main import main
sys.exit(main(sys.argv))
#!/usr/bin/env python3
# ---------------------------------------------------------------------------
#
# PySol -- a Python Solitaire game
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.
# If not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# ---------------------------------------------------------------------------

# import pychecker.checker

# Starter for kivy/android using buildozer: Needs an explizitly
# named main.py as startpoint.

if True:
    import sys
    sys.path.insert(0, '..')
if True:
    from pysollib.settings import VERSION
    print(VERSION)
#!/usr/bin/env python3
# -*- mode: python; coding: koi8-r; -*-
#

import os
import sys
import time

# from pprint import pprint
import pysollib.games
import pysollib.games.mahjongg  # noqa: F401
import pysollib.games.special
import pysollib.games.ultra  # noqa: F401
from pysollib.gamedb import GAME_DB
from pysollib.gamedb import GI
from pysollib.mfxutil import latin1_normalize
from pysollib.mygettext import fix_gettext
from pysollib.resource import CSI

from six.moves import builtins
os.environ['LANG'] = 'C'
builtins.__dict__['_'] = lambda x: x
builtins.__dict__['n_'] = lambda x: x

pysollib_path = os.path.join(sys.path[0], '..')
sys.path[0] = os.path.normpath(pysollib_path)
rules_dir = os.path.normpath(os.path.join(pysollib_path, 'data/html/rules'))
# pprint(sys.path)
# print rules_dir
html_mode = None

fix_gettext()


def getGameRulesFilename(n):
    if n.startswith('Mahjongg'):
        return 'mahjongg.html'
    return latin1_normalize(n) + '.html'


GAME_BY_TYPE = {
    GI.GT_BAKERS_DOZEN: "Baker's Dozen",
    GI.GT_BELEAGUERED_CASTLE: "Beleaguered Castle",
    GI.GT_CANFIELD: "Canfield",
    GI.GT_FAN_TYPE: "Fan",
    GI.GT_FORTY_THIEVES: "Forty Thieves",
    GI.GT_FREECELL: "FreeCell",
    GI.GT_GOLF: "Golf",
    GI.GT_GYPSY: "Gypsy",
    GI.GT_KLONDIKE: "Klondike",
    GI.GT_MONTANA: "Montana",
    GI.GT_NAPOLEON: "Napoleon",
    GI.GT_NUMERICA: "Numerica",
    GI.GT_PAIRING_TYPE: "Pairing",
    GI.GT_RAGLAN: "Raglan",
    GI.GT_SIMPLE_TYPE: "Simple game",
    GI.GT_SPIDER: "Spider",
    GI.GT_TERRACE: "Terrace",
    GI.GT_YUKON: "Yukon",
    GI.GT_1DECK_TYPE: "One-Deck game",
    GI.GT_2DECK_TYPE: "Two-Deck game",
    GI.GT_3DECK_TYPE: "Three-Deck game",
    GI.GT_4DECK_TYPE: "Four-Deck game",

    GI.GT_MATRIX: "Matrix",
    GI.GT_MEMORY: "Memory",
    GI.GT_POKER_TYPE: "Poker",
    GI.GT_PUZZLE_TYPE: "Puzzle",
    GI.GT_TAROCK: "Tarock",
    GI.GT_HEXADECK: "Hex A Deck",
    GI.GT_HANAFUDA: "Hanafuda",
    GI.GT_DASHAVATARA_GANJIFA: "Dashavatara Ganjifa",
    GI.GT_MAHJONGG: "Mahjongg",
    GI.GT_MUGHAL_GANJIFA: "Mughal Ganjifa",
    GI.GT_SHISEN_SHO: "Shisen-Sho",

}


def by_category():
    games = GAME_DB.getGamesIdSortedById()
    games_by_cat = {}
    for id in games:
        gi = GAME_DB.get(id)
        gt = CSI.TYPE_NAME[gi.category]
        if gt in games_by_cat:
            games_by_cat[gt] += 1
        else:
            games_by_cat[gt] = 1
    games_by_cat_list = [(i, j) for i, j in games_by_cat.items()]
    games_by_cat_list.sort(key=lambda x: x[1])
    games_by_cat_list = games_by_cat_list[::-1]
#     print '<table border="2"><tr><th>Name</th><th>Number</th></tr>'
#     for i in games_by_cat_list:
#         print '<tr><td>%s</td><td>%s</td></tr>' % i
#     print '</table>'
    print('<ul>')
    for i in games_by_cat_list:
        print('<li>%s (%s games)</li>' % i)
    print('</ul>')
    return


def by_type():
    games = GAME_DB.getGamesIdSortedById()
    games_by_type = {}
    for id in games:
        gi = GAME_DB.get(id)
        if gi.si.game_type not in GAME_BY_TYPE:
            print(gi.si.game_type)
            continue
        gt = GAME_BY_TYPE[gi.si.game_type]
        if gt in games_by_type:
            games_by_type[gt] += 1
        else:
            games_by_type[gt] = 1
    games_by_type_list = list(games_by_type.items())
    games_by_type_list.sort(key=lambda x: x[0])
    #  print '<table border="2"><tr><th>Name</th><th>Number</th></tr>'
    #  for i in games_by_type_list:
    #      print '<tr><td>%s</td><td>%s</td></tr>' % i
    #  print '</table>'
    print('<ul>')
    for i in games_by_type_list:
        print('<li>%s (%s games)</li>' % i)
    print('</ul>')
    return


def all_games(sort_by='id'):
    # rules_dir = 'rules'
    print('''<table><thead>
<tr><th>ID</th><th>Name</th><th>Alternate names</th><th>Type</th></tr>
</thead>
<tbody>
''')

    if sort_by == 'id':
        get_games_func = GAME_DB.getGamesIdSortedById
    else:
        get_games_func = GAME_DB.getGamesIdSortedByName

    for id in get_games_func():
        gi = GAME_DB.get(id)
        if not gi.rules_filename:
            rules_fn = getGameRulesFilename(gi.name)
        else:
            rules_fn = gi.rules_filename
        gt = CSI.TYPE_NAME[gi.category]
        if gt == 'French':
            gt = 'French (%s)' % GAME_BY_TYPE[gi.si.game_type]
        name = gi.name
        altnames = '<br/>'.join(gi.altnames)
        fn = os.path.join(rules_dir, rules_fn)
        if 1 and os.path.exists(fn):
            print('''<tr>
<td>%s</td>
<td> <a href="%s" title="Rules for this game">%s</a> </td>
<td>%s</td>
<td>%s</td>
</tr>
''' % (id, fn, name, altnames, gt))
        else:
            print('''<tr>
<td>%s</td>
<td>%s</td>
<td>%s</td>
<td>%s</td>
</tr>
''' % (id, name, altnames, gt))
    print('</tbody></table>')


def create_html(sort_by):
    if html_mode != 'bare':
        print('''<!DOCTYPE html><html lang="en-US">
<head>
  <title>PySolFC - List of solitaire games</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
</head>
<body>
''')
    print('<strong>Total games: %d</strong>' %
          len(GAME_DB.getGamesIdSortedById()))
    print('<section>')
    print('<h2>Categories</h2>')
    by_category()
    print('</section>')
    print('<section>')
    print('<h2>Types</h2>')
    by_type()
    print('</section>')
    # print '<h2>All games</h2>'
    print('<section>')
    print('<h2>The games</h2>')
    all_games(sort_by)
    print('</section>')
    if html_mode != 'bare':
        print('</body></html>')


def get_text():
    # get_games_func = GAME_DB.getGamesIdSortedById
    get_games_func = GAME_DB.getGamesIdSortedByName

    games_list = {}  # for unique
    for id in get_games_func():
        gi = GAME_DB.get(id)
        games_list[gi.name] = ''
        if gi.name != gi.short_name:
            games_list[gi.short_name] = ''
        for n in gi.altnames:
            games_list[n] = ''
    games_list = list(games_list.keys())
    games_list.sort()
    print('''\
# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR ORGANIZATION
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PySol 0.0.1\\n"
"POT-Creation-Date: %s\\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"
"Language-Team: LANGUAGE <LL@li.org>\\n"
"MIME-Version: 1.0\\n"
"Content-Type: text/plain; charset=CHARSET\\n"
"Content-Transfer-Encoding: ENCODING\\n"
"Generated-By: %s 0.1\\n"

''' % (time.asctime(), sys.argv[0]))
    for g in games_list:
        print('msgid "%s"\nmsgstr ""\n' % g)


def old_plain_text():
    # get_games_func = GAME_DB.getGamesIdSortedById
    get_games_func = GAME_DB.getGamesIdSortedByName
    games_list = {}  # for unique
    for id in get_games_func():
        gi = GAME_DB.get(id)
        games_list[gi.name] = ''
        # if gi.name != gi.short_name:
        #    games_list[gi.short_name] = ''
        for n in gi.altnames:
            games_list[n] = ''
    games_list = games_list.keys()
    games_list.sort()
    for g in games_list:
        print(g)


def plain_text():
    get_games_func = GAME_DB.getGamesIdSortedByName
    for id in get_games_func():
        gi = GAME_DB.get(id)
        if gi.category == GI.GC_FRENCH:
            # print str(gi.gameclass)
            # gc = gi.gameclass
            # h = gc.Hint_Class is None and 'None' or gc.Hint_Class.__name__
            # print gi.name.encode('utf-8'), h
            print(gi.name)
            for n in gi.altnames:
                print(n)
            # name = gi.name.lower()
            # name = re.sub('\W', '', name)
            # print id, name #, gi.si.game_type,
            #       gi.si.game_type == GI.GC_FRENCH


if len(sys.argv) < 2 or sys.argv[1] == 'html':
    sort_by = 'id'
    if len(sys.argv) > 2:
        sort_by = sys.argv[2]
    if len(sys.argv) > 3:
        rules_dir = sys.argv[3]
    if len(sys.argv) > 4:
        html_mode = sys.argv[4]
    create_html(sort_by)
elif sys.argv[1] == 'gettext':
    get_text()
elif sys.argv[1] == 'text':
    plain_text()
else:
    sys.exit('invalid argument')
#!/usr/bin/env python
# Written by Shlomi Fish, under the MIT Expat License.

import os
import os.path
import re
from sys import platform

IS_MAC = (platform == "darwin")
TEST_TAGS = os.getenv('TEST_TAGS', '')


def _has_tag(tag):
    return re.search("\\b{}\\b".format(tag), TEST_TAGS)


PY_VERS = ([] if _has_tag('SKIP_PY2') else [2])+[3]
SKIP_GTK = _has_tag('SKIP_GTK')
module_names = []
for d, _, files in os.walk("pysollib"):
    for f in files:
        if re.search("\\.py$", f):
            module_names.append(
                (d + "/" + re.sub("\\.py$", "", f))
                .replace("/", ".").replace(os.sep, "."))

module_names.sort()
for module_name in module_names:
    if "kivy" in module_name:
        continue
    is_gtk = ("gtk" in module_name)
    for ver in PY_VERS:
        if ((not is_gtk) or (ver == 2 and (not IS_MAC) and (not SKIP_GTK))):
            def fmt(s):
                return s % {'module_name': module_name, 'ver': ver}
            open(os.path.join(".", "tests", "individually-importing", fmt("import_v%(ver)d_%(module_name)s.py")), 'w').write(fmt('''#!/usr/bin/env python%(ver)d
import sys
print('1..1')
sys.path.insert(0, ".")
import %(module_name)s
print('ok 1 - imported')
'''))

for ver in PY_VERS:
    for mod in [
            'pysol_tests.acard_unit',
            'pysol_tests.game_drag',
            'pysol_tests.hint',
            'pysol_tests.import_file1',
            'pysol_tests.latin1_conv_unit',
            'pysol_tests.ms_deals1',
            'pysol_tests.scorpion_canMove',
            ]:
        open(os.path.join(".", "tests", "unit-generated",
                          'test__%s__v%d.py' % (mod, ver)
                          ), 'w').write('''#!/usr/bin/env python%(ver)d
import unittest

from pycotap import TAPTestRunner

from %(mod)s import MyTests

suite = unittest.TestLoader().loadTestsFromTestCase(MyTests)
TAPTestRunner().run(suite)
''' % {'mod': mod, 'ver': ver})
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-

import os
import sys

alpha = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'


def decode_layout(layout):
    # decode tile positions
    assert layout[0] == "0"
    assert (len(layout) - 1) % 3 == 0
    tiles = []
    for i in range(1, len(layout), 3):
        n = alpha.find(layout[i])
        level, height = n / 7, n % 7 + 1
        tx = alpha.find(layout[i+1])
        ty = alpha.find(layout[i+2])
        assert n >= 0 and tx >= 0 and ty >= 0
        for tl in range(level, level + height):
            tiles.append((tl, tx, ty))
    tiles.sort()
    return tiles


def encode_layout(layout):
    # encode positions
    s = '0'
    # layout.sort()
    x_max = max([t[1] for t in layout])
    y_max = max([t[2] for t in layout])
    for x in range(x_max+1):
        for y in range(y_max+1):
            mylist = [t[0] for t in layout if t[1] == x and t[2] == y]
            if not mylist:
                continue
            i_0 = i_n = mylist[0]
            for i in mylist[1:]:
                if i == i_n+1:
                    i_n = i
                    continue
                s += alpha[i_0*7+(i_n-i_0)] + alpha[x] + alpha[y]
                i_0 = i_n = i
            s += alpha[i_0*7+(i_n-i_0)] + alpha[x] + alpha[y]

#     for tl, tx, ty in layout:
#         s += alpha[tl*7]+alpha[tx]+alpha[ty]
    return s


def parse_kyodai(filename):
    # Kyodai (http://www.kyodai.com/)

    fd = open(filename)
    fd.readline()
    fd.readline()

    s = fd.readline()
    i = 0
    y = 0
    z = 0
    layout = []
    while True:
        ss = s[i:i+34]
        if not ss:
            break
        x = 0
        for c in ss:
            if c == '1':
                layout.append((z, x, y))
            x += 1
        y += 1
        if y == 20:
            y = 0
            z += 1
        i += 34
    layout.sort()
    return normalize(layout)


def parse_ace(filename):
    # Ace of Penguins (http://www.delorie.com/store/ace/)
    mylist = open(filename).read().replace('\n', '').split(',')
    mylist.reverse()
    layout = []
    layer = 0
    while True:
        x = int(mylist.pop())
        if x == 127:
            break
        if x <= 0:
            x = -x
            y, z = int(mylist.pop()), int(mylist.pop())
            if layer < z:
                layer = z
        layout.append((z, x, y))
    layout.sort()
    return normalize(layout)


def parse_kmahjongg(filename):
    # KMahjongg
    fd = open(filename)
    fd.readline()
    lines = fd.readlines()
    level = 0
    n = 0
    layout = []
    for s in lines:
        i = 0
        while True:
            i = s.find('1', i)
            if i >= 0:
                layout.append((level, i, n))
                i += 1
            else:
                break
        n += 1
        if n == 16:
            n = 0
            level += 1
    layout.sort()
    return normalize(layout)


def parse_xmahjongg(filename):
    if open(filename).readline().startswith('Kyodai'):
        return parse_kyodai(filename)
    fd = open(filename)
    layout = []
    for s in fd:
        s = s.strip()
        if not s:
            continue
        if s.startswith('#'):
            continue
        row, col, lev = s.split()
        layout.append((int(lev), int(col), int(row)))
    layout.sort()
    return normalize(layout)


def normalize(mylist):
    minx = min([i[1] for i in mylist])
    if minx:
        mylist = [(i[0], i[1]-minx, i[2]) for i in mylist]
    miny = min([i[2] for i in mylist])
    if miny:
        mylist = [(i[0], i[1], i[2]-miny) for i in mylist]
    return mylist


if __name__ == '__main__':
    gameid = 5200

    usage = '''usage:
%s TYPE FILE ...
  where TYPE are:
    k | kyodai    - parse kyodai file
    x | xmahjongg - parse xmahjongg file
    m | kmahjongg - parse kmahjongg file
    a | ace       - parse ace of penguins file
''' % sys.argv[0]

    if len(sys.argv) < 3:
        sys.exit(usage)
    if sys.argv[1] in ['k', 'kyodai']:
        parse_func = parse_kyodai
    elif sys.argv[1] in ['x', 'xmahjongg']:
        parse_func = parse_xmahjongg
    elif sys.argv[1] in ['m', 'kmahjongg']:
        parse_func = parse_kmahjongg
    elif sys.argv[1] in ['a', 'ace']:
        parse_func = parse_ace
    else:
        sys.exit(usage)

    for filename in sys.argv[2:]:

        layout = parse_func(filename)
        layout = normalize(layout)

        # print filename, len(layout)

        s = encode_layout(layout)

        # check
        lt = decode_layout(s)
        if lt != layout:
            print('*** ERROR ***')
        else:
            # print s

            gamename = os.path.split(filename)[1].split('.')[0]
            # classname = gamename.replace(' ', '_')
            # classname = 'Mahjongg_' + re.sub('\W', '', classname)

            ncards = len(layout)

            if ncards != 144:
                print('''r(%d, "%s", ncards=%d, layout="%s")
''' % (gameid, gamename, ncards, s))

            else:
                print('''r(%d, "%s", layout="%s")
''' % (gameid, gamename, s))

            gameid += 1
#!/usr/bin/env python3

import os
import sys

import pysollib.settings

if sys.version_info > (3,):
    def execfile(fn):
        return exec(open(fn).read())

prog_name = 'PySol Fan Club edition'


dirs_list = []
files_list = []
for root, dirs, files in os.walk('dist'):
    if files:
        files_list.append(root)
    dirs_list.append(root)

prog_version = pysollib.settings.VERSION

out = open('setup.iss', 'w')

print('''
[Setup]
AppName=%(prog_name)s
AppVerName=%(prog_name)s v.%(prog_version)s
DefaultDirName={pf}\\%(prog_name)s
DefaultGroupName=%(prog_name)s
UninstallDisplayIcon={app}\\pysol.exe
Compression=lzma
SolidCompression=yes
SourceDir=dist
OutputDir=.
OutputBaseFilename=PySolFC_%(prog_version)s_setup
DisableWelcomePage=no
DisableDirPage=no
DisableProgramGroupPage=no

[Icons]
Name: "{group}\\%(prog_name)s"; Filename: "{app}\\pysol.exe"
Name: "{group}\\Uninstall %(prog_name)s"; Filename: "{uninstallexe}"
Name: "{userdesktop}\\%(prog_name)s"; Filename: "{app}\\pysol.exe"
''' % vars(), file=out)

print('[Dirs]', file=out)
for d in dirs_list[1:]:
    print('Name: "{app}%s"' % d.replace('dist', ''), file=out)

print(file=out)
print('[Files]', file=out)
print('Source: "*"; DestDir: "{app}"', file=out)
for d in files_list[1:]:
    d = d.replace('dist\\', '')
    print('Source: "%s\\*"; DestDir: "{app}\\%s"' % (d, d), file=out)

print('Source: "..\\vcredist_x86.exe"; DestDir: {tmp}; \
Flags: deleteafterinstall', file=out)
print('[Run]\n\
Filename: {tmp}\\vcredist_x86.exe; \
Parameters: "/passive /promptrestart /showfinalerror"; \
StatusMsg: "Installing MS Visual C++ 2010 SP1 Redistributable Package (x86)"; \
Check: not isVCInstalled', file=out)
print('''
[Code]
function isVCInstalled: Boolean;
var
  find: TFindRec;
begin
  if FindFirst(ExpandConstant('{sys}\\msvcr100.dll'), find) then begin
    Result := True;
    FindClose(find);
  end else begin
    Result := False;
  end;
 end;

function InitializeSetup(): Boolean;
var
  Version: TWindowsVersion;
begin
  GetWindowsVersionEx(Version);

  // Windows XP SP3 and higher
  if  ((Version.Major = 5) and ((Version.Minor = 1) and
       (Version.ServicePackMajor >= 3) or (Version.Minor > 1)) or
       (Version.Major > 5)) then
    Result := True
  else begin
    MsgBox(
      'This version of Windows is not supported. PySolFC %(prog_version)s \
requires Windows XP SP3 or higher.',
      mbCriticalError, MB_OK);
    Result := False;
  end;
end;
''' % vars(), file=out)

out.close()
#!/usr/bin/env python
# -*- mode: python; coding: koi8-r; -*-
#

import os
import sys
from glob import glob
from math import cos, pi, sin, sqrt

from six.moves import tkinter

try:
    from PIL import Image, ImageTk
except ImportError:
    Image = None

cardset_type = {
    '1': 'French',
    '2': 'Hanafuda',
    '3': 'Tarock',
    '4': 'Mahjongg',
    '5': 'Hexadeck',
    '6': 'Mughal Ganjifa',
    '7': 'Navagraha Ganjifa',
    '8': 'Dashavatara Ganjifa',
    '9': 'Trump only',
    }

all_imgs = False


class Cardset:
    def __init__(self, dir, name, type, ext, x, y):
        self.dir, self.name, self.type, self.ext, self.x, self.y = \
            dir, name, type, ext, x, y


def create_cs_list(ls):
    cardsets_list = {}
    for f in ls:
        dir = os.path.split(f)[0]
        lines = open(f).readlines()
        l0 = lines[0].split(';')
        try:
            ext = l0[2]
        except IndexError:
            # print f
            ext = '.gif'
        if len(l0) > 3:
            type = cardset_type[l0[3]]
        else:
            # type = 'Unknown'
            type = 'French'
        l1 = lines[1].split(';')
        name = l1[1].strip()
        l2 = lines[2].split()
        x, y = int(l2[0]), int(l2[1])
        cs = Cardset(dir, name, type, ext, x, y)
        cardsets_list[name] = cs
    return cardsets_list


tk_images = []
zoom = 0


def show_cardset(*args):
    global tk_images
    tk_images = []
    if list_box.curselection():
        cs_name = list_box.get(list_box.curselection())
        cs = cardsets_dict[cs_name]
        ls = glob(os.path.join(cs.dir, '[0-9][0-9][a-z]'+cs.ext))
        ls += glob(os.path.join(cs.dir, 'back*'+cs.ext))
        if all_imgs:
            ls += glob(os.path.join(cs.dir, 'bottom*'+cs.ext))
            ls += glob(os.path.join(cs.dir, 'l*'+cs.ext))
        # ls = glob(os.path.join(cs.dir, '*.gif'))
        # if not ls: return
        ls.sort()
        pf = None
        x, y = 10, 10
        width, height = 0, 0
        canvas.delete('all')
        for f in ls:
            if Image:
                filter = {
                    'NEAREST': Image.NEAREST,
                    'BILINEAR': Image.BILINEAR,
                    'BICUBIC': Image.BICUBIC,
                    'ANTIALIAS': Image.ANTIALIAS,
                    }[filter_var.get()]
                # filter = Image.BILINEAR
                # filter = Image.BICUBIC
                # filter = Image.ANTIALIAS
                # print f
                im = Image.open(f)
                if zoom != 0:
                    w, h = im.size
                    im = im.convert('RGBA')        # for save transparency
                    if rotate_var.get():
                        # rotate
                        # if filter == Image.ANTIALIAS:
                        #    filter = Image.BICUBIC
                        z = zoom*5
                        a = abs(pi/2/90*z)
                        neww = int(w*cos(a)+h*sin(a))
                        newh = int(h*cos(a)+w*sin(a))
                        # print w, h, neww, newh
                        d = int(sqrt(w*w+h*h))
                        dx, dy = (d-w)/2, (d-h)/2
                        newim = Image.new('RGBA', (d, d))
                        newim.paste(im, (dx, dy))
                        im = newim
                        im = im.rotate(z, resample=filter)
                        x0, y0 = (d-neww)/2, (d-newh)/2
                        x1, y1 = d-x0, d-y0
                        im = im.crop((x0, y0, x1, y1))
                        t = str(z)
                    else:
                        # zoom
                        z = 1.0 + zoom/10.0
                        z = max(0.2, z)
                        if 1:
                            tmp = Image.new('RGBA', (w+2, h+2))
                            tmp.paste(im, (1, 1), im)
                            im = tmp.resize((int(w*z), int(h*z)),
                                            resample=filter)
                        else:
                            im = im.resize((int(w*z), int(h*z)),
                                           resample=filter)
                        t = '%d %%' % int(z*100)

                    zoom_label.config(text=t)

                else:
                    zoom_label.config(text='')
                image = ImageTk.tkinter.PhotoImage(im)
            else:
                image = tkinter.PhotoImage(file=f)
            tk_images.append(image)
            ff = os.path.split(f)[1]
            if pf is None:
                pf = ff[:2]
                x, y = 10, 10
            elif ff[:2] != pf:
                pf = ff[:2]
                x = 10
                y += image.height()+10
            else:
                x += image.width()+10
            canvas.create_image(x, y, image=image, anchor=tkinter.NW)
            # canvas.create_rectangle(x, y, x+image.width(), y+image.height())
            width = max(width, x)
            height = max(height, y)
        width, height = width+image.width()+10, height+image.height()+10
        canvas.config(scrollregion=(0, 0, width, height))
        # print image.width(), image.height()
        label.config(text='''\
Name: %s
Type: %s
Directory: %s''' % (cs.name, cs.type, cs.dir))


def zoom_in(*args):
    global zoom
    zoom += 1
    show_cardset()


def zoom_out(*args):
    global zoom
    zoom -= 1
    show_cardset()


def zoom_cancel(*args):
    global zoom
    zoom = 0
    show_cardset()


def show_info(*args):
    if list_box.curselection():
        cs_name = list_box.get(list_box.curselection())
        cs = cardsets_dict[cs_name]
        fn = os.path.join(cs.dir, 'COPYRIGHT')
        top = tkinter.Toplevel()
        text = tkinter.Text(top)
        text.insert('insert', open(fn).read())
        text.pack(expand=tkinter.YES, fill=tkinter.BOTH)
        b_frame = tkinter.Frame(top)
        b_frame.pack(fill=tkinter.X)
        button = tkinter.Button(b_frame, text='Close', command=top.destroy)
        button.pack(side=tkinter.RIGHT)


def create_widgets():
    global list_box, canvas, label, zoom_label
    #
    root = tkinter.Tk()
    #
    list_box = tkinter.Listbox(root, exportselection=False)
    list_box.grid(row=0, column=0, rowspan=2, sticky=tkinter.NS)
    cardsets_list = list(cardsets_dict)
    cardsets_list.sort()
    for cs in cardsets_list:
        list_box.insert(tkinter.END, cs)
    list_box.bind('<<ListboxSelect>>', show_cardset)
    #
    sb = tkinter.Scrollbar(root)
    sb.grid(row=0, column=1, rowspan=2, sticky=tkinter.NS)
    list_box.config(yscrollcommand=sb.set)
    sb.config(command=list_box.yview)
    #
    canvas = tkinter.Canvas(root, bg='#5eab6b')
    canvas.grid(row=0, column=2, sticky=tkinter.NSEW)
    canvas.bind('<4>', lambda e: canvas.yview_scroll(-5, 'unit'))
    canvas.bind('<5>', lambda e: canvas.yview_scroll(5, 'unit'))
    #
    sb = tkinter.Scrollbar(root)
    sb.grid(row=0, column=3, sticky=tkinter.NS)
    canvas.config(yscrollcommand=sb.set)
    sb.config(command=canvas.yview)
    #
    if True:
        sb = tkinter.Scrollbar(root, orient=tkinter.HORIZONTAL)
        sb.grid(row=1, column=2, sticky=tkinter.EW)
        canvas.config(xscrollcommand=sb.set)
        sb.config(command=canvas.xview)
    #
    label = tkinter.Label(root)
    label.grid(row=2, column=0, columnspan=4)
    #
    b_frame = tkinter.Frame(root)
    b_frame.grid(row=3, column=0, columnspan=4, sticky=tkinter.EW)
    button = tkinter.Button(b_frame, text='Quit', command=root.quit, width=8)
    button.pack(side=tkinter.RIGHT)
    button = tkinter.Button(b_frame, text='Info', command=show_info, width=8)
    button.pack(side=tkinter.RIGHT)
    if Image:
        global rotate_var, filter_var
        rotate_var = tkinter.IntVar(root)
        filter_var = tkinter.StringVar(root)
        button = tkinter.Button(b_frame, text='  +  ', command=zoom_in)
        button.pack(side=tkinter.LEFT)
        button = tkinter.Button(b_frame, text='  -  ', command=zoom_out)
        button.pack(side=tkinter.LEFT)
        button = tkinter.Button(b_frame, text='  =  ', command=zoom_cancel)
        button.pack(side=tkinter.LEFT)
        button = tkinter.Checkbutton(
            b_frame, text='Rotate', indicatoron=0,
            selectcolor=b_frame['bg'], width=8,
            variable=rotate_var, command=show_cardset)
        button.pack(side=tkinter.LEFT, fill='y')
        om = tkinter.OptionMenu(
            b_frame, filter_var,
            'NEAREST', 'BILINEAR', 'BICUBIC', 'ANTIALIAS',
            command=show_cardset)
        filter_var.set('NEAREST')
        om.pack(side=tkinter.LEFT, fill='y')

        zoom_label = tkinter.Label(b_frame)
        zoom_label.pack(side=tkinter.LEFT)
    #
    root.columnconfigure(2, weight=1)
    root.rowconfigure(0, weight=1)

    root.title('Show Cardsets')

    return root


if __name__ == '__main__':
    if '-a' in sys.argv:
        sys.argv.remove('-a')
        all_imgs = True
    if len(sys.argv) > 1:
        data_dir = sys.argv[1]
    else:
        data_dir = os.path.normpath(
            os.path.join(sys.path[0], os.pardir, 'data'))
    ls = glob(os.path.join(data_dir, '*', 'config.txt'))
    cardsets_dict = create_cs_list(ls)
    root = create_widgets()
    root.mainloop()
#!/usr/bin/env python
# -*- mode: python; coding: koi8-r; -*-

import os

import gtk

imdir = 'images'
imtype = 'png'
background = '#efebe7'

# fill_color = 0xff000000                 # red
fill_color = int('ff000000', 16)

if not os.path.exists(imdir):
    os.mkdir(imdir)

gc = None


def draw_rect():
    global gc
    if gc is None:
        gc = drawing_area.window.new_gc()
        colormap = gtk.gdk.colormap_get_system()
        gc.set_colormap(colormap)
        color = gtk.gdk.color_parse('red')
        colormap.alloc_color(color)
        gc.set_rgb_fg_color(color)
    drawing_area.window.draw_rectangle(gc, True, 0, 0, 800, 800)


def save_image(fn, w, h, x=0, y=0):
    pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, True, 8, w, h)
    pixbuf.fill(fill_color)
    pb = pixbuf.get_from_drawable(drawing_area.window,
                                  drawing_area.get_colormap(),
                                  x, y, 0, 0, w, h)
    pb.save(os.path.join(imdir, fn+"."+imtype), imtype)
    drawing_area.window.clear()
    draw_rect()


done = False


def save_callback(*args):
    global done

    if done:
        return
    done = True
    print('create images')

    style = drawing_area.get_style()
    draw_rect()

    # separator
    w = 20
    style.paint_vline(drawing_area.window, gtk.STATE_NORMAL, None,
                      drawing_area, "frame", 0, w, 0)
    save_image('sep-v', 2, w)
    style.paint_hline(drawing_area.window, gtk.STATE_NORMAL, None,
                      drawing_area, "frame", 0, w, 0)
    save_image('sep-h', w, 2)

    # tree
    w, h = 32, 32
    w, h = 24, 24
    for fn, state, shadow in (
        ("tree-n", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("tree-h", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("tree-p", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("tree-d", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, drawing_area, "stepper", 0, 0, w, h)
        save_image(fn, w, h)

    # sizegrip
    w, h = 16, 16
    fn = 'sizegrip'
    style.paint_resize_grip(drawing_area.window, gtk.STATE_NORMAL, None,
                            drawing_area, "statusbar",
                            gtk.gdk.WINDOW_EDGE_SOUTH_EAST, 0, 0, w, h)
    save_image(fn, w, h)

    # progress
    w, h = 37+3, 16+3
    progress_style = progress.get_style()
    fn = 'progress-h'
    progress_style.paint_box(drawing_area.window,
                             gtk.STATE_PRELIGHT, gtk.SHADOW_NONE,
                             None, progress, "bar", 0, 0, w, h)
    save_image(fn, w, h)

    # button
    w, h = 32, 32
    w, h = 28, 28
    for fn, state, shadow in (
        ("button-n", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("button-a", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("button-p", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("button-d", gtk.STATE_INSENSITIVE, gtk.SHADOW_OUT),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, drawing_area, "buttondefault", 0, 0, w, h)
        save_image(fn, w, h)

    style.paint_box(drawing_area.window, gtk.STATE_PRELIGHT, gtk.SHADOW_IN,
                    None, togglebutton, "buttondefault", 0, 0, w, h)
    save_image("button-pa", w, h)

    # toolbar
    w, h = 16, 16
    w, h = 24, 24

    fn = "blank"
    pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, True, 8, w, h)
    pixbuf.fill(fill_color)
    pixbuf.save(os.path.join(imdir, fn+"."+imtype), imtype)

    for fn, state, shadow in (
        ("toolbutton-n", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("toolbutton-a", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("toolbutton-p", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("toolbutton-d", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, drawing_area, "buttondefault", 0, 0, w, h)
        save_image(fn, w, h)

    style.paint_box(drawing_area.window, gtk.STATE_PRELIGHT, gtk.SHADOW_IN,
                    None, togglebutton, "buttondefault", 0, 0, w, h)
    save_image("toolbutton-pa", w, h)

    # slider
    msl = hscroll.style_get_property("min_slider_length")
    msl = 20
    sw = hscroll.style_get_property("slider_width")
    print('>>', msl, sw)
    for t, w, h, state, orient in (
        ('hn', msl, sw, gtk.STATE_NORMAL,      gtk.ORIENTATION_HORIZONTAL),
        ('ha', msl, sw, gtk.STATE_PRELIGHT,    gtk.ORIENTATION_HORIZONTAL),
        ('hp', msl, sw, gtk.STATE_NORMAL,      gtk.ORIENTATION_HORIZONTAL),
        ('hd', msl, sw, gtk.STATE_INSENSITIVE, gtk.ORIENTATION_HORIZONTAL),

        ('vn', sw, msl, gtk.STATE_NORMAL,      gtk.ORIENTATION_VERTICAL),
        ('va', sw, msl, gtk.STATE_PRELIGHT,    gtk.ORIENTATION_VERTICAL),
        ('vp', sw, msl, gtk.STATE_NORMAL,      gtk.ORIENTATION_VERTICAL),
        ('vd', sw, msl, gtk.STATE_INSENSITIVE, gtk.ORIENTATION_VERTICAL),
            ):
        fn = 'sbthumb-'+t
        if 0:
            style.paint_slider(drawing_area.window, state, gtk.SHADOW_OUT,
                               None, drawing_area, "slider",
                               0, 0, w, h, orient)
        else:
            if orient == gtk.ORIENTATION_VERTICAL:
                w, h = h, w
            style.paint_box(drawing_area.window, state, shadow,
                            None, drawing_area, "stepper", 0, 0, w, h)
        save_image(fn, w, h)

    msl = hscroll.style_get_property("min_slider_length")
    sw = hscroll.style_get_property("slider_width")
    # scale
    for t, w, h, state, orient in (
        ('hn', msl, sw, gtk.STATE_NORMAL,      gtk.ORIENTATION_HORIZONTAL),
        ('ha', msl, sw, gtk.STATE_PRELIGHT,    gtk.ORIENTATION_HORIZONTAL),
        ('hd', msl, sw, gtk.STATE_INSENSITIVE, gtk.ORIENTATION_HORIZONTAL),
        ('vn', sw, msl, gtk.STATE_NORMAL,      gtk.ORIENTATION_VERTICAL),
        ('va', sw, msl, gtk.STATE_PRELIGHT,    gtk.ORIENTATION_VERTICAL),
        ('vd', sw, msl, gtk.STATE_INSENSITIVE, gtk.ORIENTATION_VERTICAL),
            ):
        fn = 'scale-'+t
        if orient == gtk.ORIENTATION_HORIZONTAL:
            detail = "hscale"
        else:
            detail = "vscale"
        style.paint_slider(drawing_area.window, state, gtk.SHADOW_OUT,
                           None, drawing_area, detail, 0, 0, w+2, h+2, orient)
        save_image(fn, w, h, 1, 1)

    w, h = msl, sw
    fn = 'scaletrough-h'
    style.paint_box(drawing_area.window, gtk.STATE_ACTIVE, gtk.SHADOW_IN,
                    None, scale, "trough", 0, 0, w, h)
    save_image(fn, w, h)

    # arrow
    w = h = hscroll.style_get_property("stepper_size")
    # w = h = 15
    arrow_width = w / 2
    arrow_height = h / 2
    arrow_x = (w - arrow_width) / 2
    arrow_y = (h - arrow_height) / 2

    alloc = hscroll.get_allocation()
    x0 = alloc.x
    x1 = alloc.x+alloc.width-w
    alloc = vscroll.get_allocation()
    y0 = alloc.y
    y1 = alloc.y+alloc.height-h

    sn = gtk.STATE_NORMAL
    sp = gtk.STATE_PRELIGHT
    sa = gtk.STATE_ACTIVE
    si = gtk.STATE_INSENSITIVE

    for fn, x, y, state, shadow, arrow_type, widget in (
        ("arrowleft-n", x0, 0, sn, gtk.SHADOW_OUT, gtk.ARROW_LEFT, hscroll),
        ("arrowleft-a", x0, 0, sp, gtk.SHADOW_OUT, gtk.ARROW_LEFT, hscroll),
        ("arrowleft-p", x0, 0, sa, gtk.SHADOW_IN,  gtk.ARROW_LEFT, hscroll),
        ("arrowleft-d", x0, 0, si, gtk.SHADOW_OUT, gtk.ARROW_LEFT, hscroll),

        ("arrowright-n", x1, 0, sn, gtk.SHADOW_OUT, gtk.ARROW_RIGHT, hscroll),
        ("arrowright-a", x1, 0, sp, gtk.SHADOW_OUT, gtk.ARROW_RIGHT, hscroll),
        ("arrowright-p", x1, 0, sa, gtk.SHADOW_IN,  gtk.ARROW_RIGHT, hscroll),
        ("arrowright-d", x1, 0, si, gtk.SHADOW_OUT, gtk.ARROW_RIGHT, hscroll),

        ("arrowup-n", 0, y0, sn, gtk.SHADOW_OUT, gtk.ARROW_UP, vscroll),
        ("arrowup-a", 0, y0, sp, gtk.SHADOW_OUT, gtk.ARROW_UP, vscroll),
        ("arrowup-p", 0, y0, sa, gtk.SHADOW_IN,  gtk.ARROW_UP, vscroll),
        ("arrowup-d", 0, y0, si, gtk.SHADOW_OUT, gtk.ARROW_UP, vscroll),

        ("arrowdown-n", 0, y1, sn, gtk.SHADOW_OUT, gtk.ARROW_DOWN, vscroll),
        ("arrowdown-a", 0, y1, sp, gtk.SHADOW_OUT, gtk.ARROW_DOWN, vscroll),
        ("arrowdown-p", 0, y1, sa, gtk.SHADOW_IN,  gtk.ARROW_DOWN, vscroll),
        ("arrowdown-d", 0, y1, si, gtk.SHADOW_OUT, gtk.ARROW_DOWN, vscroll),
            ):
        if 0:
            detail = 'hscrollbar'
            if widget is vscroll:
                detail = 'vscrollbar'
        else:
            x, y = 0, 0
            detail = 'stepper'
            widget = drawing_area
        style.paint_box(drawing_area.window, state, shadow,
                        None, widget, detail, x, y, w, h)
        style.paint_arrow(drawing_area.window, state, shadow,
                          None, widget, detail, arrow_type, True,
                          x+arrow_x, y+arrow_y, arrow_width, arrow_height)
        save_image(fn, w, h, x, y)

    # combobox
    w, h = w, 24
    w, h = 16, 24
    alloc = hscroll.get_allocation()
    x1 = alloc.x+alloc.width-w
    arrow_width = w / 2
    arrow_height = h / 2
    arrow_x = (w - arrow_width) / 2
    arrow_y = (h - arrow_height) / 2
    detail = 'hscrollbar'
    widget = hscroll
    for fn, state, shadow, arrow_type in (
        ("comboarrow-n", gtk.STATE_NORMAL,     gtk.SHADOW_OUT, gtk.ARROW_DOWN),
        ("comboarrow-a", gtk.STATE_PRELIGHT,   gtk.SHADOW_OUT, gtk.ARROW_DOWN),
        ("comboarrow-p", gtk.STATE_ACTIVE,      gtk.SHADOW_IN, gtk.ARROW_DOWN),
        ("comboarrow-d", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN, gtk.ARROW_DOWN),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, widget, detail, x1, 0, w, h)
        style.paint_arrow(drawing_area.window, state, shadow,
                          None, drawing_area, "stepper", arrow_type, True,
                          x1+arrow_x, arrow_y, arrow_width, arrow_height)
        save_image(fn, w, h, x1, 0)

    w = 24
    for fn, state, shadow in (
        ("combo-rn", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("combo-ra", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("combo-rp", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("combo-rd", gtk.STATE_INSENSITIVE, gtk.SHADOW_OUT),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, drawing_area, "button", 0, 0, w+2, h)
        save_image(fn, w, h)

    style.paint_box(drawing_area.window, gtk.STATE_NORMAL, gtk.SHADOW_OUT,
                    None, drawing_area, "button", 0, 0, w+2, h)
    d = 3
    style.paint_focus(drawing_area.window, gtk.STATE_NORMAL,
                      None, drawing_area, "button", d, d, w-2*d, h-2*d)
    save_image('combo-rf', w, h)

    style.paint_shadow(drawing_area.window, gtk.STATE_NORMAL, gtk.SHADOW_IN,
                       None, drawing_area, "entry", 0, 0, w+2, h)
    save_image('combo-n', w, h)

    # checkbutton
    # define INDICATOR_SIZE     13
    # define INDICATOR_SPACING  2
    x, y = 2, 2
    w, h = 13, 13
    # w = h = checkbutton.style_get_property("indicator_size")
    for fn, state, shadow in (
        ("check-nc", gtk.STATE_NORMAL,      gtk.SHADOW_IN),
        ("check-nu", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("check-ac", gtk.STATE_PRELIGHT,    gtk.SHADOW_IN),
        ("check-au", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("check-pc", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("check-pu", gtk.STATE_ACTIVE,      gtk.SHADOW_OUT),
        ("check-dc", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN),
        ("check-du", gtk.STATE_INSENSITIVE, gtk.SHADOW_OUT),
            ):
        #   style.paint_flat_box(drawing_area.window,
        #                   gtk.STATE_PRELIGHT,
        #                   gtk.SHADOW_ETCHED_OUT,
        #                   gtk.gdk.Rectangle(0, 0,w, h), drawing_area,
        #                   "checkbutton", 0, 0, w, h)

        style.paint_check(drawing_area.window, state, shadow,
                          None, drawing_area, "checkbutton", x, y, w, h)
        save_image(fn, w+2*x, h+2*y)

    # radiobutton
    for fn, state, shadow in (
        ("radio-nc", gtk.STATE_NORMAL,      gtk.SHADOW_IN),
        ("radio-nu", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("radio-ac", gtk.STATE_PRELIGHT,    gtk.SHADOW_IN),
        ("radio-au", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("radio-pc", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("radio-pu", gtk.STATE_ACTIVE,      gtk.SHADOW_OUT),
        ("radio-dc", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN),
        ("radio-du", gtk.STATE_INSENSITIVE, gtk.SHADOW_OUT),
            ):
        #   style.paint_flat_box(drawing_area.window,
        #                   gtk.STATE_PRELIGHT,
        #                   gtk.SHADOW_ETCHED_OUT,
        #                   gtk.gdk.Rectangle(0, 0,w, h), drawing_area,
        #                   "checkbutton", 0, 0, w, h)
        style.paint_option(drawing_area.window, state, shadow,
                           None, drawing_area, "radiobutton", x, y, w, h)
        save_image(fn, w+2*x, h+2*y)

    # notebook
    w, h = 28, 22
    state = gtk.STATE_NORMAL
    shadow = gtk.SHADOW_OUT

    for fn, gap_h, state in (
        ("tab-n", 0, gtk.STATE_NORMAL),
        ("tab-a", 2, gtk.STATE_ACTIVE),
            ):
        #  style.paint_box_gap(drawing_area.window, state, shadow,
        #                      gtk.gdk.Rectangle(0, 0,w,gap_h), drawing_area,
        #                      "notebook", 0, 0, w,gap_h, gtk.POS_TOP, 0, w)
        y = gap_h
        hh = h - y
        style.paint_extension(drawing_area.window, state, gtk.SHADOW_OUT,
                              None, drawing_area, "tab",
                              0, y, w, hh, gtk.POS_BOTTOM)
        save_image(fn, w, h+2)

    print('done')

    gtk.main_quit()


def pack(w, row, col):
    table.attach(w,
                 col, col+1,              row, row+1,
                 gtk.EXPAND | gtk.FILL,   gtk.EXPAND | gtk.FILL,
                 0,                       0)


win = gtk.Window()
win.connect("destroy", gtk.main_quit)

table = gtk.Table()
win.add(table)

row, col = 0, 0

drawing_area = gtk.DrawingArea()
# drawing_area.set_size_request(100, 100)
pack(drawing_area, row, col)
row += 1

vscroll = gtk.VScrollbar()
pack(vscroll, 0, 1)

hscroll = gtk.HScrollbar()
pack(hscroll, row, col)
row += 1


notebook = gtk.Notebook()
label = gtk.Label("Label")
notebook.append_page(label)
label = gtk.Label("Label")
notebook.append_page(label)
pack(notebook, row, col)
row += 1

button = gtk.Button("Button")
pack(button, row, col)
row += 1

checkbutton = gtk.CheckButton("CheckButton")
pack(checkbutton, row, col)
row += 1

progress = gtk.ProgressBar()
pack(progress, row, col)
row += 1

scale = gtk.HScale()
pack(scale, row, col)
row += 1

entry = gtk.Entry()
pack(entry, row, col)
row += 1

togglebutton = gtk.ToggleButton()
pack(togglebutton, row, col)
togglebutton.set_active(True)
row += 1


drawing_area.connect("expose-event", save_callback)
# gobject.timeout_add(2000, save_callback)

win.show_all()
# drawing_area.modify_bg(gtk.STATE_NORMAL, gtk.gdk.color_parse('red'))

gtk.main()
